id,sourceIdentifier,published,lastModified,vulnStatus,cveTags,descriptions,weaknesses,references,metrics_cvssMetricV31,configurations,metrics_cvssMetricV40,cisaExploitAdd,cisaActionDue,cisaRequiredAction,cisaVulnerabilityName,metrics_cvssMetricV2,metrics_cvssMetricV30,evaluatorComment
CVE-2025-37087,security-alert@hpe.com,2025-04-22T21:15:45.650,2025-05-01T22:15:17.647,Awaiting Analysis,[],A vulnerability in the cmdb service of the HPE Performance Cluster Manager (HPCM) could allow an attacker to gain access to an arbitrary file on the server host.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-862""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbcr04840en_us&docLocale=en_US"",""source"":""security-alert@hpe.com""}]","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":9.8,""baseSeverity"":""CRITICAL"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":3.9,""impactScore"":5.9}]",,,,,,,,,
CVE-2025-37088,security-alert@hpe.com,2025-04-22T22:15:17.450,2025-04-25T15:15:36.593,Awaiting Analysis,[],"A security vulnerability has been identified in HPE Cray Data Virtualization Service (DVS). Depending on race conditions and configuration, this vulnerability may lead to local/cluster unauthorized access.","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-362""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbcr04749en_us&docLocale=en_US"",""source"":""security-alert@hpe.com""}]","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:A/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N"",""baseScore"":6.8,""baseSeverity"":""MEDIUM"",""attackVector"":""ADJACENT_NETWORK"",""attackComplexity"":""HIGH"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""NONE""},""exploitabilityScore"":1.6,""impactScore"":5.2}]",,,,,,,,,
CVE-2025-37089,security-alert@hpe.com,2025-06-02T14:15:22.993,2025-07-02T17:50:56.890,Analyzed,[],A command injection remote code execution vulnerability exists in HPE StoreOnce Software.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-77""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbst04847en_us&docLocale=en_US"",""source"":""security-alert@hpe.com"",""tags"":[""Vendor Advisory""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":9.8,""baseSeverity"":""CRITICAL"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":3.9,""impactScore"":5.9}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:hpe:storeonce_system:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""4.3.11"",""matchCriteriaId"":""48B94426-B10F-43F3-90C9-C60A30439D11""}]}]}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""4.0"",""vectorString"":""CVSS:4.0/AV:N/AC:L/AT:P/PR:H/UI:N/VC:H/VI:H/VA:H/SC:N/SI:N/SA:N/E:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MAT:X/MPR:X/MUI:X/MVC:X/MVI:X/MVA:X/MSC:X/MSI:X/MSA:X/S:X/AU:X/R:X/V:X/RE:X/U:X"",""baseScore"":7.5,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""attackRequirements"":""PRESENT"",""privilegesRequired"":""HIGH"",""userInteraction"":""NONE"",""vulnConfidentialityImpact"":""HIGH"",""vulnIntegrityImpact"":""HIGH"",""vulnAvailabilityImpact"":""HIGH"",""subConfidentialityImpact"":""NONE"",""subIntegrityImpact"":""NONE"",""subAvailabilityImpact"":""NONE"",""exploitMaturity"":""NOT_DEFINED"",""confidentialityRequirement"":""NOT_DEFINED"",""integrityRequirement"":""NOT_DEFINED"",""availabilityRequirement"":""NOT_DEFINED"",""modifiedAttackVector"":""NOT_DEFINED"",""modifiedAttackComplexity"":""NOT_DEFINED"",""modifiedAttackRequirements"":""NOT_DEFINED"",""modifiedPrivilegesRequired"":""NOT_DEFINED"",""modifiedUserInteraction"":""NOT_DEFINED"",""modifiedVulnConfidentialityImpact"":""NOT_DEFINED"",""modifiedVulnIntegrityImpact"":""NOT_DEFINED"",""modifiedVulnAvailabilityImpact"":""NOT_DEFINED"",""modifiedSubConfidentialityImpact"":""NOT_DEFINED"",""modifiedSubIntegrityImpact"":""NOT_DEFINED"",""modifiedSubAvailabilityImpact"":""NOT_DEFINED"",""Safety"":""NOT_DEFINED"",""Automatable"":""NOT_DEFINED"",""Recovery"":""NOT_DEFINED"",""valueDensity"":""NOT_DEFINED"",""vulnerabilityResponseEffort"":""NOT_DEFINED"",""providerUrgency"":""NOT_DEFINED""}}]",,,,,,,
CVE-2025-37090,security-alert@hpe.com,2025-06-02T14:15:23.163,2025-07-02T17:49:08.613,Analyzed,[],A server-side request forgery vulnerability exists in HPE StoreOnce Software.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-918""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbst04847en_us&docLocale=en_US"",""source"":""security-alert@hpe.com"",""tags"":[""Vendor Advisory""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":9.8,""baseSeverity"":""CRITICAL"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":3.9,""impactScore"":5.9}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:hpe:storeonce_system:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""4.3.11"",""matchCriteriaId"":""48B94426-B10F-43F3-90C9-C60A30439D11""}]}]}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""4.0"",""vectorString"":""CVSS:4.0/AV:N/AC:L/AT:N/PR:N/UI:N/VC:L/VI:N/VA:N/SC:L/SI:N/SA:N/E:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MAT:X/MPR:X/MUI:X/MVC:X/MVI:X/MVA:X/MSC:X/MSI:X/MSA:X/S:X/AU:X/R:X/V:X/RE:X/U:X"",""baseScore"":6.9,""baseSeverity"":""MEDIUM"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""attackRequirements"":""NONE"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""vulnConfidentialityImpact"":""LOW"",""vulnIntegrityImpact"":""NONE"",""vulnAvailabilityImpact"":""NONE"",""subConfidentialityImpact"":""LOW"",""subIntegrityImpact"":""NONE"",""subAvailabilityImpact"":""NONE"",""exploitMaturity"":""NOT_DEFINED"",""confidentialityRequirement"":""NOT_DEFINED"",""integrityRequirement"":""NOT_DEFINED"",""availabilityRequirement"":""NOT_DEFINED"",""modifiedAttackVector"":""NOT_DEFINED"",""modifiedAttackComplexity"":""NOT_DEFINED"",""modifiedAttackRequirements"":""NOT_DEFINED"",""modifiedPrivilegesRequired"":""NOT_DEFINED"",""modifiedUserInteraction"":""NOT_DEFINED"",""modifiedVulnConfidentialityImpact"":""NOT_DEFINED"",""modifiedVulnIntegrityImpact"":""NOT_DEFINED"",""modifiedVulnAvailabilityImpact"":""NOT_DEFINED"",""modifiedSubConfidentialityImpact"":""NOT_DEFINED"",""modifiedSubIntegrityImpact"":""NOT_DEFINED"",""modifiedSubAvailabilityImpact"":""NOT_DEFINED"",""Safety"":""NOT_DEFINED"",""Automatable"":""NOT_DEFINED"",""Recovery"":""NOT_DEFINED"",""valueDensity"":""NOT_DEFINED"",""vulnerabilityResponseEffort"":""NOT_DEFINED"",""providerUrgency"":""NOT_DEFINED""}}]",,,,,,,
CVE-2025-37091,security-alert@hpe.com,2025-06-02T14:15:23.310,2025-07-02T17:49:54.203,Analyzed,[],A command injection remote code execution vulnerability exists in HPE StoreOnce Software.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-77""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbst04847en_us&docLocale=en_US"",""source"":""security-alert@hpe.com"",""tags"":[""Vendor Advisory""]}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":7.2,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""HIGH"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.2,""impactScore"":5.9},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":9.8,""baseSeverity"":""CRITICAL"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":3.9,""impactScore"":5.9}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:hpe:storeonce_system:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""4.3.11"",""matchCriteriaId"":""48B94426-B10F-43F3-90C9-C60A30439D11""}]}]}]",,,,,,,,
CVE-2025-37092,security-alert@hpe.com,2025-06-02T14:15:23.467,2025-07-02T01:14:24.027,Analyzed,[],A command injection remote code execution vulnerability exists in HPE StoreOnce Software.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-77""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbst04847en_us&docLocale=en_US"",""source"":""security-alert@hpe.com"",""tags"":[""Vendor Advisory""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":9.8,""baseSeverity"":""CRITICAL"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":3.9,""impactScore"":5.9}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:hpe:storeonce_system:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""4.3.11"",""matchCriteriaId"":""48B94426-B10F-43F3-90C9-C60A30439D11""}]}]}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""4.0"",""vectorString"":""CVSS:4.0/AV:N/AC:L/AT:P/PR:H/UI:N/VC:H/VI:H/VA:H/SC:N/SI:N/SA:N/E:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MAT:X/MPR:X/MUI:X/MVC:X/MVI:X/MVA:X/MSC:X/MSI:X/MSA:X/S:X/AU:X/R:X/V:X/RE:X/U:X"",""baseScore"":7.5,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""attackRequirements"":""PRESENT"",""privilegesRequired"":""HIGH"",""userInteraction"":""NONE"",""vulnConfidentialityImpact"":""HIGH"",""vulnIntegrityImpact"":""HIGH"",""vulnAvailabilityImpact"":""HIGH"",""subConfidentialityImpact"":""NONE"",""subIntegrityImpact"":""NONE"",""subAvailabilityImpact"":""NONE"",""exploitMaturity"":""NOT_DEFINED"",""confidentialityRequirement"":""NOT_DEFINED"",""integrityRequirement"":""NOT_DEFINED"",""availabilityRequirement"":""NOT_DEFINED"",""modifiedAttackVector"":""NOT_DEFINED"",""modifiedAttackComplexity"":""NOT_DEFINED"",""modifiedAttackRequirements"":""NOT_DEFINED"",""modifiedPrivilegesRequired"":""NOT_DEFINED"",""modifiedUserInteraction"":""NOT_DEFINED"",""modifiedVulnConfidentialityImpact"":""NOT_DEFINED"",""modifiedVulnIntegrityImpact"":""NOT_DEFINED"",""modifiedVulnAvailabilityImpact"":""NOT_DEFINED"",""modifiedSubConfidentialityImpact"":""NOT_DEFINED"",""modifiedSubIntegrityImpact"":""NOT_DEFINED"",""modifiedSubAvailabilityImpact"":""NOT_DEFINED"",""Safety"":""NOT_DEFINED"",""Automatable"":""NOT_DEFINED"",""Recovery"":""NOT_DEFINED"",""valueDensity"":""NOT_DEFINED"",""vulnerabilityResponseEffort"":""NOT_DEFINED"",""providerUrgency"":""NOT_DEFINED""}}]",,,,,,,
CVE-2025-37093,security-alert@hpe.com,2025-06-02T14:15:23.590,2025-07-02T01:12:24.617,Analyzed,[],An authentication bypass vulnerability exists in HPE StoreOnce Software.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-287""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbst04847en_us&docLocale=en_US"",""source"":""security-alert@hpe.com"",""tags"":[""Vendor Advisory""]}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":9.8,""baseSeverity"":""CRITICAL"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":3.9,""impactScore"":5.9}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:hpe:storeonce_system:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""4.3.11"",""matchCriteriaId"":""48B94426-B10F-43F3-90C9-C60A30439D11""}]}]}]",,,,,,,,
CVE-2025-37094,security-alert@hpe.com,2025-06-02T14:15:23.720,2025-07-02T01:10:16.433,Analyzed,[],A directory traversal arbitrary file deletion vulnerability exists in HPE StoreOnce Software.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-22""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbst04847en_us&docLocale=en_US"",""source"":""security-alert@hpe.com"",""tags"":[""Vendor Advisory""]}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:N/I:L/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""HIGH"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""LOW"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.2,""impactScore"":4.2},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H"",""baseScore"":9.1,""baseSeverity"":""CRITICAL"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":3.9,""impactScore"":5.2}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:hpe:storeonce_system:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""4.3.11"",""matchCriteriaId"":""48B94426-B10F-43F3-90C9-C60A30439D11""}]}]}]",,,,,,,,
CVE-2025-37095,security-alert@hpe.com,2025-06-02T15:15:34.060,2025-07-02T18:07:31.213,Analyzed,[],A directory traversal information disclosure vulnerability exists in HPE StoreOnce Software.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-22""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbst04847en_us&docLocale=en_US"",""source"":""security-alert@hpe.com"",""tags"":[""Vendor Advisory""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":9.8,""baseSeverity"":""CRITICAL"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":3.9,""impactScore"":5.9}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:hpe:storeonce_system:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""4.3.11"",""matchCriteriaId"":""48B94426-B10F-43F3-90C9-C60A30439D11""}]}]}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""4.0"",""vectorString"":""CVSS:4.0/AV:N/AC:L/AT:P/PR:H/UI:N/VC:H/VI:N/VA:N/SC:N/SI:N/SA:N/E:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MAT:X/MPR:X/MUI:X/MVC:X/MVI:X/MVA:X/MSC:X/MSI:X/MSA:X/S:X/AU:X/R:X/V:X/RE:X/U:X"",""baseScore"":5.9,""baseSeverity"":""MEDIUM"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""attackRequirements"":""PRESENT"",""privilegesRequired"":""HIGH"",""userInteraction"":""NONE"",""vulnConfidentialityImpact"":""HIGH"",""vulnIntegrityImpact"":""NONE"",""vulnAvailabilityImpact"":""NONE"",""subConfidentialityImpact"":""NONE"",""subIntegrityImpact"":""NONE"",""subAvailabilityImpact"":""NONE"",""exploitMaturity"":""NOT_DEFINED"",""confidentialityRequirement"":""NOT_DEFINED"",""integrityRequirement"":""NOT_DEFINED"",""availabilityRequirement"":""NOT_DEFINED"",""modifiedAttackVector"":""NOT_DEFINED"",""modifiedAttackComplexity"":""NOT_DEFINED"",""modifiedAttackRequirements"":""NOT_DEFINED"",""modifiedPrivilegesRequired"":""NOT_DEFINED"",""modifiedUserInteraction"":""NOT_DEFINED"",""modifiedVulnConfidentialityImpact"":""NOT_DEFINED"",""modifiedVulnIntegrityImpact"":""NOT_DEFINED"",""modifiedVulnAvailabilityImpact"":""NOT_DEFINED"",""modifiedSubConfidentialityImpact"":""NOT_DEFINED"",""modifiedSubIntegrityImpact"":""NOT_DEFINED"",""modifiedSubAvailabilityImpact"":""NOT_DEFINED"",""Safety"":""NOT_DEFINED"",""Automatable"":""NOT_DEFINED"",""Recovery"":""NOT_DEFINED"",""valueDensity"":""NOT_DEFINED"",""vulnerabilityResponseEffort"":""NOT_DEFINED"",""providerUrgency"":""NOT_DEFINED""}}]",,,,,,,
CVE-2025-37096,security-alert@hpe.com,2025-06-02T15:15:34.193,2025-07-02T18:01:41.810,Analyzed,[],A command injection remote code execution vulnerability exists in HPE StoreOnce Software.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-77""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbst04847en_us&docLocale=en_US"",""source"":""security-alert@hpe.com"",""tags"":[""Vendor Advisory""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":9.8,""baseSeverity"":""CRITICAL"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":3.9,""impactScore"":5.9}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:hpe:storeonce_system:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""4.3.11"",""matchCriteriaId"":""48B94426-B10F-43F3-90C9-C60A30439D11""}]}]}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""4.0"",""vectorString"":""CVSS:4.0/AV:N/AC:L/AT:P/PR:H/UI:N/VC:H/VI:H/VA:H/SC:N/SI:N/SA:N/E:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MAT:X/MPR:X/MUI:X/MVC:X/MVI:X/MVA:X/MSC:X/MSI:X/MSA:X/S:X/AU:X/R:X/V:X/RE:X/U:X"",""baseScore"":7.5,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""attackRequirements"":""PRESENT"",""privilegesRequired"":""HIGH"",""userInteraction"":""NONE"",""vulnConfidentialityImpact"":""HIGH"",""vulnIntegrityImpact"":""HIGH"",""vulnAvailabilityImpact"":""HIGH"",""subConfidentialityImpact"":""NONE"",""subIntegrityImpact"":""NONE"",""subAvailabilityImpact"":""NONE"",""exploitMaturity"":""NOT_DEFINED"",""confidentialityRequirement"":""NOT_DEFINED"",""integrityRequirement"":""NOT_DEFINED"",""availabilityRequirement"":""NOT_DEFINED"",""modifiedAttackVector"":""NOT_DEFINED"",""modifiedAttackComplexity"":""NOT_DEFINED"",""modifiedAttackRequirements"":""NOT_DEFINED"",""modifiedPrivilegesRequired"":""NOT_DEFINED"",""modifiedUserInteraction"":""NOT_DEFINED"",""modifiedVulnConfidentialityImpact"":""NOT_DEFINED"",""modifiedVulnIntegrityImpact"":""NOT_DEFINED"",""modifiedVulnAvailabilityImpact"":""NOT_DEFINED"",""modifiedSubConfidentialityImpact"":""NOT_DEFINED"",""modifiedSubIntegrityImpact"":""NOT_DEFINED"",""modifiedSubAvailabilityImpact"":""NOT_DEFINED"",""Safety"":""NOT_DEFINED"",""Automatable"":""NOT_DEFINED"",""Recovery"":""NOT_DEFINED"",""valueDensity"":""NOT_DEFINED"",""vulnerabilityResponseEffort"":""NOT_DEFINED"",""providerUrgency"":""NOT_DEFINED""}}]",,,,,,,
CVE-2025-37097,security-alert@hpe.com,2025-07-01T14:15:38.537,2025-07-10T15:37:31.510,Analyzed,[],A vulnerability in HPE Insight Remote Support (IRS) prior to v7.15.0.646 may allow an unauthenticated denial of service,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-749""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbgn04878en_us&docLocale=en_US"",""source"":""security-alert@hpe.com"",""tags"":[""Vendor Advisory""]},{""url"":""https://www.tenable.com/security/research/tra-2025-15"",""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""tags"":[""Exploit"",""Third Party Advisory""]}]","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":7.5,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":3.9,""impactScore"":3.6}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:hpe:insight_remote_support:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""7.15.0.646"",""matchCriteriaId"":""48D5F9CE-1715-406A-AF4F-504BC11B3DD1""}]}]}]",,,,,,,,
CVE-2025-37098,security-alert@hpe.com,2025-07-01T15:15:25.643,2025-07-10T15:36:12.977,Analyzed,[],A path traversal vulnerability exists in HPE Insight Remote Support (IRS) prior to v7.15.0.646.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-22""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbgn04878en_us&docLocale=en_US"",""source"":""security-alert@hpe.com"",""tags"":[""Vendor Advisory""]}]","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N"",""baseScore"":7.5,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""NONE"",""availabilityImpact"":""NONE""},""exploitabilityScore"":3.9,""impactScore"":3.6}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:hpe:insight_remote_support:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""7.15.0.646"",""matchCriteriaId"":""48D5F9CE-1715-406A-AF4F-504BC11B3DD1""}]}]}]",,,,,,,,
CVE-2025-37099,security-alert@hpe.com,2025-07-01T18:15:24.763,2025-07-10T15:33:39.910,Analyzed,[],A remote code execution vulnerability exists in HPE Insight Remote Support (IRS) prior to v7.15.0.646.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-94""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbgn04878en_us&docLocale=en_US"",""source"":""security-alert@hpe.com"",""tags"":[""Vendor Advisory""]}]","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":9.8,""baseSeverity"":""CRITICAL"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":3.9,""impactScore"":5.9}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:hpe:insight_remote_support:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""7.15.0.646"",""matchCriteriaId"":""48D5F9CE-1715-406A-AF4F-504BC11B3DD1""}]}]}]",,,,,,,,
CVE-2025-37100,security-alert@hpe.com,2025-06-10T15:15:24.233,2025-06-12T16:06:39.330,Awaiting Analysis,[],A vulnerability in the APIs of HPE Aruba Networking Private 5G Core could potentially expose sensitive information to unauthorized users. A successful exploitation could allow an attacker to iteratively navigate through the filesystem and ultimately download protected system files containing sensitive information.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-22""},{""lang"":""en"",""value"":""CWE-922""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbnw04883en_us&docLocale=en_US"",""source"":""security-alert@hpe.com""}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N"",""baseScore"":7.7,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""CHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""NONE"",""availabilityImpact"":""NONE""},""exploitabilityScore"":3.1,""impactScore"":4.0}]",,,,,,,,,
CVE-2025-37101,security-alert@hpe.com,2025-06-26T06:15:23.130,2025-06-26T18:57:43.670,Awaiting Analysis,[],A potential security vulnerability has been identified in HPE OneView for VMware vCenter (OV4VC). This vulnerability could be exploited allowing an attacker with read only privilege to cause Vertical Privilege Escalation (operator can perform admin actions).,"[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-269""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbgn04876en_us&docLocale=en_US"",""source"":""security-alert@hpe.com""}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:N/I:H/A:H"",""baseScore"":8.7,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""REQUIRED"",""scope"":""CHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":2.3,""impactScore"":5.8}]",,,,,,,,,
CVE-2025-37102,security-alert@hpe.com,2025-07-08T19:15:41.753,2025-07-10T13:18:53.830,Awaiting Analysis,[],An authenticated command injection vulnerability exists in the Command line interface of HPE Networking Instant On Access Points. A successful exploitation could allow a remote attacker with elevated privileges to execute arbitrary commands on the underlying operating system as a highly privileged user.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-77""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbnw04894en_us&docLocale=en_US"",""source"":""security-alert@hpe.com""}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":7.2,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""HIGH"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.2,""impactScore"":5.9}]",,,,,,,,,
CVE-2025-37103,security-alert@hpe.com,2025-07-08T20:15:26.033,2025-07-10T13:18:53.830,Awaiting Analysis,[],"Hard-coded login credentials were found in HPE Networking Instant On Access Points, allowing anyone with knowledge of it to bypass normal device authentication. Successful exploitation could allow a remote attacker to gain administrative access to the system.","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-798""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbnw04894en_us&docLocale=en_US"",""source"":""security-alert@hpe.com""}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":9.8,""baseSeverity"":""CRITICAL"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":3.9,""impactScore"":5.9}]",,,,,,,,,
CVE-2025-37104,security-alert@hpe.com,2025-07-16T15:15:26.520,2025-07-18T15:15:26.397,Awaiting Analysis,[],"A security vulnerability has been identified in HPE Telco Service Orchestrator software. The vulnerability could allow authenticated clients to to perform a SQL Injection attack when sending a service request, and potentially exfiltrate the database's vendor name to unauthorized authenticated clients.","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-89""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbnw04875en_us&docLocale=en_US"",""source"":""security-alert@hpe.com""}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:A/AC:H/PR:L/UI:N/S:C/C:L/I:H/A:L"",""baseScore"":7.1,""baseSeverity"":""HIGH"",""attackVector"":""ADJACENT_NETWORK"",""attackComplexity"":""HIGH"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""CHANGED"",""confidentialityImpact"":""LOW"",""integrityImpact"":""HIGH"",""availabilityImpact"":""LOW""},""exploitabilityScore"":1.3,""impactScore"":5.3}]",,,,,,,,,
CVE-2025-37105,security-alert@hpe.com,2025-07-16T18:15:24.410,2025-07-25T15:28:11.190,Analyzed,[],An hsqldb-related remote code execution vulnerability exists in HPE AutoPass License Server (APLS) prior to 9.18.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-94""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbgn04877en_us"",""source"":""security-alert@hpe.com"",""tags"":[""Vendor Advisory""]}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:A/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":7.5,""baseSeverity"":""HIGH"",""attackVector"":""ADJACENT_NETWORK"",""attackComplexity"":""HIGH"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.6,""impactScore"":5.9},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":9.8,""baseSeverity"":""CRITICAL"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":3.9,""impactScore"":5.9}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:hpe:autopass_license_server:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""9.18"",""matchCriteriaId"":""9328E037-2E67-4E7F-A4B3-1695860718D0""}]}]}]",,,,,,,,
CVE-2025-37106,security-alert@hpe.com,2025-07-16T18:15:24.527,2025-07-25T15:28:26.440,Analyzed,[],An authentication bypass and disclosure of information vulnerability exists in HPE AutoPass License Server (APLS) prior to 9.18.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-287""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbgn04877en_us"",""source"":""security-alert@hpe.com"",""tags"":[""Vendor Advisory""]}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L"",""baseScore"":7.3,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""LOW"",""integrityImpact"":""LOW"",""availabilityImpact"":""LOW""},""exploitabilityScore"":3.9,""impactScore"":3.4},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":9.8,""baseSeverity"":""CRITICAL"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":3.9,""impactScore"":5.9}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:hpe:autopass_license_server:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""9.18"",""matchCriteriaId"":""9328E037-2E67-4E7F-A4B3-1695860718D0""}]}]}]",,,,,,,,
CVE-2025-37107,security-alert@hpe.com,2025-07-16T18:15:24.650,2025-07-25T15:28:37.847,Analyzed,[],An authentication bypass vulnerability exists in HPE AutoPass License Server (APLS) prior to 9.18.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-287""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbgn04877en_us"",""source"":""security-alert@hpe.com"",""tags"":[""Vendor Advisory""]}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L"",""baseScore"":7.3,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""LOW"",""integrityImpact"":""LOW"",""availabilityImpact"":""LOW""},""exploitabilityScore"":3.9,""impactScore"":3.4},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":9.8,""baseSeverity"":""CRITICAL"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":3.9,""impactScore"":5.9}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:hpe:autopass_license_server:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""9.18"",""matchCriteriaId"":""9328E037-2E67-4E7F-A4B3-1695860718D0""}]}]}]",,,,,,,,
CVE-2025-37108,security-alert@hpe.com,2025-07-31T20:15:32.357,2025-08-04T15:06:36.623,Awaiting Analysis,[],Cross-site scripting vulnerability has been identified in HPE Telco Service Activator product,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-79""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbnw04887en_us&docLocale=en_US"",""source"":""security-alert@hpe.com""}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:N/A:N"",""baseScore"":3.5,""baseSeverity"":""LOW"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""REQUIRED"",""scope"":""UNCHANGED"",""confidentialityImpact"":""LOW"",""integrityImpact"":""NONE"",""availabilityImpact"":""NONE""},""exploitabilityScore"":2.1,""impactScore"":1.4}]",,,,,,,,,
CVE-2025-37109,security-alert@hpe.com,2025-07-31T20:15:32.520,2025-08-04T19:15:30.953,Awaiting Analysis,[],Cross-site scripting vulnerability has been identified in HPE Telco Service Activator product,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-79""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbnw04887en_us&docLocale=en_US"",""source"":""security-alert@hpe.com""}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:N/A:N"",""baseScore"":3.5,""baseSeverity"":""LOW"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""REQUIRED"",""scope"":""UNCHANGED"",""confidentialityImpact"":""LOW"",""integrityImpact"":""NONE"",""availabilityImpact"":""NONE""},""exploitabilityScore"":2.1,""impactScore"":1.4}]",,,,,,,,,
CVE-2025-37110,security-alert@hpe.com,2025-07-31T20:15:32.667,2025-08-04T15:06:36.623,Awaiting Analysis,[],A vulnerability was discovered in the storage policy for certain sets of sensitive credential information in the HPE Telco Network Function Virtual Orchestrator. Successful Exploitation could lead to unauthorized parties gaining access to sensitive system information.,"[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-922""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbnw04891en_us"",""source"":""security-alert@hpe.com""}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:N/A:N"",""baseScore"":6.0,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""HIGH"",""userInteraction"":""NONE"",""scope"":""CHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""NONE"",""availabilityImpact"":""NONE""},""exploitabilityScore"":1.5,""impactScore"":4.0}]",,,,,,,,,
CVE-2025-37111,security-alert@hpe.com,2025-07-31T20:15:32.823,2025-08-04T15:06:36.623,Awaiting Analysis,[],A vulnerability was discovered in the storage policy for certain sets of authentication keys in the HPE Telco Network Function Virtual Orchestrator. Successful Exploitation could lead to unauthorized parties gaining access to sensitive system information.,"[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-798""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbnw04891en_us"",""source"":""security-alert@hpe.com""}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:N/A:N"",""baseScore"":6.0,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""HIGH"",""userInteraction"":""NONE"",""scope"":""CHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""NONE"",""availabilityImpact"":""NONE""},""exploitabilityScore"":1.5,""impactScore"":4.0}]",,,,,,,,,
CVE-2025-37112,security-alert@hpe.com,2025-07-31T20:15:32.990,2025-08-04T15:06:36.623,Awaiting Analysis,[],A vulnerability was discovered in the storage policy for certain sets of encryption keys in the HPE Telco Network Function Virtual Orchestrator. Successful Exploitation could lead to unauthorized parties gaining access to sensitive system information.,"[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-798""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbnw04891en_us"",""source"":""security-alert@hpe.com""}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:N/A:N"",""baseScore"":6.0,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""HIGH"",""userInteraction"":""NONE"",""scope"":""CHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""NONE"",""availabilityImpact"":""NONE""},""exploitabilityScore"":1.5,""impactScore"":4.0}]",,,,,,,,,
CVE-2025-37122,security-alert@hpe.com,2025-09-17T20:15:36.063,2025-09-17T20:15:36.063,Received,[],A vulnerability in the web-based management interface of network access control services could allow an unauthenticated remote attacker to conduct a Reflected Cross-Site Scripting (XSS) attack. Successful exploitation could allow an attacker to execute arbitrary JavaScript code in a victim's browser in the context of the affected interface.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-79""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbnw04950en_us&docLocale=en_US"",""source"":""security-alert@hpe.com""}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N"",""baseScore"":6.1,""baseSeverity"":""MEDIUM"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""REQUIRED"",""scope"":""CHANGED"",""confidentialityImpact"":""LOW"",""integrityImpact"":""LOW"",""availabilityImpact"":""NONE""},""exploitabilityScore"":2.8,""impactScore"":2.7}]",,,,,,,,,
CVE-2025-37123,security-alert@hpe.com,2025-09-16T23:15:31.893,2025-09-17T14:18:55.093,Awaiting Analysis,[],A vulnerability in the command-line interface of HPE Aruba Networking EdgeConnect SD-WAN Gateways could allow an authenticated remote attacker to escalate privileges. Successful exploitation of this vulnerability may enable the attacker to execute arbitrary system commands with root privileges on the underlying operating system.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-269""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbnw04943en_us&docLocale=en_US"",""source"":""security-alert@hpe.com""}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":8.8,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":2.8,""impactScore"":5.9}]",,,,,,,,,
CVE-2025-37124,security-alert@hpe.com,2025-09-16T23:15:32.103,2025-09-17T14:18:55.093,Awaiting Analysis,[],"A vulnerability in the HPE Aruba Networking SD-WAN Gateways could allow an unauthenticated remote attacker to bypass firewall protections. Successful exploitation could allow an attacker to route potentially harmful traffic through the internal network, leading to unauthorized access or disruption of services.","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-693""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbnw04943en_us&docLocale=en_US"",""source"":""security-alert@hpe.com""}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:H"",""baseScore"":8.6,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""LOW"",""integrityImpact"":""LOW"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":3.9,""impactScore"":4.7}]",,,,,,,,,
CVE-2025-37125,security-alert@hpe.com,2025-09-16T23:15:32.237,2025-09-17T14:18:55.093,Awaiting Analysis,[],"A broken access control vulnerability exists in HPE Aruba Networking EdgeConnect OS (ECOS). Successful exploitation could allow an attacker to bypass firewall protections, potentially leading to unauthorized traffic being handled improperly","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-284""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbnw04943en_us&docLocale=en_US"",""source"":""security-alert@hpe.com""}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N"",""baseScore"":7.5,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""NONE"",""availabilityImpact"":""NONE""},""exploitabilityScore"":3.9,""impactScore"":3.6}]",,,,,,,,,
CVE-2025-37126,security-alert@hpe.com,2025-09-16T23:15:32.370,2025-09-17T14:18:55.093,Awaiting Analysis,[],A vulnerability exists in the HPE Aruba Networking EdgeConnect SD-WAN Gateways Command Line Interface that allows remote authenticated users to run arbitrary commands on the underlying host. Successful exploitation of this vulnerability will result in the ability to execute arbitrary commands as root on the underlying operating system.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-78""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbnw04943en_us&docLocale=en_US"",""source"":""security-alert@hpe.com""}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":7.2,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""HIGH"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.2,""impactScore"":5.9}]",,,,,,,,,
CVE-2025-37127,security-alert@hpe.com,2025-09-16T23:15:32.493,2025-09-17T14:18:55.093,Awaiting Analysis,[],"A vulnerability in the cryptographic logic used by HPE Aruba Networking EdgeConnect SD-WAN Gateways could allow an authenticated remote attacker to gain shell access. Successful exploitation could allow an attacker to execute arbitrary commands on the underlying operating system, potentially leading to unauthorized access and control over the affected systems.","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-327""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbnw04943en_us&docLocale=en_US"",""source"":""security-alert@hpe.com""}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:H/PR:H/UI:R/S:C/C:H/I:H/A:H"",""baseScore"":7.2,""baseSeverity"":""HIGH"",""attackVector"":""LOCAL"",""attackComplexity"":""HIGH"",""privilegesRequired"":""HIGH"",""userInteraction"":""REQUIRED"",""scope"":""CHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":0.6,""impactScore"":6.0}]",,,,,,,,,
CVE-2025-37128,security-alert@hpe.com,2025-09-16T23:15:32.640,2025-09-17T14:18:55.093,Awaiting Analysis,[],"A vulnerability in the web API of HPE Aruba Networking EdgeConnect SD-WAN Gateways could allow an authenticated remote attacker to terminate arbitrary running processes. Successful exploitation could allow an attacker to disrupt system operations, potentially resulting in an unstable system state.","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-250""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbnw04943en_us&docLocale=en_US"",""source"":""security-alert@hpe.com""}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:N/I:N/A:H"",""baseScore"":6.8,""baseSeverity"":""MEDIUM"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""REQUIRED"",""scope"":""CHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":2.3,""impactScore"":4.0}]",,,,,,,,,
CVE-2025-37129,security-alert@hpe.com,2025-09-16T23:15:32.773,2025-09-17T14:18:55.093,Awaiting Analysis,[],A vulnerable feature in the command line interface of EdgeConnect SD-WAN could allow an authenticated attacker to exploit built-in script execution capabilities. Successful exploitation could allow an attacker to execute arbitrary commands on the underlying operating system if the feature is enabled without proper security measures.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-78""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbnw04943en_us&docLocale=en_US"",""source"":""security-alert@hpe.com""}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":6.7,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""HIGH"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":0.8,""impactScore"":5.9}]",,,,,,,,,
CVE-2025-37130,security-alert@hpe.com,2025-09-16T23:15:32.897,2025-09-17T14:18:55.093,Awaiting Analysis,[],A vulnerability in the command-line interface of EdgeConnect SD-WAN could allow an authenticated attacker to read arbitrary files within the system. Successful exploitation could allow an attacker to read sensitive data from the underlying file system.,"[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-552""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbnw04943en_us&docLocale=en_US"",""source"":""security-alert@hpe.com""}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"",""baseScore"":6.5,""baseSeverity"":""MEDIUM"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""NONE"",""availabilityImpact"":""NONE""},""exploitabilityScore"":2.8,""impactScore"":3.6}]",,,,,,,,,
CVE-2025-37131,security-alert@hpe.com,2025-09-16T23:15:33.023,2025-09-17T14:18:55.093,Awaiting Analysis,[],"A vulnerability in EdgeConnect SD-WAN ECOS could allow an authenticated remote threat actor with admin privileges to access sensitive unauthorized system files. Under certain conditions, this could lead to exposure and exfiltration of sensitive information.","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-284""}]}]","[{""url"":""https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbnw04943en_us&docLocale=en_US"",""source"":""security-alert@hpe.com""}]","[{""source"":""security-alert@hpe.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N"",""baseScore"":4.9,""baseSeverity"":""MEDIUM"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""HIGH"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""NONE"",""availabilityImpact"":""NONE""},""exploitabilityScore"":1.2,""impactScore"":3.6}]",,,,,,,,,
CVE-2025-37730,bressers@elastic.co,2025-05-06T18:15:38.410,2025-05-07T14:13:20.483,Awaiting Analysis,[],"Improper certificate validation in Logstash's TCP output could lead to a man-in-the-middle (MitM) attack in client mode, as hostname verification in TCP output was not being performed when the ssl_verification_mode => full was set.","[{""source"":""bressers@elastic.co"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-295""}]}]","[{""url"":""https://discuss.elastic.co/t/logstash-8-17-6-8-18-1-and-9-0-1-security-update-esa-2025-08/377869"",""source"":""bressers@elastic.co""}]","[{""source"":""bressers@elastic.co"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:L/A:N"",""baseScore"":6.5,""baseSeverity"":""MEDIUM"",""attackVector"":""NETWORK"",""attackComplexity"":""HIGH"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""LOW"",""availabilityImpact"":""NONE""},""exploitabilityScore"":2.2,""impactScore"":4.2}]",,,,,,,,,
CVE-2025-37738,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:52.383,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: ignore xattrs past end Once inside 'ext4_xattr_inode_dec_ref_all' we should ignore xattrs entries past the 'end' entry. This fixes the following KASAN reported issue: ================================================================== BUG: KASAN: slab-use-after-free in ext4_xattr_inode_dec_ref_all+0xb8c/0xe90 Read of size 4 at addr ffff888012c120c4 by task repro/2065 CPU: 1 UID: 0 PID: 2065 Comm: repro Not tainted 6.13.0-rc2+ #11 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x1fd/0x300 ? tcp_gro_dev_warn+0x260/0x260 ? _printk+0xc0/0x100 ? read_lock_is_recursive+0x10/0x10 ? irq_work_queue+0x72/0xf0 ? __virt_addr_valid+0x17b/0x4b0 print_address_description+0x78/0x390 print_report+0x107/0x1f0 ? __virt_addr_valid+0x17b/0x4b0 ? __virt_addr_valid+0x3ff/0x4b0 ? __phys_addr+0xb5/0x160 ? ext4_xattr_inode_dec_ref_all+0xb8c/0xe90 kasan_report+0xcc/0x100 ? ext4_xattr_inode_dec_ref_all+0xb8c/0xe90 ext4_xattr_inode_dec_ref_all+0xb8c/0xe90 ? ext4_xattr_delete_inode+0xd30/0xd30 ? __ext4_journal_ensure_credits+0x5f0/0x5f0 ? __ext4_journal_ensure_credits+0x2b/0x5f0 ? inode_update_timestamps+0x410/0x410 ext4_xattr_delete_inode+0xb64/0xd30 ? ext4_truncate+0xb70/0xdc0 ? ext4_expand_extra_isize_ea+0x1d20/0x1d20 ? __ext4_mark_inode_dirty+0x670/0x670 ? ext4_journal_check_start+0x16f/0x240 ? ext4_inode_is_fast_symlink+0x2f2/0x3a0 ext4_evict_inode+0xc8c/0xff0 ? ext4_inode_is_fast_symlink+0x3a0/0x3a0 ? do_raw_spin_unlock+0x53/0x8a0 ? ext4_inode_is_fast_symlink+0x3a0/0x3a0 evict+0x4ac/0x950 ? proc_nr_inodes+0x310/0x310 ? trace_ext4_drop_inode+0xa2/0x220 ? _raw_spin_unlock+0x1a/0x30 ? iput+0x4cb/0x7e0 do_unlinkat+0x495/0x7c0 ? try_break_deleg+0x120/0x120 ? 0xffffffff81000000 ? __check_object_size+0x15a/0x210 ? strncpy_from_user+0x13e/0x250 ? getname_flags+0x1dc/0x530 __x64_sys_unlinkat+0xc8/0xf0 do_syscall_64+0x65/0x110 entry_SYSCALL_64_after_hwframe+0x67/0x6f RIP: 0033:0x434ffd Code: 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 8 RSP: 002b:00007ffc50fa7b28 EFLAGS: 00000246 ORIG_RAX: 0000000000000107 RAX: ffffffffffffffda RBX: 00007ffc50fa7e18 RCX: 0000000000434ffd RDX: 0000000000000000 RSI: 0000000020000240 RDI: 0000000000000005 RBP: 00007ffc50fa7be0 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000001 R13: 00007ffc50fa7e08 R14: 00000000004bbf30 R15: 0000000000000001 </TASK> The buggy address belongs to the object at ffff888012c12000 which belongs to the cache filp of size 360 The buggy address is located 196 bytes inside of freed 360-byte region [ffff888012c12000, ffff888012c12168) The buggy address belongs to the physical page: page: refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x12c12 head: order:1 mapcount:0 entire_mapcount:0 nr_pages_mapped:0 pincount:0 flags: 0x40(head|node=0|zone=0) page_type: f5(slab) raw: 0000000000000040 ffff888000ad7640 ffffea0000497a00 dead000000000004 raw: 0000000000000000 0000000000100010 00000001f5000000 0000000000000000 head: 0000000000000040 ffff888000ad7640 ffffea0000497a00 dead000000000004 head: 0000000000000000 0000000000100010 00000001f5000000 0000000000000000 head: 0000000000000001 ffffea00004b0481 ffffffffffffffff 0000000000000000 head: 0000000000000002 0000000000000000 00000000ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffff888012c11f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ffff888012c12000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb > ffff888012c12080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ^ ffff888012c12100: fb fb fb fb fb fb fb fb fb fb fb fb fb fc fc fc ffff888012c12180: fc fc fc fc fc fc fc fc fc ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/362a90cecd36e8a5c415966d0b75b04a0270e4dd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3bc6317033f365ce578eb6039445fb66162722fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6aff941cb0f7d0c897c3698ad2e30672709135e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/76c365fa7e2a8bb85f0190cdb4b8cdc99b2fdce3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/836e625b03a666cf93ff5be328c8cb30336db872"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c8e008b60492cf6fd31ef127aea6d02fd3d314cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cf9291a3449b04688b81e32621e88de8f4314b54"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb59cc31b6ea076021d14b04e7faab1636b87d0e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f737418b6de31c962c7192777ee4018906975383"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37739,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:52.500,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to avoid out-of-bounds access in f2fs_truncate_inode_blocks() syzbot reports an UBSAN issue as below: ------------[ cut here ]------------ UBSAN: array-index-out-of-bounds in fs/f2fs/node.h:381:10 index 18446744073709550692 is out of range for type '__le32[5]' (aka 'unsigned int[5]') CPU: 0 UID: 0 PID: 5318 Comm: syz.0.0 Not tainted 6.14.0-rc3-syzkaller-00060-g6537cfb395f3 #0 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 ubsan_epilogue lib/ubsan.c:231 [inline] __ubsan_handle_out_of_bounds+0x121/0x150 lib/ubsan.c:429 get_nid fs/f2fs/node.h:381 [inline] f2fs_truncate_inode_blocks+0xa5e/0xf60 fs/f2fs/node.c:1181 f2fs_do_truncate_blocks+0x782/0x1030 fs/f2fs/file.c:808 f2fs_truncate_blocks+0x10d/0x300 fs/f2fs/file.c:836 f2fs_truncate+0x417/0x720 fs/f2fs/file.c:886 f2fs_file_write_iter+0x1bdb/0x2550 fs/f2fs/file.c:5093 aio_write+0x56b/0x7c0 fs/aio.c:1633 io_submit_one+0x8a7/0x18a0 fs/aio.c:2052 __do_sys_io_submit fs/aio.c:2111 [inline] __se_sys_io_submit+0x171/0x2e0 fs/aio.c:2081 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7f238798cde9 index 18446744073709550692 (decimal, unsigned long long) = 0xfffffffffffffc64 (hexadecimal, unsigned long long) = -924 (decimal, long long) In f2fs_truncate_inode_blocks(), UBSAN detects that get_nid() tries to access .i_nid[-924], it means both offset[0] and level should zero. The possible case should be in f2fs_do_truncate_blocks(), we try to truncate inode size to zero, however, dn.ofs_in_node is zero and dn.node_page is not an inode page, so it fails to truncate inode page, and then pass zeroed free_from to f2fs_truncate_inode_blocks(), result in this issue. if (dn.ofs_in_node || IS_INODE(dn.node_page)) { f2fs_truncate_data_blocks_range(&dn, count); free_from += count; } I guess the reason why dn.node_page is not an inode page could be: there are multiple nat entries share the same node block address, once the node block address was reused, f2fs_get_node_page() may load a non-inode block. Let's add a sanity check for such condition to avoid out-of-bounds access issue.",,"[{""url"":""https://git.kernel.org/stable/c/67e16ccba74dd8de0a7b10062f1e02d77432f573"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6ba8b41d0aa4b82f90f0c416cb53fcef9696525d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8b5e5aac44fee122947a269f9034c048e4c295de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/98dbf2af63de0b551082c9bc48333910e009b09f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a67e1bf03c609a751d1740a1789af25e599966fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d7242fd7946d4cba0411effb6b5048ca55125747"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e6494977bd4a83862118a05f57a8df40256951c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ecc461331604b07cdbdb7360dbdf78471653264c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37740,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:52.617,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: jfs: add sanity check for agwidth in dbMount The width in dmapctl of the AG is zero, it trigger a divide error when calculating the control page level in dbAllocAG. To avoid this issue, add a check for agwidth in dbAllocAG.",,"[{""url"":""https://git.kernel.org/stable/c/722e72f7f9c69fcb3ab7988c2471feff7a4c8de1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a065cec230aa807c18828a3eee82f1c8592c2adf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a260bf14cd347878f01f70739ba829442a474a16"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a741f29ac8b6374c9904be8b7ac7cdfcd7e7e4fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c8c96a9e7660e5e5eea445978fe8f2e432d91c1f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc0bc4cb62ce5fa0c383e3bf0765d01f46bd49ac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ccd97c8a4f90810f228ee40d1055148fa146dd57"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ddf2846f22e8575d6b4b6a66f2100f168b8cd73d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3f85edb03183fb06539e5b50dd2c4bb42b869f0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37741,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:52.723,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: jfs: Prevent copying of nlink with value 0 from disk inode syzbot report a deadlock in diFree. [1] When calling ""ioctl$LOOP_SET_STATUS64"", the offset value passed in is 4, which does not match the mounted loop device, causing the mapping of the mounted loop device to be invalidated. When creating the directory and creating the inode of iag in diReadSpecial(), read the page of fixed disk inode (AIT) in raw mode in read_metapage(), the metapage data it returns is corrupted, which causes the nlink value of 0 to be assigned to the iag inode when executing copy_from_dinode(), which ultimately causes a deadlock when entering diFree(). To avoid this, first check the nlink value of dinode before setting iag inode. [1] WARNING: possible recursive locking detected 6.12.0-rc7-syzkaller-00212-g4a5df3796467 #0 Not tainted -------------------------------------------- syz-executor301/5309 is trying to acquire lock: ffff888044548920 (&(imap->im_aglock[index])){+.+.}-{3:3}, at: diFree+0x37c/0x2fb0 fs/jfs/jfs_imap.c:889 but task is already holding lock: ffff888044548920 (&(imap->im_aglock[index])){+.+.}-{3:3}, at: diAlloc+0x1b6/0x1630 other info that might help us debug this: Possible unsafe locking scenario: CPU0 ---- lock(&(imap->im_aglock[index])); lock(&(imap->im_aglock[index])); *** DEADLOCK *** May be due to missing lock nesting notation 5 locks held by syz-executor301/5309: #0: ffff8880422a4420 (sb_writers#9){.+.+}-{0:0}, at: mnt_want_write+0x3f/0x90 fs/namespace.c:515 #1: ffff88804755b390 (&type->i_mutex_dir_key#6/1){+.+.}-{3:3}, at: inode_lock_nested include/linux/fs.h:850 [inline] #1: ffff88804755b390 (&type->i_mutex_dir_key#6/1){+.+.}-{3:3}, at: filename_create+0x260/0x540 fs/namei.c:4026 #2: ffff888044548920 (&(imap->im_aglock[index])){+.+.}-{3:3}, at: diAlloc+0x1b6/0x1630 #3: ffff888044548890 (&imap->im_freelock){+.+.}-{3:3}, at: diNewIAG fs/jfs/jfs_imap.c:2460 [inline] #3: ffff888044548890 (&imap->im_freelock){+.+.}-{3:3}, at: diAllocExt fs/jfs/jfs_imap.c:1905 [inline] #3: ffff888044548890 (&imap->im_freelock){+.+.}-{3:3}, at: diAllocAG+0x4b7/0x1e50 fs/jfs/jfs_imap.c:1669 #4: ffff88804755a618 (&jfs_ip->rdwrlock/1){++++}-{3:3}, at: diNewIAG fs/jfs/jfs_imap.c:2477 [inline] #4: ffff88804755a618 (&jfs_ip->rdwrlock/1){++++}-{3:3}, at: diAllocExt fs/jfs/jfs_imap.c:1905 [inline] #4: ffff88804755a618 (&jfs_ip->rdwrlock/1){++++}-{3:3}, at: diAllocAG+0x869/0x1e50 fs/jfs/jfs_imap.c:1669 stack backtrace: CPU: 0 UID: 0 PID: 5309 Comm: syz-executor301 Not tainted 6.12.0-rc7-syzkaller-00212-g4a5df3796467 #0 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_deadlock_bug+0x483/0x620 kernel/locking/lockdep.c:3037 check_deadlock kernel/locking/lockdep.c:3089 [inline] validate_chain+0x15e2/0x5920 kernel/locking/lockdep.c:3891 __lock_acquire+0x1384/0x2050 kernel/locking/lockdep.c:5202 lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5825 __mutex_lock_common kernel/locking/mutex.c:608 [inline] __mutex_lock+0x136/0xd70 kernel/locking/mutex.c:752 diFree+0x37c/0x2fb0 fs/jfs/jfs_imap.c:889 jfs_evict_inode+0x32d/0x440 fs/jfs/inode.c:156 evict+0x4e8/0x9b0 fs/inode.c:725 diFreeSpecial fs/jfs/jfs_imap.c:552 [inline] duplicateIXtree+0x3c6/0x550 fs/jfs/jfs_imap.c:3022 diNewIAG fs/jfs/jfs_imap.c:2597 [inline] diAllocExt fs/jfs/jfs_imap.c:1905 [inline] diAllocAG+0x17dc/0x1e50 fs/jfs/jfs_imap.c:1669 diAlloc+0x1d2/0x1630 fs/jfs/jfs_imap.c:1590 ialloc+0x8f/0x900 fs/jfs/jfs_inode.c:56 jfs_mkdir+0x1c5/0xba0 fs/jfs/namei.c:225 vfs_mkdir+0x2f9/0x4f0 fs/namei.c:4257 do_mkdirat+0x264/0x3a0 fs/namei.c:4280 __do_sys_mkdirat fs/namei.c:4295 [inline] __se_sys_mkdirat fs/namei.c:4293 [inline] __x64_sys_mkdirat+0x87/0xa0 fs/namei.c:4293 do_syscall_x64 arch/x86/en ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/5b2f26d3fba4e9aac314f8bc0963b3fc28c0e456"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/86bfeaa18f9e4615b97f2d613e0fcc4ced196527"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8b5ce75f8bd3ddf480cc0a240d7ff5cdea0444f9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/994787341358816d91b2fded288ecb7f129f2b27"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a2b560815528ae8e266fca6038bb5585d13aaef4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aeb926e605f97857504bdf748f575e40617e2ef9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3c4884b987e5d8d0ec061a4d52653c4f4b9c37e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b61e69bb1c049cf507e3c654fa3dc1568231bd07"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c9541c2bd0edbdbc5c1148a84d3b48dc8d1b8af2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37742,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:52.870,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: jfs: Fix uninit-value access of imap allocated in the diMount() function syzbot reports that hex_dump_to_buffer is using uninit-value: ===================================================== BUG: KMSAN: uninit-value in hex_dump_to_buffer+0x888/0x1100 lib/hexdump.c:171 hex_dump_to_buffer+0x888/0x1100 lib/hexdump.c:171 print_hex_dump+0x13d/0x3e0 lib/hexdump.c:276 diFree+0x5ba/0x4350 fs/jfs/jfs_imap.c:876 jfs_evict_inode+0x510/0x550 fs/jfs/inode.c:156 evict+0x723/0xd10 fs/inode.c:796 iput_final fs/inode.c:1946 [inline] iput+0x97b/0xdb0 fs/inode.c:1972 txUpdateMap+0xf3e/0x1150 fs/jfs/jfs_txnmgr.c:2367 txLazyCommit fs/jfs/jfs_txnmgr.c:2664 [inline] jfs_lazycommit+0x627/0x11d0 fs/jfs/jfs_txnmgr.c:2733 kthread+0x6b9/0xef0 kernel/kthread.c:464 ret_from_fork+0x6d/0x90 arch/x86/kernel/process.c:148 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 Uninit was created at: slab_post_alloc_hook mm/slub.c:4121 [inline] slab_alloc_node mm/slub.c:4164 [inline] __kmalloc_cache_noprof+0x8e3/0xdf0 mm/slub.c:4320 kmalloc_noprof include/linux/slab.h:901 [inline] diMount+0x61/0x7f0 fs/jfs/jfs_imap.c:105 jfs_mount+0xa8e/0x11d0 fs/jfs/jfs_mount.c:176 jfs_fill_super+0xa47/0x17c0 fs/jfs/super.c:523 get_tree_bdev_flags+0x6ec/0x910 fs/super.c:1636 get_tree_bdev+0x37/0x50 fs/super.c:1659 jfs_get_tree+0x34/0x40 fs/jfs/super.c:635 vfs_get_tree+0xb1/0x5a0 fs/super.c:1814 do_new_mount+0x71f/0x15e0 fs/namespace.c:3560 path_mount+0x742/0x1f10 fs/namespace.c:3887 do_mount fs/namespace.c:3900 [inline] __do_sys_mount fs/namespace.c:4111 [inline] __se_sys_mount+0x71f/0x800 fs/namespace.c:4088 __x64_sys_mount+0xe4/0x150 fs/namespace.c:4088 x64_sys_call+0x39bf/0x3c30 arch/x86/include/generated/asm/syscalls_64.h:166 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f ===================================================== The reason is that imap is not properly initialized after memory allocation. It will cause the snprintf() function to write uninitialized data into linebuf within hex_dump_to_buffer(). Fix this by using kzalloc instead of kmalloc to clear its content at the beginning in diMount().",,"[{""url"":""https://git.kernel.org/stable/c/067347e00a3a7d04afed93f080c6c131e5dd15ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4f10732712fce33e53703ffe5ed9155f23814097"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/63148ce4904faa668daffdd1d3c1199ae315ef2c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7057f3aab47629d38e54eae83505813cf0da1e4b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9629d7d66c621671d9a47afe27ca9336bfc8a9ea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cab1852368dd74d629ee02abdbc559218ca64dde"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d0d7eca253ccd0619b3d2b683ffe32218ebca9ac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37743,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:53.000,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: Avoid memory leak while enabling statistics Driver uses monitor destination rings for extended statistics mode and standalone monitor mode. In extended statistics mode, TLVs are parsed from the buffer received from the monitor destination ring and assigned to the ppdu_info structure to update per-packet statistics. In standalone monitor mode, along with per-packet statistics, the packet data (payload) is captured, and the driver updates per MSDU to mac80211. When the AP interface is enabled, only extended statistics mode is activated. As part of enabling monitor rings for collecting statistics, the driver subscribes to HAL_RX_MPDU_START TLV in the filter configuration. This TLV is received from the monitor destination ring, and kzalloc for the mon_mpdu object occurs, which is not freed, leading to a memory leak. The kzalloc for the mon_mpdu object is only required while enabling the standalone monitor interface. This causes a memory leak while enabling extended statistics mode in the driver. Fix this memory leak by removing the kzalloc for the mon_mpdu object in the HAL_RX_MPDU_START TLV handling. Additionally, remove the standalone monitor mode handlings in the HAL_MON_BUF_ADDR and HAL_RX_MSDU_END TLVs. These TLV tags will be handled properly when enabling standalone monitor mode in the future. Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1 Tested-on: WCN7850 hw2.0 PCI WLAN.HMT.1.0.c5-00481-QCAHMTSWPL_V1.0_V2.0_SILICONZ-3",,"[{""url"":""https://git.kernel.org/stable/c/286bab0fc7b9db728dab8c63cadf6be9b3facf8c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ecfc131389923405be8e7a6f4408fd9321e4d19b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37744,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:53.100,2025-09-03T14:15:44.970,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: fix memory leak in ath12k_pci_remove() Kmemleak reported this error: unreferenced object 0xffff1c165cec3060 (size 32): comm ""insmod"", pid 560, jiffies 4296964570 (age 235.596s) backtrace: [<000000005434db68>] __kmem_cache_alloc_node+0x1f4/0x2c0 [<000000001203b155>] kmalloc_trace+0x40/0x88 [<0000000028adc9c8>] _request_firmware+0xb8/0x608 [<00000000cad1aef7>] firmware_request_nowarn+0x50/0x80 [<000000005011a682>] local_pci_probe+0x48/0xd0 [<00000000077cd295>] pci_device_probe+0xb4/0x200 [<0000000087184c94>] really_probe+0x150/0x2c0 The firmware memory was allocated in ath12k_pci_probe(), but not freed in ath12k_pci_remove() in case ATH12K_FLAG_QMI_FAIL bit is set. So call ath12k_fw_unmap() to free the memory. Tested-on: WCN7850 hw2.0 PCI WLAN.HMT.2.0-02280-QCAHMTSWPL_V1.0_V2.0_SILICONZ-1",,"[{""url"":""https://git.kernel.org/stable/c/1b24394ed5c8a8d8f7b9e3aa9044c31495d46f2e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/52e3132e62c31b5ade43dc4495fa81175e6e8398"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37745,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:53.207,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: PM: hibernate: Avoid deadlock in hibernate_compressor_param_set() syzbot reported a deadlock in lock_system_sleep() (see below). The write operation to ""/sys/module/hibernate/parameters/compressor"" conflicts with the registration of ieee80211 device, resulting in a deadlock when attempting to acquire system_transition_mutex under param_lock. To avoid this deadlock, change hibernate_compressor_param_set() to use mutex_trylock() for attempting to acquire system_transition_mutex and return -EBUSY when it fails. Task flags need not be saved or adjusted before calling mutex_trylock(&system_transition_mutex) because the caller is not going to end up waiting for this mutex and if it runs concurrently with system suspend in progress, it will be frozen properly when it returns to user space. syzbot report: syz-executor895/5833 is trying to acquire lock: ffffffff8e0828c8 (system_transition_mutex){+.+.}-{4:4}, at: lock_system_sleep+0x87/0xa0 kernel/power/main.c:56 but task is already holding lock: ffffffff8e07dc68 (param_lock){+.+.}-{4:4}, at: kernel_param_lock kernel/params.c:607 [inline] ffffffff8e07dc68 (param_lock){+.+.}-{4:4}, at: param_attr_store+0xe6/0x300 kernel/params.c:586 which lock already depends on the new lock. the existing dependency chain (in reverse order) is: -> #3 (param_lock){+.+.}-{4:4}: __mutex_lock_common kernel/locking/mutex.c:585 [inline] __mutex_lock+0x19b/0xb10 kernel/locking/mutex.c:730 ieee80211_rate_control_ops_get net/mac80211/rate.c:220 [inline] rate_control_alloc net/mac80211/rate.c:266 [inline] ieee80211_init_rate_ctrl_alg+0x18d/0x6b0 net/mac80211/rate.c:1015 ieee80211_register_hw+0x20cd/0x4060 net/mac80211/main.c:1531 mac80211_hwsim_new_radio+0x304e/0x54e0 drivers/net/wireless/virtual/mac80211_hwsim.c:5558 init_mac80211_hwsim+0x432/0x8c0 drivers/net/wireless/virtual/mac80211_hwsim.c:6910 do_one_initcall+0x128/0x700 init/main.c:1257 do_initcall_level init/main.c:1319 [inline] do_initcalls init/main.c:1335 [inline] do_basic_setup init/main.c:1354 [inline] kernel_init_freeable+0x5c7/0x900 init/main.c:1568 kernel_init+0x1c/0x2b0 init/main.c:1457 ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:148 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 -> #2 (rtnl_mutex){+.+.}-{4:4}: __mutex_lock_common kernel/locking/mutex.c:585 [inline] __mutex_lock+0x19b/0xb10 kernel/locking/mutex.c:730 wg_pm_notification drivers/net/wireguard/device.c:80 [inline] wg_pm_notification+0x49/0x180 drivers/net/wireguard/device.c:64 notifier_call_chain+0xb7/0x410 kernel/notifier.c:85 notifier_call_chain_robust kernel/notifier.c:120 [inline] blocking_notifier_call_chain_robust kernel/notifier.c:345 [inline] blocking_notifier_call_chain_robust+0xc9/0x170 kernel/notifier.c:333 pm_notifier_call_chain_robust+0x27/0x60 kernel/power/main.c:102 snapshot_open+0x189/0x2b0 kernel/power/user.c:77 misc_open+0x35a/0x420 drivers/char/misc.c:179 chrdev_open+0x237/0x6a0 fs/char_dev.c:414 do_dentry_open+0x735/0x1c40 fs/open.c:956 vfs_open+0x82/0x3f0 fs/open.c:1086 do_open fs/namei.c:3830 [inline] path_openat+0x1e88/0x2d80 fs/namei.c:3989 do_filp_open+0x20c/0x470 fs/namei.c:4016 do_sys_openat2+0x17a/0x1e0 fs/open.c:1428 do_sys_open fs/open.c:1443 [inline] __do_sys_openat fs/open.c:1459 [inline] __se_sys_openat fs/open.c:1454 [inline] __x64_sys_openat+0x175/0x210 fs/open.c:1454 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f -> #1 ((pm_chain_head).rwsem){++++}-{4:4}: down_read+0x9a/0x330 kernel/locking/rwsem.c:1524 blocking_notifier_call_chain_robust kerne ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/11ae4fec1f4b4ee06770a572c37d89cbaecbf66e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3b2c3806ef4253595dfcb8b58352cfab55c9bfb0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/52323ed1444ea5c2a5f1754ea0a2d9c8c216ccdf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6dbaa8583af74814a5aae03a337cb1722c414808"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37746,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:53.313,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: perf/dwc_pcie: fix duplicate pci_dev devices During platform_device_register, wrongly using struct device pci_dev as platform_data caused a kmemdup copy of pci_dev. Worse still, accessing the duplicated device leads to list corruption as its mutex content (e.g., list, magic) remains the same as the original.",,"[{""url"":""https://git.kernel.org/stable/c/7f35b429802a8065aa61e2a3f567089649f4d98e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a71c6fc87b2b9905dc2e38887fe4122287216be9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37747,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:53.417,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: perf: Fix hang while freeing sigtrap event Perf can hang while freeing a sigtrap event if a related deferred signal hadn't managed to be sent before the file got closed: perf_event_overflow() task_work_add(perf_pending_task) fput() task_work_add(____fput()) task_work_run() ____fput() perf_release() perf_event_release_kernel() _free_event() perf_pending_task_sync() task_work_cancel() -> FAILED rcuwait_wait_event() Once task_work_run() is running, the list of pending callbacks is removed from the task_struct and from this point on task_work_cancel() can't remove any pending and not yet started work items, hence the task_work_cancel() failure and the hang on rcuwait_wait_event(). Task work could be changed to remove one work at a time, so a work running on the current task can always cancel a pending one, however the wait / wake design is still subject to inverted dependencies when remote targets are involved, as pictured by Oleg: T1 T2 fd = perf_event_open(pid => T2->pid); fd = perf_event_open(pid => T1->pid); close(fd) close(fd) <IRQ> <IRQ> perf_event_overflow() perf_event_overflow() task_work_add(perf_pending_task) task_work_add(perf_pending_task) </IRQ> </IRQ> fput() fput() task_work_add(____fput()) task_work_add(____fput()) task_work_run() task_work_run() ____fput() ____fput() perf_release() perf_release() perf_event_release_kernel() perf_event_release_kernel() _free_event() _free_event() perf_pending_task_sync() perf_pending_task_sync() rcuwait_wait_event() rcuwait_wait_event() Therefore the only option left is to acquire the event reference count upon queueing the perf task work and release it from the task work, just like it was done before 3a5465418f5f (""perf: Fix event leak upon exec and file release"") but without the leaks it fixed. Some adjustments are necessary to make it work: * A child event might dereference its parent upon freeing. Care must be taken to release the parent last. * Some places assuming the event doesn't have any reference held and therefore can be freed right away must instead put the reference and let the reference counting to its job.",,"[{""url"":""https://git.kernel.org/stable/c/1267bd38f161c1a27d9b722de017027167a225a0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/56799bc035658738f362acec3e7647bb84e68933"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/665b87b8f8b3aeb49083ef3b65c4953e7753fc12"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa1827fa968c0674e9b6fca223fa9fb4da4493eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37748,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:53.523,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iommu/mediatek: Fix NULL pointer deference in mtk_iommu_device_group Currently, mtk_iommu calls during probe iommu_device_register before the hw_list from driver data is initialized. Since iommu probing issue fix, it leads to NULL pointer dereference in mtk_iommu_device_group when hw_list is accessed with list_first_entry (not null safe). So, change the call order to ensure iommu_device_register is called after the driver data are initialized.",,"[{""url"":""https://git.kernel.org/stable/c/2f75cb27bef43c8692b0f5e471e5632f6a9beb99"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/38e8844005e6068f336a3ad45451a562a0040ca1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/69f9d2d37d1207c5a73dac52a4ce1361ead707f5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6abd09bed43b8d83d461e0fb5b9a200a06aa8a27"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a0842539e8ef9386c070156103aff888e558a60c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce7d3b2f6f393fa35f0ea12861b83a1ca28b295c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37749,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:53.633,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: ppp: Add bound checking for skb data on ppp_sync_txmung Ensure we have enough data in linear buffer from skb before accessing initial bytes. This prevents potential out-of-bounds accesses when processing short packets. When ppp_sync_txmung receives an incoming package with an empty payload: (remote) gef p *(struct pppoe_hdr *) (skb->head + skb->network_header) $18 = { type = 0x1, ver = 0x1, code = 0x0, sid = 0x2, length = 0x0, tag = 0xffff8880371cdb96 } from the skb struct (trimmed) tail = 0x16, end = 0x140, head = 0xffff88803346f400 ""4"", data = 0xffff88803346f416 "":\377"", truesize = 0x380, len = 0x0, data_len = 0x0, mac_len = 0xe, hdr_len = 0x0, it is not safe to access data[2]. [pabeni@redhat.com: fixed subj typo]",,"[{""url"":""https://git.kernel.org/stable/c/1f6eb9fa87a781d5370c0de7794ae242f1a95ee5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/529401c8f12ecc35f9ea5d946d5a5596cf172b48"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6e8a6bf43cea4347121ab21bb1ed8d7bef7e732e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/99aa698dec342a07125d733e39aab4394b3b7e05"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aabc6596ffb377c4c9c8f335124b92ea282c9821"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b4c836d33ca888695b2f2665f948bc1b34fbd533"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b78f2b458f56a5a4d976c8e01c43dbf58d3ea2ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de5a4f0cba58625e88b7bebd88f780c8c0150997"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fbaffe8bccf148ece8ad67eb5d7aa852cabf59c8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37750,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:53.740,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: smb: client: fix UAF in decryption with multichannel After commit f7025d861694 (""smb: client: allocate crypto only for primary server"") and commit b0abcd65ec54 (""smb: client: fix UAF in async decryption""), the channels started reusing AEAD TFM from primary channel to perform synchronous decryption, but that can't done as there could be multiple cifsd threads (one per channel) simultaneously accessing it to perform decryption. This fixes the following KASAN splat when running fstest generic/249 with 'vers=3.1.1,multichannel,max_channels=4,seal' against Windows Server 2022: BUG: KASAN: slab-use-after-free in gf128mul_4k_lle+0xba/0x110 Read of size 8 at addr ffff8881046c18a0 by task cifsd/986 CPU: 3 UID: 0 PID: 986 Comm: cifsd Not tainted 6.15.0-rc1 #1 PREEMPT(voluntary) Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-3.fc41 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x5d/0x80 print_report+0x156/0x528 ? gf128mul_4k_lle+0xba/0x110 ? __virt_addr_valid+0x145/0x300 ? __phys_addr+0x46/0x90 ? gf128mul_4k_lle+0xba/0x110 kasan_report+0xdf/0x1a0 ? gf128mul_4k_lle+0xba/0x110 gf128mul_4k_lle+0xba/0x110 ghash_update+0x189/0x210 shash_ahash_update+0x295/0x370 ? __pfx_shash_ahash_update+0x10/0x10 ? __pfx_shash_ahash_update+0x10/0x10 ? __pfx_extract_iter_to_sg+0x10/0x10 ? ___kmalloc_large_node+0x10e/0x180 ? __asan_memset+0x23/0x50 crypto_ahash_update+0x3c/0xc0 gcm_hash_assoc_remain_continue+0x93/0xc0 crypt_message+0xe09/0xec0 [cifs] ? __pfx_crypt_message+0x10/0x10 [cifs] ? _raw_spin_unlock+0x23/0x40 ? __pfx_cifs_readv_from_socket+0x10/0x10 [cifs] decrypt_raw_data+0x229/0x380 [cifs] ? __pfx_decrypt_raw_data+0x10/0x10 [cifs] ? __pfx_cifs_read_iter_from_socket+0x10/0x10 [cifs] smb3_receive_transform+0x837/0xc80 [cifs] ? __pfx_smb3_receive_transform+0x10/0x10 [cifs] ? __pfx___might_resched+0x10/0x10 ? __pfx_smb3_is_transform_hdr+0x10/0x10 [cifs] cifs_demultiplex_thread+0x692/0x1570 [cifs] ? __pfx_cifs_demultiplex_thread+0x10/0x10 [cifs] ? rcu_is_watching+0x20/0x50 ? rcu_lockdep_current_cpu_online+0x62/0xb0 ? find_held_lock+0x32/0x90 ? kvm_sched_clock_read+0x11/0x20 ? local_clock_noinstr+0xd/0xd0 ? trace_irq_enable.constprop.0+0xa8/0xe0 ? __pfx_cifs_demultiplex_thread+0x10/0x10 [cifs] kthread+0x1fe/0x380 ? kthread+0x10f/0x380 ? __pfx_kthread+0x10/0x10 ? local_clock_noinstr+0xd/0xd0 ? ret_from_fork+0x1b/0x60 ? local_clock+0x15/0x30 ? lock_release+0x29b/0x390 ? rcu_is_watching+0x20/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x31/0x60 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK>",,"[{""url"":""https://git.kernel.org/stable/c/9502dd5c7029902f4a425bf959917a5a9e7c0e50"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/950557922c1298464749c216d8763e97faf5d0a6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa5a1e4b882964eb79d5b5d1d1e8a1a5efbb1d15"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e859b216d94668bc66330e61be201234f4413d1a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37751,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:53.843,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: x86/cpu: Avoid running off the end of an AMD erratum table The NULL array terminator at the end of erratum_1386_microcode was removed during the switch from x86_cpu_desc to x86_cpu_id. This causes readers to run off the end of the array. Replace the NULL.",,"[{""url"":""https://git.kernel.org/stable/c/1b518f73f1b6f59e083ec33dea22d9a1a275a970"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f0df00ebc57f803603f2a2e0df197e51f06fbe90"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37752,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:53.933,2025-08-28T15:15:47.020,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net_sched: sch_sfq: move the limit validation It is not sufficient to directly validate the limit on the data that the user passes as it can be updated based on how the other parameters are changed. Move the check at the end of the configuration update process to also catch scenarios where the limit is indirectly updated, for example with the following configurations: tc qdisc add dev dummy0 handle 1: root sfq limit 2 flows 1 depth 1 tc qdisc add dev dummy0 handle 1: root sfq limit 2 flows 1 divisor 1 This fixes the following syzkaller reported crash: ------------[ cut here ]------------ UBSAN: array-index-out-of-bounds in net/sched/sch_sfq.c:203:6 index 65535 is out of range for type 'struct sfq_head[128]' CPU: 1 UID: 0 PID: 3037 Comm: syz.2.16 Not tainted 6.14.0-rc2-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 12/27/2024 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x201/0x300 lib/dump_stack.c:120 ubsan_epilogue lib/ubsan.c:231 [inline] __ubsan_handle_out_of_bounds+0xf5/0x120 lib/ubsan.c:429 sfq_link net/sched/sch_sfq.c:203 [inline] sfq_dec+0x53c/0x610 net/sched/sch_sfq.c:231 sfq_dequeue+0x34e/0x8c0 net/sched/sch_sfq.c:493 sfq_reset+0x17/0x60 net/sched/sch_sfq.c:518 qdisc_reset+0x12e/0x600 net/sched/sch_generic.c:1035 tbf_reset+0x41/0x110 net/sched/sch_tbf.c:339 qdisc_reset+0x12e/0x600 net/sched/sch_generic.c:1035 dev_reset_queue+0x100/0x1b0 net/sched/sch_generic.c:1311 netdev_for_each_tx_queue include/linux/netdevice.h:2590 [inline] dev_deactivate_many+0x7e5/0xe70 net/sched/sch_generic.c:1375",,"[{""url"":""https://git.kernel.org/stable/c/1348214fa042a71406964097e743c87a42c85a49"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e5e1fcc1b8ed57f902c424c5d9b328a3a19073d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c589aa318023690f1606c666a7fb5f4c1c9c219"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d62ded97db6b7c94c891f704151f372b1ba4688"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8fadc871a42933aacb7f1ce9ed9a96485e2c9cf4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b36a68192037d1614317a09b0d78c7814e2eecf9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3bf8f63e6179076b57c9de660c9f80b5abefe70"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d2718324f9e329b10ddc091fba5a0ba2b9d4d96a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f86293adce0c201cfabb283ef9d6f21292089bb8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37753,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:54.050,2025-05-26T11:15:24.393,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,[],,,,,,,,,,
CVE-2025-37754,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:54.157,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/i915/huc: Fix fence not released on early probe errors HuC delayed loading fence, introduced with commit 27536e03271da (""drm/i915/huc: track delayed HuC load with a fence""), is registered with object tracker early on driver probe but unregistered only from driver remove, which is not called on early probe errors. Since its memory is allocated under devres, then released anyway, it may happen to be allocated again to the fence and reused on future driver probes, resulting in kernel warnings that taint the kernel: <4> [309.731371] ------------[ cut here ]------------ <3> [309.731373] ODEBUG: init destroyed (active state 0) object: ffff88813d7dd2e0 object type: i915_sw_fence hint: sw_fence_dummy_notify+0x0/0x20 [i915] <4> [309.731575] WARNING: CPU: 2 PID: 3161 at lib/debugobjects.c:612 debug_print_object+0x93/0xf0 ... <4> [309.731693] CPU: 2 UID: 0 PID: 3161 Comm: i915_module_loa Tainted: G U 6.14.0-CI_DRM_16362-gf0fd77956987+ #1 ... <4> [309.731700] RIP: 0010:debug_print_object+0x93/0xf0 ... <4> [309.731728] Call Trace: <4> [309.731730] <TASK> ... <4> [309.731949] __debug_object_init+0x17b/0x1c0 <4> [309.731957] debug_object_init+0x34/0x50 <4> [309.732126] __i915_sw_fence_init+0x34/0x60 [i915] <4> [309.732256] intel_huc_init_early+0x4b/0x1d0 [i915] <4> [309.732468] intel_uc_init_early+0x61/0x680 [i915] <4> [309.732667] intel_gt_common_init_early+0x105/0x130 [i915] <4> [309.732804] intel_root_gt_init_early+0x63/0x80 [i915] <4> [309.732938] i915_driver_probe+0x1fa/0xeb0 [i915] <4> [309.733075] i915_pci_probe+0xe6/0x220 [i915] <4> [309.733198] local_pci_probe+0x44/0xb0 <4> [309.733203] pci_device_probe+0xf4/0x270 <4> [309.733209] really_probe+0xee/0x3c0 <4> [309.733215] __driver_probe_device+0x8c/0x180 <4> [309.733219] driver_probe_device+0x24/0xd0 <4> [309.733223] __driver_attach+0x10f/0x220 <4> [309.733230] bus_for_each_dev+0x7d/0xe0 <4> [309.733236] driver_attach+0x1e/0x30 <4> [309.733239] bus_add_driver+0x151/0x290 <4> [309.733244] driver_register+0x5e/0x130 <4> [309.733247] __pci_register_driver+0x7d/0x90 <4> [309.733251] i915_pci_register_driver+0x23/0x30 [i915] <4> [309.733413] i915_init+0x34/0x120 [i915] <4> [309.733655] do_one_initcall+0x62/0x3f0 <4> [309.733667] do_init_module+0x97/0x2a0 <4> [309.733671] load_module+0x25ff/0x2890 <4> [309.733688] init_module_from_file+0x97/0xe0 <4> [309.733701] idempotent_init_module+0x118/0x330 <4> [309.733711] __x64_sys_finit_module+0x77/0x100 <4> [309.733715] x64_sys_call+0x1f37/0x2650 <4> [309.733719] do_syscall_64+0x91/0x180 <4> [309.733763] entry_SYSCALL_64_after_hwframe+0x76/0x7e <4> [309.733792] </TASK> ... <4> [309.733806] ---[ end trace 0000000000000000 ]--- That scenario is most easily reproducible with igt@i915_module_load@reload-with-fault-injection. Fix the issue by moving the cleanup step to driver release path. (cherry picked from commit 795dbde92fe5c6996a02a5b579481de73035e7bf)",,"[{""url"":""https://git.kernel.org/stable/c/4bd4bf79bcfe101f0385ab81dbabb6e3f7d96c00"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9f5ef4a5eaa61a7a4ed31231da45deb85065397a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c5a906806162aea62dbe5d327760ce3b7117ca17"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3ea2eae70692a455e256787e4f54153fb739b90"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f104ef4db9f8f3923cc06ed1fafb3da38df6006d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37755,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:54.267,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: libwx: handle page_pool_dev_alloc_pages error page_pool_dev_alloc_pages could return NULL. There was a WARN_ON(!page) but it would still proceed to use the NULL pointer and then crash. This is similar to commit 001ba0902046 (""net: fec: handle page_pool_dev_alloc_pages error""). This is found by our static analysis tool KNighter.",,"[{""url"":""https://git.kernel.org/stable/c/1dd13c60348f515acd8c6f25a561b9c4e3b04fea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f1ff1b38a7c8b872382b796023419d87d78c47e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90bec7cef8805f9a23145e070dff28a02bb584eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad81d666e114ebf989fc9994d4c93d451dc60056"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c17ef974bfcf1a50818168b47c4606b425a957c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37756,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:54.370,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: tls: explicitly disallow disconnect syzbot discovered that it can disconnect a TLS socket and then run into all sort of unexpected corner cases. I have a vague recollection of Eric pointing this out to us a long time ago. Supporting disconnect is really hard, for one thing if offload is enabled we'd need to wait for all packets to be _acked_. Disconnect is not commonly used, disallow it. The immediate problem syzbot run into is the warning in the strp, but that's just the easiest bug to trigger: WARNING: CPU: 0 PID: 5834 at net/tls/tls_strp.c:486 tls_strp_msg_load+0x72e/0xa80 net/tls/tls_strp.c:486 RIP: 0010:tls_strp_msg_load+0x72e/0xa80 net/tls/tls_strp.c:486 Call Trace: <TASK> tls_rx_rec_wait+0x280/0xa60 net/tls/tls_sw.c:1363 tls_sw_recvmsg+0x85c/0x1c30 net/tls/tls_sw.c:2043 inet6_recvmsg+0x2c9/0x730 net/ipv6/af_inet6.c:678 sock_recvmsg_nosec net/socket.c:1023 [inline] sock_recvmsg+0x109/0x280 net/socket.c:1045 __sys_recvfrom+0x202/0x380 net/socket.c:2237",,"[{""url"":""https://git.kernel.org/stable/c/2bcad8fefcecdd5f005d8c550b25d703c063c34a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5071a1e606b30c0c11278d3c6620cd6a24724cf6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7bdcf5bc35ae59fc4a0fa23276e84b4d1534a3cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8513411ec321942bd3cfed53d5bb700665c67d86"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9fcbca0f801580cbb583e9cb274e2c7fbe766ca6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac91c6125468be720eafde9c973994cb45b61d44"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c665bef891e8972e1d3ce5bbc0d42a373346a2c3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f3ce4d3f874ab7919edca364c147ac735f9f1d04"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37757,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:54.480,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tipc: fix memory leak in tipc_link_xmit In case the backlog transmit queue for system-importance messages is overloaded, tipc_link_xmit() returns -ENOBUFS but the skb list is not purged. This leads to memory leak and failure when a skb is allocated. This commit fixes this issue by purging the skb list before tipc_link_xmit() returns.",,"[{""url"":""https://git.kernel.org/stable/c/09c2dcda2c551bba30710c33f6ac678ae7395389"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/24e6280cdd7f8d01fc6b9b365fb800c2fb7ea9bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/69ae94725f4fc9e75219d2d69022029c5b24bc9a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c5957f7905b4aede9d7a559d271438f3ca9e852"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/84895f5ce3829d9fc030e5ec2d8729da4c0c9d08"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a40cbfbb8f95c325430f017883da669b2aa927d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d0e02d3d27a0b4dcb13f954f537ca1dd8f282dcf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d4d40e437adb376be16b3a12dd5c63f0fa768247"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ed06675d3b8cd37120b447646d53f7cd3e6fcd63"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37758,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:54.583,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ata: pata_pxa: Fix potential NULL pointer dereference in pxa_ata_probe() devm_ioremap() returns NULL on error. Currently, pxa_ata_probe() does not check for this case, which can result in a NULL pointer dereference. Add NULL check after devm_ioremap() to prevent this issue.",,"[{""url"":""https://git.kernel.org/stable/c/17d5e6e915fad5a261db3698c9c5bbe702102d7c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2ba9e4c69207777bb0775c7c091800ecd69de144"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2dc53c7a0c1f57b082931facafa804a7ca32a9a6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5b09bf6243b0bc0ae58bd9efdf6f0de5546f8d06"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a551f75401793ba8075d7f46ffc931ce5151f03f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad320e408a8c95a282ab9c05cdf0c9b95e317985"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c022287f6e599422511aa227dc6da37b58d9ceac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d0d720f9282839b9db625a376c02a1426a16b0ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee2b0301d6bfe16b35d57947687c664ecb815775"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37759,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T13:15:54.690,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ublk: fix handling recovery & reissue in ublk_abort_queue() Commit 8284066946e6 (""ublk: grab request reference when the request is handled by userspace"") doesn't grab request reference in case of recovery reissue. Then the request can be requeued & re-dispatch & failed when canceling uring command. If it is one zc request, the request can be freed before io_uring returns the zc buffer back, then cause kernel panic: [ 126.773061] BUG: kernel NULL pointer dereference, address: 00000000000000c8 [ 126.773657] #PF: supervisor read access in kernel mode [ 126.774052] #PF: error_code(0x0000) - not-present page [ 126.774455] PGD 0 P4D 0 [ 126.774698] Oops: Oops: 0000 [#1] SMP NOPTI [ 126.775034] CPU: 13 UID: 0 PID: 1612 Comm: kworker/u64:55 Not tainted 6.14.0_blk+ #182 PREEMPT(full) [ 126.775676] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-1.fc39 04/01/2014 [ 126.776275] Workqueue: iou_exit io_ring_exit_work [ 126.776651] RIP: 0010:ublk_io_release+0x14/0x130 [ublk_drv] Fixes it by always grabbing request reference for aborting the request.",,"[{""url"":""https://git.kernel.org/stable/c/0a21d259ca4d6310fdfcc0284ebbc000e66cbf70"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5d34a30efac9c9c93e150130caa940c0df6053c1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6ee6bd5d4fce502a5b5a2ea805e9ff16e6aa890f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/caa5c8a2358604f38bf0a4afaa5eacda13763067"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37760,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:38.110,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm/vma: add give_up_on_oom option on modify/merge, use in uffd release Currently, if a VMA merge fails due to an OOM condition arising on commit merge or a failure to duplicate anon_vma's, we report this so the caller can handle it. However there are cases where the caller is only ostensibly trying a merge, and doesn't mind if it fails due to this condition. Since we do not want to introduce an implicit assumption that we only actually modify VMAs after OOM conditions might arise, add a 'give up on oom' option and make an explicit contract that, should this flag be set, we absolutely will not modify any VMAs should OOM arise and just bail out. Since it'd be very unusual for a user to try to vma_modify() with this flag set but be specifying a range within a VMA which ends up being split (which can fail due to rlimit issues, not only OOM), we add a debug warning for this condition. The motivating reason for this is uffd release - syzkaller (and Pedro Falcato's VERY astute analysis) found a way in which an injected fault on allocation, triggering an OOM condition on commit merge, would result in uffd code becoming confused and treating an error value as if it were a VMA pointer. To avoid this, we make use of this new VMG flag to ensure that this never occurs, utilising the fact that, should we be clearing entire VMAs, we do not wish an OOM event to be reported to us. Many thanks to Pedro Falcato for his excellent analysis and Jann Horn for his insightful and intelligent analysis of the situation, both of whom were instrumental in this fix.",,"[{""url"":""https://git.kernel.org/stable/c/41e6ddcaa0f18dda4c3fadf22533775a30d6f72f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b906c1ad25adce6ff35be19b65a1aa7d960fe1d7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c103a75c61648203d731e3b97a6fbeea4003cb15"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37761,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:38.377,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/xe: Fix an out-of-bounds shift when invalidating TLB When the size of the range invalidated is larger than rounddown_pow_of_two(ULONG_MAX), The function macro roundup_pow_of_two(length) will hit an out-of-bounds shift [1]. Use a full TLB invalidation for such cases. v2: - Use a define for the range size limit over which we use a full TLB invalidation. (Lucas) - Use a better calculation of the limit. [1]: [ 39.202421] ------------[ cut here ]------------ [ 39.202657] UBSAN: shift-out-of-bounds in ./include/linux/log2.h:57:13 [ 39.202673] shift exponent 64 is too large for 64-bit type 'long unsigned int' [ 39.202688] CPU: 8 UID: 0 PID: 3129 Comm: xe_exec_system_ Tainted: G U 6.14.0+ #10 [ 39.202690] Tainted: [U]=USER [ 39.202690] Hardware name: ASUS System Product Name/PRIME B560M-A AC, BIOS 2001 02/01/2023 [ 39.202691] Call Trace: [ 39.202692] <TASK> [ 39.202695] dump_stack_lvl+0x6e/0xa0 [ 39.202699] ubsan_epilogue+0x5/0x30 [ 39.202701] __ubsan_handle_shift_out_of_bounds.cold+0x61/0xe6 [ 39.202705] xe_gt_tlb_invalidation_range.cold+0x1d/0x3a [xe] [ 39.202800] ? find_held_lock+0x2b/0x80 [ 39.202803] ? mark_held_locks+0x40/0x70 [ 39.202806] xe_svm_invalidate+0x459/0x700 [xe] [ 39.202897] drm_gpusvm_notifier_invalidate+0x4d/0x70 [drm_gpusvm] [ 39.202900] __mmu_notifier_release+0x1f5/0x270 [ 39.202905] exit_mmap+0x40e/0x450 [ 39.202912] __mmput+0x45/0x110 [ 39.202914] exit_mm+0xc5/0x130 [ 39.202916] do_exit+0x21c/0x500 [ 39.202918] ? lockdep_hardirqs_on_prepare+0xdb/0x190 [ 39.202920] do_group_exit+0x36/0xa0 [ 39.202922] get_signal+0x8f8/0x900 [ 39.202926] arch_do_signal_or_restart+0x35/0x100 [ 39.202930] syscall_exit_to_user_mode+0x1fc/0x290 [ 39.202932] do_syscall_64+0xa1/0x180 [ 39.202934] ? do_user_addr_fault+0x59f/0x8a0 [ 39.202937] ? lock_release+0xd2/0x2a0 [ 39.202939] ? do_user_addr_fault+0x5a9/0x8a0 [ 39.202942] ? trace_hardirqs_off+0x4b/0xc0 [ 39.202944] ? clear_bhb_loop+0x25/0x80 [ 39.202946] ? clear_bhb_loop+0x25/0x80 [ 39.202947] ? clear_bhb_loop+0x25/0x80 [ 39.202950] entry_SYSCALL_64_after_hwframe+0x76/0x7e [ 39.202952] RIP: 0033:0x7fa945e543e1 [ 39.202961] Code: Unable to access opcode bytes at 0x7fa945e543b7. [ 39.202962] RSP: 002b:00007ffca8fb4170 EFLAGS: 00000293 [ 39.202963] RAX: 000000000000003d RBX: 0000000000000000 RCX: 00007fa945e543e3 [ 39.202964] RDX: 0000000000000000 RSI: 00007ffca8fb41ac RDI: 00000000ffffffff [ 39.202964] RBP: 00007ffca8fb4190 R08: 0000000000000000 R09: 00007fa945f600a0 [ 39.202965] R10: 0000000000000000 R11: 0000000000000293 R12: 0000000000000000 [ 39.202966] R13: 00007fa9460dd310 R14: 00007ffca8fb41ac R15: 0000000000000000 [ 39.202970] </TASK> [ 39.202970] ---[ end trace ]--- (cherry picked from commit b88f48f86500bc0b44b4f73ac66d500a40d320ad)",,"[{""url"":""https://git.kernel.org/stable/c/28477f701b63922ff88e9fb13f5519c11cd48b86"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7bcfeddb36b77f9fe3b010bb0b282b7618420bba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e4715858f87b78ce58cfa03bbe140321edbbaf20"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37762,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:38.500,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/virtio: Fix missed dmabuf unpinning in error path of prepare_fb() Correct error handling in prepare_fb() to fix leaking resources when error happens.",,"[{""url"":""https://git.kernel.org/stable/c/395cc80051f8da267b27496a4029dd931a198855"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe983e925bf7062d7b975357afcbc77bb7f354d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37763,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:38.817,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/imagination: take paired job reference For paired jobs, have the fragment job take a reference on the geometry job, so that the geometry job cannot be freed until the fragment job has finished with it. The geometry job structure is accessed when the fragment job is being prepared by the GPU scheduler. Taking the reference prevents the geometry job being freed until the fragment job no longer requires it. Fixes a use after free bug detected by KASAN: [ 124.256386] BUG: KASAN: slab-use-after-free in pvr_queue_prepare_job+0x108/0x868 [powervr] [ 124.264893] Read of size 1 at addr ffff0000084cb960 by task kworker/u16:4/63",,"[{""url"":""https://git.kernel.org/stable/c/4ba2abe154ef68f9612eee9d6fbfe53a1736b064"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b5a6f97a78e2fc008fd6503b7040cb7e1120b873"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c90b95e12eb88d23740e5ea2c43d71675d17ac8d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37764,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:39.150,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/imagination: fix firmware memory leaks Free the memory used to hold the results of firmware image processing when the module is unloaded. Fix the related issue of the same memory being leaked if processing of the firmware image fails during module load. Ensure all firmware GEM objects are destroyed if firmware image processing fails. Fixes memory leaks on powervr module unload detected by Kmemleak: unreferenced object 0xffff000042e20000 (size 94208): comm ""modprobe"", pid 470, jiffies 4295277154 hex dump (first 32 bytes): 02 ae 7f ed bf 45 84 00 3c 5b 1f ed 9f 45 45 05 .....E..<[...EE. d5 4f 5d 14 6c 00 3d 23 30 d0 3a 4a 66 0e 48 c8 .O].l.=#0.:Jf.H. backtrace (crc dd329dec): kmemleak_alloc+0x30/0x40 ___kmalloc_large_node+0x140/0x188 __kmalloc_large_node_noprof+0x2c/0x13c __kmalloc_noprof+0x48/0x4c0 pvr_fw_init+0xaa4/0x1f50 [powervr] unreferenced object 0xffff000042d20000 (size 20480): comm ""modprobe"", pid 470, jiffies 4295277154 hex dump (first 32 bytes): 00 00 00 00 00 00 00 00 09 00 00 00 0b 00 00 00 ................ 00 00 00 00 00 00 00 00 07 00 00 00 08 00 00 00 ................ backtrace (crc 395b02e3): kmemleak_alloc+0x30/0x40 ___kmalloc_large_node+0x140/0x188 __kmalloc_large_node_noprof+0x2c/0x13c __kmalloc_noprof+0x48/0x4c0 pvr_fw_init+0xb0c/0x1f50 [powervr]",,"[{""url"":""https://git.kernel.org/stable/c/490c30fd554597e78f66650044877e7defb5f83c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/891c12ba855ccb34c06a2e5da75c644683087036"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a5b230e7f3a55bd8bd8d012eec75a4b7baa671d5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37765,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:39.417,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/nouveau: prime: fix ttm_bo_delayed_delete oops Fix an oops in ttm_bo_delayed_delete which results from dererencing a dangling pointer: Oops: general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6b7b: 0000 [#1] PREEMPT SMP CPU: 4 UID: 0 PID: 1082 Comm: kworker/u65:2 Not tainted 6.14.0-rc4-00267-g505460b44513-dirty #216 Hardware name: LENOVO 82N6/LNVNB161216, BIOS GKCN65WW 01/16/2024 Workqueue: ttm ttm_bo_delayed_delete [ttm] RIP: 0010:dma_resv_iter_first_unlocked+0x55/0x290 Code: 31 f6 48 c7 c7 00 2b fa aa e8 97 bd 52 ff e8 a2 c1 53 00 5a 85 c0 74 48 e9 88 01 00 00 4c 89 63 20 4d 85 e4 0f 84 30 01 00 00 <41> 8b 44 24 10 c6 43 2c 01 48 89 df 89 43 28 e8 97 fd ff ff 4c 8b RSP: 0018:ffffbf9383473d60 EFLAGS: 00010202 RAX: 0000000000000001 RBX: ffffbf9383473d88 RCX: 0000000000000000 RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000 RBP: ffffbf9383473d78 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000000 R12: 6b6b6b6b6b6b6b6b R13: ffffa003bbf78580 R14: ffffa003a6728040 R15: 00000000000383cc FS: 0000000000000000(0000) GS:ffffa00991c00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000758348024dd0 CR3: 000000012c259000 CR4: 0000000000f50ef0 PKRU: 55555554 Call Trace: <TASK> ? __die_body.cold+0x19/0x26 ? die_addr+0x3d/0x70 ? exc_general_protection+0x159/0x460 ? asm_exc_general_protection+0x27/0x30 ? dma_resv_iter_first_unlocked+0x55/0x290 dma_resv_wait_timeout+0x56/0x100 ttm_bo_delayed_delete+0x69/0xb0 [ttm] process_one_work+0x217/0x5c0 worker_thread+0x1c8/0x3d0 ? apply_wqattrs_cleanup.part.0+0xc0/0xc0 kthread+0x10b/0x240 ? kthreads_online_cpu+0x140/0x140 ret_from_fork+0x40/0x70 ? kthreads_online_cpu+0x140/0x140 ret_from_fork_asm+0x11/0x20 </TASK> The cause of this is: - drm_prime_gem_destroy calls dma_buf_put(dma_buf) which releases the reference to the shared dma_buf. The reference count is 0, so the dma_buf is destroyed, which in turn decrements the corresponding amdgpu_bo reference count to 0, and the amdgpu_bo is destroyed - calling drm_gem_object_release then dma_resv_fini (which destroys the reservation object), then finally freeing the amdgpu_bo. - nouveau_bo obj->bo.base.resv is now a dangling pointer to the memory formerly allocated to the amdgpu_bo. - nouveau_gem_object_del calls ttm_bo_put(&nvbo->bo) which calls ttm_bo_release, which schedules ttm_bo_delayed_delete. - ttm_bo_delayed_delete runs and dereferences the dangling resv pointer, resulting in a general protection fault. Fix this by moving the drm_prime_gem_destroy call from nouveau_gem_object_del to nouveau_bo_del_ttm. This ensures that it will be run after ttm_bo_delayed_delete.",,"[{""url"":""https://git.kernel.org/stable/c/12b038d521c75e3521522503becf3bc162628469"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/31e94c7989572f96926673614a3b958915a13ca9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/47761deabb69a5df0c2c4ec400d80bb3e072bd2e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6b95947ee780f4e1fb26413a1437d05bcb99712b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6e2c805996a49998d31ac522beb1534ca417e761"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/706868a1a1072cffd8bd63f7e161d79141099849"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ec0fbb28d049273bfd4f1e7a5ae4c74884beed3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ada78110b2d3ec88b398a49703bd336d4cee7a08"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37766,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:39.550,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/pm: Prevent division by zero The user can set any speed value. If speed is greater than UINT_MAX/8, division by zero is possible. Found by Linux Verification Center (linuxtesting.org) with SVACE.",,"[{""url"":""https://git.kernel.org/stable/c/068091b796480819bf70b159f17e222ad8bea900"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/42f7b5d12c28b2a601a98d10a80c6db1fe1a2900"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4e3d9508c056d7e0a56b58d5c81253e2a0d22b6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6b9f9b998b107c7539f148a013d789ddb860c3b9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/80814924260cea431a8fc6137d11cc8cb331a10c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/affd2241927a1e74c0aecd50c2d920dc4213c56d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce773dd844ee19a605af27f11470887e0f2044a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ffd688804425579a472fbd2525bedb58b1d28bd9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37767,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:39.723,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/pm: Prevent division by zero The user can set any speed value. If speed is greater than UINT_MAX/8, division by zero is possible. Found by Linux Verification Center (linuxtesting.org) with SVACE.",,"[{""url"":""https://git.kernel.org/stable/c/327107bd7f052f4ee2d0c966c7ae879822f1814f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8f7b5987e21e003cafac28f0e4d323e6496f83ba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c3ff73e3bddf1a6c30d7effe4018d12ba0cadd2e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f23e9116ebb71b63fe9cec0dcac792aa9af30b0c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f2904fa2b9da943db6bef7c0f8b3fb4fc14acbc4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fb803d4bb9ea0a61c21c4987505e4d4ae18f9fdc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37768,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:39.977,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/pm: Prevent division by zero The user can set any speed value. If speed is greater than UINT_MAX/8, division by zero is possible. Found by Linux Verification Center (linuxtesting.org) with SVACE.",,"[{""url"":""https://git.kernel.org/stable/c/3cdd02cb70682d7d205ca6dc02a4d1eb76758d24"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5fc4fb54f6f064c25bfbbfd443aa861d3422dd4c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c246a05df51c52fe0852ce56ba10c41e6ed1f39"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e9c4f8d197d5709c75effa5d58e80b4fa01981a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9e4f1e21fe7b93a8ef57db433071266c2590e260"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b0742a709be7979c7a480772046a1f36d09dab00"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be0fffc4152aac4f0291ed2d793f3cfee788449d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37769,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:40.190,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/pm/smu11: Prevent division by zero The user can set any speed value. If speed is greater than UINT_MAX/8, division by zero is possible. Found by Linux Verification Center (linuxtesting.org) with SVACE. (cherry picked from commit da7dc714a8f8e1c9fc33c57cd63583779a3bef71)",,"[{""url"":""https://git.kernel.org/stable/c/63a150400194592206817124268ff6f43947e8c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ba88b5cccc1a99c1afb96e31e7eedac9907704c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de2cba068c9c648503973b57696d035cfe58a9f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de6f8e0534cfabc528c969d453150ca90b24fb01"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc9d55377353321e78f9e108d15f72a17e8c6ee2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37770,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:40.330,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/pm: Prevent division by zero The user can set any speed value. If speed is greater than UINT_MAX/8, division by zero is possible. Found by Linux Verification Center (linuxtesting.org) with SVACE.",,"[{""url"":""https://git.kernel.org/stable/c/05de66de280ea1bd0459c994bfd2dd332cfbc2a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0c02fcbe4a1393a3c02da6ae35e72493cfdb2155"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4b8c3c0d17c07f301011e2908fecd2ebdcfe3d1c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/587de3ca7875c06fe3c3aa4073a85c4eff46591f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/836a189fb422e7efb81c51d5160e47ec7bc11500"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd4d90adbca1862d03e581e10e74ab73ec75e61b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e109528bbf460e50074c156253d9080d223ee37f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37771,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:40.453,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/pm: Prevent division by zero The user can set any speed value. If speed is greater than UINT_MAX/8, division by zero is possible. Found by Linux Verification Center (linuxtesting.org) with SVACE.",,"[{""url"":""https://git.kernel.org/stable/c/402964994e8ece29702383b234fabcf04791ff95"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5096174074114f83c700a27869c54362cbb10f3e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6413fed016208171592c88b5df002af8a1387e24"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d641c2b83275d3b0424127b2e0d2d0f7dd82aef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b7c41df4913789ebfe73cc1e17c6401d4c5eab69"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/baa54adb5e0599299b8f088efb5544d876a3eb62"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37772,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:40.580,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/cma: Fix workqueue crash in cma_netevent_work_handler struct rdma_cm_id has member ""struct work_struct net_work"" that is reused for enqueuing cma_netevent_work_handler()s onto cma_wq. Below crash[1] can occur if more than one call to cma_netevent_callback() occurs in quick succession, which further enqueues cma_netevent_work_handler()s for the same rdma_cm_id, overwriting any previously queued work-item(s) that was just scheduled to run i.e. there is no guarantee the queued work item may run between two successive calls to cma_netevent_callback() and the 2nd INIT_WORK would overwrite the 1st work item (for the same rdma_cm_id), despite grabbing id_table_lock during enqueue. Also drgn analysis [2] indicates the work item was likely overwritten. Fix this by moving the INIT_WORK() to __rdma_create_id(), so that it doesn't race with any existing queue_work() or its worker thread. [1] Trimmed crash stack: ============================================= BUG: kernel NULL pointer dereference, address: 0000000000000008 kworker/u256:6 ... 6.12.0-0... Workqueue: cma_netevent_work_handler [rdma_cm] (rdma_cm) RIP: 0010:process_one_work+0xba/0x31a Call Trace: worker_thread+0x266/0x3a0 kthread+0xcf/0x100 ret_from_fork+0x31/0x50 ret_from_fork_asm+0x1a/0x30 ============================================= [2] drgn crash analysis: >>> trace = prog.crashed_thread().stack_trace() >>> trace (0) crash_setup_regs (./arch/x86/include/asm/kexec.h:111:15) (1) __crash_kexec (kernel/crash_core.c:122:4) (2) panic (kernel/panic.c:399:3) (3) oops_end (arch/x86/kernel/dumpstack.c:382:3) ... (8) process_one_work (kernel/workqueue.c:3168:2) (9) process_scheduled_works (kernel/workqueue.c:3310:3) (10) worker_thread (kernel/workqueue.c:3391:4) (11) kthread (kernel/kthread.c:389:9) Line workqueue.c:3168 for this kernel version is in process_one_work(): 3168 strscpy(worker->desc, pwq->wq->name, WORKER_DESC_LEN); >>> trace[8][""work""] *(struct work_struct *)0xffff92577d0a21d8 = { .data = (atomic_long_t){ .counter = (s64)536870912, <=== Note }, .entry = (struct list_head){ .next = (struct list_head *)0xffff924d075924c0, .prev = (struct list_head *)0xffff924d075924c0, }, .func = (work_func_t)cma_netevent_work_handler+0x0 = 0xffffffffc2cec280, } Suspicion is that pwq is NULL: >>> trace[8][""pwq""] (struct pool_workqueue *)<absent> In process_one_work(), pwq is assigned from: struct pool_workqueue *pwq = get_work_pwq(work); and get_work_pwq() is: static struct pool_workqueue *get_work_pwq(struct work_struct *work) { unsigned long data = atomic_long_read(&work->data); if (data & WORK_STRUCT_PWQ) return work_struct_pwq(data); else return NULL; } WORK_STRUCT_PWQ is 0x4: >>> print(repr(prog['WORK_STRUCT_PWQ'])) Object(prog, 'enum work_flags', value=4) But work->data is 536870912 which is 0x20000000. So, get_work_pwq() returns NULL and we crash in process_one_work(): 3168 strscpy(worker->desc, pwq->wq->name, WORKER_DESC_LEN); =============================================",,"[{""url"":""https://git.kernel.org/stable/c/45f5dcdd049719fb999393b30679605f16ebce14"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/51003b2c872c63d28bcf5fbcc52cf7b05615f7b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b172a4a0de254f1fcce7591833a9a63547c2f447"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c2b169fc7a12665d8a675c1ff14bca1b9c63fb9a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d23fd7a539ac078df119707110686a5b226ee3bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37773,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:40.703,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: virtiofs: add filesystem context source name check In certain scenarios, for example, during fuzz testing, the source name may be NULL, which could lead to a kernel panic. Therefore, an extra check for the source name should be added.",,"[{""url"":""https://git.kernel.org/stable/c/599d1e2a6aecc44acf22fe7ea6f5e84a7e526abe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5ee09cdaf3414f6c92960714af46d3d90eede2f3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d6dcf18a1b49990295ac8a05fd9bdfd27ccbf88"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a648d80f8d9b208beee03a2d9aa690cfacf1d41e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a94fd938df2b1628da66b498aa0eeb89593bc7a2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b84f13fdad10a543e2e65bab7e81b3f0bceabd67"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c3e31d613951c299487844c4d1686a933e8ee291"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f6ec52710dc5e156b774cbef5d0f5c99b1c53a80"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37774,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:40.877,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: slab: ensure slab->obj_exts is clear in a newly allocated slab page ktest recently reported crashes while running several buffered io tests with __alloc_tagging_slab_alloc_hook() at the top of the crash call stack. The signature indicates an invalid address dereference with low bits of slab->obj_exts being set. The bits were outside of the range used by page_memcg_data_flags and objext_flags and hence were not masked out by slab_obj_exts() when obtaining the pointer stored in slab->obj_exts. The typical crash log looks like this: 00510 Unable to handle kernel NULL pointer dereference at virtual address 0000000000000010 00510 Mem abort info: 00510 ESR = 0x0000000096000045 00510 EC = 0x25: DABT (current EL), IL = 32 bits 00510 SET = 0, FnV = 0 00510 EA = 0, S1PTW = 0 00510 FSC = 0x05: level 1 translation fault 00510 Data abort info: 00510 ISV = 0, ISS = 0x00000045, ISS2 = 0x00000000 00510 CM = 0, WnR = 1, TnD = 0, TagAccess = 0 00510 GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 00510 user pgtable: 4k pages, 39-bit VAs, pgdp=0000000104175000 00510 [0000000000000010] pgd=0000000000000000, p4d=0000000000000000, pud=0000000000000000 00510 Internal error: Oops: 0000000096000045 [#1] SMP 00510 Modules linked in: 00510 CPU: 10 UID: 0 PID: 7692 Comm: cat Not tainted 6.15.0-rc1-ktest-g189e17946605 #19327 NONE 00510 Hardware name: linux,dummy-virt (DT) 00510 pstate: 20001005 (nzCv daif -PAN -UAO -TCO -DIT +SSBS BTYPE=--) 00510 pc : __alloc_tagging_slab_alloc_hook+0xe0/0x190 00510 lr : __kmalloc_noprof+0x150/0x310 00510 sp : ffffff80c87df6c0 00510 x29: ffffff80c87df6c0 x28: 000000000013d1ff x27: 000000000013d200 00510 x26: ffffff80c87df9e0 x25: 0000000000000000 x24: 0000000000000001 00510 x23: ffffffc08041953c x22: 000000000000004c x21: ffffff80c0002180 00510 x20: fffffffec3120840 x19: ffffff80c4821000 x18: 0000000000000000 00510 x17: fffffffec3d02f00 x16: fffffffec3d02e00 x15: fffffffec3d00700 00510 x14: fffffffec3d00600 x13: 0000000000000200 x12: 0000000000000006 00510 x11: ffffffc080bb86c0 x10: 0000000000000000 x9 : ffffffc080201e58 00510 x8 : ffffff80c4821060 x7 : 0000000000000000 x6 : 0000000055555556 00510 x5 : 0000000000000001 x4 : 0000000000000010 x3 : 0000000000000060 00510 x2 : 0000000000000000 x1 : ffffffc080f50cf8 x0 : ffffff80d801d000 00510 Call trace: 00510 __alloc_tagging_slab_alloc_hook+0xe0/0x190 (P) 00510 __kmalloc_noprof+0x150/0x310 00510 __bch2_folio_create+0x5c/0xf8 00510 bch2_folio_create+0x2c/0x40 00510 bch2_readahead+0xc0/0x460 00510 read_pages+0x7c/0x230 00510 page_cache_ra_order+0x244/0x3a8 00510 page_cache_async_ra+0x124/0x170 00510 filemap_readahead.isra.0+0x58/0xa0 00510 filemap_get_pages+0x454/0x7b0 00510 filemap_read+0xdc/0x418 00510 bch2_read_iter+0x100/0x1b0 00510 vfs_read+0x214/0x300 00510 ksys_read+0x6c/0x108 00510 __arm64_sys_read+0x20/0x30 00510 invoke_syscall.constprop.0+0x54/0xe8 00510 do_el0_svc+0x44/0xc8 00510 el0_svc+0x18/0x58 00510 el0t_64_sync_handler+0x104/0x130 00510 el0t_64_sync+0x154/0x158 00510 Code: d5384100 f9401c01 b9401aa3 b40002e1 (f8227881) 00510 ---[ end trace 0000000000000000 ]--- 00510 Kernel panic - not syncing: Oops: Fatal exception 00510 SMP: stopping secondary CPUs 00510 Kernel Offset: disabled 00510 CPU features: 0x0000,000000e0,00000410,8240500b 00510 Memory Limit: none Investigation indicates that these bits are already set when we allocate slab page and are not zeroed out after allocation. We are not yet sure why these crashes start happening only recently but regardless of the reason, not initializing a field that gets used later is wrong. Fix it by initializing slab->obj_exts during slab page allocation.",,"[{""url"":""https://git.kernel.org/stable/c/28bef6622a1a874fe63aceeb0c684fab75afb3ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8baa747193591410a853bac9c3710142dfa4937b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d2f5819b6ed357c0c350c0616b6b9f38be59adf6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37775,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:41.197,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix the warning from __kernel_write_iter [ 2110.972290] ------------[ cut here ]------------ [ 2110.972301] WARNING: CPU: 3 PID: 735 at fs/read_write.c:599 __kernel_write_iter+0x21b/0x280 This patch doesn't allow writing to directory.",,"[{""url"":""https://git.kernel.org/stable/c/1ed343481ba6911178bc5ca7a51be319eafcc747"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2a879da5c34a1e5d971e815d5b30f27eb6d69efc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/44079e544c9f6e3e9fb43a16ddf8b08cf686d657"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b37f2f332b40ad1c27f18682a495850f2f04db0a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b7ce8db490286c2e009758fa1416d66aeb333614"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37776,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:41.373,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix use-after-free in smb_break_all_levII_oplock() There is a room in smb_break_all_levII_oplock that can cause racy issues when unlocking in the middle of the loop. This patch use read lock to protect whole loop.",,"[{""url"":""https://git.kernel.org/stable/c/18b4fac5ef17f77fed9417d22210ceafd6525fc7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/296cb5457cc6f4a754c4ae29855f8a253d52bcc6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d54ab1520d43e95f9b2e22d7a05fc9614192e5a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d73686367ad68534257cd88a36ca3c52cb8b81d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37777,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:41.493,2025-08-01T09:15:31.173,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix use-after-free in __smb2_lease_break_noti() Move tcp_transport free to ksmbd_conn_free. If ksmbd connection is referenced when ksmbd server thread terminates, It will not be freed, but conn->tcp_transport is freed. __smb2_lease_break_noti can be performed asynchronously when the connection is disconnected. __smb2_lease_break_noti calls ksmbd_conn_write, which can cause use-after-free when conn->ksmbd_transport is already freed.",,"[{""url"":""https://git.kernel.org/stable/c/1aec4d14cf81b7b3e7b69eb1cfa94144eed7138e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1da8bd9a10ecd718692732294d15fd801c0eabb5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/21a4e47578d44c6b37c4fc4aba8ed7cc8dbb13de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e59796fc80603bcd8569d4d2e10b213c1918edb4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37778,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:41.617,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: Fix dangling pointer in krb_authenticate krb_authenticate frees sess->user and does not set the pointer to NULL. It calls ksmbd_krb5_authenticate to reinitialise sess->user but that function may return without doing so. If that happens then smb2_sess_setup, which calls krb_authenticate, will be accessing free'd memory when it later uses sess->user.",,"[{""url"":""https://git.kernel.org/stable/c/1db2451de23e98bc864c6a6e52aa0d82c91cb325"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1e440d5b25b7efccb3defe542a73c51005799a5f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6e30c0e10210c714f3d4453dc258d4abcc70364e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d5b554bc8d554ed6ddf443d3db2fad9f665cec10"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e83e39a5f6a01a81411a4558a59a10f87aa88dd6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37779,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:41.733,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: lib/iov_iter: fix to increase non slab folio refcount When testing EROFS file-backed mount over v9fs on qemu, I encountered a folio UAF issue. The page sanity check reports the following call trace. The root cause is that pages in bvec are coalesced across a folio bounary. The refcount of all non-slab folios should be increased to ensure p9_releas_pages can put them correctly. BUG: Bad page state in process md5sum pfn:18300 page: refcount:0 mapcount:0 mapping:00000000d5ad8e4e index:0x60 pfn:0x18300 head: order:0 mapcount:0 entire_mapcount:0 nr_pages_mapped:0 pincount:0 aops:z_erofs_aops ino:30b0f dentry name(?):""GoogleExtServicesCn.apk"" flags: 0x100000000000041(locked|head|node=0|zone=1) raw: 0100000000000041 dead000000000100 dead000000000122 ffff888014b13bd0 raw: 0000000000000060 0000000000000020 00000000ffffffff 0000000000000000 head: 0100000000000041 dead000000000100 dead000000000122 ffff888014b13bd0 head: 0000000000000060 0000000000000020 00000000ffffffff 0000000000000000 head: 0100000000000000 0000000000000000 ffffffffffffffff 0000000000000000 head: 0000000000000010 0000000000000000 00000000ffffffff 0000000000000000 page dumped because: PAGE_FLAGS_CHECK_AT_FREE flag(s) set Call Trace: dump_stack_lvl+0x53/0x70 bad_page+0xd4/0x220 __free_pages_ok+0x76d/0xf30 __folio_put+0x230/0x320 p9_release_pages+0x179/0x1f0 p9_virtio_zc_request+0xa2a/0x1230 p9_client_zc_rpc.constprop.0+0x247/0x700 p9_client_read_once+0x34d/0x810 p9_client_read+0xf3/0x150 v9fs_issue_read+0x111/0x360 netfs_unbuffered_read_iter_locked+0x927/0x1390 netfs_unbuffered_read_iter+0xa2/0xe0 vfs_iocb_iter_read+0x2c7/0x460 erofs_fileio_rq_submit+0x46b/0x5b0 z_erofs_runqueue+0x1203/0x21e0 z_erofs_readahead+0x579/0x8b0 read_pages+0x19f/0xa70 page_cache_ra_order+0x4ad/0xb80 filemap_readahead.isra.0+0xe7/0x150 filemap_get_pages+0x7aa/0x1890 filemap_read+0x320/0xc80 vfs_read+0x6c6/0xa30 ksys_read+0xf9/0x1c0 do_syscall_64+0x9e/0x1a0 entry_SYSCALL_64_after_hwframe+0x71/0x79",,"[{""url"":""https://git.kernel.org/stable/c/770c8d55c42868239c748a3ebc57c9e37755f842"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d833f21162c4d536d729628f8cf1ee8d4110f2b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37780,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:41.863,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: isofs: Prevent the use of too small fid syzbot reported a slab-out-of-bounds Read in isofs_fh_to_parent. [1] The handle_bytes value passed in by the reproducing program is equal to 12. In handle_to_path(), only 12 bytes of memory are allocated for the structure file_handle->f_handle member, which causes an out-of-bounds access when accessing the member parent_block of the structure isofs_fid in isofs, because accessing parent_block requires at least 16 bytes of f_handle. Here, fh_len is used to indirectly confirm that the value of handle_bytes is greater than 3 before accessing parent_block. [1] BUG: KASAN: slab-out-of-bounds in isofs_fh_to_parent+0x1b8/0x210 fs/isofs/export.c:183 Read of size 4 at addr ffff0000cc030d94 by task syz-executor215/6466 CPU: 1 UID: 0 PID: 6466 Comm: syz-executor215 Not tainted 6.14.0-rc7-syzkaller-ga2392f333575 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 02/12/2025 Call trace: show_stack+0x2c/0x3c arch/arm64/kernel/stacktrace.c:466 (C) __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0xe4/0x150 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:408 [inline] print_report+0x198/0x550 mm/kasan/report.c:521 kasan_report+0xd8/0x138 mm/kasan/report.c:634 __asan_report_load4_noabort+0x20/0x2c mm/kasan/report_generic.c:380 isofs_fh_to_parent+0x1b8/0x210 fs/isofs/export.c:183 exportfs_decode_fh_raw+0x2dc/0x608 fs/exportfs/expfs.c:523 do_handle_to_path+0xa0/0x198 fs/fhandle.c:257 handle_to_path fs/fhandle.c:385 [inline] do_handle_open+0x8cc/0xb8c fs/fhandle.c:403 __do_sys_open_by_handle_at fs/fhandle.c:443 [inline] __se_sys_open_by_handle_at fs/fhandle.c:434 [inline] __arm64_sys_open_by_handle_at+0x80/0x94 fs/fhandle.c:434 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline] invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151 el0_svc+0x54/0x168 arch/arm64/kernel/entry-common.c:744 el0t_64_sync_handler+0x84/0x108 arch/arm64/kernel/entry-common.c:762 el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600 Allocated by task 6466: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x40/0x78 mm/kasan/common.c:68 kasan_save_alloc_info+0x40/0x50 mm/kasan/generic.c:562 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0xac/0xc4 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __do_kmalloc_node mm/slub.c:4294 [inline] __kmalloc_noprof+0x32c/0x54c mm/slub.c:4306 kmalloc_noprof include/linux/slab.h:905 [inline] handle_to_path fs/fhandle.c:357 [inline] do_handle_open+0x5a4/0xb8c fs/fhandle.c:403 __do_sys_open_by_handle_at fs/fhandle.c:443 [inline] __se_sys_open_by_handle_at fs/fhandle.c:434 [inline] __arm64_sys_open_by_handle_at+0x80/0x94 fs/fhandle.c:434 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline] invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151 el0_svc+0x54/0x168 arch/arm64/kernel/entry-common.c:744 el0t_64_sync_handler+0x84/0x108 arch/arm64/kernel/entry-common.c:762 el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600",,"[{""url"":""https://git.kernel.org/stable/c/007124c896e7d4614ac1f6bd4dedb975c35a2a8e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0405d4b63d082861f4eaff9d39c78ee9dc34f845"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0fdafdaef796816a9ed0fd7ac812932d569d9beb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/56dfffea9fd3be0b3795a9ca6401e133a8427e0b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e7de55602c61c8ff28db075cc49c8dd6989d7e0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/63d5a3e207bf315a32c7d16de6c89753a759f95a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/952e7a7e317f126d0a2b879fc531b716932d5ffa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee01a309ebf598be1ff8174901ed6e91619f1749"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37781,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:42.020,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: i2c: cros-ec-tunnel: defer probe if parent EC is not present When i2c-cros-ec-tunnel and the EC driver are built-in, the EC parent device will not be found, leading to NULL pointer dereference. That can also be reproduced by unbinding the controller driver and then loading i2c-cros-ec-tunnel module (or binding the device). [ 271.991245] BUG: kernel NULL pointer dereference, address: 0000000000000058 [ 271.998215] #PF: supervisor read access in kernel mode [ 272.003351] #PF: error_code(0x0000) - not-present page [ 272.008485] PGD 0 P4D 0 [ 272.011022] Oops: Oops: 0000 [#1] SMP NOPTI [ 272.015207] CPU: 0 UID: 0 PID: 3859 Comm: insmod Tainted: G S 6.15.0-rc1-00004-g44722359ed83 #30 PREEMPT(full) 3c7fb39a552e7d949de2ad921a7d6588d3a4fdc5 [ 272.030312] Tainted: [S]=CPU_OUT_OF_SPEC [ 272.034233] Hardware name: HP Berknip/Berknip, BIOS Google_Berknip.13434.356.0 05/17/2021 [ 272.042400] RIP: 0010:ec_i2c_probe+0x2b/0x1c0 [i2c_cros_ec_tunnel] [ 272.048577] Code: 1f 44 00 00 41 57 41 56 41 55 41 54 53 48 83 ec 10 65 48 8b 05 06 a0 6c e7 48 89 44 24 08 4c 8d 7f 10 48 8b 47 50 4c 8b 60 78 <49> 83 7c 24 58 00 0f 84 2f 01 00 00 48 89 fb be 30 06 00 00 4c 9 [ 272.067317] RSP: 0018:ffffa32082a03940 EFLAGS: 00010282 [ 272.072541] RAX: ffff969580b6a810 RBX: ffff969580b68c10 RCX: 0000000000000000 [ 272.079672] RDX: 0000000000000000 RSI: 0000000000000282 RDI: ffff969580b68c00 [ 272.086804] RBP: 00000000fffffdfb R08: 0000000000000000 R09: 0000000000000000 [ 272.093936] R10: 0000000000000000 R11: ffffffffc0600000 R12: 0000000000000000 [ 272.101067] R13: ffffffffa666fbb8 R14: ffffffffc05b5528 R15: ffff969580b68c10 [ 272.108198] FS: 00007b930906fc40(0000) GS:ffff969603149000(0000) knlGS:0000000000000000 [ 272.116282] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 272.122024] CR2: 0000000000000058 CR3: 000000012631c000 CR4: 00000000003506f0 [ 272.129155] Call Trace: [ 272.131606] <TASK> [ 272.133709] ? acpi_dev_pm_attach+0xdd/0x110 [ 272.137985] platform_probe+0x69/0xa0 [ 272.141652] really_probe+0x152/0x310 [ 272.145318] __driver_probe_device+0x77/0x110 [ 272.149678] driver_probe_device+0x1e/0x190 [ 272.153864] __driver_attach+0x10b/0x1e0 [ 272.157790] ? driver_attach+0x20/0x20 [ 272.161542] bus_for_each_dev+0x107/0x150 [ 272.165553] bus_add_driver+0x15d/0x270 [ 272.169392] driver_register+0x65/0x110 [ 272.173232] ? cleanup_module+0xa80/0xa80 [i2c_cros_ec_tunnel 3a00532f3f4af4a9eade753f86b0f8dd4e4e5698] [ 272.182617] do_one_initcall+0x110/0x350 [ 272.186543] ? security_kernfs_init_security+0x49/0xd0 [ 272.191682] ? __kernfs_new_node+0x1b9/0x240 [ 272.195954] ? security_kernfs_init_security+0x49/0xd0 [ 272.201093] ? __kernfs_new_node+0x1b9/0x240 [ 272.205365] ? kernfs_link_sibling+0x105/0x130 [ 272.209810] ? kernfs_next_descendant_post+0x1c/0xa0 [ 272.214773] ? kernfs_activate+0x57/0x70 [ 272.218699] ? kernfs_add_one+0x118/0x160 [ 272.222710] ? __kernfs_create_file+0x71/0xa0 [ 272.227069] ? sysfs_add_bin_file_mode_ns+0xd6/0x110 [ 272.232033] ? internal_create_group+0x453/0x4a0 [ 272.236651] ? __vunmap_range_noflush+0x214/0x2d0 [ 272.241355] ? __free_frozen_pages+0x1dc/0x420 [ 272.245799] ? free_vmap_area_noflush+0x10a/0x1c0 [ 272.250505] ? load_module+0x1509/0x16f0 [ 272.254431] do_init_module+0x60/0x230 [ 272.258181] __se_sys_finit_module+0x27a/0x370 [ 272.262627] do_syscall_64+0x6a/0xf0 [ 272.266206] ? do_syscall_64+0x76/0xf0 [ 272.269956] ? irqentry_exit_to_user_mode+0x79/0x90 [ 272.274836] entry_SYSCALL_64_after_hwframe+0x55/0x5d [ 272.279887] RIP: 0033:0x7b9309168d39 [ 272.283466] Code: 5b 41 5c 5d c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d af 40 0c 00 f7 d8 64 89 01 8 [ 272.302210] RSP: 002b:00007fff50f1a288 EFLAGS: 00000246 ORIG_RAX: 000 ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/092de5ac8cb2eaa9593a765fa92ba39d8173f984"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1355b5ca4782be85a2ef7275e4c508f770d0fb27"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3090cad5ccff8963b95160f4060068048a1e4c4c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/424eafe65647a8d6c690284536e711977153195a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b66d4910a608427367c4e21499e149f085782df7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd83035b6f2a102c2d5acd3bfb2a11ff967aaba6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da8edc9eb2516aface7f86be5fa6d09c0d07b9f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e89bf1311d4497c6743f3021e9c481b16c3a41c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37782,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:42.163,2025-06-04T11:15:21.673,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,[],,,,,,,,,,
CVE-2025-37783,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:42.593,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/msm/dpu: Fix error pointers in dpu_plane_virtual_atomic_check The function dpu_plane_virtual_atomic_check was dereferencing pointers returned by drm_atomic_get_plane_state without checking for errors. This could lead to undefined behavior if the function returns an error pointer. This commit adds checks using IS_ERR to ensure that plane_state is valid before dereferencing them. Similar to commit da29abe71e16 (""drm/amd/display: Fix error pointers in amdgpu_dm_crtc_mem_type_changed""). Patchwork: https://patchwork.freedesktop.org/patch/643132/",,"[{""url"":""https://git.kernel.org/stable/c/5cb1b130e1cd04239cc9c26a98279f4660dce583"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9670ed1cce3216778c89936d3ae91cf0d436035"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37784,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:42.770,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: ti: icss-iep: Fix possible NULL pointer dereference for perout request The ICSS IEP driver tracks perout and pps enable state with flags. Currently when disabling pps and perout signals during icss_iep_exit(), results in NULL pointer dereference for perout. To fix the null pointer dereference issue, the icss_iep_perout_enable_hw function can be modified to directly clear the IEP CMP registers when disabling PPS or PEROUT, without referencing the ptp_perout_request structure, as its contents are irrelevant in this case.",,"[{""url"":""https://git.kernel.org/stable/c/7349c9e9979333abfce42da5f9025598083b59c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7891619d21f07a88e0275d6d43db74035aa74f69"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da5035d7aeadcfa44096dd34689bfed6c657f559"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eeec66327001421531b3fb1a2ac32efc8a2493b0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37785,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-04-18T07:15:42.693,2025-05-02T07:16:03.590,Modified,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: fix OOB read when checking dotdot dir Mounting a corrupted filesystem with directory which contains '.' dir entry with rec_len == block size results in out-of-bounds read (later on, when the corrupted directory is removed). ext4_empty_dir() assumes every ext4 directory contains at least '.' and '..' as directory entries in the first data block. It first loads the '.' dir entry, performs sanity checks by calling ext4_check_dir_entry() and then uses its rec_len member to compute the location of '..' dir entry (in ext4_next_entry). It assumes the '..' dir entry fits into the same data block. If the rec_len of '.' is precisely one block (4KB), it slips through the sanity checks (it is considered the last directory entry in the data block) and leaves ""struct ext4_dir_entry_2 *de"" point exactly past the memory slot allocated to the data block. The following call to ext4_check_dir_entry() on new value of de then dereferences this pointer which results in out-of-bounds mem access. Fix this by extending __ext4_check_dir_entry() to check for '.' dir entries that reach the end of data block. Make sure to ignore the phony dir entries for checksum (by checking name_len for non-zero). Note: This is reported by KASAN as use-after-free in case another structure was recently freed from the slot past the bound, but it is really an OOB read. This issue was found by syzkaller tool. Call Trace: [ 38.594108] BUG: KASAN: slab-use-after-free in __ext4_check_dir_entry+0x67e/0x710 [ 38.594649] Read of size 2 at addr ffff88802b41a004 by task syz-executor/5375 [ 38.595158] [ 38.595288] CPU: 0 UID: 0 PID: 5375 Comm: syz-executor Not tainted 6.14.0-rc7 #1 [ 38.595298] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014 [ 38.595304] Call Trace: [ 38.595308] <TASK> [ 38.595311] dump_stack_lvl+0xa7/0xd0 [ 38.595325] print_address_description.constprop.0+0x2c/0x3f0 [ 38.595339] ? __ext4_check_dir_entry+0x67e/0x710 [ 38.595349] print_report+0xaa/0x250 [ 38.595359] ? __ext4_check_dir_entry+0x67e/0x710 [ 38.595368] ? kasan_addr_to_slab+0x9/0x90 [ 38.595378] kasan_report+0xab/0xe0 [ 38.595389] ? __ext4_check_dir_entry+0x67e/0x710 [ 38.595400] __ext4_check_dir_entry+0x67e/0x710 [ 38.595410] ext4_empty_dir+0x465/0x990 [ 38.595421] ? __pfx_ext4_empty_dir+0x10/0x10 [ 38.595432] ext4_rmdir.part.0+0x29a/0xd10 [ 38.595441] ? __dquot_initialize+0x2a7/0xbf0 [ 38.595455] ? __pfx_ext4_rmdir.part.0+0x10/0x10 [ 38.595464] ? __pfx___dquot_initialize+0x10/0x10 [ 38.595478] ? down_write+0xdb/0x140 [ 38.595487] ? __pfx_down_write+0x10/0x10 [ 38.595497] ext4_rmdir+0xee/0x140 [ 38.595506] vfs_rmdir+0x209/0x670 [ 38.595517] ? lookup_one_qstr_excl+0x3b/0x190 [ 38.595529] do_rmdir+0x363/0x3c0 [ 38.595537] ? __pfx_do_rmdir+0x10/0x10 [ 38.595544] ? strncpy_from_user+0x1ff/0x2e0 [ 38.595561] __x64_sys_unlinkat+0xf0/0x130 [ 38.595570] do_syscall_64+0x5b/0x180 [ 38.595583] entry_SYSCALL_64_after_hwframe+0x76/0x7e","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-125""}]}]","[{""url"":""https://git.kernel.org/stable/c/14da7dbecb430e35b5889da8dae7bef33173b351"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/52a5509ab19a5d3afe301165d9b5787bba34d842"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/53bc45da8d8da92ec07877f5922b130562eb4b00"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/89503e5eae64637d0fa2218912b54660effe7d93"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/ac28c5684c1cdab650a7e5065b19e91577d37a4b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/b47584c556444cf7acb66b26a62cbc348eb92b78"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/b7531a4f99c3887439d778afaf418d1a01a5f01b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/d5e206778e96e8667d3bde695ad372c296dc9353"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/e47f472a664d70a3d104a6c2a035cdff55a719b4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"",""baseScore"":7.1,""baseSeverity"":""HIGH"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":5.2}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""2.6.19"",""versionEndExcluding"":""5.10.236"",""matchCriteriaId"":""5093EDFD-21CC-4898-9E34-0C31FADEF44A""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.11"",""versionEndExcluding"":""5.15.180"",""matchCriteriaId"":""D19801C8-3D18-405D-9989-E6C9B30255FA""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.134"",""matchCriteriaId"":""3985DEC3-0437-4177-BC42-314AB575285A""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.2"",""versionEndExcluding"":""6.6.87"",""matchCriteriaId"":""EFF24260-49B1-4251-9477-C564CFDAD25B""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.7"",""versionEndExcluding"":""6.12.23"",""matchCriteriaId"":""26CAB76D-F00F-43CE-BEAD-7097F8FB1D6C""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.13"",""versionEndExcluding"":""6.13.11"",""matchCriteriaId"":""E7E864B0-8C00-4679-BA55-659B4C9C3AD3""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.14"",""versionEndExcluding"":""6.14.2"",""matchCriteriaId"":""FADAE5D8-4808-442C-B218-77B2CE8780A0""}]}]}]",,,,,,,,
CVE-2025-37786,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:42.890,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: dsa: free routing table on probe failure If complete = true in dsa_tree_setup(), it means that we are the last switch of the tree which is successfully probing, and we should be setting up all switches from our probe path. After ""complete"" becomes true, dsa_tree_setup_cpu_ports() or any subsequent function may fail. If that happens, the entire tree setup is in limbo: the first N-1 switches have successfully finished probing (doing nothing but having allocated persistent memory in the tree's dst->ports, and maybe dst->rtable), and switch N failed to probe, ending the tree setup process before anything is tangible from the user's PoV. If switch N fails to probe, its memory (ports) will be freed and removed from dst->ports. However, the dst->rtable elements pointing to its ports, as created by dsa_link_touch(), will remain there, and will lead to use-after-free if dereferenced. If dsa_tree_setup_switches() returns -EPROBE_DEFER, which is entirely possible because that is where ds->ops->setup() is, we get a kasan report like this: ================================================================== BUG: KASAN: slab-use-after-free in mv88e6xxx_setup_upstream_port+0x240/0x568 Read of size 8 at addr ffff000004f56020 by task kworker/u8:3/42 Call trace: __asan_report_load8_noabort+0x20/0x30 mv88e6xxx_setup_upstream_port+0x240/0x568 mv88e6xxx_setup+0xebc/0x1eb0 dsa_register_switch+0x1af4/0x2ae0 mv88e6xxx_register_switch+0x1b8/0x2a8 mv88e6xxx_probe+0xc4c/0xf60 mdio_probe+0x78/0xb8 really_probe+0x2b8/0x5a8 __driver_probe_device+0x164/0x298 driver_probe_device+0x78/0x258 __device_attach_driver+0x274/0x350 Allocated by task 42: __kasan_kmalloc+0x84/0xa0 __kmalloc_cache_noprof+0x298/0x490 dsa_switch_touch_ports+0x174/0x3d8 dsa_register_switch+0x800/0x2ae0 mv88e6xxx_register_switch+0x1b8/0x2a8 mv88e6xxx_probe+0xc4c/0xf60 mdio_probe+0x78/0xb8 really_probe+0x2b8/0x5a8 __driver_probe_device+0x164/0x298 driver_probe_device+0x78/0x258 __device_attach_driver+0x274/0x350 Freed by task 42: __kasan_slab_free+0x48/0x68 kfree+0x138/0x418 dsa_register_switch+0x2694/0x2ae0 mv88e6xxx_register_switch+0x1b8/0x2a8 mv88e6xxx_probe+0xc4c/0xf60 mdio_probe+0x78/0xb8 really_probe+0x2b8/0x5a8 __driver_probe_device+0x164/0x298 driver_probe_device+0x78/0x258 __device_attach_driver+0x274/0x350 The simplest way to fix the bug is to delete the routing table in its entirety. dsa_tree_setup_routing_table() has no problem in regenerating it even if we deleted links between ports other than those of switch N, because dsa_link_touch() first checks whether the port pair already exists in dst->rtable, allocating if not. The deletion of the routing table in its entirety already exists in dsa_tree_teardown(), so refactor that into a function that can also be called from the tree setup error path. In my analysis of the commit to blame, it is the one which added dsa_link elements to dst->rtable. Prior to that, each switch had its own ds->rtable which is freed when the switch fails to probe. But the tree is potentially persistent memory.",,"[{""url"":""https://git.kernel.org/stable/c/5c8066fbdb9653c6e9a224bdcd8f9c91a484f0de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8bf108d7161ffc6880ad13a0cc109de3cf631727"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a038f5f15af455dfe35bc68549e02b950978700a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fb12b460ec46c9efad98de6d9ba349691db51dc7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37787,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:43.040,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: dsa: mv88e6xxx: avoid unregistering devlink regions which were never registered Russell King reports that a system with mv88e6xxx dereferences a NULL pointer when unbinding this driver: https://lore.kernel.org/netdev/Z_lRkMlTJ1KQ0kVX@shell.armlinux.org.uk/ The crash seems to be in devlink_region_destroy(), which is not NULL tolerant but is given a NULL devlink global region pointer. At least on some chips, some devlink regions are conditionally registered since the blamed commit, see mv88e6xxx_setup_devlink_regions_global(): if (cond && !cond(chip)) continue; These are MV88E6XXX_REGION_STU and MV88E6XXX_REGION_PVT. If the chip does not have an STU or PVT, it should crash like this. To fix the issue, avoid unregistering those regions which are NULL, i.e. were skipped at mv88e6xxx_setup_devlink_regions_global() time.",,"[{""url"":""https://git.kernel.org/stable/c/3665695e3572239dc233216f06b41f40cc771889"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5f5e95945bb1e08be7655da6acba648274db457d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ccdf5e24b276848eefb2755e05ff0f005a0c4a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3c70dfe51f10df60db2646c08cebd24bcdc5247"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bbb80f004f7a90c3dcaacc982c59967457254a05"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c84f6ce918a9e6f4996597cbc62536bbf2247c96"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37788,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:43.163,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: cxgb4: fix memory leak in cxgb4_init_ethtool_filters() error path In the for loop used to allocate the loc_array and bmap for each port, a memory leak is possible when the allocation for loc_array succeeds, but the allocation for bmap fails. This is because when the control flow goes to the label free_eth_finfo, only the allocations starting from (i-1)th iteration are freed. Fix that by freeing the loc_array in the bmap allocation error path.",,"[{""url"":""https://git.kernel.org/stable/c/00ffb3724ce743578163f5ade2884374554ca021"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/08aa59c0be768596467552c129e9f82166779a67"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/118d05b530343cd9322607b9719405ba254a4183"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/76deedea08899885f076aba0bb80bd1276446822"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dafb6e433ab2333b67be05433dc9c6ccbc7b1284"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e9de08e15aee35b96064960f95997bb6c1209c4b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa2d7708955e4f8212fd69bab1da604e60cb0b15"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37789,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:43.290,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: openvswitch: fix nested key length validation in the set() action It's not safe to access nla_len(ovs_key) if the data is smaller than the netlink header. Check that the attribute is OK first.",,"[{""url"":""https://git.kernel.org/stable/c/03d7262dd53e8c404da35cc81aaa887fd901f76b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1489c195c8eecd262aa6712761ba5288203e28ec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/54c6957d1123a2032099b9eab51c314800f677ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/65d91192aa66f05710cfddf6a14b5a25ee554dba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7fcaec0b2ab8fa5fbf0b45e5512364a168f445bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/824a7c2df5127b2402b68a21a265d413e78dcad7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a27526e6b48eee9e2d82efff502c4f272f1a91d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be80768d4f3b6fd13f421451cc3fee8778aba8bc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37790,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:43.407,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: mctp: Set SOCK_RCU_FREE Bind lookup runs under RCU, so ensure that a socket doesn't go away in the middle of a lookup.",,"[{""url"":""https://git.kernel.org/stable/c/3f899bd6dd56ddc46509b526e23a8f0a97712a6d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/52024cd6ec71a6ca934d0cc12452bd8d49850679"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5c1313b93c8c2e3904a48aa88e2fa1db28c607ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a8a3b61ce140e2b0a72a779e8d70f60c0cf1e47a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b9764ebebb007249fb733a131b6110ff333b6616"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3b5edbdb45924a7d4206d13868a2aac71f1e53d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37791,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:43.540,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ethtool: cmis_cdb: use correct rpl size in ethtool_cmis_module_poll() rpl is passed as a pointer to ethtool_cmis_module_poll(), so the correct size of rpl is sizeof(*rpl) which should be just 1 byte. Using the pointer size instead can cause stack corruption: Kernel panic - not syncing: stack-protector: Kernel stack is corrupted in: ethtool_cmis_wait_for_cond+0xf4/0x100 CPU: 72 UID: 0 PID: 4440 Comm: kworker/72:2 Kdump: loaded Tainted: G OE 6.11.0 #24 Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE Hardware name: Dell Inc. PowerEdge R760/04GWWM, BIOS 1.6.6 09/20/2023 Workqueue: events module_flash_fw_work Call Trace: <TASK> panic+0x339/0x360 ? ethtool_cmis_wait_for_cond+0xf4/0x100 ? __pfx_status_success+0x10/0x10 ? __pfx_status_fail+0x10/0x10 __stack_chk_fail+0x10/0x10 ethtool_cmis_wait_for_cond+0xf4/0x100 ethtool_cmis_cdb_execute_cmd+0x1fc/0x330 ? __pfx_status_fail+0x10/0x10 cmis_cdb_module_features_get+0x6d/0xd0 ethtool_cmis_cdb_init+0x8a/0xd0 ethtool_cmis_fw_update+0x46/0x1d0 module_flash_fw_work+0x17/0xa0 process_one_work+0x179/0x390 worker_thread+0x239/0x340 ? __pfx_worker_thread+0x10/0x10 kthread+0xcc/0x100 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x2d/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK>",,"[{""url"":""https://git.kernel.org/stable/c/61765e1b417a23371c3735e3cddf4ad9354ed2e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7eb0a0072f966bb0b01d8b7d529d9743a7187bd1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f3fdd4fba16c74697d8bc730b82fb7c1eff7fab3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37792,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:43.660,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: btrtl: Prevent potential NULL dereference The btrtl_initialize() function checks that rtl_load_file() either had an error or it loaded a zero length file. However, if it loaded a zero length file then the error code is not set correctly. It results in an error pointer vs NULL bug, followed by a NULL pointer dereference. This was detected by Smatch: drivers/bluetooth/btrtl.c:592 btrtl_initialize() warn: passing zero to 'ERR_PTR'",,"[{""url"":""https://git.kernel.org/stable/c/2d7c60c2a38b4b461fa960ad0995136a6bfe0756"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/324dddea321078a6eeb535c2bff5257be74c9799"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3db6605043b50c8bb768547b23e0222f67ceef3e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/53ceef799dcfc22c734d600811bfc9dd32eaea0a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73dc99c0ea94abd22379b2d82cacbc73f3e18ec1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aaf356f872a60db1e96fb762a62c4607fd22741f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c3e9717276affe59fd8213706db021b493e81e34"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d8441818690d795232331bd8358545c5c95b6b72"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37793,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:43.787,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: Intel: avs: Fix null-ptr-deref in avs_component_probe() devm_kasprintf() returns NULL when memory allocation fails. Currently, avs_component_probe() does not check for this case, which results in a NULL pointer dereference.",,"[{""url"":""https://git.kernel.org/stable/c/23fde311ea1d0a6c36bf92ce48b90b77d0ece1a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/95f723cf141b95e3b3a5b92cf2ea98a863fe7275"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aaa93b8846101461de815759d39979661b82d5a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c2825073271b6f15e669a424b363612082494863"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37794,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:43.913,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mac80211: Purge vif txq in ieee80211_do_stop() After ieee80211_do_stop() SKB from vif's txq could still be processed. Indeed another concurrent vif schedule_and_wake_txq call could cause those packets to be dequeued (see ieee80211_handle_wake_tx_queue()) without checking the sdata current state. Because vif.drv_priv is now cleared in this function, this could lead to driver crash. For example in ath12k, ahvif is store in vif.drv_priv. Thus if ath12k_mac_op_tx() is called after ieee80211_do_stop(), ahvif->ah can be NULL, leading the ath12k_warn(ahvif->ah,...) call in this function to trigger the NULL deref below. Unable to handle kernel paging request at virtual address dfffffc000000001 KASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f] batman_adv: bat0: Interface deactivated: brbh1337 Mem abort info: ESR = 0x0000000096000004 EC = 0x25: DABT (current EL), IL = 32 bits SET = 0, FnV = 0 EA = 0, S1PTW = 0 FSC = 0x04: level 0 translation fault Data abort info: ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000 CM = 0, WnR = 0, TnD = 0, TagAccess = 0 GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 [dfffffc000000001] address between user and kernel address ranges Internal error: Oops: 0000000096000004 [#1] SMP CPU: 1 UID: 0 PID: 978 Comm: lbd Not tainted 6.13.0-g633f875b8f1e #114 Hardware name: HW (DT) pstate: 10000005 (nzcV daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : ath12k_mac_op_tx+0x6cc/0x29b8 [ath12k] lr : ath12k_mac_op_tx+0x174/0x29b8 [ath12k] sp : ffffffc086ace450 x29: ffffffc086ace450 x28: 0000000000000000 x27: 1ffffff810d59ca4 x26: ffffff801d05f7c0 x25: 0000000000000000 x24: 000000004000001e x23: ffffff8009ce4926 x22: ffffff801f9c0800 x21: ffffff801d05f7f0 x20: ffffff8034a19f40 x19: 0000000000000000 x18: ffffff801f9c0958 x17: ffffff800bc0a504 x16: dfffffc000000000 x15: ffffffc086ace4f8 x14: ffffff801d05f83c x13: 0000000000000000 x12: ffffffb003a0bf03 x11: 0000000000000000 x10: ffffffb003a0bf02 x9 : ffffff8034a19f40 x8 : ffffff801d05f818 x7 : 1ffffff0069433dc x6 : ffffff8034a19ee0 x5 : ffffff801d05f7f0 x4 : 0000000000000000 x3 : 0000000000000001 x2 : 0000000000000000 x1 : dfffffc000000000 x0 : 0000000000000008 Call trace: ath12k_mac_op_tx+0x6cc/0x29b8 [ath12k] (P) ieee80211_handle_wake_tx_queue+0x16c/0x260 ieee80211_queue_skb+0xeec/0x1d20 ieee80211_tx+0x200/0x2c8 ieee80211_xmit+0x22c/0x338 __ieee80211_subif_start_xmit+0x7e8/0xc60 ieee80211_subif_start_xmit+0xc4/0xee0 __ieee80211_subif_start_xmit_8023.isra.0+0x854/0x17a0 ieee80211_subif_start_xmit_8023+0x124/0x488 dev_hard_start_xmit+0x160/0x5a8 __dev_queue_xmit+0x6f8/0x3120 br_dev_queue_push_xmit+0x120/0x4a8 __br_forward+0xe4/0x2b0 deliver_clone+0x5c/0xd0 br_flood+0x398/0x580 br_dev_xmit+0x454/0x9f8 dev_hard_start_xmit+0x160/0x5a8 __dev_queue_xmit+0x6f8/0x3120 ip6_finish_output2+0xc28/0x1b60 __ip6_finish_output+0x38c/0x638 ip6_output+0x1b4/0x338 ip6_local_out+0x7c/0xa8 ip6_send_skb+0x7c/0x1b0 ip6_push_pending_frames+0x94/0xd0 rawv6_sendmsg+0x1a98/0x2898 inet_sendmsg+0x94/0xe0 __sys_sendto+0x1e4/0x308 __arm64_sys_sendto+0xc4/0x140 do_el0_svc+0x110/0x280 el0_svc+0x20/0x60 el0t_64_sync_handler+0x104/0x138 el0t_64_sync+0x154/0x158 To avoid that, empty vif's txq at ieee80211_do_stop() so no packet could be dequeued after ieee80211_do_stop() (new packets cannot be queued because SDATA_STATE_RUNNING is cleared at this point).",,"[{""url"":""https://git.kernel.org/stable/c/305741e7e63234cbcf9b5c4e6aeca25ba0834be8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/378677eb8f44621ecc9ce659f7af61e5baa94d81"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5f6863dc407f25fcf23fc857f9ac51756a09ea2c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8bc34db7f771a464ff8f686b6f8d4e04963fec27"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/929ec2c9ad34248ef625e137b6118b6e965797d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a8df245b5b29f6de98d016dc18e2bb35ec70b0cb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a932a5ce4eee0cbad20220f950fe7bd3534bcbc9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c74b84544dee27298a71715b3ce2c40d372b5a23"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37795,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:44.043,2025-05-10T14:15:32.673,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,[],,,,,,,,,,
CVE-2025-37796,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-01T14:15:44.173,2025-05-02T13:53:20.943,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: at76c50x: fix use after free access in at76_disconnect The memory pointed to by priv is freed at the end of at76_delete_device function (using ieee80211_free_hw). But the code then accesses the udev field of the freed object to put the USB device. This may also lead to a memory leak of the usb device. Fix this by using udev from interface.",,"[{""url"":""https://git.kernel.org/stable/c/152721cbae42713ecfbca6847e0f102ee6b19546"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/27c7e63b3cb1a20bb78ed4a36c561ea4579fd7da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3c619aec1f538333b56746d2f796aab1bca5c9a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e7df74745700f059dc117a620e566964a2e8f2c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6e4ab3e574c2a335b40fa1f70d1c54fcb58ab33f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ca513631fa6ad3011b8b9197cdde0f351103704"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9682bfef2cf3802515a902e964d774e137be1b9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c731cdfddcf1be1590d5ba8c9b508f98e3a2b3d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37797,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T15:15:48.557,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net_sched: hfsc: Fix a UAF vulnerability in class handling This patch fixes a Use-After-Free vulnerability in the HFSC qdisc class handling. The issue occurs due to a time-of-check/time-of-use condition in hfsc_change_class() when working with certain child qdiscs like netem or codel. The vulnerability works as follows: 1. hfsc_change_class() checks if a class has packets (q.qlen != 0) 2. It then calls qdisc_peek_len(), which for certain qdiscs (e.g., codel, netem) might drop packets and empty the queue 3. The code continues assuming the queue is still non-empty, adding the class to vttree 4. This breaks HFSC scheduler assumptions that only non-empty classes are in vttree 5. Later, when the class is destroyed, this can lead to a Use-After-Free The fix adds a second queue length check after qdisc_peek_len() to verify the queue wasn't emptied.",,"[{""url"":""https://git.kernel.org/stable/c/20d584a33e480ae80d105f43e0e7b56784da41b9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/28b09a067831f7317c3841812276022d6c940677"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/39b9095dd3b55d9b2743df038c32138efa34a9de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3aa852e3605000d5c47035c3fc3a986d14ccfa9f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3df275ef0a6ae181e8428a6589ef5d5231e58b5c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/86cd4641c713455a4f1c8e54c370c598c2b1cee0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bb583c88d23b72d8d16453d24856c99bd93dadf5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fcc8ede663569c704fb00a702973bd6c00373283"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37798,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T15:15:48.657,2025-08-28T15:15:47.170,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: codel: remove sch->q.qlen check before qdisc_tree_reduce_backlog() After making all ->qlen_notify() callbacks idempotent, now it is safe to remove the check of qlen!=0 from both fq_codel_dequeue() and codel_qdisc_dequeue().",,"[{""url"":""https://git.kernel.org/stable/c/2f9761a94bae33d26e6a81b31b36e7d776d93dc1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/342debc12183b51773b3345ba267e9263bdfaaef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4d55144b12e742404bb3f8fee6038bafbf45619d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7a742a9506849d1c1aa71e36c89855ceddc7d58e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/829c49b6b2ff45b043739168fd1245e4e1a91a30"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a57fe60ef4cf96bfbb6b58397ec28bdb5a5c6b31"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc71a757da78dd4aa1b4a9b19cb011833730ccf2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e73c838c80dccb9e4f19becc11d9f3cb4a27d483"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eda741fe155ddf5ecd2dd3bfbd4fc3c0c7dbb450"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37799,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-03T12:15:14.950,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: vmxnet3: Fix malformed packet sizing in vmxnet3_process_xdp vmxnet3 driver's XDP handling is buggy for packet sizes using ring0 (that is, packet sizes between 128 - 3k bytes). We noticed MTU-related connectivity issues with Cilium's service load- balancing in case of vmxnet3 as NIC underneath. A simple curl to a HTTP backend service where the XDP LB was doing IPIP encap led to overly large packet sizes but only for *some* of the packets (e.g. HTTP GET request) while others (e.g. the prior TCP 3WHS) looked completely fine on the wire. In fact, the pcap recording on the backend node actually revealed that the node with the XDP LB was leaking uninitialized kernel data onto the wire for the affected packets, for example, while the packets should have been 152 bytes their actual size was 1482 bytes, so the remainder after 152 bytes was padded with whatever other data was in that page at the time (e.g. we saw user/payload data from prior processed packets). We only noticed this through an MTU issue, e.g. when the XDP LB node and the backend node both had the same MTU (e.g. 1500) then the curl request got dropped on the backend node's NIC given the packet was too large even though the IPIP-encapped packet normally would never even come close to the MTU limit. Lowering the MTU on the XDP LB (e.g. 1480) allowed to let the curl request succeed (which also indicates that the kernel ignored the padding, and thus the issue wasn't very user-visible). Commit e127ce7699c1 (""vmxnet3: Fix missing reserved tailroom"") was too eager to also switch xdp_prepare_buff() from rcd->len to rbi->len. It really needs to stick to rcd->len which is the actual packet length from the descriptor. The latter we also feed into vmxnet3_process_xdp_small(), by the way, and it indicates the correct length needed to initialize the xdp->{data,data_end} parts. For e127ce7699c1 (""vmxnet3: Fix missing reserved tailroom"") the relevant part was adapting xdp_init_buff() to address the warning given the xdp_data_hard_end() depends on xdp->frame_sz. With that fixed, traffic on the wire looks good again.",,"[{""url"":""https://git.kernel.org/stable/c/33e131a10459d16f181c8184d3f17f1c318c7002"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c2227656d9003f4d77afc76f34dd81b95e4c2c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c4312c4d244aa58e811ff0297e013124d115e793"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3ad76e36a37b0ff4a71b06d5b33530ee8c3a177"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37800,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:50.420,2025-06-05T14:32:50.747,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: driver core: fix potential NULL pointer dereference in dev_uevent() If userspace reads ""uevent"" device attribute at the same time as another threads unbinds the device from its driver, change to dev->driver from a valid pointer to NULL may result in crash. Fix this by using READ_ONCE() when fetching the pointer, and take bus' drivers klist lock to make sure driver instance will not disappear while we access it. Use WRITE_ONCE() when setting the driver pointer to ensure there is no tearing.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-476""}]}]","[{""url"":""https://git.kernel.org/stable/c/18daa52418e7e4629ed1703b64777294209d2622"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/2b344e779d9afd0fcb5ee4000e4d0fc7d8d867eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/3781e4b83e174364998855de777e184cf0b62c40"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/abe56be73eb10a677d16066f65ff9d30251f5eee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""6.6.89"",""matchCriteriaId"":""4D51CA5E-345A-4098-B85D-3F2BED7BF3A0""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.7"",""versionEndExcluding"":""6.12.26"",""matchCriteriaId"":""22F52099-F422-4D19-8283-45F9F9BF4392""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.13"",""versionEndExcluding"":""6.14.5"",""matchCriteriaId"":""6B25CA7E-4CD0-46DB-B4EF-13A3516071FB""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.15:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""8D465631-2980-487A-8E65-40AE2B9F8ED1""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.15:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""4C9D071F-B28E-46EC-AC61-22B913390211""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.15:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""13FC0DDE-E513-465E-9E81-515702D49B74""}]}]}]",,,,,,,,
CVE-2025-37801,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:51.257,2025-06-05T14:32:39.940,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: spi: spi-imx: Add check for spi_imx_setupxfer() Add check for the return value of spi_imx_setupxfer(). spi_imx->rx and spi_imx->tx function pointer can be NULL when spi_imx_setupxfer() return error, and make NULL pointer dereference. Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000 Call trace: 0x0 spi_imx_pio_transfer+0x50/0xd8 spi_imx_transfer_one+0x18c/0x858 spi_transfer_one_message+0x43c/0x790 __spi_pump_transfer_message+0x238/0x5d4 __spi_sync+0x2b0/0x454 spi_write_then_read+0x11c/0x200","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-476""}]}]","[{""url"":""https://git.kernel.org/stable/c/055ef73bb1afc3f783a9a13b496770a781964a07"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/185d376875ea6fb4256b9dc97ee0b4d2b0fdd399"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/2b4479eb462ecb39001b38dfb331fc6028dedac8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/2fea0d6d7b5d27fbf55512d51851ba0a346ede52"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/951a04ab3a2db4029debfa48d380ef834b93207e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""6.1.136"",""matchCriteriaId"":""05A05DE3-3248-434C-8967-0FB26A540FA5""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.2"",""versionEndExcluding"":""6.6.89"",""matchCriteriaId"":""D79CE030-3114-45E0-B52B-C77781BCB587""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.7"",""versionEndExcluding"":""6.12.26"",""matchCriteriaId"":""22F52099-F422-4D19-8283-45F9F9BF4392""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.13"",""versionEndExcluding"":""6.14.5"",""matchCriteriaId"":""6B25CA7E-4CD0-46DB-B4EF-13A3516071FB""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.15:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""8D465631-2980-487A-8E65-40AE2B9F8ED1""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.15:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""4C9D071F-B28E-46EC-AC61-22B913390211""}]}]}]",,,,,,,,
CVE-2025-37802,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:51.363,2025-06-05T14:32:23.670,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix WARNING ""do not call blocking ops when !TASK_RUNNING"" wait_event_timeout() will set the state of the current task to TASK_UNINTERRUPTIBLE, before doing the condition check. This means that ksmbd_durable_scavenger_alive() will try to acquire the mutex while already in a sleeping state. The scheduler warns us by giving the following warning: do not call blocking ops when !TASK_RUNNING; state=2 set at [<0000000061515a6f>] prepare_to_wait_event+0x9f/0x6c0 WARNING: CPU: 2 PID: 4147 at kernel/sched/core.c:10099 __might_sleep+0x12f/0x160 mutex lock is not needed in ksmbd_durable_scavenger_alive().","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-667""}]}]","[{""url"":""https://git.kernel.org/stable/c/1df0d4c616138784e033ad337961b6e1a6bcd999"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/8f805b3746d2f41702c77cba22f94f8415fadd1a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/cd161198e091e8a62b9bd631be970ea9a87d2d6a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""6.12.26"",""matchCriteriaId"":""505F343C-3DE3-4984-A2E0-52BAFF9CC7CE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.13"",""versionEndExcluding"":""6.14.5"",""matchCriteriaId"":""6B25CA7E-4CD0-46DB-B4EF-13A3516071FB""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.15:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""8D465631-2980-487A-8E65-40AE2B9F8ED1""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.15:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""4C9D071F-B28E-46EC-AC61-22B913390211""}]}]}]",,,,,,,,
CVE-2025-37803,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:51.467,2025-06-05T14:32:13.953,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: udmabuf: fix a buf size overflow issue during udmabuf creation by casting size_limit_mb to u64 when calculate pglimit.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-120""}]}]","[{""url"":""https://git.kernel.org/stable/c/021ba7f1babd029e714d13a6bf2571b08af96d0f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/13fe12c037b470321436deec393030c6153cfeb9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/2b8419c6ecf69007dcff54ea0b9f0b215282c55a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/373512760e13fdaa726faa9502d0f5be2abb3d33"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/3f6c9d66e0f8eb9679b57913aa64b4d2266f6fbe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/b2ff4e9c599b000833d16a917f519aa2e4a75de2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/e84a08fc7e25cdad5d9a3def42cc770ff711193f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":7.8,""baseSeverity"":""HIGH"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":5.9}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""5.4.293"",""matchCriteriaId"":""389EB980-4648-446E-A0DC-5FB0265E0F02""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.5"",""versionEndExcluding"":""5.10.237"",""matchCriteriaId"":""0710B81E-E2FA-4E15-8F68-D297EBB4D50D""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.11"",""versionEndExcluding"":""5.15.181"",""matchCriteriaId"":""12331C9E-F601-4EFC-899E-369F98DCC70B""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.136"",""matchCriteriaId"":""27735C1B-DDFC-4860-8952-1D01025F9D4C""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.2"",""versionEndExcluding"":""6.6.89"",""matchCriteriaId"":""D79CE030-3114-45E0-B52B-C77781BCB587""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.7"",""versionEndExcluding"":""6.14.5"",""matchCriteriaId"":""3D7A59A8-D160-4B5D-A80A-3EC733EFA5CB""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.15:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""8D465631-2980-487A-8E65-40AE2B9F8ED1""}]}]}]",,,,,,,,
CVE-2025-37804,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:51.570,2025-05-20T14:15:48.763,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,[],,,,,,,,,,
CVE-2025-37805,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:51.667,2025-06-05T14:31:32.787,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: sound/virtio: Fix cancel_sync warnings on uninitialized work_structs Betty reported hitting the following warning: [ 8.709131][ T221] WARNING: CPU: 2 PID: 221 at kernel/workqueue.c:4182 ... [ 8.713282][ T221] Call trace: [ 8.713365][ T221] __flush_work+0x8d0/0x914 [ 8.713468][ T221] __cancel_work_sync+0xac/0xfc [ 8.713570][ T221] cancel_work_sync+0x24/0x34 [ 8.713667][ T221] virtsnd_remove+0xa8/0xf8 [virtio_snd ab15f34d0dd772f6d11327e08a81d46dc9c36276] [ 8.713868][ T221] virtsnd_probe+0x48c/0x664 [virtio_snd ab15f34d0dd772f6d11327e08a81d46dc9c36276] [ 8.714035][ T221] virtio_dev_probe+0x28c/0x390 [ 8.714139][ T221] really_probe+0x1bc/0x4c8 ... It seems we're hitting the error path in virtsnd_probe(), which triggers a virtsnd_remove() which iterates over the substreams calling cancel_work_sync() on the elapsed_period work_struct. Looking at the code, from earlier in: virtsnd_probe()->virtsnd_build_devs()->virtsnd_pcm_parse_cfg() We set snd->nsubstreams, allocate the snd->substreams, and if we then hit an error on the info allocation or something in virtsnd_ctl_query_info() fails, we will exit without having initialized the elapsed_period work_struct. When that error path unwinds we then call virtsnd_remove() which as long as the substreams array is allocated, will iterate through calling cancel_work_sync() on the uninitialized work struct hitting this warning. Takashi Iwai suggested this fix, which initializes the substreams structure right after allocation, so that if we hit the error paths we avoid trying to cleanup uninitialized data. Note: I have not yet managed to reproduce the issue myself, so this patch has had limited testing. Feedback or thoughts would be appreciated!","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-770""}]}]","[{""url"":""https://git.kernel.org/stable/c/3c7df2e27346eb40a0e86230db1ccab195c97cfe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/54c7b864fbe4423a07b443a4ada0106052942116"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/5be9407b41eae20eef9140f5cfbfcbc3d01aaf45"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/66046b586c0aaa9332483bcdbd76e3305d6138e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/9908498ce929a5a052b79bb7942f9ea317312ce4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/e03b10c45c7675b6098190c6e7de1b656d8bcdbe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""5.15.181"",""matchCriteriaId"":""E1AE45B7-B31B-48DF-9F83-959F56624B62""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.136"",""matchCriteriaId"":""27735C1B-DDFC-4860-8952-1D01025F9D4C""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.2"",""versionEndExcluding"":""6.6.89"",""matchCriteriaId"":""D79CE030-3114-45E0-B52B-C77781BCB587""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.7"",""versionEndExcluding"":""6.12.26"",""matchCriteriaId"":""22F52099-F422-4D19-8283-45F9F9BF4392""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.13"",""versionEndExcluding"":""6.14.5"",""matchCriteriaId"":""6B25CA7E-4CD0-46DB-B4EF-13A3516071FB""}]}]}]",,,,,,,,
CVE-2025-37806,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:51.773,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: Keep write operations atomic syzbot reported a NULL pointer dereference in __generic_file_write_iter. [1] Before the write operation is completed, the user executes ioctl[2] to clear the compress flag of the file, which causes the is_compressed() judgment to return 0, further causing the program to enter the wrong process and call the wrong ops ntfs_aops_cmpr, which triggers the null pointer dereference of write_begin. Use inode lock to synchronize ioctl and write to avoid this case. [1] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000 Mem abort info: ESR = 0x0000000086000006 EC = 0x21: IABT (current EL), IL = 32 bits SET = 0, FnV = 0 EA = 0, S1PTW = 0 FSC = 0x06: level 2 translation fault user pgtable: 4k pages, 48-bit VAs, pgdp=000000011896d000 [0000000000000000] pgd=0800000118b44403, p4d=0800000118b44403, pud=0800000117517403, pmd=0000000000000000 Internal error: Oops: 0000000086000006 [#1] PREEMPT SMP Modules linked in: CPU: 0 UID: 0 PID: 6427 Comm: syz-executor347 Not tainted 6.13.0-rc3-syzkaller-g573067a5a685 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 pstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : 0x0 lr : generic_perform_write+0x29c/0x868 mm/filemap.c:4055 sp : ffff80009d4978a0 x29: ffff80009d4979c0 x28: dfff800000000000 x27: ffff80009d497bc8 x26: 0000000000000000 x25: ffff80009d497960 x24: ffff80008ba71c68 x23: 0000000000000000 x22: ffff0000c655dac0 x21: 0000000000001000 x20: 000000000000000c x19: 1ffff00013a92f2c x18: ffff0000e183aa1c x17: 0004060000000014 x16: ffff800083275834 x15: 0000000000000001 x14: 0000000000000000 x13: 0000000000000001 x12: ffff0000c655dac0 x11: 0000000000ff0100 x10: 0000000000ff0100 x9 : 0000000000000000 x8 : 0000000000000000 x7 : 0000000000000000 x6 : 0000000000000000 x5 : ffff80009d497980 x4 : ffff80009d497960 x3 : 0000000000001000 x2 : 0000000000000000 x1 : ffff0000e183a928 x0 : ffff0000d60b0fc0 Call trace: 0x0 (P) __generic_file_write_iter+0xfc/0x204 mm/filemap.c:4156 ntfs_file_write_iter+0x54c/0x630 fs/ntfs3/file.c:1267 new_sync_write fs/read_write.c:586 [inline] vfs_write+0x920/0xcf4 fs/read_write.c:679 ksys_write+0x15c/0x26c fs/read_write.c:731 __do_sys_write fs/read_write.c:742 [inline] __se_sys_write fs/read_write.c:739 [inline] __arm64_sys_write+0x7c/0x90 fs/read_write.c:739 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline] invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151 el0_svc+0x54/0x168 arch/arm64/kernel/entry-common.c:744 el0t_64_sync_handler+0x84/0x108 arch/arm64/kernel/entry-common.c:762 [2] ioctl$FS_IOC_SETFLAGS(r0, 0x40086602, &(0x7f00000000c0)=0x20)",,"[{""url"":""https://git.kernel.org/stable/c/285cec318bf5a7a6c8ba999b2b6ec96f9a20590f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/464139e18f619aa14fb921a61721862f43421c54"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8db49e89a7f8b48ee59fa9ad32b6ed0879747df8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37807,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:51.873,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf: Fix kmemleak warning for percpu hashmap Vlad Poenaru reported the following kmemleak issue: unreferenced object 0x606fd7c44ac8 (size 32): backtrace (crc 0): pcpu_alloc_noprof+0x730/0xeb0 bpf_map_alloc_percpu+0x69/0xc0 prealloc_init+0x9d/0x1b0 htab_map_alloc+0x363/0x510 map_create+0x215/0x3a0 __sys_bpf+0x16b/0x3e0 __x64_sys_bpf+0x18/0x20 do_syscall_64+0x7b/0x150 entry_SYSCALL_64_after_hwframe+0x4b/0x53 Further investigation shows the reason is due to not 8-byte aligned store of percpu pointer in htab_elem_set_ptr(): *(void __percpu **)(l->key + key_size) = pptr; Note that the whole htab_elem alignment is 8 (for x86_64). If the key_size is 4, that means pptr is stored in a location which is 4 byte aligned but not 8 byte aligned. In mm/kmemleak.c, scan_block() scans the memory based on 8 byte stride, so it won't detect above pptr, hence reporting the memory leak. In htab_map_alloc(), we already have htab->elem_size = sizeof(struct htab_elem) + round_up(htab->map.key_size, 8); if (percpu) htab->elem_size += sizeof(void *); else htab->elem_size += round_up(htab->map.value_size, 8); So storing pptr with 8-byte alignment won't cause any problem and can fix kmemleak too. The issue can be reproduced with bpf selftest as well: 1. Enable CONFIG_DEBUG_KMEMLEAK config 2. Add a getchar() before skel destroy in test_hash_map() in prog_tests/for_each.c. The purpose is to keep map available so kmemleak can be detected. 3. run './test_progs -t for_each/hash_map &' and a kmemleak should be reported.",,"[{""url"":""https://git.kernel.org/stable/c/11ba7ce076e5903e7bdc1fd1498979c331b3c286"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1f1c29aa1934177349c17e3c32e68ec38a7a56df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7758e308aeda1038aba1944f7302d34161b3effe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37808,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:51.973,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: crypto: null - Use spin lock instead of mutex As the null algorithm may be freed in softirq context through af_alg, use spin locks instead of mutexes to protect the default null algorithm.",,"[{""url"":""https://git.kernel.org/stable/c/0486de3c1b8223138dcc614846bd76364f758de6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1b66a5920b7fc7cc6251192a3fcad115b6d75dd5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1dd4a8561d85dea545cf93f56efc48df8176e218"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8cf2945512a8c0ef74ddd5b5a4f6b6a2fb1a4efb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dcc47a028c24e793ce6d6efebfef1a1e92f80297"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e27244cbe10658a66b8775be7f0acc4ad2f618d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e307c54ac8198bf09652c72603ba6e6d97798410"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f7a5a5c8e1ec16a4b2041398abe95de0e14572ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37809,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:52.087,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: typec: class: Fix NULL pointer access Concurrent calls to typec_partner_unlink_device can lead to a NULL pointer dereference. This patch adds a mutex to protect USB device pointers and prevent this issue. The same mutex protects both the device pointers and the partner device registration.",,"[{""url"":""https://git.kernel.org/stable/c/1fdde62411fe65640e69bc55ea027d5b7b2f0093"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de7c24febd21413ea8f49f61b36338b676c02852"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec27386de23a511008c53aa2f3434ad180a3ca9a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37810,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:52.197,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: dwc3: gadget: check that event count does not exceed event buffer length The event count is read from register DWC3_GEVNTCOUNT. There is a check for the count being zero, but not for exceeding the event buffer length. Check that event count does not exceed event buffer length, avoiding an out-of-bounds access when memcpy'ing the event. Crash log: Unable to handle kernel paging request at virtual address ffffffc0129be000 pc : __memcpy+0x114/0x180 lr : dwc3_check_event_buf+0xec/0x348 x3 : 0000000000000030 x2 : 000000000000dfc4 x1 : ffffffc0129be000 x0 : ffffff87aad60080 Call trace: __memcpy+0x114/0x180 dwc3_interrupt+0x24/0x34",,"[{""url"":""https://git.kernel.org/stable/c/015c39f38e69a491d2abd5e98869a500a9459b3b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/52a7c9d930b95aa8b1620edaba4818040c32631f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/63ccd26cd1f6600421795f6ca3e625076be06c9f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/99d655119b870ee60e4dbf310aa9a1ed8d9ede3d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a44547015287a19001384fe94dbff84c92ce4ee1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b43225948b231b3f331194010f84512bee4d9f59"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c0079630f268843a25ed75226169cba40e0d8880"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c4d80e41cb42008dceb35e5dbf52574d93beac0d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37811,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:52.310,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: chipidea: ci_hdrc_imx: fix usbmisc handling usbmisc is an optional device property so it is totally valid for the corresponding data->usbmisc_data to have a NULL value. Check that before dereferencing the pointer. Found by Linux Verification Center (linuxtesting.org) with Svace static analysis tool.",,"[{""url"":""https://git.kernel.org/stable/c/0ee460498ced49196149197c9f6d29a10e5e0798"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/121e9f80ea5478bca3a8f3f26593fd66f87da649"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2aa87bd825377f5073b76701780a902cd0fc725a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4e28f79e3dffa52d327b46d1a78dac16efb5810b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8060b719676e8c0e5a2222c2977ba0458d9d9535"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/887902ca73490f38c69fd6149ef361a041cf912f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37812,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:52.413,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: cdns3: Fix deadlock when using NCM gadget The cdns3 driver has the same NCM deadlock as fixed in cdnsp by commit 58f2fcb3a845 (""usb: cdnsp: Fix deadlock issue during using NCM gadget""). Under PREEMPT_RT the deadlock can be readily triggered by heavy network traffic, for example using ""iperf --bidir"" over NCM ethernet link. The deadlock occurs because the threaded interrupt handler gets preempted by a softirq, but both are protected by the same spinlock. Prevent deadlock by disabling softirq during threaded irq handler.",,"[{""url"":""https://git.kernel.org/stable/c/09e90a9689a4aac7a2f726dc2aa472b0b37937b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/48a62deb857f0694f611949015e70ad194d97159"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/59a760e4796a3cd88d8b9d7706e0a638de677751"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74cd6e408a4c010e404832f0e4609d29bf1d0c41"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a1059896f2bfdcebcdc7153c3be2307ea319501f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b96239582531775f2fdcb14de29bdb6870fd4c8c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c27db84ed44e50ff90d9e3a2a25fae2e0a0fa015"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eebfb64c624fc738b669100173344fb441c5e719"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37813,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:52.523,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: xhci: Fix invalid pointer dereference in Etron workaround This check is performed before prepare_transfer() and prepare_ring(), so enqueue can already point at the final link TRB of a segment. And indeed it will, some 0.4% of times this code is called. Then enqueue + 1 is an invalid pointer. It will crash the kernel right away or load some junk which may look like a link TRB and cause the real link TRB to be replaced with a NOOP. This wouldn't end well. Use a functionally equivalent test which doesn't dereference the pointer and always gives correct result. Something has crashed my machine twice in recent days while playing with an Etron HC, and a control transfer stress test ran for confirmation has just crashed it again. The same test passes with this patch applied.",,"[{""url"":""https://git.kernel.org/stable/c/0624e29c595b05e7a0e6d1c368f0a05799928e30"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/142273a49f2c315eabdbdf5a71c15e479b75ca91"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1ea050da5562af9b930d17cbbe9632d30f5df43a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bce3055b08e303e28a8751f6073066f5c33a0744"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37814,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:52.623,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tty: Require CAP_SYS_ADMIN for all usages of TIOCL_SELMOUSEREPORT This requirement was overeagerly loosened in commit 2f83e38a095f (""tty: Permit some TIOCL_SETSEL modes without CAP_SYS_ADMIN""), but as it turns out, (1) the logic I implemented there was inconsistent (apologies!), (2) TIOCL_SELMOUSEREPORT might actually be a small security risk after all, and (3) TIOCL_SELMOUSEREPORT is only meant to be used by the mouse daemon (GPM or Consolation), which runs as CAP_SYS_ADMIN already. In more detail: 1. The previous patch has inconsistent logic: In commit 2f83e38a095f (""tty: Permit some TIOCL_SETSEL modes without CAP_SYS_ADMIN""), we checked for sel_mode == TIOCL_SELMOUSEREPORT, but overlooked that the lower four bits of this ""mode"" parameter were actually used as an additional way to pass an argument. So the patch did actually still require CAP_SYS_ADMIN, if any of the mouse button bits are set, but did not require it if none of the mouse buttons bits are set. This logic is inconsistent and was not intentional. We should have the same policies for using TIOCL_SELMOUSEREPORT independent of the value of the ""hidden"" mouse button argument. I sent a separate documentation patch to the man page list with more details on TIOCL_SELMOUSEREPORT: https://lore.kernel.org/all/20250223091342.35523-2-gnoack3000@gmail.com/ 2. TIOCL_SELMOUSEREPORT is indeed a potential security risk which can let an attacker simulate ""keyboard"" input to command line applications on the same terminal, like TIOCSTI and some other TIOCLINUX ""selection mode"" IOCTLs. By enabling mouse reporting on a terminal and then injecting mouse reports through TIOCL_SELMOUSEREPORT, an attacker can simulate mouse movements on the same terminal, similar to the TIOCSTI keystroke injection attacks that were previously possible with TIOCSTI and other TIOCL_SETSEL selection modes. Many programs (including libreadline/bash) are then prone to misinterpret these mouse reports as normal keyboard input because they do not expect input in the X11 mouse protocol form. The attacker does not have complete control over the escape sequence, but they can at least control the values of two consecutive bytes in the binary mouse reporting escape sequence. I went into more detail on that in the discussion at https://lore.kernel.org/all/20250221.0a947528d8f3@gnoack.org/ It is not equally trivial to simulate arbitrary keystrokes as it was with TIOCSTI (commit 83efeeeb3d04 (""tty: Allow TIOCSTI to be disabled"")), but the general mechanism is there, and together with the small number of existing legit use cases (see below), it would be better to revert back to requiring CAP_SYS_ADMIN for TIOCL_SELMOUSEREPORT, as it was already the case before commit 2f83e38a095f (""tty: Permit some TIOCL_SETSEL modes without CAP_SYS_ADMIN""). 3. TIOCL_SELMOUSEREPORT is only used by the mouse daemons (GPM or Consolation), and they are the only legit use case: To quote console_codes(4): The mouse tracking facility is intended to return xterm(1)-compatible mouse status reports. Because the console driver has no way to know the device or type of the mouse, these reports are returned in the console input stream only when the virtual terminal driver receives a mouse update ioctl. These ioctls must be generated by a mouse-aware user-mode application such as the gpm(8) daemon. Jared Finder has also confirmed in https://lore.kernel.org/all/491f3df9de6593df8e70dbe77614b026@finder.org/ that Emacs does not call TIOCL_SELMOUSEREPORT directly, and it would be difficult to find good reasons for doing that, given that it would interfere with the reports that GPM is sending. More information on the interaction between GPM, terminals and th ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/6f021bc0083b96125fdbed6a60d7b4396c4d6dac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9b50c9c97db953de756a39af83d4be4d7f618aa6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee6a44da3c87cf64d67dd02be8c0127a5bf56175"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37815,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:52.730,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: misc: microchip: pci1xxxx: Fix Kernel panic during IRQ handler registration Resolve kernel panic while accessing IRQ handler associated with the generated IRQ. This is done by acquiring the spinlock and storing the current interrupt state before handling the interrupt request using generic_handle_irq. A previous fix patch was submitted where 'generic_handle_irq' was replaced with 'handle_nested_irq'. However, this change also causes the kernel panic where after determining which GPIO triggered the interrupt and attempting to call handle_nested_irq with the mapped IRQ number, leads to a failure in locating the registered handler.",,"[{""url"":""https://git.kernel.org/stable/c/1263d5f581908602c618c6665e683c4436383a09"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/12cc2193f2b9548e8ea5fbce8201b44158222edf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/18eb77c75ed01439f96ae5c0f33461eb5134b907"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4e02059dc91068bc5017b8546f9ec3b930f6d6a6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/62957f58ab3aa7fa792dc6ff3575624062539a4d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37816,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:52.837,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mei: vsc: Fix fortify-panic caused by invalid counted_by() use gcc 15 honors the __counted_by(len) attribute on vsc_tp_packet.buf[] and the vsc-tp.c code is using this in a wrong way. len does not contain the available size in the buffer, it contains the actual packet length *without* the crc. So as soon as vsc_tp_xfer() tries to add the crc to buf[] the fortify-panic handler gets triggered: [ 80.842193] memcpy: detected buffer overflow: 4 byte write of buffer size 0 [ 80.842243] WARNING: CPU: 4 PID: 272 at lib/string_helpers.c:1032 __fortify_report+0x45/0x50 ... [ 80.843175] __fortify_panic+0x9/0xb [ 80.843186] vsc_tp_xfer.cold+0x67/0x67 [mei_vsc_hw] [ 80.843210] ? seqcount_lockdep_reader_access.constprop.0+0x82/0x90 [ 80.843229] ? lockdep_hardirqs_on+0x7c/0x110 [ 80.843250] mei_vsc_hw_start+0x98/0x120 [mei_vsc] [ 80.843270] mei_reset+0x11d/0x420 [mei] The easiest fix would be to just drop the counted-by but with the exception of the ack buffer in vsc_tp_xfer_helper() which only contains enough room for the packet-header, all other uses of vsc_tp_packet always use a buffer of VSC_TP_MAX_XFER_SIZE bytes for the packet. Instead of just dropping the counted-by, split the vsc_tp_packet struct definition into a header and a full-packet definition and use a fixed size buf[] in the packet definition, this way fortify-source buffer overrun checking still works when enabled.",,"[{""url"":""https://git.kernel.org/stable/c/00f1cc14da0f06d2897b8c528df7c7dcf1b8da50"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3e243378f27cc7d11682a3ad720228b0723affa5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac04663c67f244810b3492e9ecd9f7cdbefeca2d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37817,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:52.933,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mcb: fix a double free bug in chameleon_parse_gdd() In chameleon_parse_gdd(), if mcb_device_register() fails, 'mdev' would be released in mcb_device_register() via put_device(). Thus, goto 'err' label and free 'mdev' again causes a double free. Just return if mcb_device_register() fails.",,"[{""url"":""https://git.kernel.org/stable/c/4ffe8c9fb561e4427dd1a3056cd5b3685b74f78d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/59f993cd36b6e28a394ba3d977e8ffe5c9884e3b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c7f1bfdb2249f854a736d9b79778c7e5a29a150"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/96838eb1836fd372e42be5db84f0b333b65146a6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bcc7d58ee5173e34306026bd01e1fbf75e169d37"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c5b8a549ef1fcc6066b037a3962c79d60465ba0b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d70184958b0ea8c0fd52e2b456654b503e769fc8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/df1a5d5c6134224f9298e5189230f9d29ae50cac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37818,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:53.040,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: LoongArch: Return NULL from huge_pte_offset() for invalid PMD LoongArch's huge_pte_offset() currently returns a pointer to a PMD slot even if the underlying entry points to invalid_pte_table (indicating no mapping). Callers like smaps_hugetlb_range() fetch this invalid entry value (the address of invalid_pte_table) via this pointer. The generic is_swap_pte() check then incorrectly identifies this address as a swap entry on LoongArch, because it satisfies the ""!pte_present() && !pte_none()"" conditions. This misinterpretation, combined with a coincidental match by is_migration_entry() on the address bits, leads to kernel crashes in pfn_swap_entry_to_page(). Fix this at the architecture level by modifying huge_pte_offset() to check the PMD entry's content using pmd_none() before returning. If the entry is invalid (i.e., it points to invalid_pte_table), return NULL instead of the pointer to the slot.",,"[{""url"":""https://git.kernel.org/stable/c/2ca9380b12711afe95b3589bd82b59623b3c96b3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/34256805720993e37adf6127371a1265aea8376a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/51424fd171cee6a33f01f7c66b8eb23ac42289d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b49f085cd671addbda4802d6b9382513f7dd0f30"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd51834d1cf65a2c801295d230c220aeebf87a73"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37819,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:53.140,2025-06-04T13:15:26.007,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: irqchip/gic-v2m: Prevent use after free of gicv2m_get_fwnode() With ACPI in place, gicv2m_get_fwnode() is registered with the pci subsystem as pci_msi_get_fwnode_cb(), which may get invoked at runtime during a PCI host bridge probe. But, the call back is wrongly marked as __init, causing it to be freed, while being registered with the PCI subsystem and could trigger: Unable to handle kernel paging request at virtual address ffff8000816c0400 gicv2m_get_fwnode+0x0/0x58 (P) pci_set_bus_msi_domain+0x74/0x88 pci_register_host_bridge+0x194/0x548 This is easily reproducible on a Juno board with ACPI boot. Retain the function for later use.",,"[{""url"":""https://git.kernel.org/stable/c/0c241dedc43a036599757cd08f356253fa3e5014"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2f2803e4b5e4df2b08d378deaab78b1681ef9b30"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3318dc299b072a0511d6dfd8367f3304fb6d9827"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3939d6f29d34cdb60e3f68b76e39e00a964a1d51"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/47bee0081b483b077c7560bc5358ad101f89c8ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b63de43af8d215b0499eac28b2caa4439183efc1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc0d654eb4179b06d3206e4396d072108b9ba082"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f95659affee301464f0d058d528d96b35b452da8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37820,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:53.237,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: xen-netfront: handle NULL returned by xdp_convert_buff_to_frame() The function xdp_convert_buff_to_frame() may return NULL if it fails to correctly convert the XDP buffer into an XDP frame due to memory constraints, internal errors, or invalid data. Failing to check for NULL may lead to a NULL pointer dereference if the result is used later in processing, potentially causing crashes, data corruption, or undefined behavior. On XDP redirect failure, the associated page must be released explicitly if it was previously retained via get_page(). Failing to do so may result in a memory leak, as the pages reference count is not decremented.",,"[{""url"":""https://git.kernel.org/stable/c/5b83d30c63f9964acb1bc63eb8e670b9e0d2c240"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc3628dcd851ddd8d418bf0c897024b4621ddc92"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cefd8a2e2de46209ce66e6d30c237eb59b6c5bfa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d6a9c4e6f9b3ec3ad98468c950ad214af8a2efb9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eefccd889df3b49d92e7349d94c4aa7e1ba19f6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37821,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:53.333,2025-05-18T07:15:17.197,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: sched/eevdf: Fix se->slice being set to U64_MAX and resulting crash There is a code path in dequeue_entities() that can set the slice of a sched_entity to U64_MAX, which sometimes results in a crash. The offending case is when dequeue_entities() is called to dequeue a delayed group entity, and then the entity's parent's dequeue is delayed. In that case: 1. In the if (entity_is_task(se)) else block at the beginning of dequeue_entities(), slice is set to cfs_rq_min_slice(group_cfs_rq(se)). If the entity was delayed, then it has no queued tasks, so cfs_rq_min_slice() returns U64_MAX. 2. The first for_each_sched_entity() loop dequeues the entity. 3. If the entity was its parent's only child, then the next iteration tries to dequeue the parent. 4. If the parent's dequeue needs to be delayed, then it breaks from the first for_each_sched_entity() loop _without updating slice_. 5. The second for_each_sched_entity() loop sets the parent's ->slice to the saved slice, which is still U64_MAX. This throws off subsequent calculations with potentially catastrophic results. A manifestation we saw in production was: 6. In update_entity_lag(), se->slice is used to calculate limit, which ends up as a huge negative number. 7. limit is used in se->vlag = clamp(vlag, -limit, limit). Because limit is negative, vlag > limit, so se->vlag is set to the same huge negative number. 8. In place_entity(), se->vlag is scaled, which overflows and results in another huge (positive or negative) number. 9. The adjusted lag is subtracted from se->vruntime, which increases or decreases se->vruntime by a huge number. 10. pick_eevdf() calls entity_eligible()/vruntime_eligible(), which incorrectly returns false because the vruntime is so far from the other vruntimes on the queue, causing the (vruntime - cfs_rq->min_vruntime) * load calulation to overflow. 11. Nothing appears to be eligible, so pick_eevdf() returns NULL. 12. pick_next_entity() tries to dereference the return value of pick_eevdf() and crashes. Dumping the cfs_rq states from the core dumps with drgn showed tell-tale huge vruntime ranges and bogus vlag values, and I also traced se->slice being set to U64_MAX on live systems (which was usually ""benign"" since the rest of the runqueue needed to be in a particular state to crash). Fix it in dequeue_entities() by always setting slice from the first non-empty cfs_rq.",,"[{""url"":""https://git.kernel.org/stable/c/50a665496881262519f115f1bfe5822f30580eb0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/86b37810fa1e40b93171da023070b99ccbb4ea04"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bbce3de72be56e4b5f68924b7da9630cc89aa1a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37822,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:53.427,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: riscv: uprobes: Add missing fence.i after building the XOL buffer The XOL (execute out-of-line) buffer is used to single-step the replaced instruction(s) for uprobes. The RISC-V port was missing a proper fence.i (i$ flushing) after constructing the XOL buffer, which can result in incorrect execution of stale/broken instructions. This was found running the BPF selftests ""test_progs: uprobe_autoattach, attach_probe"" on the Spacemit K1/X60, where the uprobes tests randomly blew up.",,"[{""url"":""https://git.kernel.org/stable/c/1dbb95a36499374c51b47ee8ae258a8862c20978"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d1d19a11cfbfd8bae1d89cc010b2cc397cd0c48"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bcf6d3158c5902d92b6d62335af4422b7bf7c4e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37823,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:53.520,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net_sched: hfsc: Fix a potential UAF in hfsc_dequeue() too Similarly to the previous patch, we need to safe guard hfsc_dequeue() too. But for this one, we don't have a reliable reproducer.",,"[{""url"":""https://git.kernel.org/stable/c/11bccb054c1462fb069219f8e98e97a5a730758e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2f46d14919c39528c6e540ebc43f90055993eedc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/68f256305ceb426d545a0dc31f83c2ab1d211a1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6ccbda44e2cc3d26fd22af54c650d6d5d801addf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/76c4c22c2437d3d3880efc0f62eca06ef078d290"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c6936266f8bf98a53f28ef9a820e6a501e946d09"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c6f035044104c6ff656f4565cd22938dc892528c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da7936518996d290e2fcfcaf6cd7e15bfd87804a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37824,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:53.627,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tipc: fix NULL pointer dereference in tipc_mon_reinit_self() syzbot reported: tipc: Node number set to 1055423674 Oops: general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] SMP KASAN NOPTI KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007] CPU: 3 UID: 0 PID: 6017 Comm: kworker/3:5 Not tainted 6.15.0-rc1-syzkaller-00246-g900241a5cc15 #0 PREEMPT(full) Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 Workqueue: events tipc_net_finalize_work RIP: 0010:tipc_mon_reinit_self+0x11c/0x210 net/tipc/monitor.c:719 ... RSP: 0018:ffffc9000356fb68 EFLAGS: 00010246 RAX: 0000000000000000 RBX: 0000000000000000 RCX: 000000003ee87cba RDX: 0000000000000000 RSI: ffffffff8dbc56a7 RDI: ffff88804c2cc010 RBP: dffffc0000000000 R08: 0000000000000001 R09: 0000000000000000 R10: 0000000000000001 R11: 0000000000000000 R12: 0000000000000007 R13: fffffbfff2111097 R14: ffff88804ead8000 R15: ffff88804ead9010 FS: 0000000000000000(0000) GS:ffff888097ab9000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00000000f720eb00 CR3: 000000000e182000 CR4: 0000000000352ef0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> tipc_net_finalize+0x10b/0x180 net/tipc/net.c:140 process_one_work+0x9cc/0x1b70 kernel/workqueue.c:3238 process_scheduled_works kernel/workqueue.c:3319 [inline] worker_thread+0x6c8/0xf10 kernel/workqueue.c:3400 kthread+0x3c2/0x780 kernel/kthread.c:464 ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:153 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:245 </TASK> ... RIP: 0010:tipc_mon_reinit_self+0x11c/0x210 net/tipc/monitor.c:719 ... RSP: 0018:ffffc9000356fb68 EFLAGS: 00010246 RAX: 0000000000000000 RBX: 0000000000000000 RCX: 000000003ee87cba RDX: 0000000000000000 RSI: ffffffff8dbc56a7 RDI: ffff88804c2cc010 RBP: dffffc0000000000 R08: 0000000000000001 R09: 0000000000000000 R10: 0000000000000001 R11: 0000000000000000 R12: 0000000000000007 R13: fffffbfff2111097 R14: ffff88804ead8000 R15: ffff88804ead9010 FS: 0000000000000000(0000) GS:ffff888097ab9000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00000000f720eb00 CR3: 000000000e182000 CR4: 0000000000352ef0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 There is a racing condition between workqueue created when enabling bearer and another thread created when disabling bearer right after that as follow: enabling_bearer | disabling_bearer --------------- | ---------------- tipc_disc_timeout() | { | bearer_disable() ... | { schedule_work(&tn->work); | tipc_mon_delete() ... | { } | ... | write_lock_bh(&mon->lock); | mon->self = NULL; | write_unlock_bh(&mon->lock); | ... | } tipc_net_finalize_work() | } { | ... | tipc_net_finalize() | { | ... | tipc_mon_reinit_self() | { | ... | write_lock_bh(&mon->lock); | mon->self->addr = tipc_own_addr(net); | write_unlock_bh(&mon->lock); | ... ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/0ceef62a328ce1288598c9242576292671f21e96"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4d5e1e2d3e9d70beff7beab44fd6ce91405a405e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5fd464fd24de93d0eca377554bf0ff2548f76f30"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a3df56010403b2cd26388096ebccf959d23c4dcc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d63527e109e811ef11abb1c2985048fdb528b4cb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dd6cb0a8575b00fbd503e96903184125176f4fa3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e6613b6d41f4010c4d484cbc7bfca690d8d522a2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e79e8e05aa46f90d21023f0ffe6f136ed6a20932"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37825,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:53.747,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nvmet: fix out-of-bounds access in nvmet_enable_port When trying to enable a port that has no transport configured yet, nvmet_enable_port() uses NVMF_TRTYPE_MAX (255) to query the transports array, causing an out-of-bounds access: [ 106.058694] BUG: KASAN: global-out-of-bounds in nvmet_enable_port+0x42/0x1da [ 106.058719] Read of size 8 at addr ffffffff89dafa58 by task ln/632 [...] [ 106.076026] nvmet: transport type 255 not supported Since commit 200adac75888, NVMF_TRTYPE_MAX is the default state as configured by nvmet_ports_make(). Avoid this by checking for NVMF_TRTYPE_MAX before proceeding.",,"[{""url"":""https://git.kernel.org/stable/c/3d7aa0c7b4e96cd460826d932e44710cdeb3378b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/83c00860a37b3fcba8026cb344101f1b8af547cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37826,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:53.840,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: ufs: core: Add NULL check in ufshcd_mcq_compl_pending_transfer() Add a NULL check for the returned hwq pointer by ufshcd_mcq_req_to_hwq(). This is similar to the fix in commit 74736103fb41 (""scsi: ufs: core: Fix ufshcd_abort_one racing issue"").",,"[{""url"":""https://git.kernel.org/stable/c/08a966a917fe3d92150fa3cc15793ad5e57051eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/700128d67d57bb1de4251e563ab85202def36c50"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eeab6618037be84e438e9d6ed5d9a53502faf81f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37827,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:53.933,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: zoned: return EIO on RAID1 block group write pointer mismatch There was a bug report about a NULL pointer dereference in __btrfs_add_free_space_zoned() that ultimately happens because a conversion from the default metadata profile DUP to a RAID1 profile on two disks. The stack trace has the following signature: BTRFS error (device sdc): zoned: write pointer offset mismatch of zones in raid1 profile BUG: kernel NULL pointer dereference, address: 0000000000000058 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 0 P4D 0 Oops: Oops: 0000 [#1] PREEMPT SMP NOPTI RIP: 0010:__btrfs_add_free_space_zoned.isra.0+0x61/0x1a0 RSP: 0018:ffffa236b6f3f6d0 EFLAGS: 00010246 RAX: 0000000000000000 RBX: ffff96c8132f3400 RCX: 0000000000000001 RDX: 0000000010000000 RSI: 0000000000000000 RDI: ffff96c8132f3410 RBP: 0000000010000000 R08: 0000000000000003 R09: 0000000000000000 R10: 0000000000000000 R11: 00000000ffffffff R12: 0000000000000000 R13: ffff96c758f65a40 R14: 0000000000000001 R15: 000011aac0000000 FS: 00007fdab1cb2900(0000) GS:ffff96e60ca00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000058 CR3: 00000001a05ae000 CR4: 0000000000350ef0 Call Trace: <TASK> ? __die_body.cold+0x19/0x27 ? page_fault_oops+0x15c/0x2f0 ? exc_page_fault+0x7e/0x180 ? asm_exc_page_fault+0x26/0x30 ? __btrfs_add_free_space_zoned.isra.0+0x61/0x1a0 btrfs_add_free_space_async_trimmed+0x34/0x40 btrfs_add_new_free_space+0x107/0x120 btrfs_make_block_group+0x104/0x2b0 btrfs_create_chunk+0x977/0xf20 btrfs_chunk_alloc+0x174/0x510 ? srso_return_thunk+0x5/0x5f btrfs_inc_block_group_ro+0x1b1/0x230 btrfs_relocate_block_group+0x9e/0x410 btrfs_relocate_chunk+0x3f/0x130 btrfs_balance+0x8ac/0x12b0 ? srso_return_thunk+0x5/0x5f ? srso_return_thunk+0x5/0x5f ? __kmalloc_cache_noprof+0x14c/0x3e0 btrfs_ioctl+0x2686/0x2a80 ? srso_return_thunk+0x5/0x5f ? ioctl_has_perm.constprop.0.isra.0+0xd2/0x120 __x64_sys_ioctl+0x97/0xc0 do_syscall_64+0x82/0x160 ? srso_return_thunk+0x5/0x5f ? __memcg_slab_free_hook+0x11a/0x170 ? srso_return_thunk+0x5/0x5f ? kmem_cache_free+0x3f0/0x450 ? srso_return_thunk+0x5/0x5f ? srso_return_thunk+0x5/0x5f ? syscall_exit_to_user_mode+0x10/0x210 ? srso_return_thunk+0x5/0x5f ? do_syscall_64+0x8e/0x160 ? sysfs_emit+0xaf/0xc0 ? srso_return_thunk+0x5/0x5f ? srso_return_thunk+0x5/0x5f ? seq_read_iter+0x207/0x460 ? srso_return_thunk+0x5/0x5f ? vfs_read+0x29c/0x370 ? srso_return_thunk+0x5/0x5f ? srso_return_thunk+0x5/0x5f ? syscall_exit_to_user_mode+0x10/0x210 ? srso_return_thunk+0x5/0x5f ? do_syscall_64+0x8e/0x160 ? srso_return_thunk+0x5/0x5f ? exc_page_fault+0x7e/0x180 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7fdab1e0ca6d RSP: 002b:00007ffeb2b60c80 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007fdab1e0ca6d RDX: 00007ffeb2b60d80 RSI: 00000000c4009420 RDI: 0000000000000003 RBP: 00007ffeb2b60cd0 R08: 0000000000000000 R09: 0000000000000013 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 00007ffeb2b6343b R14: 00007ffeb2b60d80 R15: 0000000000000001 </TASK> CR2: 0000000000000058 ---[ end trace 0000000000000000 ]--- The 1st line is the most interesting here: BTRFS error (device sdc): zoned: write pointer offset mismatch of zones in raid1 profile When a RAID1 block-group is created and a write pointer mismatch between the disks in the RAID set is detected, btrfs sets the alloc_offset to the length of the block group marking it as full. Afterwards the code expects that a balance operation will evacuate the data in this block-group and repair the problems. But before this is possible, the new space of this block-group will be accounted in the free space cache. But in __btrfs_ ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/9a447f748f6c7287dad68fa91913cd382fa0fcc8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b0c26f47992672661340dd6ea931240213016609"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f4717a02cc422cf4bb2dbb280b154a1ae65c5f84"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37828,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:54.033,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: ufs: mcq: Add NULL check in ufshcd_mcq_abort() A race can occur between the MCQ completion path and the abort handler: once a request completes, __blk_mq_free_request() sets rq->mq_hctx to NULL, meaning the subsequent ufshcd_mcq_req_to_hwq() call in ufshcd_mcq_abort() can return a NULL pointer. If this NULL pointer is dereferenced, the kernel will crash. Add a NULL check for the returned hwq pointer. If hwq is NULL, log an error and return FAILED, preventing a potential NULL-pointer dereference. As suggested by Bart, the ufshcd_cmd_inflight() check is removed. This is similar to the fix in commit 74736103fb41 (""scsi: ufs: core: Fix ufshcd_abort_one racing issue""). This is found by our static analysis tool KNighter.",,"[{""url"":""https://git.kernel.org/stable/c/47eec518aef3814f64a5da43df81bdd74d8c0041"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c324085062919d4e21c69e5e78456dcec0052fe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d002f591486f5ef4bc02eb02025a53f931f0eb5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d6979fabe812a168d5053e5a41d5a2e9b8afd7bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37829,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:54.130,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: cpufreq: scpi: Fix null-ptr-deref in scpi_cpufreq_get_rate() cpufreq_cpu_get_raw() can return NULL when the target CPU is not present in the policy->cpus mask. scpi_cpufreq_get_rate() does not check for this case, which results in a NULL pointer dereference.",,"[{""url"":""https://git.kernel.org/stable/c/124bddf123311cd1f18bffd63a5d974468d59c67"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/19e0eaa62e8831f2bc0285fef3bf8faaa7f3e09b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/28fbd7b13b4d3074b16db913aedc9d8d37ab41e7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73b24dc731731edf762f9454552cb3a5b7224949"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8fbaa76690f67a7cbad315f89d607b46e3e06ede"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad4796f2da495b2cbbd0fccccbcbf63f2aeee613"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da8ee91e532486055ecf88478d38c2f3dc234182"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fdf035d9c5436536ffcfea0ac6adeb5dda3c3a23"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37830,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:54.240,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: cpufreq: scmi: Fix null-ptr-deref in scmi_cpufreq_get_rate() cpufreq_cpu_get_raw() can return NULL when the target CPU is not present in the policy->cpus mask. scmi_cpufreq_get_rate() does not check for this case, which results in a NULL pointer dereference. Add NULL check after cpufreq_cpu_get_raw() to prevent this issue.",,"[{""url"":""https://git.kernel.org/stable/c/484d3f15cc6cbaa52541d6259778e715b2c83c54"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4e3d1c1925d8e752992cd893d03d974e6807ac16"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ccfadfb2562337b4f0462a86a9746a6eea89718"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cfaca93b8fe317b7faa9af732e0ba8c9081fa018"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ea834c90aa7cc80a1b456f7a91432734d5087d16"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f9c5423855e3687262d881aeee5cfb3bc8577bff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37831,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:54.340,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: cpufreq: apple-soc: Fix null-ptr-deref in apple_soc_cpufreq_get_rate() cpufreq_cpu_get_raw() can return NULL when the target CPU is not present in the policy->cpus mask. apple_soc_cpufreq_get_rate() does not check for this case, which results in a NULL pointer dereference.",,"[{""url"":""https://git.kernel.org/stable/c/01e86ea22610d98ae6141e428019a6916e79f725"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1053dcf8a504d4933bb3f73df22bc363298d194b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9992649f6786921873a9b89dafa5e04d8c5fef2b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fbdba5f37413dbc09d82ad7235e5b7a2fb8e0f75"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37832,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:54.437,2025-06-04T08:15:21.743,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,[],,,,,,,,,,
CVE-2025-37833,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:54.533,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/niu: Niu requires MSIX ENTRY_DATA fields touch before entry reads Fix niu_try_msix() to not cause a fatal trap on sparc systems. Set PCI_DEV_FLAGS_MSIX_TOUCH_ENTRY_DATA_FIRST on the struct pci_dev to work around a bug in the hardware or firmware. For each vector entry in the msix table, niu chips will cause a fatal trap if any registers in that entry are read before that entries' ENTRY_DATA register is written to. Testing indicates writes to other registers are not sufficient to prevent the fatal trap, however the value does not appear to matter. This only needs to happen once after power up, so simply rebooting into a kernel lacking this fix will NOT cause the trap. NON-RESUMABLE ERROR: Reporting on cpu 64 NON-RESUMABLE ERROR: TPC [0x00000000005f6900] <msix_prepare_msi_desc+0x90/0xa0> NON-RESUMABLE ERROR: RAW [4010000000000016:00000e37f93e32ff:0000000202000080:ffffffffffffffff NON-RESUMABLE ERROR: 0000000800000000:0000000000000000:0000000000000000:0000000000000000] NON-RESUMABLE ERROR: handle [0x4010000000000016] stick [0x00000e37f93e32ff] NON-RESUMABLE ERROR: type [precise nonresumable] NON-RESUMABLE ERROR: attrs [0x02000080] < ASI sp-faulted priv > NON-RESUMABLE ERROR: raddr [0xffffffffffffffff] NON-RESUMABLE ERROR: insn effective address [0x000000c50020000c] NON-RESUMABLE ERROR: size [0x8] NON-RESUMABLE ERROR: asi [0x00] CPU: 64 UID: 0 PID: 745 Comm: kworker/64:1 Not tainted 6.11.5 #63 Workqueue: events work_for_cpu_fn TSTATE: 0000000011001602 TPC: 00000000005f6900 TNPC: 00000000005f6904 Y: 00000000 Not tainted TPC: <msix_prepare_msi_desc+0x90/0xa0> g0: 00000000000002e9 g1: 000000000000000c g2: 000000c50020000c g3: 0000000000000100 g4: ffff8000470307c0 g5: ffff800fec5be000 g6: ffff800047a08000 g7: 0000000000000000 o0: ffff800014feb000 o1: ffff800047a0b620 o2: 0000000000000011 o3: ffff800047a0b620 o4: 0000000000000080 o5: 0000000000000011 sp: ffff800047a0ad51 ret_pc: 00000000005f7128 RPC: <__pci_enable_msix_range+0x3cc/0x460> l0: 000000000000000d l1: 000000000000c01f l2: ffff800014feb0a8 l3: 0000000000000020 l4: 000000000000c000 l5: 0000000000000001 l6: 0000000020000000 l7: ffff800047a0b734 i0: ffff800014feb000 i1: ffff800047a0b730 i2: 0000000000000001 i3: 000000000000000d i4: 0000000000000000 i5: 0000000000000000 i6: ffff800047a0ae81 i7: 00000000101888b0 I7: <niu_try_msix.constprop.0+0xc0/0x130 [niu]> Call Trace: [<00000000101888b0>] niu_try_msix.constprop.0+0xc0/0x130 [niu] [<000000001018f840>] niu_get_invariants+0x183c/0x207c [niu] [<00000000101902fc>] niu_pci_init_one+0x27c/0x2fc [niu] [<00000000005ef3e4>] local_pci_probe+0x28/0x74 [<0000000000469240>] work_for_cpu_fn+0x8/0x1c [<000000000046b008>] process_scheduled_works+0x144/0x210 [<000000000046b518>] worker_thread+0x13c/0x1c0 [<00000000004710e0>] kthread+0xb8/0xc8 [<00000000004060c8>] ret_from_fork+0x1c/0x2c [<0000000000000000>] 0x0 Kernel panic - not syncing: Non-resumable error.",,"[{""url"":""https://git.kernel.org/stable/c/64903e4849a71cf7f7c7e5d45225ccefc1280929"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c187aaa9e79b4b6d86ac7ba941e579ad33df5538"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fbb429ddff5c8e479edcc7dde5a542c9295944e6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37834,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-08T07:15:54.627,2025-05-08T14:39:09.683,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm/vmscan: don't try to reclaim hwpoison folio Syzkaller reports a bug as follows: Injecting memory failure for pfn 0x18b00e at process virtual address 0x20ffd000 Memory failure: 0x18b00e: dirty swapcache page still referenced by 2 users Memory failure: 0x18b00e: recovery action for dirty swapcache page: Failed page: refcount:2 mapcount:0 mapping:0000000000000000 index:0x20ffd pfn:0x18b00e memcg:ffff0000dd6d9000 anon flags: 0x5ffffe00482011(locked|dirty|arch_1|swapbacked|hwpoison|node=0|zone=2|lastcpupid=0xfffff) raw: 005ffffe00482011 dead000000000100 dead000000000122 ffff0000e232a7c9 raw: 0000000000020ffd 0000000000000000 00000002ffffffff ffff0000dd6d9000 page dumped because: VM_BUG_ON_FOLIO(!folio_test_uptodate(folio)) ------------[ cut here ]------------ kernel BUG at mm/swap_state.c:184! Internal error: Oops - BUG: 00000000f2000800 [#1] SMP Modules linked in: CPU: 0 PID: 60 Comm: kswapd0 Not tainted 6.6.0-gcb097e7de84e #3 Hardware name: linux,dummy-virt (DT) pstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : add_to_swap+0xbc/0x158 lr : add_to_swap+0xbc/0x158 sp : ffff800087f37340 x29: ffff800087f37340 x28: fffffc00052c0380 x27: ffff800087f37780 x26: ffff800087f37490 x25: ffff800087f37c78 x24: ffff800087f377a0 x23: ffff800087f37c50 x22: 0000000000000000 x21: fffffc00052c03b4 x20: 0000000000000000 x19: fffffc00052c0380 x18: 0000000000000000 x17: 296f696c6f662865 x16: 7461646f7470755f x15: 747365745f6f696c x14: 6f6621284f494c4f x13: 0000000000000001 x12: ffff600036d8b97b x11: 1fffe00036d8b97a x10: ffff600036d8b97a x9 : dfff800000000000 x8 : 00009fffc9274686 x7 : ffff0001b6c5cbd3 x6 : 0000000000000001 x5 : ffff0000c25896c0 x4 : 0000000000000000 x3 : 0000000000000000 x2 : 0000000000000000 x1 : ffff0000c25896c0 x0 : 0000000000000000 Call trace: add_to_swap+0xbc/0x158 shrink_folio_list+0x12ac/0x2648 shrink_inactive_list+0x318/0x948 shrink_lruvec+0x450/0x720 shrink_node_memcgs+0x280/0x4a8 shrink_node+0x128/0x978 balance_pgdat+0x4f0/0xb20 kswapd+0x228/0x438 kthread+0x214/0x230 ret_from_fork+0x10/0x20 I can reproduce this issue with the following steps: 1) When a dirty swapcache page is isolated by reclaim process and the page isn't locked, inject memory failure for the page. me_swapcache_dirty() clears uptodate flag and tries to delete from lru, but fails. Reclaim process will put the hwpoisoned page back to lru. 2) The process that maps the hwpoisoned page exits, the page is deleted the page will never be freed and will be in the lru forever. 3) If we trigger a reclaim again and tries to reclaim the page, add_to_swap() will trigger VM_BUG_ON_FOLIO due to the uptodate flag is cleared. To fix it, skip the hwpoisoned page in shrink_folio_list(). Besides, the hwpoison folio may not be unmapped by hwpoison_user_mappings() yet, unmap it in shrink_folio_list(), otherwise the folio will fail to be unmaped by hwpoison_user_mappings() since the folio isn't in lru list.",,"[{""url"":""https://git.kernel.org/stable/c/1b0449544c6482179ac84530b61fc192a6527bfd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1c9798bf8145a92abf45aa9d38a6406d9eb8bdf0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/912e9f0300c3564b72a8808db406e313193a37ad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37835,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:04.187,2025-05-10T14:15:32.750,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,[],,,,,,,,,,
CVE-2025-37836,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:04.320,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: PCI: Fix reference leak in pci_register_host_bridge() If device_register() fails, call put_device() to give up the reference to avoid a memory leak, per the comment at device_register(). Found by code review. [bhelgaas: squash Dan Carpenter's double free fix from https://lore.kernel.org/r/db806a6c-a91b-4e5a-a84b-6b7e01bdac85@stanley.mountain]",,"[{""url"":""https://git.kernel.org/stable/c/3297497ad2246eb9243849bfbbc57a0dea97d76e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/804443c1f27883926de94c849d91f5b7d7d696e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9707d0c932f41006a2701afc926b232b50e356b4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b783478e0c53ffb4f04f25fb4e21ef7f482b05df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bbba4c50a2d2a1d3f3bf31cc4b8280cb492bf2c7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd2a352a0d72575f1842d28c14c10089f0cfe1ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f4db1b2c9ae3d013733c302ee70cac943b7070c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f9208aec86226524ec1cb68a09ac70e974ea6536"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37837,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:04.467,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iommu/tegra241-cmdqv: Fix warnings due to dmam_free_coherent() Two WARNINGs are observed when SMMU driver rolls back upon failure: arm-smmu-v3.9.auto: Failed to register iommu arm-smmu-v3.9.auto: probe with driver arm-smmu-v3 failed with error -22 ------------[ cut here ]------------ WARNING: CPU: 5 PID: 1 at kernel/dma/mapping.c:74 dmam_free_coherent+0xc0/0xd8 Call trace: dmam_free_coherent+0xc0/0xd8 (P) tegra241_vintf_free_lvcmdq+0x74/0x188 tegra241_cmdqv_remove_vintf+0x60/0x148 tegra241_cmdqv_remove+0x48/0xc8 arm_smmu_impl_remove+0x28/0x60 devm_action_release+0x1c/0x40 ------------[ cut here ]------------ 128 pages are still in use! WARNING: CPU: 16 PID: 1 at mm/page_alloc.c:6902 free_contig_range+0x18c/0x1c8 Call trace: free_contig_range+0x18c/0x1c8 (P) cma_release+0x154/0x2f0 dma_free_contiguous+0x38/0xa0 dma_direct_free+0x10c/0x248 dma_free_attrs+0x100/0x290 dmam_free_coherent+0x78/0xd8 tegra241_vintf_free_lvcmdq+0x74/0x160 tegra241_cmdqv_remove+0x98/0x198 arm_smmu_impl_remove+0x28/0x60 devm_action_release+0x1c/0x40 This is because the LVCMDQ queue memory are managed by devres, while that dmam_free_coherent() is called in the context of devm_action_release(). Jason pointed out that ""arm_smmu_impl_probe() has mis-ordered the devres callbacks if ops->device_remove() is going to be manually freeing things that probe allocated"": https://lore.kernel.org/linux-iommu/20250407174408.GB1722458@nvidia.com/ In fact, tegra241_cmdqv_init_structures() only allocates memory resources which means any failure that it generates would be similar to -ENOMEM, so there is no point in having that ""falling back to standard SMMU"" routine, as the standard SMMU would likely fail to allocate memory too. Remove the unwind part in tegra241_cmdqv_init_structures(), and return a proper error code to ask SMMU driver to call tegra241_cmdqv_remove() via impl_ops->device_remove(). Then, drop tegra241_vintf_free_lvcmdq() since devres will take care of that.",,"[{""url"":""https://git.kernel.org/stable/c/5584dbf393df509159813645a487b1ef76557722"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/767e22001dfce64cc03b7def1562338591ab6031"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e38ed6908080047d8fa1763d1da86b584f9eb55b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e5dd974d6e00704553308ef1a88659f8dcfb39d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37838,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-04-18T15:15:59.090,2025-05-02T07:16:04.937,Modified,[],"In the Linux kernel, the following vulnerability has been resolved: HSI: ssi_protocol: Fix use after free vulnerability in ssi_protocol Driver Due to Race Condition In the ssi_protocol_probe() function, &ssi->work is bound with ssip_xmit_work(), In ssip_pn_setup(), the ssip_pn_xmit() function within the ssip_pn_ops structure is capable of starting the work. If we remove the module which will call ssi_protocol_remove() to make a cleanup, it will free ssi through kfree(ssi), while the work mentioned above will be used. The sequence of operations that may lead to a UAF bug is as follows: CPU0 CPU1 | ssip_xmit_work ssi_protocol_remove | kfree(ssi); | | struct hsi_client *cl = ssi->cl; | // use ssi Fix it by ensuring that the work is canceled before proceeding with the cleanup in ssi_protocol_remove().","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-416""}]}]","[{""url"":""https://git.kernel.org/stable/c/4a8c29beb8a02b5a0a9d77d608aa14b6f88a6b86"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4b4194c9a7a8f92db39e8e86c85f4fb12ebbec4f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/58eb29dba712ab0f13af59ca2fe545f5ce360e78"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/72972552d0d0bfeb2dec5daf343a19018db36ffa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/834e602d0cc7c743bfce734fad4a46cefc0f9ab1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/ae5a6a0b425e8f76a9f0677e50796e494e89b088"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/d03abc1c2b21324550fa71e12d53e7d3498e0af6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d58493832e284f066e559b8da5ab20c15a2801d3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/e3f88665a78045fe35c7669d2926b8d97b892c11"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":7.8,""baseSeverity"":""HIGH"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":5.9}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""6.1.135"",""matchCriteriaId"":""29C64220-D258-41B3-A931-B8C3456115E5""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.2"",""versionEndExcluding"":""6.6.88"",""matchCriteriaId"":""6E5947E5-45E3-462A-829B-382B3B1C61BD""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.7"",""versionEndExcluding"":""6.12.24"",""matchCriteriaId"":""1D35A8A8-F3EC-45E6-AD37-1F154B27529D""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.13"",""versionEndExcluding"":""6.13.12"",""matchCriteriaId"":""4A475784-BF3B-4514-81EE-49C8522FB24A""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.14"",""versionEndExcluding"":""6.14.3"",""matchCriteriaId"":""483E2E15-2135-4EC6-AB64-16282C5EF704""}]}]}]",,,,,,,,
CVE-2025-37839,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:04.593,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: jbd2: remove wrong sb->s_sequence check Journal emptiness is not determined by sb->s_sequence == 0 but rather by sb->s_start == 0 (which is set a few lines above). Furthermore 0 is a valid transaction ID so the check can spuriously trigger. Remove the invalid WARN_ON.",,"[{""url"":""https://git.kernel.org/stable/c/3b4643ffaf72d7a5a357e9bf68b1775f8cfe7e77"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9eaec071f111cd2124ce9a5b93536d3f6837d457"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad926f735b4d4f10768fec7d080cadeb6d075cac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b0cca357f85beb6144ab60c62dcc98508cc044bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b479839525fe7906966cdc4b5b2afbca048558a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c88f7328bb0fff66520fc9164f02b1d06e083c1b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c98eb9ffb1d9c98237b5e1668eee17654e129fb0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cf30432f5b3064ff85d85639c2f0106f89c566f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e6eff39dd0fe4190c6146069cc16d160e71d1148"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37840,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:04.710,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mtd: rawnand: brcmnand: fix PM resume warning Fixed warning on PM resume as shown below caused due to uninitialized struct nand_operation that checks chip select field : WARN_ON(op->cs >= nanddev_ntargets(&chip->base) [ 14.588522] ------------[ cut here ]------------ [ 14.588529] WARNING: CPU: 0 PID: 1392 at drivers/mtd/nand/raw/internals.h:139 nand_reset_op+0x1e0/0x1f8 [ 14.588553] Modules linked in: bdc udc_core [ 14.588579] CPU: 0 UID: 0 PID: 1392 Comm: rtcwake Tainted: G W 6.14.0-rc4-g5394eea10651 #16 [ 14.588590] Tainted: [W]=WARN [ 14.588593] Hardware name: Broadcom STB (Flattened Device Tree) [ 14.588598] Call trace: [ 14.588604] dump_backtrace from show_stack+0x18/0x1c [ 14.588622] r7:00000009 r6:0000008b r5:60000153 r4:c0fa558c [ 14.588625] show_stack from dump_stack_lvl+0x70/0x7c [ 14.588639] dump_stack_lvl from dump_stack+0x18/0x1c [ 14.588653] r5:c08d40b0 r4:c1003cb0 [ 14.588656] dump_stack from __warn+0x84/0xe4 [ 14.588668] __warn from warn_slowpath_fmt+0x18c/0x194 [ 14.588678] r7:c08d40b0 r6:c1003cb0 r5:00000000 r4:00000000 [ 14.588681] warn_slowpath_fmt from nand_reset_op+0x1e0/0x1f8 [ 14.588695] r8:70c40dff r7:89705f41 r6:36b4a597 r5:c26c9444 r4:c26b0048 [ 14.588697] nand_reset_op from brcmnand_resume+0x13c/0x150 [ 14.588714] r9:00000000 r8:00000000 r7:c24f8010 r6:c228a3f8 r5:c26c94bc r4:c26b0040 [ 14.588717] brcmnand_resume from platform_pm_resume+0x34/0x54 [ 14.588735] r5:00000010 r4:c0840a50 [ 14.588738] platform_pm_resume from dpm_run_callback+0x5c/0x14c [ 14.588757] dpm_run_callback from device_resume+0xc0/0x324 [ 14.588776] r9:c24f8054 r8:c24f80a0 r7:00000000 r6:00000000 r5:00000010 r4:c24f8010 [ 14.588779] device_resume from dpm_resume+0x130/0x160 [ 14.588799] r9:c22539e4 r8:00000010 r7:c22bebb0 r6:c24f8010 r5:c22539dc r4:c22539b0 [ 14.588802] dpm_resume from dpm_resume_end+0x14/0x20 [ 14.588822] r10:c2204e40 r9:00000000 r8:c228a3fc r7:00000000 r6:00000003 r5:c228a414 [ 14.588826] r4:00000010 [ 14.588828] dpm_resume_end from suspend_devices_and_enter+0x274/0x6f8 [ 14.588848] r5:c228a414 r4:00000000 [ 14.588851] suspend_devices_and_enter from pm_suspend+0x228/0x2bc [ 14.588868] r10:c3502910 r9:c3501f40 r8:00000004 r7:c228a438 r6:c0f95e18 r5:00000000 [ 14.588871] r4:00000003 [ 14.588874] pm_suspend from state_store+0x74/0xd0 [ 14.588889] r7:c228a438 r6:c0f934c8 r5:00000003 r4:00000003 [ 14.588892] state_store from kobj_attr_store+0x1c/0x28 [ 14.588913] r9:00000000 r8:00000000 r7:f09f9f08 r6:00000004 r5:c3502900 r4:c0283250 [ 14.588916] kobj_attr_store from sysfs_kf_write+0x40/0x4c [ 14.588936] r5:c3502900 r4:c0d92a48 [ 14.588939] sysfs_kf_write from kernfs_fop_write_iter+0x104/0x1f0 [ 14.588956] r5:c3502900 r4:c3501f40 [ 14.588960] kernfs_fop_write_iter from vfs_write+0x250/0x420 [ 14.588980] r10:c0e14b48 r9:00000000 r8:c25f5780 r7:00443398 r6:f09f9f68 r5:c34f7f00 [ 14.588983] r4:c042a88c [ 14.588987] vfs_write from ksys_write+0x74/0xe4 [ 14.589005] r10:00000004 r9:c25f5780 r8:c02002fA0 r7:00000000 r6:00000000 r5:c34f7f00 [ 14.589008] r4:c34f7f00 [ 14.589011] ksys_write from sys_write+0x10/0x14 [ 14.589029] r7:00000004 r6:004421c0 r5:00443398 r4:00000004 [ 14.589032] sys_write from ret_fast_syscall+0x0/0x5c [ 14.589044] Exception stack(0xf09f9fa8 to 0xf09f9ff0) [ 14.589050] 9fa0: 00000004 00443398 00000004 00443398 00000004 00000001 [ 14.589056] 9fc0: 00000004 00443398 004421c0 00000004 b6ecbd58 00000008 bebfbc38 0043eb78 [ 14.589062] 9fe0: 00440eb0 bebfbaf8 b6de18a0 b6e579e8 [ 14.589065] ---[ end trace 0000000000000000 ]--- The fix uses the higher level nand_reset(chip, chipnr); where chipnr = 0, when doing PM resume operation in compliance with the controller support for single die nand chip. Switching from nand_reset_op() to nan ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/659b1f29f3e2fd5d751fdf35c5526d1f1c9b3dd2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6f567c6a5250e3531cfd9c7ff254ecc2650464fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7266066b9469f04ed1d4c0fdddaea1425835eb55"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8775581e1c48e1bdd04a893d6f6bbe5128ad0ea7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9bd51723ab51580e077c91d494c37e80703b8524"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9dd161f707ecb7db38e5f529e979a5b6eb565b2d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c2eb3cffb0d972c5503e4d48921971c81def0fe5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ddc210cf8b8a8be68051ad958bf3e2cef6b681c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fbcb584efa5cd912ff8a151d67b8fe22f4162a85"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37841,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:04.837,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: pm: cpupower: bench: Prevent NULL dereference on malloc failure If malloc returns NULL due to low memory, 'config' pointer can be NULL. Add a check to prevent NULL dereference.",,"[{""url"":""https://git.kernel.org/stable/c/0e297a02e03dceb2874789ca40bd4e65c5371704"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/208baa3ec9043a664d9acfb8174b332e6b17fb69"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/34a9394794b0f97af6afedc0c9ee2012c24b28ed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e38122aa3fd0f9788186e86a677925bfec0b2d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/79bded9d70142d2a11d931fc029afece471641db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/87b9f0867c0afa7e892f4b30c36cff6bf2707f85"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/942a4b97fc77516678b1d8af1521ff9a94c13b3e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ceec06f464d5cfc0ba966225f7d50506ceb62242"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8d28fa305b78c5d1073b63f26db265ba8291ae1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37842,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:04.963,2025-09-09T17:15:43.797,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: spi: fsl-qspi: use devm function instead of driver remove Driver use devm APIs to manage clk/irq/resources and register the spi controller, but the legacy remove function will be called first during device detach and trigger kernel panic. Drop the remove function and use devm_add_action_or_reset() for driver cleanup to ensure the release sequence. Trigger kernel panic on i.MX8MQ by echo 30bb0000.spi >/sys/bus/platform/drivers/fsl-quadspi/unbind",,"[{""url"":""https://git.kernel.org/stable/c/40369bfe717e96e26650eeecfa5a6363563df6e4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/439688dbe82baa10d4430dc3252bb5ef1183a171"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/50ae352c1848cab408fb4f7d7f50c71f818bbdbf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f68b27d82a749117d9c7d7f33fa53f46373e38e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f9bfb3a5f6f616f3eb7665c8ff3bcb9760ae33c8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37843,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:05.077,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: PCI: pciehp: Avoid unnecessary device replacement check Hot-removal of nested PCI hotplug ports suffers from a long-standing race condition which can lead to a deadlock: A parent hotplug port acquires pci_lock_rescan_remove(), then waits for pciehp to unbind from a child hotplug port. Meanwhile that child hotplug port tries to acquire pci_lock_rescan_remove() as well in order to remove its own children. The deadlock only occurs if the parent acquires pci_lock_rescan_remove() first, not if the child happens to acquire it first. Several workarounds to avoid the issue have been proposed and discarded over the years, e.g.: https://lore.kernel.org/r/4c882e25194ba8282b78fe963fec8faae7cf23eb.1529173804.git.lukas@wunner.de/ A proper fix is being worked on, but needs more time as it is nontrivial and necessarily intrusive. Recent commit 9d573d19547b (""PCI: pciehp: Detect device replacement during system sleep"") provokes more frequent occurrence of the deadlock when removing more than one Thunderbolt device during system sleep. The commit sought to detect device replacement, but also triggered on device removal. Differentiating reliably between replacement and removal is impossible because pci_get_dsn() returns 0 both if the device was removed, as well as if it was replaced with one lacking a Device Serial Number. Avoid the more frequent occurrence of the deadlock by checking whether the hotplug port itself was hot-removed. If so, there's no sense in checking whether its child device was replaced. This works because the ->resume_noirq() callback is invoked in top-down order for the entire hierarchy: A parent hotplug port detecting device replacement (or removal) marks all children as removed using pci_dev_set_disconnected() and a child hotplug port can then reliably detect being removed.",,"[{""url"":""https://git.kernel.org/stable/c/0d0bbd01f7c0ac7d1be9f85aaf2cd0baec34655f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7535d10a2c61baeff493300070cf04d9ddda216b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3260237aaadc9799107ccb940c6688195c4518d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e4a1d7defbc2d806540720a5adebe24ec3488683"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37844,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:05.190,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: cifs: avoid NULL pointer dereference in dbg call cifs_server_dbg() implies server to be non-NULL so move call under condition to avoid NULL pointer dereference. Found by Linux Verification Center (linuxtesting.org) with SVACE.",,"[{""url"":""https://git.kernel.org/stable/c/20048e658652e731f5cadf4a695925e570ca0ff9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c14ee6af8f1f188b668afd6d003f7516a507b08"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/864ba5c651b03830f36f0906c21af05b15c1aaa6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9c9000cb91b986eb7f75835340c67857ab97c09b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b2a1833e1c63e2585867ebeaf4dd41494dcede4b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b4885bd5935bb26f0a414ad55679a372e53f9b9b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba3ce6c60cd5db258687dfeba9fc608f5e7cadf3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0717385f5c51e290c2cd2ad4699a778316b5132"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37845,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:05.307,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tracing: fprobe events: Fix possible UAF on modules Commit ac91052f0ae5 (""tracing: tprobe-events: Fix leakage of module refcount"") moved try_module_get() from __find_tracepoint_module_cb() to find_tracepoint() caller, but that introduced a possible UAF because the module can be unloaded before try_module_get(). In this case, the module object should be freed too. Thus, try_module_get() does not only fail but may access to the freed object. To avoid that, try_module_get() in __find_tracepoint_module_cb() again.",,"[{""url"":""https://git.kernel.org/stable/c/626f01f4d26e8cf92e69c1df53036153c8e98a20"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/868df4eb784c3ccc7e4340a9ea993cbbedca167e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a27d2de2472b1cc7d582ab405d1d5832a80481de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dd941507a9486252d6fcf11814387666792020f3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37846,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:05.430,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: arm64: mops: Do not dereference src reg for a set operation The source register is not used for SET* and reading it can result in a UBSAN out-of-bounds array access error, specifically when the MOPS exception is taken from a SET* sequence with XZR (reg 31) as the source. Architecturally this is the only case where a src/dst/size field in the ESR can be reported as 31. Prior to 2de451a329cf662b the code in do_el0_mops() was benign as the use of pt_regs_read_reg() prevented the out-of-bounds access.",,"[{""url"":""https://git.kernel.org/stable/c/43267d934eacff6c70e15545d804ebbcab8a0bf5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5f6022a74147675124b781fdc056b291850e7786"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a13bfa4fe0d6949cea14718df2d1fe84c38cd113"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eec737e17e5567e08148550a7f1d94d495b9fb17"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37847,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:05.537,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: accel/ivpu: Fix deadlock in ivpu_ms_cleanup() Fix deadlock in ivpu_ms_cleanup() by preventing runtime resume after file_priv->ms_lock is acquired. During a failure in runtime resume, a cold boot is executed, which calls ivpu_ms_cleanup_all(). This function calls ivpu_ms_cleanup() that acquires file_priv->ms_lock and causes the deadlock.",,"[{""url"":""https://git.kernel.org/stable/c/019634f27a16796eab749e8107dae32099945f29"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d12a7d43c7bab9097ba466581d8db702e7908dc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9a6f56762d23a1f3af15e67901493c927caaf882"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f996ecc789b5dbaaf38b6ec0a1917821789cbd9c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37848,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:05.650,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: accel/ivpu: Fix PM related deadlocks in MS IOCTLs Prevent runtime resume/suspend while MS IOCTLs are in progress. Failed suspend will call ivpu_ms_cleanup() that would try to acquire file_priv->ms_lock, which is already held by the IOCTLs.",,"[{""url"":""https://git.kernel.org/stable/c/84547128526441b45c3c241419dececf20c30104"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/afada73000bef7c79a22f0d7e93fac414eeff19e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c3d9fc2f2746b52e9f820a13c53b4418bec04b48"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d893da85e06edf54737bb80648bb58ba8fd56d9f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37849,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:05.760,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: KVM: arm64: Tear down vGIC on failed vCPU creation If kvm_arch_vcpu_create() fails to share the vCPU page with the hypervisor, we propagate the error back to the ioctl but leave the vGIC vCPU data initialised. Note only does this leak the corresponding memory when the vCPU is destroyed but it can also lead to use-after-free if the redistributor device handling tries to walk into the vCPU. Add the missing cleanup to kvm_arch_vcpu_create(), ensuring that the vGIC vCPU structures are destroyed on error.",,"[{""url"":""https://git.kernel.org/stable/c/07476e0d932afc53c05468076393ac35d0b4999e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2480326eba8ae9ccc5e4c3c2dc8d407db68e3c52"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/250f25367b58d8c65a1b060a2dda037eea09a672"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5085e02362b9948f82fceca979b8f8e12acb1cc5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c322789613407647a05ff5c451a7bf545fb34e73"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1e9087abaeedec9bf2894a282ee4f0d8383f299"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37850,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:05.887,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: pwm: mediatek: Prevent divide-by-zero in pwm_mediatek_config() With CONFIG_COMPILE_TEST && !CONFIG_HAVE_CLK, pwm_mediatek_config() has a divide-by-zero in the following line: do_div(resolution, clk_get_rate(pc->clk_pwms[pwm->hwpwm])); due to the fact that the !CONFIG_HAVE_CLK version of clk_get_rate() returns zero. This is presumably just a theoretical problem: COMPILE_TEST overrides the dependency on RALINK which would select COMMON_CLK. Regardless it's a good idea to check for the error explicitly to avoid divide-by-zero. Fixes the following warning: drivers/pwm/pwm-mediatek.o: warning: objtool: .text: unexpected end of section [ukleinek: s/CONFIG_CLK/CONFIG_HAVE_CLK/]",,"[{""url"":""https://git.kernel.org/stable/c/4cb15042b5f3ec0474e91cf379120cc597625dbb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/77fb96dbe350e8a5ae4965ff9f6e7049f3966a6b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ca59947b5fcf94e7ea4029d1bd0f7c41500a161"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8b9f60725d74b72c238e4437c957d0217746b506"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ddbec73ea2598d8414e8f7103241b55cf877010"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c343856ff2689ce0afef823592732fc178ef4aac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e1206d8e1651c9f62e5640b69b14d925b1a0a00a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3cf0c38d3ce754ad63005102fcfeb0b7ff3290b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f3e9cf266c2c103cf071e15d7a17e2c699fff3c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37851,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:06.003,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fbdev: omapfb: Add 'plane' value check Function dispc_ovl_setup is not intended to work with the value OMAP_DSS_WB of the enum parameter plane. The value of this parameter is initialized in dss_init_overlays and in the current state of the code it cannot take this value so it's not a real problem. For the purposes of defensive coding it wouldn't be superfluous to check the parameter value, because some functions down the call stack process this value correctly and some not. For example, in dispc_ovl_setup_global_alpha it may lead to buffer overflow. Add check for this value. Found by Linux Verification Center (linuxtesting.org) with SVACE static analysis tool.",,"[{""url"":""https://git.kernel.org/stable/c/09dbf22fd68c2f1a81ab89670ffa1ec3033436c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3e411827f31db7f938a30a3c7a7599839401ec30"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4efd8ef5e40f2c7a4a91a5a9f03140bfa827da89"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/52eafaa56f8f6d6a0cdff9282b25b4acbde34edc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/660a53a0694d1f3789802509fe729dd4656fc5e0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9b0a41589ee70529b20e1e0108d03f10c649bdc4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a570efb4d877adbf3db2dc95487f2ba6bfdd148a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cdf41d72e8b015d9ea68f5a1c0a79624e7c312aa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fda15c5b96b883d62fb2d84a3a1422aa87717897"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37852,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:06.133,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: handle amdgpu_cgs_create_device() errors in amd_powerplay_create() Add error handling to propagate amdgpu_cgs_create_device() failures to the caller. When amdgpu_cgs_create_device() fails, release hwmgr and return -ENOMEM to prevent null pointer dereference. [v1]->[v2]: Change error code from -EINVAL to -ENOMEM. Free hwmgr.",,"[{""url"":""https://git.kernel.org/stable/c/1435e895d4fc967d64e9f5bf81e992ac32f5ac76"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/22ea19cc089013b55c240134dbb2797700ff5a6a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/55ef52c30c3e747f145a64de96192e37a8fed670"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b784734811438f11533e2fb9e0deb327844bdb56"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc4380f34613eaae997b3ed263bd1cb3d0fd0075"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8693e1bae9c08233a2f535c3f412e157df32b33"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37853,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:06.257,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdkfd: debugfs hang_hws skip GPU with MES debugfs hang_hws is used by GPU reset test with HWS, for MES this crash the kernel with NULL pointer access because dqm->packet_mgr is not setup for MES path. Skip GPU with MES for now, MES hang_hws debugfs interface will be supported later.",,"[{""url"":""https://git.kernel.org/stable/c/1a322b330dc0b775d1d7a84e55c752d9451bfe7d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/24b9e0e2e6147314c22d821f0542c4dd9a320c40"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a36f8d544522a19ef06ed9e84667d154dcb6be52"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f84c57906f0fd2185e557d2552b20aa8430a4677"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe9d0061c413f8fb8c529b18b592b04170850ded"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37854,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:06.367,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdkfd: Fix mode1 reset crash issue If HW scheduler hangs and mode1 reset is used to recover GPU, KFD signal user space to abort the processes. After process abort exit, user queues still use the GPU to access system memory before h/w is reset while KFD cleanup worker free system memory and free VRAM. There is use-after-free race bug that KFD allocate and reuse the freed system memory, and user queue write to the same system memory to corrupt the data structure and cause driver crash. To fix this race, KFD cleanup worker terminate user queues, then flush reset_domain wq to wait for any GPU ongoing reset complete, and then free outstanding BOs.",,"[{""url"":""https://git.kernel.org/stable/c/57c9dabda80ac167de8cd71231baae37cc2f442d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6f30a847432cae84c7428e9b684b3e3fa49b2391"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/89af6b39f028c130d4362f57042927f005423e6a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9c4bcdf4068aae3e17e31c144300be405cfa03ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f0b4440cdc1807bb6ec3dce0d6de81170803569b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ffd37d7d44d7e0b6e769d4fe6590e327f8cc3951"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37855,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:06.487,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Guard Possible Null Pointer Dereference [WHY] In some situations, dc->res_pool may be null. [HOW] Check if pointer is null before dereference.",,"[{""url"":""https://git.kernel.org/stable/c/c87d202692de34ee71d1fd4679a549a29095658a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc2de1ac7145f882f3c03d2d6f84583ae7e35d41"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37856,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:06.593,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: harden block_group::bg_list against list_del() races As far as I can tell, these calls of list_del_init() on bg_list cannot run concurrently with btrfs_mark_bg_unused() or btrfs_mark_bg_to_reclaim(), as they are in transaction error paths and situations where the block group is readonly. However, if there is any chance at all of racing with mark_bg_unused(), or a different future user of bg_list, better to be safe than sorry. Otherwise we risk the following interleaving (bg_list refcount in parens) T1 (some random op) T2 (btrfs_mark_bg_unused) !list_empty(&bg->bg_list); (1) list_del_init(&bg->bg_list); (1) list_move_tail (1) btrfs_put_block_group (0) btrfs_delete_unused_bgs bg = list_first_entry list_del_init(&bg->bg_list); btrfs_put_block_group(bg); (-1) Ultimately, this results in a broken ref count that hits zero one deref early and the real final deref underflows the refcount, resulting in a WARNING.",,"[{""url"":""https://git.kernel.org/stable/c/185fd73e5ac06027c4be9a129e59193f6a3ef202"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7511e29cf1355b2c47d0effb39e463119913e2f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/909e60fb469d4101c6b08cf6e622efb062bb24a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf089c4d1141b27332c092b1dcca5022c415a3b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37857,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:06.707,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: st: Fix array overflow in st_setup() Change the array size to follow parms size instead of a fixed value.",,"[{""url"":""https://git.kernel.org/stable/c/574b399a7fb6ae71c97e26d122205c4a720c0e43"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/736ae988bfb5932c05625baff70fba224d547c08"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7fe3b4deed8b93609058c37c9a11df1d2b2c0423"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a018d1cf990d0c339fe0e29b762ea5dc10567d67"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad4c3037dc77739a625246a2a0fb23b8f3402c06"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c6015d0f7a2236ddb3928b2dfcb1c556a1368b55"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e4d1ca0a84a6650d3172eb8c07ef2fbc585b0d96"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e6b585d016c47ca8a37b92ea8a3fe35c0b585256"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f746fe0c51e044d1248dc67918328bfb3d86b639"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37858,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:06.827,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fs/jfs: Prevent integer overflow in AG size calculation The JFS filesystem calculates allocation group (AG) size using 1 << l2agsize in dbExtendFS(). When l2agsize exceeds 31 (possible with >2TB aggregates on 32-bit systems), this 32-bit shift operation causes undefined behavior and improper AG sizing. On 32-bit architectures: - Left-shifting 1 by 32+ bits results in 0 due to integer overflow - This creates invalid AG sizes (0 or garbage values) in sbi->bmap->db_agsize - Subsequent block allocations would reference invalid AG structures - Could lead to: - Filesystem corruption during extend operations - Kernel crashes due to invalid memory accesses - Security vulnerabilities via malformed on-disk structures Fix by casting to s64 before shifting: bmp->db_agsize = (s64)1 << l2agsize; This ensures 64-bit arithmetic even on 32-bit architectures. The cast matches the data type of db_agsize (s64) and follows similar patterns in JFS block calculation code. Found by Linux Verification Center (linuxtesting.org) with SVACE.",,"[{""url"":""https://git.kernel.org/stable/c/211ed8f5e39e61f9e4d18edd64ce8005a67a1b2a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3d8a45f87010a802aa214bf39702ca9d99cbf3ba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/55edbf5dbf60a8195c21e92124c4028939ae16b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ccf3b35274512b60ecb614e0637e76bd6f2d829"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7fcbf789629cdb9fbf4e2172ce31136cfed11e5e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8bb29629a5e4090e1ef7199cb42db04a52802239"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c802a6a4009f585111f903e810b3be9c6d0da329"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dd07a985e2ded47b6c7d69fc93c1fe02977c8454"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec34cdf4f917cc6abd306cf091f8b8361fedac88"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37859,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:06.960,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: page_pool: avoid infinite loop to schedule delayed worker We noticed the kworker in page_pool_release_retry() was waken up repeatedly and infinitely in production because of the buggy driver causing the inflight less than 0 and warning us in page_pool_inflight()[1]. Since the inflight value goes negative, it means we should not expect the whole page_pool to get back to work normally. This patch mitigates the adverse effect by not rescheduling the kworker when detecting the inflight negative in page_pool_release_retry(). [1] [Mon Feb 10 20:36:11 2025] ------------[ cut here ]------------ [Mon Feb 10 20:36:11 2025] Negative(-51446) inflight packet-pages ... [Mon Feb 10 20:36:11 2025] Call Trace: [Mon Feb 10 20:36:11 2025] page_pool_release_retry+0x23/0x70 [Mon Feb 10 20:36:11 2025] process_one_work+0x1b1/0x370 [Mon Feb 10 20:36:11 2025] worker_thread+0x37/0x3a0 [Mon Feb 10 20:36:11 2025] kthread+0x11a/0x140 [Mon Feb 10 20:36:11 2025] ? process_one_work+0x370/0x370 [Mon Feb 10 20:36:11 2025] ? __kthread_cancel_work+0x40/0x40 [Mon Feb 10 20:36:11 2025] ret_from_fork+0x35/0x40 [Mon Feb 10 20:36:11 2025] ---[ end trace ebffe800f33e7e34 ]--- Note: before this patch, the above calltrace would flood the dmesg due to repeated reschedule of release_dw kworker.",,"[{""url"":""https://git.kernel.org/stable/c/43130d02baa137033c25297aaae95fd0edc41654"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7204335d1991c23fc615ab76f31f175748a578e1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/738d1812ec2e395e953258aea912ddd867d11a13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90e089a64504982f8d62f223027cb9f903781f78"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/91522aba56e9fcdf64da25ffef9b27f8fad48e0f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/95f17738b86fd198924d874a5639bcdc49c7e5b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9f71db4fb82deb889e0bac4a51b34daea7d506a3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c3c7c57017ce1d4b2d3788c1fc59e7e39026e158"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e74e5aa33228c5e2cb4fc80ad103541a7b7805ec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37860,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-04-18T07:15:42.883,2025-04-29T16:55:17.163,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: sfc: fix NULL dereferences in ef100_process_design_param() Since cited commit, ef100_probe_main() and hence also ef100_check_design_params() run before efx->net_dev is created; consequently, we cannot netif_set_tso_max_size() or _segs() at this point. Move those netif calls to ef100_probe_netdev(), and also replace netif_err within the design params code with pci_err.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-476""}]}]","[{""url"":""https://git.kernel.org/stable/c/8241ecec1cdc6699ae197d52d58e76bddd995fa5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/e56391011381d6d029da377a65ac314cb3d5def2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.0"",""versionEndExcluding"":""6.14.2"",""matchCriteriaId"":""DC685F25-CCF6-40A3-AB2D-9EC8065257E6""}]}]}]",,,,,,,,
CVE-2025-37861,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:07.073,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: mpi3mr: Synchronous access b/w reset and tm thread for reply queue When the task management thread processes reply queues while the reset thread resets them, the task management thread accesses an invalid queue ID (0xFFFF), set by the reset thread, which points to unallocated memory, causing a crash. Add flag 'io_admin_reset_sync' to synchronize access between the reset, I/O, and admin threads. Before a reset, the reset handler sets this flag to block I/O and admin processing threads. If any thread bypasses the initial check, the reset thread waits up to 10 seconds for processing to finish. If the wait exceeds 10 seconds, the controller is marked as unrecoverable.",,"[{""url"":""https://git.kernel.org/stable/c/65ba18c84dbd03afe9b38c06c151239d97a09834"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/75b67dca4195e11ccf966a704787b2aa2754a457"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8d310d66e2b0f5f9f709764641647e8a3a4924fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f195fc060c738d303a21fae146dbf85e1595fb4c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37862,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:07.190,2025-05-12T17:32:52.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: HID: pidff: Fix null pointer dereference in pidff_find_fields This function triggered a null pointer dereference if used to search for a report that isn't implemented on the device. This happened both for optional and required reports alike. The same logic was applied to pidff_find_special_field and although pidff_init_fields should return an error earlier if one of the required reports is missing, future modifications could change this logic and resurface this possible null pointer dereference again. LKML bug report: https://lore.kernel.org/all/CAL-gK7f5=R0nrrQdPtaZZr1fd-cdAMbDMuZ_NLA8vM0SX+nGSw@mail.gmail.com",,"[{""url"":""https://git.kernel.org/stable/c/22a05462c3d0eee15154faf8d13c49e6295270a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3a507184f9307e19cb441b897c49e7843c94e56b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/44a1b8b2027afbb37e418993fb23561bdb9efb38"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6b4449e4f03326fbd2136e67bfcc1e6ffe61541d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be706a48bb7896d4130edc82811233d1d62158e7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d230becb9d38b7325c5c38d051693e4c26b1829b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ddb147885225d768025f6818df533d30edf3e102"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e368698da79af821f18c099520deab1219c2044b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8f4d77710e1c38f4a2bd26c88c4878b5b5e817a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37863,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:07.317,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ovl: don't allow datadir only In theory overlayfs could support upper layer directly referring to a data layer, but there's no current use case for this. Originally, when data-only layers were introduced, this wasn't allowed, only introduced by the ""datadir+"" feature, but without actually handling this case, resulting in an Oops. Fix by disallowing datadir without lowerdir.",,"[{""url"":""https://git.kernel.org/stable/c/0874b629f65320778e7e3e206177770666d9db18"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/21d2ffb0e9838a175064c22f3a9de97d1f56f27d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b9e3579213ba648fa23f780e8d53e99011c62331"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb3a04a8516ee9b5174379306f94279fc90424c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37864,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:07.410,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: dsa: clean up FDB, MDB, VLAN entries on unbind As explained in many places such as commit b117e1e8a86d (""net: dsa: delete dsa_legacy_fdb_add and dsa_legacy_fdb_del""), DSA is written given the assumption that higher layers have balanced additions/deletions. As such, it only makes sense to be extremely vocal when those assumptions are violated and the driver unbinds with entries still present. But Ido Schimmel points out a very simple situation where that is wrong: https://lore.kernel.org/netdev/ZDazSM5UsPPjQuKr@shredder/ (also briefly discussed by me in the aforementioned commit). Basically, while the bridge bypass operations are not something that DSA explicitly documents, and for the majority of DSA drivers this API simply causes them to go to promiscuous mode, that isn't the case for all drivers. Some have the necessary requirements for bridge bypass operations to do something useful - see dsa_switch_supports_uc_filtering(). Although in tools/testing/selftests/net/forwarding/local_termination.sh, we made an effort to popularize better mechanisms to manage address filters on DSA interfaces from user space - namely macvlan for unicast, and setsockopt(IP_ADD_MEMBERSHIP) - through mtools - for multicast, the fact is that 'bridge fdb add ... self static local' also exists as kernel UAPI, and might be useful to someone, even if only for a quick hack. It seems counter-productive to block that path by implementing shim .ndo_fdb_add and .ndo_fdb_del operations which just return -EOPNOTSUPP in order to prevent the ndo_dflt_fdb_add() and ndo_dflt_fdb_del() from running, although we could do that. Accepting that cleanup is necessary seems to be the only option. Especially since we appear to be coming back at this from a different angle as well. Russell King is noticing that the WARN_ON() triggers even for VLANs: https://lore.kernel.org/netdev/Z_li8Bj8bD4-BYKQ@shell.armlinux.org.uk/ What happens in the bug report above is that dsa_port_do_vlan_del() fails, then the VLAN entry lingers on, and then we warn on unbind and leak it. This is not a straight revert of the blamed commit, but we now add an informational print to the kernel log (to still have a way to see that bugs exist), and some extra comments gathered from past years' experience, to justify the logic.",,"[{""url"":""https://git.kernel.org/stable/c/7afb5fb42d4950f33af2732b8147c552659f79b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/86c6613a69bca815f1865ed8cedfd4b9142621ab"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8fcc1e6f808912977caf17366c625b95dc29ba4f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/99c50c98803425378e08a7394dc885506dc85f06"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37865,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:07.530,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: dsa: mv88e6xxx: fix -ENOENT when deleting VLANs and MST is unsupported Russell King reports that on the ZII dev rev B, deleting a bridge VLAN from a user port fails with -ENOENT: https://lore.kernel.org/netdev/Z_lQXNP0s5-IiJzd@shell.armlinux.org.uk/ This comes from mv88e6xxx_port_vlan_leave() -> mv88e6xxx_mst_put(), which tries to find an MST entry in &chip->msts associated with the SID, but fails and returns -ENOENT as such. But we know that this chip does not support MST at all, so that is not surprising. The question is why does the guard in mv88e6xxx_mst_put() not exit early: if (!sid) return 0; And the answer seems to be simple: the sid comes from vlan.sid which supposedly was previously populated by mv88e6xxx_vtu_get(). But some chip->info->ops->vtu_getnext() implementations do not populate vlan.sid, for example see mv88e6185_g1_vtu_getnext(). In that case, later in mv88e6xxx_port_vlan_leave() we are using a garbage sid which is just residual stack memory. Testing for sid == 0 covers all cases of a non-bridge VLAN or a bridge VLAN mapped to the default MSTI. For some chips, SID 0 is valid and installed by mv88e6xxx_stu_setup(). A chip which does not support the STU would implicitly only support mapping all VLANs to the default MSTI, so although SID 0 is not valid, it would be sufficient, if we were to zero-initialize the vlan structure, to fix the bug, due to the coincidence that a test for vlan.sid == 0 already exists and leads to the same (correct) behavior. Another option which would be sufficient would be to add a test for mv88e6xxx_has_stu() inside mv88e6xxx_mst_put(), symmetric to the one which already exists in mv88e6xxx_mst_get(). But that placement means the caller will have to dereference vlan.sid, which means it will access uninitialized memory, which is not nice even if it ignores it later. So we end up making both modifications, in order to not rely just on the sid == 0 coincidence, but also to avoid having uninitialized structure fields which might get temporarily accessed.",,"[{""url"":""https://git.kernel.org/stable/c/35cde75c08a1fa1a5ac0467afe2709caceeef002"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9da4acbd60664271d34a627f7f63cd5bad8eba74"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ee6d3a368ed34f2457863da3085c676e9e37a3d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/afae9087301471970254a9180e5a26d3d8e8af09"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ea08dfc35f83cfc73493c52f63ae4f2e29edfe8d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37866,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:07.647,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mlxbf-bootctl: use sysfs_emit_at() in secure_boot_fuse_state_show() A warning is seen when running the latest kernel on a BlueField SOC: [251.512704] ------------[ cut here ]------------ [251.512711] invalid sysfs_emit: buf:0000000003aa32ae [251.512720] WARNING: CPU: 1 PID: 705264 at fs/sysfs/file.c:767 sysfs_emit+0xac/0xc8 The warning is triggered because the mlxbf-bootctl driver invokes ""sysfs_emit()"" with a buffer pointer that is not aligned to the start of the page. The driver should instead use ""sysfs_emit_at()"" to support non-zero offsets into the destination buffer.",,"[{""url"":""https://git.kernel.org/stable/c/5e1dcc5bfd7a2896178c604bc69d6ab9650967da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b129005ddfc0e6daf04a6d3b928a9e474f9b3918"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37867,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:07.763,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/core: Silence oversized kvmalloc() warning syzkaller triggered an oversized kvmalloc() warning. Silence it by adding __GFP_NOWARN. syzkaller log: WARNING: CPU: 7 PID: 518 at mm/util.c:665 __kvmalloc_node_noprof+0x175/0x180 CPU: 7 UID: 0 PID: 518 Comm: c_repro Not tainted 6.11.0-rc6+ #6 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 RIP: 0010:__kvmalloc_node_noprof+0x175/0x180 RSP: 0018:ffffc90001e67c10 EFLAGS: 00010246 RAX: 0000000000000100 RBX: 0000000000000400 RCX: ffffffff8149d46b RDX: 0000000000000000 RSI: ffff8881030fae80 RDI: 0000000000000002 RBP: 000000712c800000 R08: 0000000000000100 R09: 0000000000000000 R10: ffffc90001e67c10 R11: 0030ae0601000000 R12: 0000000000000000 R13: 0000000000000000 R14: 00000000ffffffff R15: 0000000000000000 FS: 00007fde79159740(0000) GS:ffff88813bdc0000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000020000180 CR3: 0000000105eb4005 CR4: 00000000003706b0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ib_umem_odp_get+0x1f6/0x390 mlx5_ib_reg_user_mr+0x1e8/0x450 ib_uverbs_reg_mr+0x28b/0x440 ib_uverbs_write+0x7d3/0xa30 vfs_write+0x1ac/0x6c0 ksys_write+0x134/0x170 ? __sanitizer_cov_trace_pc+0x1c/0x50 do_syscall_64+0x50/0x110 entry_SYSCALL_64_after_hwframe+0x76/0x7e",,"[{""url"":""https://git.kernel.org/stable/c/0d81bb58a203ad5f4044dc18cfbc230c194f650a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c588e9afbab240c921f936cb676dac72e2e2b66"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/791daf8240cedf27af8794038ae1d32ef643bce6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9a0e6f15029e1a8a21e40f06fd05aa52b7f063de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ae470d06320dea4002d441784d691f0a26b4322d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f476eba25fdf70faa7b19a3e0fb00e65c5b53106"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f94ac90ce7bd6f9266ad0d99044ed86e8d1416c1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37868,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:07.880,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/xe/userptr: fix notifier vs folio deadlock User is reporting what smells like notifier vs folio deadlock, where migrate_pages_batch() on core kernel side is holding folio lock(s) and then interacting with the mappings of it, however those mappings are tied to some userptr, which means calling into the notifier callback and grabbing the notifier lock. With perfect timing it looks possible that the pages we pulled from the hmm fault can get sniped by migrate_pages_batch() at the same time that we are holding the notifier lock to mark the pages as accessed/dirty, but at this point we also want to grab the folio locks(s) to mark them as dirty, but if they are contended from notifier/migrate_pages_batch side then we deadlock since folio lock won't be dropped until we drop the notifier lock. Fortunately the mark_page_accessed/dirty is not really needed in the first place it seems and should have already been done by hmm fault, so just remove it. (cherry picked from commit bd7c0cb695e87c0e43247be8196b4919edbe0e85)",,"[{""url"":""https://git.kernel.org/stable/c/2577b202458cddff85cc154b1fe7f313e0d1f418"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/65dc4e3d5b01db0179fc95c1f0bdb87194c28ab5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90574ecf6052be83971d91d16600c5cf07003bbb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37869,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:07.997,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/xe: Use local fence in error path of xe_migrate_clear The intent of the error path in xe_migrate_clear is to wait on locally generated fence and then return. The code is waiting on m->fence which could be the local fence but this is only stable under the job mutex leading to a possible UAF. Fix code to wait on local fence. (cherry picked from commit 762b7e95362170b3e13a8704f38d5e47eca4ba74)",,"[{""url"":""https://git.kernel.org/stable/c/20659d3150f1a2a258a173fe011013178ff2a197"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2ac5f466f62892a7d1ac2d1a3eb6cd14efbe2f2d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc712938aa26b001f448d5e93f59d57fa80f2dbd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37870,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:08.107,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: prevent hang on link training fail [Why] When link training fails, the phy clock will be disabled. However, in enable_streams, it is assumed that link training succeeded and the mux selects the phy clock, causing a hang when a register write is made. [How] When enable_stream is hit, check if link training failed. If it did, fall back to the ref clock to avoid a hang and keep the system in a recoverable state.",,"[{""url"":""https://git.kernel.org/stable/c/0363c03672cd3191f037905bf981eb523a3b71b1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/04bf4f2a497e9877c425c5124652e61fb8a1a0aa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8058061ed9d6bc259d1e678607b07d259342c08f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37871,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:08.210,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nfsd: decrease sc_count directly if fail to queue dl_recall A deadlock warning occurred when invoking nfs4_put_stid following a failed dl_recall queue operation: T1 T2 nfs4_laundromat nfs4_get_client_reaplist nfs4_anylock_blockers __break_lease spin_lock // ctx->flc_lock spin_lock // clp->cl_lock nfs4_lockowner_has_blockers locks_owner_has_blockers spin_lock // flctx->flc_lock nfsd_break_deleg_cb nfsd_break_one_deleg nfs4_put_stid refcount_dec_and_lock spin_lock // clp->cl_lock When a file is opened, an nfs4_delegation is allocated with sc_count initialized to 1, and the file_lease holds a reference to the delegation. The file_lease is then associated with the file through kernel_setlease. The disassociation is performed in nfsd4_delegreturn via the following call chain: nfsd4_delegreturn --> destroy_delegation --> destroy_unhashed_deleg --> nfs4_unlock_deleg_lease --> kernel_setlease --> generic_delete_lease The corresponding sc_count reference will be released after this disassociation. Since nfsd_break_one_deleg executes while holding the flc_lock, the disassociation process becomes blocked when attempting to acquire flc_lock in generic_delete_lease. This means: 1) sc_count in nfsd_break_one_deleg will not be decremented to 0; 2) The nfs4_put_stid called by nfsd_break_one_deleg will not attempt to acquire cl_lock; 3) Consequently, no deadlock condition is created. Given that sc_count in nfsd_break_one_deleg remains non-zero, we can safely perform refcount_dec on sc_count directly. This approach effectively avoids triggering deadlock warnings.",,"[{""url"":""https://git.kernel.org/stable/c/14985d66b9b99c12995dd99d1c6c8dec4114c2a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d192e27a431026c58d60edf66dc6cd98d0c01fc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a1d14d931bf700c1025db8c46d6731aa5cf440f9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a70832d3555987035fc430ccd703acd89393eadb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a7fce086f6ca84db409b9d58493ea77c1978897c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b9bbe8f9d5663311d06667ce36d6ed255ead1a26"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba903539fff745d592d893c71b30e5e268a95413"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37872,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:08.323,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: txgbe: fix memory leak in txgbe_probe() error path When txgbe_sw_init() is called, memory is allocated for wx->rss_key in wx_init_rss_key(). However, in txgbe_probe() function, the subsequent error paths after txgbe_sw_init() don't free the rss_key. Fix that by freeing it in error path along with wx->mac_table. Also change the label to which execution jumps when txgbe_sw_init() fails, because otherwise, it could lead to a double free for rss_key, when the mac_table allocation fails in wx_sw_init().",,"[{""url"":""https://git.kernel.org/stable/c/635863d93deb8e352d63a8eba852efeaf1ac3539"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/837197a722919f5b0eeb967fe7cb0cc1e83173b9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b2727326d0a53709380aa147018085d71a6d4843"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37873,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:08.440,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: eth: bnxt: fix missing ring index trim on error path Commit under Fixes converted tx_prod to be free running but missed masking it on the Tx error path. This crashes on error conditions, for example when DMA mapping fails.",,"[{""url"":""https://git.kernel.org/stable/c/12f2d033fae957d84c2c0ce604d2a077e61fa2c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/21e70f694bc0dcb40174b0940cc52a7769fc19e0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3742c55de00266fa7c8fd2c5d61a453d223a9cd1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37874,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:08.553,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: ngbe: fix memory leak in ngbe_probe() error path When ngbe_sw_init() is called, memory is allocated for wx->rss_key in wx_init_rss_key(). However, in ngbe_probe() function, the subsequent error paths after ngbe_sw_init() don't free the rss_key. Fix that by freeing it in error path along with wx->mac_table. Also change the label to which execution jumps when ngbe_sw_init() fails, because otherwise, it could lead to a double free for rss_key, when the mac_table allocation fails in wx_sw_init().",,"[{""url"":""https://git.kernel.org/stable/c/397487338eff1891c4654ce7deaafbf72a1688b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c2b66a31c7a4866400f7e6fb43cb32021bfca01"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8335a3feb9d0d97e5e8f76d38b6bb8573d5b4a29"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/88fa80021b77732bc98f73fb69d69c7cc37b9f0d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37875,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:08.670,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: igc: fix PTM cycle trigger logic Writing to clear the PTM status 'valid' bit while the PTM cycle is triggered results in unreliable PTM operation. To fix this, clear the PTM 'trigger' and status after each PTM transaction. The issue can be reproduced with the following: $ sudo phc2sys -R 1000 -O 0 -i tsn0 -m Note: 1000 Hz (-R 1000) is unrealistically large, but provides a way to quickly reproduce the issue. PHC2SYS exits with: ""ioctl PTP_OFFSET_PRECISE: Connection timed out"" when the PTM transaction fails This patch also fixes a hang in igc_probe() when loading the igc driver in the kdump kernel on systems supporting PTM. The igc driver running in the base kernel enables PTM trigger in igc_probe(). Therefore the driver is always in PTM trigger mode, except in brief periods when manually triggering a PTM cycle. When a crash occurs, the NIC is reset while PTM trigger is enabled. Due to a hardware problem, the NIC is subsequently in a bad busmaster state and doesn't handle register reads/writes. When running igc_probe() in the kdump kernel, the first register access to a NIC register hangs driver probing and ultimately breaks kdump. With this patch, igc has PTM trigger disabled most of the time, and the trigger is only enabled for very brief (10 - 100 us) periods when manually triggering a PTM cycle. Chances that a crash occurs during a PTM trigger are not 0, but extremely reduced.",,"[{""url"":""https://git.kernel.org/stable/c/0c03e4fbe1321697d9d04587e21e416705e1b19f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/16194ca3f3b4448a062650c869a7b3b206c6f5d3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/31959e06143692f7e02b8eef7d7d6ac645637906"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e404ad95d2c10c261e2ef6992c7c12dde03df0e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c1f174edaccc5a00f8e218c42a0aa9156efd5f76"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f3516229cd12dcd45f23ed01adab17e8772b1bd5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37876,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:08.790,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfs: Only create /proc/fs/netfs with CONFIG_PROC_FS When testing a special config: CONFIG_NETFS_SUPPORTS=y CONFIG_PROC_FS=n The system crashes with something like: [ 3.766197] ------------[ cut here ]------------ [ 3.766484] kernel BUG at mm/mempool.c:560! [ 3.766789] Oops: invalid opcode: 0000 [#1] SMP NOPTI [ 3.767123] CPU: 0 UID: 0 PID: 1 Comm: swapper/0 Tainted: G W [ 3.767777] Tainted: [W]=WARN [ 3.767968] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), [ 3.768523] RIP: 0010:mempool_alloc_slab.cold+0x17/0x19 [ 3.768847] Code: 50 fe ff 58 5b 5d 41 5c 41 5d 41 5e 41 5f e9 93 95 13 00 [ 3.769977] RSP: 0018:ffffc90000013998 EFLAGS: 00010286 [ 3.770315] RAX: 000000000000002f RBX: ffff888100ba8640 RCX: 0000000000000000 [ 3.770749] RDX: 0000000000000000 RSI: 0000000000000003 RDI: 00000000ffffffff [ 3.771217] RBP: 0000000000092880 R08: 0000000000000000 R09: ffffc90000013828 [ 3.771664] R10: 0000000000000001 R11: 00000000ffffffea R12: 0000000000092cc0 [ 3.772117] R13: 0000000000000400 R14: ffff8881004b1620 R15: ffffea0004ef7e40 [ 3.772554] FS: 0000000000000000(0000) GS:ffff8881b5f3c000(0000) knlGS:0000000000000000 [ 3.773061] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 3.773443] CR2: ffffffff830901b4 CR3: 0000000004296001 CR4: 0000000000770ef0 [ 3.773884] PKRU: 55555554 [ 3.774058] Call Trace: [ 3.774232] <TASK> [ 3.774371] mempool_alloc_noprof+0x6a/0x190 [ 3.774649] ? _printk+0x57/0x80 [ 3.774862] netfs_alloc_request+0x85/0x2ce [ 3.775147] netfs_readahead+0x28/0x170 [ 3.775395] read_pages+0x6c/0x350 [ 3.775623] ? srso_alias_return_thunk+0x5/0xfbef5 [ 3.775928] page_cache_ra_unbounded+0x1bd/0x2a0 [ 3.776247] filemap_get_pages+0x139/0x970 [ 3.776510] ? srso_alias_return_thunk+0x5/0xfbef5 [ 3.776820] filemap_read+0xf9/0x580 [ 3.777054] ? srso_alias_return_thunk+0x5/0xfbef5 [ 3.777368] ? srso_alias_return_thunk+0x5/0xfbef5 [ 3.777674] ? find_held_lock+0x32/0x90 [ 3.777929] ? netfs_start_io_read+0x19/0x70 [ 3.778221] ? netfs_start_io_read+0x19/0x70 [ 3.778489] ? srso_alias_return_thunk+0x5/0xfbef5 [ 3.778800] ? lock_acquired+0x1e6/0x450 [ 3.779054] ? srso_alias_return_thunk+0x5/0xfbef5 [ 3.779379] netfs_buffered_read_iter+0x57/0x80 [ 3.779670] __kernel_read+0x158/0x2c0 [ 3.779927] bprm_execve+0x300/0x7a0 [ 3.780185] kernel_execve+0x10c/0x140 [ 3.780423] ? __pfx_kernel_init+0x10/0x10 [ 3.780690] kernel_init+0xd5/0x150 [ 3.780910] ret_from_fork+0x2d/0x50 [ 3.781156] ? __pfx_kernel_init+0x10/0x10 [ 3.781414] ret_from_fork_asm+0x1a/0x30 [ 3.781677] </TASK> [ 3.781823] Modules linked in: [ 3.782065] ---[ end trace 0000000000000000 ]--- This is caused by the following error path in netfs_init(): if (!proc_mkdir(""fs/netfs"", NULL)) goto error_proc; Fix this by adding ifdef in netfs_main(), so that /proc/fs/netfs is only created with CONFIG_PROC_FS.",,"[{""url"":""https://git.kernel.org/stable/c/2ef6eea2efce01d1956ace483216f6b6e26330c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/40cb48eba3b4b79e110c1a35d33a48cac54507a2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c4c5e0b96a90f2a11c378e66edc1f25165e10b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37877,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:08.907,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iommu: Clear iommu-dma ops on cleanup If iommu_device_register() encounters an error, it can end up tearing down already-configured groups and default domains, however this currently still leaves devices hooked up to iommu-dma (and even historically the behaviour in this area was at best inconsistent across architectures/drivers...) Although in the case that an IOMMU is present whose driver has failed to probe, users cannot necessarily expect DMA to work anyway, it's still arguable that we should do our best to put things back as if the IOMMU driver was never there at all, and certainly the potential for crashing in iommu-dma itself is undesirable. Make sure we clean up the dev->dma_iommu flag along with everything else.",,"[{""url"":""https://git.kernel.org/stable/c/104a84276821aed0ed241ce0d82d6c3267e3fcb8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/280e5a30100578106a4305ce0118e0aa9b866f12"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b14d98641312d972bb3f38e82eddf92898522389"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37878,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:09.020,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: perf/core: Fix WARN_ON(!ctx) in __free_event() for partial init Move the get_ctx(child_ctx) call and the child_event->ctx assignment to occur immediately after the child event is allocated. Ensure that child_event->ctx is non-NULL before any subsequent error path within inherit_event calls free_event(), satisfying the assumptions of the cleanup code. Details: There's no clear Fixes tag, because this bug is a side-effect of multiple interacting commits over time (up to 15 years old), not a single regression. The code initially incremented refcount then assigned context immediately after the child_event was created. Later, an early validity check for child_event was added before the refcount/assignment. Even later, a WARN_ON_ONCE() cleanup check was added, assuming event->ctx is valid if the pmu_ctx is valid. The problem is that the WARN_ON_ONCE() could trigger after the initial check passed but before child_event->ctx was assigned, violating its precondition. The solution is to assign child_event->ctx right after its initial validation. This ensures the context exists for any subsequent checks or cleanup routines, resolving the WARN_ON_ONCE(). To resolve it, defer the refcount update and child_event->ctx assignment directly after child_event->pmu_ctx is set but before checking if the parent event is orphaned. The cleanup routine depends on event->pmu_ctx being non-NULL before it verifies event->ctx is non-NULL. This also maintains the author's original intent of passing in child_ctx to find_get_pmu_context before its refcount/assignment. [ mingo: Expanded the changelog from another email by Gabriel Shahrouzi. ]",,"[{""url"":""https://git.kernel.org/stable/c/0ba3a4ab76fd3367b9cb680cad70182c896c795c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1fe9b92eede32574dbe05b5bdb6ad666b350bed0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90dc6c1e3b200812da8d0aa030e1b7fda8226d0e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cb56cd11feabf99e08bc18960700a53322ffcea7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37879,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:09.143,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: 9p/net: fix improper handling of bogus negative read/write replies In p9_client_write() and p9_client_read_once(), if the server incorrectly replies with success but a negative write/read count then we would consider written (negative) <= rsize (positive) because both variables were signed. Make variables unsigned to avoid this problem. The reproducer linked below now fails with the following error instead of a null pointer deref: 9pnet: bogus RWRITE count (4294967295 > 3)",,"[{""url"":""https://git.kernel.org/stable/c/374e4cd75617c8c2552f562f39dd989583f5c330"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/468ff4a7c61fb811c596a7c44b6a5455e40fd12b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a68768e280b7d0c967ea509e791bb9b90adc94a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c548f95688e2b5ae0e2ae43d53cf717156c7d034"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d0259a856afca31d699b706ed5e2adf11086c73b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37880,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:09.257,2025-05-18T07:15:19.287,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: um: work around sched_yield not yielding in time-travel mode sched_yield by a userspace may not actually cause scheduling in time-travel mode as no time has passed. In the case seen it appears to be a badly implemented userspace spinlock in ASAN. Unfortunately, with time-travel it causes an extreme slowdown or even deadlock depending on the kernel configuration (CONFIG_UML_MAX_USERSPACE_ITERATIONS). Work around it by accounting time to the process whenever it executes a sched_yield syscall.",,"[{""url"":""https://git.kernel.org/stable/c/887c5c12e80c8424bd471122d2e8b6b462e12874"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/990ddc65173776f1e01e7135d8c1fd5f8fd4d5d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37881,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:09.367,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: gadget: aspeed: Add NULL pointer check in ast_vhub_init_dev() The variable d->name, returned by devm_kasprintf(), could be NULL. A pointer check is added to prevent potential NULL pointer dereference. This is similar to the fix in commit 3027e7b15b02 (""ice: Fix some null pointer dereference issues in ice_ptp.c""). This issue is found by our static analysis tool",,"[{""url"":""https://git.kernel.org/stable/c/052fb65335befeae8500e88d69ea022266baaf6d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/36d68151712e525450f0fbb3045e7110f0d9b610"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/61006ca381b4d65d2b8ca695ea8da1ce18d6dee3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c75f3e6a433d92084ad4e78b029ae680865420f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a777ccfb9ba8d43f745e41b69ba39d4a506a081e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c8d4faf452a627f9b09c3a5c366133a19e5b7a28"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cfa7984f69359761b07a7831c1258c0fde1e0389"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d26a6093d52904cacdbb75424c323c19b443a890"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37882,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:09.497,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: xhci: Fix isochronous Ring Underrun/Overrun event handling The TRB pointer of these events points at enqueue at the time of error occurrence on xHCI 1.1+ HCs or it's NULL on older ones. By the time we are handling the event, a new TD may be queued at this ring position. I can trigger this race by rising interrupt moderation to increase IRQ handling delay. Similar delay may occur naturally due to system load. If this ever happens after a Missed Service Error, missed TDs will be skipped and the new TD processed as if it matched the event. It could be given back prematurely, risking data loss or buffer UAF by the xHC. Don't complete TDs on xrun events and don't warn if queued TDs don't match the event's TRB pointer, which can be NULL or a link/no-op TRB. Don't warn if there are no queued TDs at all. Now that it's safe, also handle xrun events if the skip flag is clear. This ensures completion of any TD stuck in 'error mid TD' state right before the xrun event, which could happen if a driver submits a finite number of URBs to a buggy HC and then an error occurs on the last TD.",,"[{""url"":""https://git.kernel.org/stable/c/16a7a8e6c47fea5c847beb696c8c21a7a44c1915"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/39a080a2925c81b0f1da0add44722ef2b78e5454"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/906dec15b9b321b546fd31a3c99ffc13724c7af4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37883,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:09.607,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: s390/sclp: Add check for get_zeroed_page() Add check for the return value of get_zeroed_page() in sclp_console_init() to prevent null pointer dereference. Furthermore, to solve the memory leak caused by the loop allocation, add a free helper to do the free job.",,"[{""url"":""https://git.kernel.org/stable/c/28e5a867aa542e369e211c2baba7044228809a99"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/397254706eba9d8f99fd237feede7ab3169a7f9a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3b3aa72636a6205933609ec274a8747720c1ee3f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3db42c75a921854a99db0a2775814fef97415bac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e1e00dc45648125ef7cb87ebc3b581ac224e7b39"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f69f8a93aacf6e99af7b1cc992d8ca2cc07b96fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37884,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:09.727,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf: Fix deadlock between rcu_tasks_trace and event_mutex. Fix the following deadlock: CPU A _free_event() perf_kprobe_destroy() mutex_lock(&event_mutex) perf_trace_event_unreg() synchronize_rcu_tasks_trace() There are several paths where _free_event() grabs event_mutex and calls sync_rcu_tasks_trace. Above is one such case. CPU B bpf_prog_test_run_syscall() rcu_read_lock_trace() bpf_prog_run_pin_on_cpu() bpf_prog_load() bpf_tracing_func_proto() trace_set_clr_event() mutex_lock(&event_mutex) Delegate trace_set_clr_event() to workqueue to avoid such lock dependency.",,"[{""url"":""https://git.kernel.org/stable/c/255cbc9db7067a83713fd2f4b31034ddd266549a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/45286680b385f2592db3003554872388dee66d68"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4580f4e0ebdf8dc8d506ae926b88510395a0c1d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b5a528a34e1f613565115a7a6016862ccbfcb9ac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c5c833f6375f8ecf9254dd27946c927c7d645421"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37885,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:09.843,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: KVM: x86: Reset IRTE to host control if *new* route isn't postable Restore an IRTE back to host control (remapped or posted MSI mode) if the *new* GSI route prevents posting the IRQ directly to a vCPU, regardless of the GSI routing type. Updating the IRTE if and only if the new GSI is an MSI results in KVM leaving an IRTE posting to a vCPU. The dangling IRTE can result in interrupts being incorrectly delivered to the guest, and in the worst case scenario can result in use-after-free, e.g. if the VM is torn down, but the underlying host IRQ isn't freed.",,"[{""url"":""https://git.kernel.org/stable/c/023816bd5fa46fab94d1e7917fe131b79ed1fb41"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/116c7d35b8f72eac383b9fd371d7c1a8ffc2968b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3066ec21d1a33896125747f68638725f456308db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3481fd96d801715942b6f69fe251133128156f30"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9bcac97dc42d2f4da8229d18feb0fe2b1ce523a2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b5de7ac74f69603ad803c524b840bffd36368fc3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e5f2dee9f7fcd2ff4b97869f3c66a0d89c167769"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37886,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:09.973,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: pds_core: make wait_context part of q_info Make the wait_context a full part of the q_info struct rather than a stack variable that goes away after pdsc_adminq_post() is done so that the context is still available after the wait loop has given up. There was a case where a slow development firmware caused the adminq request to time out, but then later the FW finally finished the request and sent the interrupt. The handler tried to complete_all() the completion context that had been created on the stack in pdsc_adminq_post() but no longer existed. This caused bad pointer usage, kernel crashes, and much wailing and gnashing of teeth.",,"[{""url"":""https://git.kernel.org/stable/c/1d7c4b2b0bbfb09b55b2dc0e2355d7936bf89381"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f77c3dfffc7063428b100c4945ca2a7a8680380"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/520f012fe75fb8efc9f16a57ef929a7a2115d892"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/66d7702b42ffdf0dce4808626088268a4e905ca6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37887,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:10.077,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: pds_core: handle unsupported PDS_CORE_CMD_FW_CONTROL result If the FW doesn't support the PDS_CORE_CMD_FW_CONTROL command the driver might at the least print garbage and at the worst crash when the user runs the ""devlink dev info"" devlink command. This happens because the stack variable fw_list is not 0 initialized which results in fw_list.num_fw_slots being a garbage value from the stack. Then the driver tries to access fw_list.fw_names[i] with i >= ARRAY_SIZE and runs off the end of the array. Fix this by initializing the fw_list and by not failing completely if the devcmd fails because other useful information is printed via devlink dev info even if the devcmd fails.",,"[{""url"":""https://git.kernel.org/stable/c/12a4651a80dbe4589a84e26785fbbe1ed4d043b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2567daad69cd1107fc0ec29b1615f110d7cf7385"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6702f5c6b22deaa95bf84f526148174a160a02cb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cdd784c96fe2e5edbf0ed9b3e96fe776e8092385"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37888,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:10.193,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/mlx5: Fix null-ptr-deref in mlx5_create_{inner_,}ttc_table() Add NULL check for mlx5_get_flow_namespace() returns in mlx5_create_inner_ttc_table() and mlx5_create_ttc_table() to prevent NULL pointer dereference.",,"[{""url"":""https://git.kernel.org/stable/c/0b682680b12b08cd62b113ea92b2938195de1dfe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/91037037ee3d611ce17f39d75f79c7de394b122a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ecd9d2647ddb4f42a121de648e48659ae1856c39"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37889,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-09T07:16:10.307,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: ops: Consistently treat platform_max as control value This reverts commit 9bdd10d57a88 (""ASoC: ops: Shift tested values in snd_soc_put_volsw() by +min""), and makes some additional related updates. There are two ways the platform_max could be interpreted; the maximum register value, or the maximum value the control can be set to. The patch moved from treating the value as a control value to a register one. When the patch was applied it was technically correct as snd_soc_limit_volume() also used the register interpretation. However, even then most of the other usages treated platform_max as a control value, and snd_soc_limit_volume() has since been updated to also do so in commit fb9ad24485087 (""ASoC: ops: add correct range check for limiting volume""). That patch however, missed updating snd_soc_put_volsw() back to the control interpretation, and fixing snd_soc_info_volsw_range(). The control interpretation makes more sense as limiting is typically done from the machine driver, so it is appropriate to use the customer facing representation rather than the internal codec representation. Update all the code to consistently use this interpretation of platform_max. Finally, also add some comments to the soc_mixer_control struct to hopefully avoid further patches switching between the two approaches.",,"[{""url"":""https://git.kernel.org/stable/c/0eba2a7e858907a746ba69cd002eb9eb4dbd7bf3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/296c8295ae34045da0214882628d49c1c060dd8a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/544055329560d4b64fe204fc6be325ebc24c72ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/694110bc2407a61f02a770cbb5f39b51e4ec77c6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a46a9371f8b9a0eeff53a21e11ed3b65f52d9cf6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c402f184a053c8e7ca325e50f04bbbc1e4fee019"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37890,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-16T13:15:52.437,2025-06-04T13:15:26.170,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net_sched: hfsc: Fix a UAF vulnerability in class with netem as child qdisc As described in Gerrard's report [1], we have a UAF case when an hfsc class has a netem child qdisc. The crux of the issue is that hfsc is assuming that checking for cl->qdisc->q.qlen == 0 guarantees that it hasn't inserted the class in the vttree or eltree (which is not true for the netem duplicate case). This patch checks the n_active class variable to make sure that the code won't insert the class in the vttree or eltree twice, catering for the reentrant case. [1] https://lore.kernel.org/netdev/CAHcdcOm+03OD2j6R0=YHKqmy=VgJ8xEOKuP6c7mSgnp-TEJJbw@mail.gmail.com/",,"[{""url"":""https://git.kernel.org/stable/c/141d34391abbb315d68556b7c67ad97885407547"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/273bbcfa53541cde38b2003ad88a59b770306421"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2e7093c7a8aba5d4f8809f271488e5babe75e202"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6082a87af4c52f58150d40dec1716011d871ac21"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8df7d37d626430035b413b97cee18396b3450bef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac39fd4a757584d78ed062d4f6fd913f83bd98b5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0cf8ee23e1915431f262a7b2dee0c7a7d699af0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3e949a39a91d1f829a4890e7dfe9417ac72e4d0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37891,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-19T08:15:21.710,2025-05-19T13:35:20.460,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ALSA: ump: Fix buffer overflow at UMP SysEx message conversion The conversion function from MIDI 1.0 to UMP packet contains an internal buffer to keep the incoming MIDI bytes, and its size is 4, as it was supposed to be the max size for a MIDI1 UMP packet data. However, the implementation overlooked that SysEx is handled in a different format, and it can be up to 6 bytes, as found in do_convert_to_ump(). It leads eventually to a buffer overflow, and may corrupt the memory when a longer SysEx message is received. The fix is simply to extend the buffer size to 6 to fit with the SysEx UMP message.",,"[{""url"":""https://git.kernel.org/stable/c/226beac5605afbb33f8782148d188b64396145a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/42ef48dd4ebb082a1a90b5c3feeda2e68a9e32fe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/56f1f30e6795b890463d9b20b11e576adf5a2f77"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce4f77bef276e7d2eb7ab03a5d08bcbaa40710ec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37892,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T11:15:48.233,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mtd: inftlcore: Add error check for inftl_read_oob() In INFTL_findwriteunit(), the return value of inftl_read_oob() need to be checked. A proper implementation can be found in INFTL_deleteblock(). The status will be set as SECTOR_IGNORE to break from the while-loop correctly if the inftl_read_oob() fails.",,"[{""url"":""https://git.kernel.org/stable/c/0300e751170cf80c05ca1a762a7b449e8ca6b693"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/114d94f095aa405fa9a51484c4be34846d7bb386"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1c22356dfb041e5292835c9ff44d5f91bef8dd18"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5479a6af3c96f73bec2d2819532b6d6814f52dd6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6af3b92b1c0b58ca281d0e1501bad2567f73c1a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7772621041ee78823ccc5f1fe38f6faa22af7023"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b828d394308e8e00df0a6f57e7dabae609bb8b7b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d027951dc85cb2e15924c980dc22a6754d100c7c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e7d6ceff95c55297f0ee8f9dbc4da5c558f30e9e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37893,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-04-18T07:15:42.983,2025-04-29T16:54:26.433,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: LoongArch: BPF: Fix off-by-one error in build_prologue() Vincent reported that running BPF progs with tailcalls on LoongArch causes kernel hard lockup. Debugging the issues shows that the JITed image missing a jirl instruction at the end of the epilogue. There are two passes in JIT compiling, the first pass set the flags and the second pass generates JIT code based on those flags. With BPF progs mixing bpf2bpf and tailcalls, build_prologue() generates N insns in the first pass and then generates N+1 insns in the second pass. This makes epilogue_offset off by one and we will jump to some unexpected insn and cause lockup. Fix this by inserting a nop insn.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-193""}]}]","[{""url"":""https://git.kernel.org/stable/c/205a2182c51ffebaef54d643e3745e720cded08b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/48b904de2408af5f936f0e03f48dfcddeab58aa0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/7e2586991e36663c9bc48c828b83eab180ad30a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/b3ffad2f02db4aace6799fe0049508b8925eae45"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/c74d95a5679741ef428974ab788f5b0758dc78ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.1"",""versionEndExcluding"":""6.1.134"",""matchCriteriaId"":""10FAA32F-8D33-4A36-8482-01961DD84A84""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.2"",""versionEndExcluding"":""6.6.87"",""matchCriteriaId"":""EFF24260-49B1-4251-9477-C564CFDAD25B""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.7"",""versionEndExcluding"":""6.12.23"",""matchCriteriaId"":""26CAB76D-F00F-43CE-BEAD-7097F8FB1D6C""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.13"",""versionEndExcluding"":""6.13.11"",""matchCriteriaId"":""E7E864B0-8C00-4679-BA55-659B4C9C3AD3""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.14"",""versionEndExcluding"":""6.14.2"",""matchCriteriaId"":""FADAE5D8-4808-442C-B218-77B2CE8780A0""}]}]}]",,,,,,,,
CVE-2025-37894,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:25.760,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: use sock_gen_put() when sk_state is TCP_TIME_WAIT It is possible for a pointer of type struct inet_timewait_sock to be returned from the functions __inet_lookup_established() and __inet6_lookup_established(). This can cause a crash when the returned pointer is of type struct inet_timewait_sock and sock_put() is called on it. The following is a crash call stack that shows sk->sk_wmem_alloc being accessed in sk_free() during the call to sock_put() on a struct inet_timewait_sock pointer. To avoid this issue, use sock_gen_put() instead of sock_put() when sk->sk_state is TCP_TIME_WAIT. mrdump.ko ipanic() + 120 vmlinux notifier_call_chain(nr_to_call=-1, nr_calls=0) + 132 vmlinux atomic_notifier_call_chain(val=0) + 56 vmlinux panic() + 344 vmlinux add_taint() + 164 vmlinux end_report() + 136 vmlinux kasan_report(size=0) + 236 vmlinux report_tag_fault() + 16 vmlinux do_tag_recovery() + 16 vmlinux __do_kernel_fault() + 88 vmlinux do_bad_area() + 28 vmlinux do_tag_check_fault() + 60 vmlinux do_mem_abort() + 80 vmlinux el1_abort() + 56 vmlinux el1h_64_sync_handler() + 124 vmlinux > 0xFFFFFFC080011294() vmlinux __lse_atomic_fetch_add_release(v=0xF2FFFF82A896087C) vmlinux __lse_atomic_fetch_sub_release(v=0xF2FFFF82A896087C) vmlinux arch_atomic_fetch_sub_release(i=1, v=0xF2FFFF82A896087C) + 8 vmlinux raw_atomic_fetch_sub_release(i=1, v=0xF2FFFF82A896087C) + 8 vmlinux atomic_fetch_sub_release(i=1, v=0xF2FFFF82A896087C) + 8 vmlinux __refcount_sub_and_test(i=1, r=0xF2FFFF82A896087C, oldp=0) + 8 vmlinux __refcount_dec_and_test(r=0xF2FFFF82A896087C, oldp=0) + 8 vmlinux refcount_dec_and_test(r=0xF2FFFF82A896087C) + 8 vmlinux sk_free(sk=0xF2FFFF82A8960700) + 28 vmlinux sock_put() + 48 vmlinux tcp6_check_fraglist_gro() + 236 vmlinux tcp6_gro_receive() + 624 vmlinux ipv6_gro_receive() + 912 vmlinux dev_gro_receive() + 1116 vmlinux napi_gro_receive() + 196 ccmni.ko ccmni_rx_callback() + 208 ccmni.ko ccmni_queue_recv_skb() + 388 ccci_dpmaif.ko dpmaif_rxq_push_thread() + 1088 vmlinux kthread() + 268 vmlinux 0xFFFFFFC08001F30C()",,"[{""url"":""https://git.kernel.org/stable/c/786650e644c5b1c063921799ca203c0b8670d79a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c0dba059b118b5206e755042b15b49368a388898"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f920436a44295ca791ebb6dae3f4190142eec703"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37895,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:25.860,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bnxt_en: Fix error handling path in bnxt_init_chip() WARN_ON() is triggered in __flush_work() if bnxt_init_chip() fails because we call cancel_work_sync() on dim work that has not been initialized. WARNING: CPU: 37 PID: 5223 at kernel/workqueue.c:4201 __flush_work.isra.0+0x212/0x230 The driver relies on the BNXT_STATE_NAPI_DISABLED bit to check if dim work has already been cancelled. But in the bnxt_open() path, BNXT_STATE_NAPI_DISABLED is not set and this causes the error path to think that it needs to cancel the uninitalized dim work. Fix it by setting BNXT_STATE_NAPI_DISABLED during initialization. The bit will be cleared when we enable NAPI and initialize dim work.",,"[{""url"":""https://git.kernel.org/stable/c/21116727f452474502ee74f956d5e7466103e19b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ab7a709c926c16b4433cf02d04fcbcf35aaab2b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e039b00ddbfeaa0dc59b8659be114f1a1b37c5bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37896,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:25.960,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: spi: spi-mem: Add fix to avoid divide error For some SPI flash memory operations, dummy bytes are not mandatory. For example, in Winbond SPINAND flash memory devices, the `write_cache` and `update_cache` operation variants have zero dummy bytes. Calculating the duration for SPI memory operations with zero dummy bytes causes a divide error when `ncycles` is calculated in the spi_mem_calc_op_duration(). Add changes to skip the 'ncylcles' calculation for zero dummy bytes. Following divide error is fixed by this change: Oops: divide error: 0000 [#1] PREEMPT SMP NOPTI ... ? do_trap+0xdb/0x100 ? do_error_trap+0x75/0xb0 ? spi_mem_calc_op_duration+0x56/0xb0 ? exc_divide_error+0x3b/0x70 ? spi_mem_calc_op_duration+0x56/0xb0 ? asm_exc_divide_error+0x1b/0x20 ? spi_mem_calc_op_duration+0x56/0xb0 ? spinand_select_op_variant+0xee/0x190 [spinand] spinand_match_and_init+0x13e/0x1a0 [spinand] spinand_manufacturer_match+0x6e/0xa0 [spinand] spinand_probe+0x357/0x7f0 [spinand] ? kernfs_activate+0x87/0xd0 spi_mem_probe+0x7a/0xb0 spi_probe+0x7d/0x130",,"[{""url"":""https://git.kernel.org/stable/c/1915dbd67dadc0bb35670c8e28229baa29368d17"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e4d3d8a5e51e07bd0d6cdd81b5e4af79f796927"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37897,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:26.067,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: plfxlc: Remove erroneous assert in plfxlc_mac_release plfxlc_mac_release() asserts that mac->lock is held. This assertion is incorrect, because even if it was possible, it would not be the valid behaviour. The function is used when probe fails or after the device is disconnected. In both cases mac->lock can not be held as the driver is not working with the device at the moment. All functions that use mac->lock unlock it just after it was held. There is also no need to hold mac->lock for plfxlc_mac_release() itself, as mac data is not affected, except for mac->flags, which is modified atomically. This bug leads to the following warning: ================================================================ WARNING: CPU: 0 PID: 127 at drivers/net/wireless/purelifi/plfxlc/mac.c:106 plfxlc_mac_release+0x7d/0xa0 Modules linked in: CPU: 0 PID: 127 Comm: kworker/0:2 Not tainted 6.1.124-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Workqueue: usb_hub_wq hub_event RIP: 0010:plfxlc_mac_release+0x7d/0xa0 drivers/net/wireless/purelifi/plfxlc/mac.c:106 Call Trace: <TASK> probe+0x941/0xbd0 drivers/net/wireless/purelifi/plfxlc/usb.c:694 usb_probe_interface+0x5c0/0xaf0 drivers/usb/core/driver.c:396 really_probe+0x2ab/0xcb0 drivers/base/dd.c:639 __driver_probe_device+0x1a2/0x3d0 drivers/base/dd.c:785 driver_probe_device+0x50/0x420 drivers/base/dd.c:815 __device_attach_driver+0x2cf/0x510 drivers/base/dd.c:943 bus_for_each_drv+0x183/0x200 drivers/base/bus.c:429 __device_attach+0x359/0x570 drivers/base/dd.c:1015 bus_probe_device+0xba/0x1e0 drivers/base/bus.c:489 device_add+0xb48/0xfd0 drivers/base/core.c:3696 usb_set_configuration+0x19dd/0x2020 drivers/usb/core/message.c:2165 usb_generic_driver_probe+0x84/0x140 drivers/usb/core/generic.c:238 usb_probe_device+0x130/0x260 drivers/usb/core/driver.c:293 really_probe+0x2ab/0xcb0 drivers/base/dd.c:639 __driver_probe_device+0x1a2/0x3d0 drivers/base/dd.c:785 driver_probe_device+0x50/0x420 drivers/base/dd.c:815 __device_attach_driver+0x2cf/0x510 drivers/base/dd.c:943 bus_for_each_drv+0x183/0x200 drivers/base/bus.c:429 __device_attach+0x359/0x570 drivers/base/dd.c:1015 bus_probe_device+0xba/0x1e0 drivers/base/bus.c:489 device_add+0xb48/0xfd0 drivers/base/core.c:3696 usb_new_device+0xbdd/0x18f0 drivers/usb/core/hub.c:2620 hub_port_connect drivers/usb/core/hub.c:5477 [inline] hub_port_connect_change drivers/usb/core/hub.c:5617 [inline] port_event drivers/usb/core/hub.c:5773 [inline] hub_event+0x2efe/0x5730 drivers/usb/core/hub.c:5855 process_one_work+0x8a9/0x11d0 kernel/workqueue.c:2292 worker_thread+0xa47/0x1200 kernel/workqueue.c:2439 kthread+0x28d/0x320 kernel/kthread.c:376 ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:295 </TASK> ================================================================ Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",,"[{""url"":""https://git.kernel.org/stable/c/0fb15ae3b0a9221be01715dac0335647c79f3362"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/36a9a2647810e57e704dde59abdf831380ca9102"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/791a2d9e87c411aec0b9b2fb735fd15e48af9de9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/93d646911be1e5be20d4f5d6c48359464cef0097"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ecb4af39f80cdda3e57825923243ec11e48be6b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37898,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:26.177,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: powerpc64/ftrace: fix module loading without patchable function entries get_stubs_size assumes that there must always be at least one patchable function entry, which is not always the case (modules that export data but no code), otherwise it returns -ENOEXEC and thus the section header sh_size is set to that value. During module_memory_alloc() the size is passed to execmem_alloc() after being page-aligned and thus set to zero which will cause it to fail the allocation (and thus module loading) as __vmalloc_node_range() checks for zero-sized allocs and returns null: [ 115.466896] module_64: cast_common: doesn't contain __patchable_function_entries. [ 115.469189] ------------[ cut here ]------------ [ 115.469496] WARNING: CPU: 0 PID: 274 at mm/vmalloc.c:3778 __vmalloc_node_range_noprof+0x8b4/0x8f0 ... [ 115.478574] ---[ end trace 0000000000000000 ]--- [ 115.479545] execmem: unable to allocate memory Fix this by removing the check completely, since it is anyway not helpful to propagate this as an error upwards.",,"[{""url"":""https://git.kernel.org/stable/c/358b559afec7806b9d01c2405b490e782c347022"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/534f5a8ba27863141e29766467a3e1f61bcb47ac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37899,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:26.273,2025-05-24T19:15:23.640,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix use-after-free in session logoff The sess->user object can currently be in use by another thread, for example if another connection has sent a session setup request to bind to the session being free'd. The handler for that connection could be in the smb2_sess_setup function which makes use of sess->user.",,"[{""url"":""https://git.kernel.org/stable/c/02d16046cd11a5c037b28c12ffb818c56dd3ef43"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2fc9feff45d92a92cd5f96487655d5be23fb7e2b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d5ec1d79509b3ee01de02c236f096bc050221b7f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://news.ycombinator.com/item?id=44081338"",""source"":""af854a3a-2127-422b-91ae-364da2661108""},{""url"":""https://sean.heelan.io/2025/05/22/how-i-used-o3-to-find-cve-2025-37899-a-remote-zeroday-vulnerability-in-the-linux-kernels-smb-implementation/"",""source"":""af854a3a-2127-422b-91ae-364da2661108""}]",,,,,,,,,,
CVE-2025-37900,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:26.357,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iommu: Fix two issues in iommu_copy_struct_from_user() In the review for iommu_copy_struct_to_user() helper, Matt pointed out that a NULL pointer should be rejected prior to dereferencing it: https://lore.kernel.org/all/86881827-8E2D-461C-BDA3-FA8FD14C343C@nvidia.com And Alok pointed out a typo at the same time: https://lore.kernel.org/all/480536af-6830-43ce-a327-adbd13dc3f1d@oracle.com Since both issues were copied from iommu_copy_struct_from_user(), fix them first in the current header.",,"[{""url"":""https://git.kernel.org/stable/c/2e303d010722787dc84d94f68d70fe10dfc1b9ea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/30a3f2f3e4bd6335b727c83c08a982d969752bc1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/967d6f0d9a20a1bf15ee7ed881e2d4e532e22709"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37901,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:26.453,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: irqchip/qcom-mpm: Prevent crash when trying to handle non-wake GPIOs On Qualcomm chipsets not all GPIOs are wakeup capable. Those GPIOs do not have a corresponding MPM pin and should not be handled inside the MPM driver. The IRQ domain hierarchy is always applied, so it's required to explicitly disconnect the hierarchy for those. The pinctrl-msm driver marks these with GPIO_NO_WAKE_IRQ. qcom-pdc has a check for this, but irq-qcom-mpm is currently missing the check. This is causing crashes when setting up interrupts for non-wake GPIOs: root@rb1:~# gpiomon -c gpiochip1 10 irq: IRQ159: trimming hierarchy from :soc@0:interrupt-controller@f200000-1 Unable to handle kernel paging request at virtual address ffff8000a1dc3820 Hardware name: Qualcomm Technologies, Inc. Robotics RB1 (DT) pc : mpm_set_type+0x80/0xcc lr : mpm_set_type+0x5c/0xcc Call trace: mpm_set_type+0x80/0xcc (P) qcom_mpm_set_type+0x64/0x158 irq_chip_set_type_parent+0x20/0x38 msm_gpio_irq_set_type+0x50/0x530 __irq_set_trigger+0x60/0x184 __setup_irq+0x304/0x6bc request_threaded_irq+0xc8/0x19c edge_detector_setup+0x260/0x364 linereq_create+0x420/0x5a8 gpio_ioctl+0x2d4/0x6c0 Fix this by copying the check for GPIO_NO_WAKE_IRQ from qcom-pdc.c, so that MPM is removed entirely from the hierarchy for non-wake GPIOs.",,"[{""url"":""https://git.kernel.org/stable/c/38a05c0b87833f5b188ae43b428b1f792df2b384"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/45aced97f01d5ab14c8a2a60f6748f18c501c3f5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d5c10448f411a925dd59005785cb971f0626e032"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dfbaecf7e38f5e9bfa5e47a1e525ffbb58bab8cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f102342360950b56959e5fff4a874ea88ae13758"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37902,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:26.560,2025-05-26T11:15:24.460,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,[],,,,,,,,,,
CVE-2025-37903,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:26.683,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix slab-use-after-free in hdcp The HDCP code in amdgpu_dm_hdcp.c copies pointers to amdgpu_dm_connector objects without incrementing the kref reference counts. When using a USB-C dock, and the dock is unplugged, the corresponding amdgpu_dm_connector objects are freed, creating dangling pointers in the HDCP code. When the dock is plugged back, the dangling pointers are dereferenced, resulting in a slab-use-after-free: [ 66.775837] BUG: KASAN: slab-use-after-free in event_property_validate+0x42f/0x6c0 [amdgpu] [ 66.776171] Read of size 4 at addr ffff888127804120 by task kworker/0:1/10 [ 66.776179] CPU: 0 UID: 0 PID: 10 Comm: kworker/0:1 Not tainted 6.14.0-rc7-00180-g54505f727a38-dirty #233 [ 66.776183] Hardware name: HP HP Pavilion Aero Laptop 13-be0xxx/8916, BIOS F.17 12/18/2024 [ 66.776186] Workqueue: events event_property_validate [amdgpu] [ 66.776494] Call Trace: [ 66.776496] <TASK> [ 66.776497] dump_stack_lvl+0x70/0xa0 [ 66.776504] print_report+0x175/0x555 [ 66.776507] ? __virt_addr_valid+0x243/0x450 [ 66.776510] ? kasan_complete_mode_report_info+0x66/0x1c0 [ 66.776515] kasan_report+0xeb/0x1c0 [ 66.776518] ? event_property_validate+0x42f/0x6c0 [amdgpu] [ 66.776819] ? event_property_validate+0x42f/0x6c0 [amdgpu] [ 66.777121] __asan_report_load4_noabort+0x14/0x20 [ 66.777124] event_property_validate+0x42f/0x6c0 [amdgpu] [ 66.777342] ? __lock_acquire+0x6b40/0x6b40 [ 66.777347] ? enable_assr+0x250/0x250 [amdgpu] [ 66.777571] process_one_work+0x86b/0x1510 [ 66.777575] ? pwq_dec_nr_in_flight+0xcf0/0xcf0 [ 66.777578] ? assign_work+0x16b/0x280 [ 66.777580] ? lock_is_held_type+0xa3/0x130 [ 66.777583] worker_thread+0x5c0/0xfa0 [ 66.777587] ? process_one_work+0x1510/0x1510 [ 66.777588] kthread+0x3a2/0x840 [ 66.777591] ? kthread_is_per_cpu+0xd0/0xd0 [ 66.777594] ? trace_hardirqs_on+0x4f/0x60 [ 66.777597] ? _raw_spin_unlock_irq+0x27/0x60 [ 66.777599] ? calculate_sigpending+0x77/0xa0 [ 66.777602] ? kthread_is_per_cpu+0xd0/0xd0 [ 66.777605] ret_from_fork+0x40/0x90 [ 66.777607] ? kthread_is_per_cpu+0xd0/0xd0 [ 66.777609] ret_from_fork_asm+0x11/0x20 [ 66.777614] </TASK> [ 66.777643] Allocated by task 10: [ 66.777646] kasan_save_stack+0x39/0x60 [ 66.777649] kasan_save_track+0x14/0x40 [ 66.777652] kasan_save_alloc_info+0x37/0x50 [ 66.777655] __kasan_kmalloc+0xbb/0xc0 [ 66.777658] __kmalloc_cache_noprof+0x1c8/0x4b0 [ 66.777661] dm_dp_add_mst_connector+0xdd/0x5c0 [amdgpu] [ 66.777880] drm_dp_mst_port_add_connector+0x47e/0x770 [drm_display_helper] [ 66.777892] drm_dp_send_link_address+0x1554/0x2bf0 [drm_display_helper] [ 66.777901] drm_dp_check_and_send_link_address+0x187/0x1f0 [drm_display_helper] [ 66.777909] drm_dp_mst_link_probe_work+0x2b8/0x410 [drm_display_helper] [ 66.777917] process_one_work+0x86b/0x1510 [ 66.777919] worker_thread+0x5c0/0xfa0 [ 66.777922] kthread+0x3a2/0x840 [ 66.777925] ret_from_fork+0x40/0x90 [ 66.777927] ret_from_fork_asm+0x11/0x20 [ 66.777932] Freed by task 1713: [ 66.777935] kasan_save_stack+0x39/0x60 [ 66.777938] kasan_save_track+0x14/0x40 [ 66.777940] kasan_save_free_info+0x3b/0x60 [ 66.777944] __kasan_slab_free+0x52/0x70 [ 66.777946] kfree+0x13f/0x4b0 [ 66.777949] dm_dp_mst_connector_destroy+0xfa/0x150 [amdgpu] [ 66.778179] drm_connector_free+0x7d/0xb0 [ 66.778184] drm_mode_object_put.part.0+0xee/0x160 [ 66.778188] drm_mode_object_put+0x37/0x50 [ 66.778191] drm_atomic_state_default_clear+0x220/0xd60 [ 66.778194] __drm_atomic_state_free+0x16e/0x2a0 [ 66.778197] drm_mode_atomic_ioctl+0x15ed/0x2ba0 [ 66.778200] drm_ioctl_kernel+0x17a/0x310 [ 66.778203] drm_ioctl+0x584/0xd10 [ 66.778206] amdgpu_drm_ioctl+0xd2/0x1c0 [amdgpu] [ 66.778375] __x64_sys_ioctl+0x139/0x1a0 [ 66.778378] x64_sys_call+0xee7/0xfb0 [ 66.778381] ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/3a782a83d130ceac6c98a87639ddd89640bff486"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bbc66abcd297be67e3d835276e21e6fdc65205a6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be593d9d91c5a3a363d456b9aceb71029aeb3f1d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dd329f04dda35a66e0c9ed462ba91bd5f2c8be70"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e25139c4aa5621f2db8e86688c33546cdd885e42"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37904,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:26.820,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: fix the inode leak in btrfs_iget() [BUG] There is a bug report that a syzbot reproducer can lead to the following busy inode at unmount time: BTRFS info (device loop1): last unmount of filesystem 1680000e-3c1e-4c46-84b6-56bd3909af50 VFS: Busy inodes after unmount of loop1 (btrfs) ------------[ cut here ]------------ kernel BUG at fs/super.c:650! Oops: invalid opcode: 0000 [#1] SMP KASAN NOPTI CPU: 0 UID: 0 PID: 48168 Comm: syz-executor Not tainted 6.15.0-rc2-00471-g119009db2674 #2 PREEMPT(full) Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 RIP: 0010:generic_shutdown_super+0x2e9/0x390 fs/super.c:650 Call Trace: <TASK> kill_anon_super+0x3a/0x60 fs/super.c:1237 btrfs_kill_super+0x3b/0x50 fs/btrfs/super.c:2099 deactivate_locked_super+0xbe/0x1a0 fs/super.c:473 deactivate_super fs/super.c:506 [inline] deactivate_super+0xe2/0x100 fs/super.c:502 cleanup_mnt+0x21f/0x440 fs/namespace.c:1435 task_work_run+0x14d/0x240 kernel/task_work.c:227 resume_user_mode_work include/linux/resume_user_mode.h:50 [inline] exit_to_user_mode_loop kernel/entry/common.c:114 [inline] exit_to_user_mode_prepare include/linux/entry-common.h:329 [inline] __syscall_exit_to_user_mode_work kernel/entry/common.c:207 [inline] syscall_exit_to_user_mode+0x269/0x290 kernel/entry/common.c:218 do_syscall_64+0xd4/0x250 arch/x86/entry/syscall_64.c:100 entry_SYSCALL_64_after_hwframe+0x77/0x7f </TASK> [CAUSE] When btrfs_alloc_path() failed, btrfs_iget() directly returned without releasing the inode already allocated by btrfs_iget_locked(). This results the above busy inode and trigger the kernel BUG. [FIX] Fix it by calling iget_failed() if btrfs_alloc_path() failed. If we hit error inside btrfs_read_locked_inode(), it will properly call iget_failed(), so nothing to worry about. Although the iget_failed() cleanup inside btrfs_read_locked_inode() is a break of the normal error handling scheme, let's fix the obvious bug and backport first, then rework the error handling later.",,"[{""url"":""https://git.kernel.org/stable/c/30a339bece3a44ab0a821477139e84fb86af9761"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/48c1d1bb525b1c44b8bdc8e7ec5629cb6c2b9fc4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37905,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:26.927,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: firmware: arm_scmi: Balance device refcount when destroying devices Using device_find_child() to lookup the proper SCMI device to destroy causes an unbalance in device refcount, since device_find_child() calls an implicit get_device(): this, in turns, inhibits the call of the provided release methods upon devices destruction. As a consequence, one of the structures that is not freed properly upon destruction is the internal struct device_private dev->p populated by the drivers subsystem core. KMemleak detects this situation since loading/unloding some SCMI driver causes related devices to be created/destroyed without calling any device_release method. unreferenced object 0xffff00000f583800 (size 512): comm ""insmod"", pid 227, jiffies 4294912190 hex dump (first 32 bytes): 00 00 00 00 ad 4e ad de ff ff ff ff 00 00 00 00 .....N.......... ff ff ff ff ff ff ff ff 60 36 1d 8a 00 80 ff ff ........`6...... backtrace (crc 114e2eed): kmemleak_alloc+0xbc/0xd8 __kmalloc_cache_noprof+0x2dc/0x398 device_add+0x954/0x12d0 device_register+0x28/0x40 __scmi_device_create.part.0+0x1bc/0x380 scmi_device_create+0x2d0/0x390 scmi_create_protocol_devices+0x74/0xf8 scmi_device_request_notifier+0x1f8/0x2a8 notifier_call_chain+0x110/0x3b0 blocking_notifier_call_chain+0x70/0xb0 scmi_driver_register+0x350/0x7f0 0xffff80000a3b3038 do_one_initcall+0x12c/0x730 do_init_module+0x1dc/0x640 load_module+0x4b20/0x5b70 init_module_from_file+0xec/0x158 $ ./scripts/faddr2line ./vmlinux device_add+0x954/0x12d0 device_add+0x954/0x12d0: kmalloc_noprof at include/linux/slab.h:901 (inlined by) kzalloc_noprof at include/linux/slab.h:1037 (inlined by) device_private_init at drivers/base/core.c:3510 (inlined by) device_add at drivers/base/core.c:3561 Balance device refcount by issuing a put_device() on devices found via device_find_child().",,"[{""url"":""https://git.kernel.org/stable/c/2fbf6c9695ad9f05e7e5c166bf43fac7cb3276b3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8a8a3547d5c4960da053df49c75bf623827a25da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/91ff1e9652fb9beb0174267d6bb38243dff211bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/969d8beaa2e374387bf9aa5602ef84fc50bb48d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ca67840c0ddf3f39407339624cef824a4f27599"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff4273d47da81b95ed9396110bcbd1b7b7470fe8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37906,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:27.070,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ublk: fix race between io_uring_cmd_complete_in_task and ublk_cancel_cmd ublk_cancel_cmd() calls io_uring_cmd_done() to complete uring_cmd, but we may have scheduled task work via io_uring_cmd_complete_in_task() for dispatching request, then kernel crash can be triggered. Fix it by not trying to canceling the command if ublk block request is started.",,"[{""url"":""https://git.kernel.org/stable/c/f40139fde5278d81af3227444fd6e76a76b9506d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fb2eb9ddf556f93fef45201e1f9d2b8674bcc975"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37907,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:27.177,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: accel/ivpu: Fix locking order in ivpu_job_submit Fix deadlock in job submission and abort handling. When a thread aborts currently executing jobs due to a fault, it first locks the global lock protecting submitted_jobs (#1). After the last job is destroyed, it proceeds to release the related context and locks file_priv (#2). Meanwhile, in the job submission thread, the file_priv lock (#2) is taken first, and then the submitted_jobs lock (#1) is obtained when a job is added to the submitted jobs list. CPU0 CPU1 ---- ---- (for example due to a fault) (jobs submissions keep coming) lock(&vdev->submitted_jobs_lock) #1 ivpu_jobs_abort_all() job_destroy() lock(&file_priv->lock) #2 lock(&vdev->submitted_jobs_lock) #1 file_priv_release() lock(&vdev->context_list_lock) lock(&file_priv->lock) #2 This order of locking causes a deadlock. To resolve this issue, change the order of locking in ivpu_job_submit().",,"[{""url"":""https://git.kernel.org/stable/c/079d2622f8c9e0c380149645fff21d35c59ce6ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ab680dc6c78aa035e944ecc8c48a1caab9f39924"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b9b70924a272c2d72023306bc56f521c056212ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37908,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:27.280,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm, slab: clean up slab->obj_exts always When memory allocation profiling is disabled at runtime or due to an error, shutdown_mem_profiling() is called: slab->obj_exts which previously allocated remains. It won't be cleared by unaccount_slab() because of mem_alloc_profiling_enabled() not true. It's incorrect, slab->obj_exts should always be cleaned up in unaccount_slab() to avoid following error: [...]BUG: Bad page state in process... .. [...]page dumped because: page still charged to cgroup [andriy.shevchenko@linux.intel.com: fold need_slab_obj_ext() into its only user]",,"[{""url"":""https://git.kernel.org/stable/c/01db0e1a48345aa1937f3bdfc7c7108d03ebcf7e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be8250786ca94952a19ce87f98ad9906448bc9ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dab2a13059a475b6392550f882276e170fe2fcff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37909,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:27.390,2025-06-04T13:15:26.290,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: lan743x: Fix memleak issue when GSO enabled Always map the `skb` to the LS descriptor. Previously skb was mapped to EXT descriptor when the number of fragments is zero with GSO enabled. Mapping the skb to EXT descriptor prevents it from being freed, leading to a memory leak",,"[{""url"":""https://git.kernel.org/stable/c/093855ce90177488eac772de4eefbb909033ce5f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/189b05f189cac9fd233ef04d31cb5078c4d09c39"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2d52e2e38b85c8b7bc00dca55c2499f46f8c8198"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c65ee5ad632eb8dcd3a91cf5dc99b22535f44d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a0e0efbabbbe6a1859bc31bf65237ce91e124b9b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dae1ce27ceaea7e1522025b15252e3cc52802622"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/df993daa4c968b4b23078eacc248f6502ede8664"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f42c18e2f14c1b1fdd2a5250069a84bc854c398c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37910,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:27.507,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ptp: ocp: Fix NULL dereference in Adva board SMA sysfs operations On Adva boards, SMA sysfs store/get operations can call __handle_signal_outputs() or __handle_signal_inputs() while the `irig` and `dcf` pointers are uninitialized, leading to a NULL pointer dereference in __handle_signal() and causing a kernel crash. Adva boards don't use `irig` or `dcf` functionality, so add Adva-specific callbacks `ptp_ocp_sma_adva_set_outputs()` and `ptp_ocp_sma_adva_set_inputs()` that avoid invoking `irig` or `dcf` input/output routines.",,"[{""url"":""https://git.kernel.org/stable/c/5b349f9cdb4a9daa133bea267dfc0c383628387a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8a543d825e78b8d680d8f891381b83fbffdb0bb6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e98386d79a23c57cf179fe4138322e277aa3aa74"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37911,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:27.610,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bnxt_en: Fix out-of-bound memcpy() during ethtool -w When retrieving the FW coredump using ethtool, it can sometimes cause memory corruption: BUG: KFENCE: memory corruption in __bnxt_get_coredump+0x3ef/0x670 [bnxt_en] Corrupted memory at 0x000000008f0f30e8 [ ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ] (in kfence-#45): __bnxt_get_coredump+0x3ef/0x670 [bnxt_en] ethtool_get_dump_data+0xdc/0x1a0 __dev_ethtool+0xa1e/0x1af0 dev_ethtool+0xa8/0x170 dev_ioctl+0x1b5/0x580 sock_do_ioctl+0xab/0xf0 sock_ioctl+0x1ce/0x2e0 __x64_sys_ioctl+0x87/0xc0 do_syscall_64+0x5c/0xf0 entry_SYSCALL_64_after_hwframe+0x78/0x80 ... This happens when copying the coredump segment list in bnxt_hwrm_dbg_dma_data() with the HWRM_DBG_COREDUMP_LIST FW command. The info->dest_buf buffer is allocated based on the number of coredump segments returned by the FW. The segment list is then DMA'ed by the FW and the length of the DMA is returned by FW. The driver then copies this DMA'ed segment list to info->dest_buf. In some cases, this DMA length may exceed the info->dest_buf length and cause the above BUG condition. Fix it by capping the copy length to not exceed the length of info->dest_buf. The extra DMA data contains no useful information. This code path is shared for the HWRM_DBG_COREDUMP_LIST and the HWRM_DBG_COREDUMP_RETRIEVE FW commands. The buffering is different for these 2 FW commands. To simplify the logic, we need to move the line to adjust the buffer length for HWRM_DBG_COREDUMP_RETRIEVE up, so that the new check to cap the copy length will work for both commands.",,"[{""url"":""https://git.kernel.org/stable/c/43292b83424158fa6ec458799f3cb9c54d18c484"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/44807af79efd0d78fa36383dd865ddfe7992c0a6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/44d81a9ebf0cad92512e0ffdf7412bfe20db66ec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4d69864915a3a052538e4ba76cd6fd77cfc64ebe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/69b10dd23ab826d0c7f2d9ab311842251978d0c1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6b87bd94f34370bbf1dfa59352bed8efab5bf419"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37912,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:27.723,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ice: Check VF VSI Pointer Value in ice_vc_add_fdir_fltr() As mentioned in the commit baeb705fd6a7 (""ice: always check VF VSI pointer values""), we need to perform a null pointer check on the return value of ice_get_vf_vsi() before using it.",,"[{""url"":""https://git.kernel.org/stable/c/0561f2e374c3732b90e50f0a244791a4308ec67e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/073791e9cfe6e4a11a6d85816ba87b1aa207493e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/425c5f266b2edeee0ce16fedd8466410cdcfcfe3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a32dcc3b8293600ddc4024731b4d027d4de061a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eae60cfe25d022d7f0321dba4cc23ad8e87ade48"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f68237982dc012230550f4ecf7ce286a9c37ddc9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37913,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:27.837,2025-06-04T13:15:26.490,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net_sched: qfq: Fix double list add in class with netem as child qdisc As described in Gerrard's report [1], there are use cases where a netem child qdisc will make the parent qdisc's enqueue callback reentrant. In the case of qfq, there won't be a UAF, but the code will add the same classifier to the list twice, which will cause memory corruption. This patch checks whether the class was already added to the agg->active list (cl_is_active) before doing the addition to cater for the reentrant case. [1] https://lore.kernel.org/netdev/CAHcdcOm+03OD2j6R0=YHKqmy=VgJ8xEOKuP6c7mSgnp-TEJJbw@mail.gmail.com/",,"[{""url"":""https://git.kernel.org/stable/c/005a479540478a820c52de098e5e767e63e36f0a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/041f410aec2c1751ee22b8b73ba05d38c3a6a602"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0aa23e0856b7cedb3c88d8e3d281c212c7e4fbeb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0bf32d6fb1fcbf841bb9945570e0e2a70072c00f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/370218e8ce711684acc4cdd3cc3c6dd7956bc165"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/53bc0b55178bd59bdd4bcd16349505cabf54b1a2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a43783119e01849fbf2fe8855634e8989b240cb4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f139f37dcdf34b67f5bf92bc8e0f7f6b3ac63aa4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37914,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:27.943,2025-06-04T13:15:26.610,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net_sched: ets: Fix double list add in class with netem as child qdisc As described in Gerrard's report [1], there are use cases where a netem child qdisc will make the parent qdisc's enqueue callback reentrant. In the case of ets, there won't be a UAF, but the code will add the same classifier to the list twice, which will cause memory corruption. In addition to checking for qlen being zero, this patch checks whether the class was already added to the active_list (cl_is_active) before doing the addition to cater for the reentrant case. [1] https://lore.kernel.org/netdev/CAHcdcOm+03OD2j6R0=YHKqmy=VgJ8xEOKuP6c7mSgnp-TEJJbw@mail.gmail.com/",,"[{""url"":""https://git.kernel.org/stable/c/1a6d0c00fa07972384b0c308c72db091d49988b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1f01e9f961605eb397c6ecd1d7b0233dfbf9077c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/24388ba0a1b1b6d4af1b205927ac7f7b119ee4ea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/554acc5a2ea9703e08023eb9a003f9e5a830a502"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/72c3da7e6ceb74e74ddbb5a305a35c9fdfcac6e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9efb6a0fa88e0910d079fdfeb4f7ce4d4ac6c990"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bc321f714de693aae06e3786f88df2975376d996"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37915,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:28.057,2025-06-04T13:15:26.730,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net_sched: drr: Fix double list add in class with netem as child qdisc As described in Gerrard's report [1], there are use cases where a netem child qdisc will make the parent qdisc's enqueue callback reentrant. In the case of drr, there won't be a UAF, but the code will add the same classifier to the list twice, which will cause memory corruption. In addition to checking for qlen being zero, this patch checks whether the class was already added to the active_list (cl_is_active) before adding to the list to cover for the reentrant case. [1] https://lore.kernel.org/netdev/CAHcdcOm+03OD2j6R0=YHKqmy=VgJ8xEOKuP6c7mSgnp-TEJJbw@mail.gmail.com/",,"[{""url"":""https://git.kernel.org/stable/c/26e75716b94d6ff9be5ea07d63675c4d189f30b4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2968632880f1792007eedd12eeedf7f6e2b7e9f3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4b07ac06b0a712923255aaf2691637693fc7100d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4f0ecf50cdf76da95828578a92f130b653ac2fcf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5da3aad1a13e7edb8ff0778a444ccf49930313e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ab2248110738d4429668140ad22f530a9ee730e1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/db205b92dfe0501e5b92fb7cf00971d0e44ba3eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f99a3fbf023e20b626be4b0f042463d598050c9a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37916,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:28.170,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: pds_core: remove write-after-free of client_id A use-after-free error popped up in stress testing: [Mon Apr 21 21:21:33 2025] BUG: KFENCE: use-after-free write in pdsc_auxbus_dev_del+0xef/0x160 [pds_core] [Mon Apr 21 21:21:33 2025] Use-after-free write at 0x000000007013ecd1 (in kfence-#47): [Mon Apr 21 21:21:33 2025] pdsc_auxbus_dev_del+0xef/0x160 [pds_core] [Mon Apr 21 21:21:33 2025] pdsc_remove+0xc0/0x1b0 [pds_core] [Mon Apr 21 21:21:33 2025] pci_device_remove+0x24/0x70 [Mon Apr 21 21:21:33 2025] device_release_driver_internal+0x11f/0x180 [Mon Apr 21 21:21:33 2025] driver_detach+0x45/0x80 [Mon Apr 21 21:21:33 2025] bus_remove_driver+0x83/0xe0 [Mon Apr 21 21:21:33 2025] pci_unregister_driver+0x1a/0x80 The actual device uninit usually happens on a separate thread scheduled after this code runs, but there is no guarantee of order of thread execution, so this could be a problem. There's no actual need to clear the client_id at this point, so simply remove the offending code.",,"[{""url"":""https://git.kernel.org/stable/c/26dc701021302f11c8350108321d11763bd81dfe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9b467c5bcdb45a41d2a49fbb9ffca73d1380e99b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c649b9653ed09196e91d3f4b16b679041b3c42e6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dfd76010f8e821b66116dec3c7d90dd2403d1396"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37917,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:28.273,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: ethernet: mtk-star-emac: fix spinlock recursion issues on rx/tx poll Use spin_lock_irqsave and spin_unlock_irqrestore instead of spin_lock and spin_unlock in mtk_star_emac driver to avoid spinlock recursion occurrence that can happen when enabling the DMA interrupts again in rx/tx poll. ``` BUG: spinlock recursion on CPU#0, swapper/0/0 lock: 0xffff00000db9cf20, .magic: dead4ead, .owner: swapper/0/0, .owner_cpu: 0 CPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.15.0-rc2-next-20250417-00001-gf6a27738686c-dirty #28 PREEMPT Hardware name: MediaTek MT8365 Open Platform EVK (DT) Call trace: show_stack+0x18/0x24 (C) dump_stack_lvl+0x60/0x80 dump_stack+0x18/0x24 spin_dump+0x78/0x88 do_raw_spin_lock+0x11c/0x120 _raw_spin_lock+0x20/0x2c mtk_star_handle_irq+0xc0/0x22c [mtk_star_emac] __handle_irq_event_percpu+0x48/0x140 handle_irq_event+0x4c/0xb0 handle_fasteoi_irq+0xa0/0x1bc handle_irq_desc+0x34/0x58 generic_handle_domain_irq+0x1c/0x28 gic_handle_irq+0x4c/0x120 do_interrupt_handler+0x50/0x84 el1_interrupt+0x34/0x68 el1h_64_irq_handler+0x18/0x24 el1h_64_irq+0x6c/0x70 regmap_mmio_read32le+0xc/0x20 (P) _regmap_bus_reg_read+0x6c/0xac _regmap_read+0x60/0xdc regmap_read+0x4c/0x80 mtk_star_rx_poll+0x2f4/0x39c [mtk_star_emac] __napi_poll+0x38/0x188 net_rx_action+0x164/0x2c0 handle_softirqs+0x100/0x244 __do_softirq+0x14/0x20 ____do_softirq+0x10/0x20 call_on_irq_stack+0x24/0x64 do_softirq_own_stack+0x1c/0x40 __irq_exit_rcu+0xd4/0x10c irq_exit_rcu+0x10/0x1c el1_interrupt+0x38/0x68 el1h_64_irq_handler+0x18/0x24 el1h_64_irq+0x6c/0x70 cpuidle_enter_state+0xac/0x320 (P) cpuidle_enter+0x38/0x50 do_idle+0x1e4/0x260 cpu_startup_entry+0x34/0x3c rest_init+0xdc/0xe0 console_on_rootfs+0x0/0x6c __primary_switched+0x88/0x90 ```",,"[{""url"":""https://git.kernel.org/stable/c/6fe0866014486736cc3ba1c6fd4606d3dbe55c9c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7cb10f17bddc415f30fbc00a4e2b490e0d94c462"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8d40bf73fa7f31eac2b0a7c9d85de67df82ee7f3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/94107259f972d2fd896dbbcaa176b3b2451ff9e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bedd287fdd3142dffad7ae2ac6ef15f4a2ad0629"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d886f8d85494d12b2752fd7c6c32162d982d5dd5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37918,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:28.393,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: btusb: avoid NULL pointer dereference in skb_dequeue() A NULL pointer dereference can occur in skb_dequeue() when processing a QCA firmware crash dump on WCN7851 (0489:e0f3). [ 93.672166] Bluetooth: hci0: ACL memdump size(589824) [ 93.672475] BUG: kernel NULL pointer dereference, address: 0000000000000008 [ 93.672517] Workqueue: hci0 hci_devcd_rx [bluetooth] [ 93.672598] RIP: 0010:skb_dequeue+0x50/0x80 The issue stems from handle_dump_pkt_qca() returning 0 even when a dump packet is successfully processed. This is because it incorrectly forwards the return value of hci_devcd_init() (which returns 0 on success). As a result, the caller (btusb_recv_acl_qca() or btusb_recv_evt_qca()) assumes the packet was not handled and passes it to hci_recv_frame(), leading to premature kfree() of the skb. Later, hci_devcd_rx() attempts to dequeue the same skb from the dump queue, resulting in a NULL pointer dereference. Fix this by: 1. Making handle_dump_pkt_qca() return 0 on success and negative errno on failure, consistent with kernel conventions. 2. Splitting dump packet detection into separate functions for ACL and event packets for better structure and readability. This ensures dump packets are properly identified and consumed, avoiding double handling and preventing NULL pointer access.",,"[{""url"":""https://git.kernel.org/stable/c/0317b033abcd1d8dd2798f0e2de5e84543d0bd22"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2e8d44ebaa7babdd5c5ab50ca275826e241920d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8563d9fabd8a4b726ba7acab4737c438bf11a059"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b70b41591ec48c78ec6a885e1f57bfc4029e5e13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37919,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:28.500,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: amd: acp: Fix NULL pointer deref in acp_i2s_set_tdm_slot Update chip data using dev_get_drvdata(dev->parent) to fix NULL pointer deref in acp_i2s_set_tdm_slot.",,"[{""url"":""https://git.kernel.org/stable/c/3104b7d559ffb28f34e55028ff55a475e26e2e1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6d9b64156d849e358cb49b6b899fb0b7d262bda8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd4d8d139030dd2de97ef46d332673675ca8ad72"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37920,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:28.603,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: xsk: Fix race condition in AF_XDP generic RX path Move rx_lock from xsk_socket to xsk_buff_pool. Fix synchronization for shared umem mode in generic RX path where multiple sockets share single xsk_buff_pool. RX queue is exclusive to xsk_socket, while FILL queue can be shared between multiple sockets. This could result in race condition where two CPU cores access RX path of two different sockets sharing the same umem. Protect both queues by acquiring spinlock in shared xsk_buff_pool. Lock contention may be minimized in the future by some per-thread FQ buffering. It's safe and necessary to move spin_lock_bh(rx_lock) after xsk_rcv_check(): * xs->pool and spinlock_init is synchronized by xsk_bind() -> xsk_is_bound() memory barriers. * xsk_rcv_check() may return true at the moment of xsk_release() or xsk_unbind_dev(), however this will not cause any data races or race conditions. xsk_unbind_dev() removes xdp socket from all maps and waits for completion of all outstanding rx operations. Packets in RX path will either complete safely or drop.",,"[{""url"":""https://git.kernel.org/stable/c/65d3c570614b892257dc58a1b202908242ecf8fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/75a240a3e8abf17b9e00b0ef0492b1bbaa932251"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a1356ac7749cafc4e27aa62c0c4604b5dca4983e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37921,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:28.713,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: vxlan: vnifilter: Fix unlocked deletion of default FDB entry When a VNI is deleted from a VXLAN device in 'vnifilter' mode, the FDB entry associated with the default remote (assuming one was configured) is deleted without holding the hash lock. This is wrong and will result in a warning [1] being generated by the lockdep annotation that was added by commit ebe642067455 (""vxlan: Create wrappers for FDB lookup""). Reproducer: # ip link add vx0 up type vxlan dstport 4789 external vnifilter local 192.0.2.1 # bridge vni add vni 10010 remote 198.51.100.1 dev vx0 # bridge vni del vni 10010 dev vx0 Fix by acquiring the hash lock before the deletion and releasing it afterwards. Blame the original commit that introduced the issue rather than the one that exposed it. [1] WARNING: CPU: 3 PID: 392 at drivers/net/vxlan/vxlan_core.c:417 vxlan_find_mac+0x17f/0x1a0 [...] RIP: 0010:vxlan_find_mac+0x17f/0x1a0 [...] Call Trace: <TASK> __vxlan_fdb_delete+0xbe/0x560 vxlan_vni_delete_group+0x2ba/0x940 vxlan_vni_del.isra.0+0x15f/0x580 vxlan_process_vni_filter+0x38b/0x7b0 vxlan_vnifilter_process+0x3bb/0x510 rtnetlink_rcv_msg+0x2f7/0xb70 netlink_rcv_skb+0x131/0x360 netlink_unicast+0x426/0x710 netlink_sendmsg+0x75a/0xc20 __sock_sendmsg+0xc1/0x150 ____sys_sendmsg+0x5aa/0x7b0 ___sys_sendmsg+0xfc/0x180 __sys_sendmsg+0x121/0x1b0 do_syscall_64+0xbb/0x1d0 entry_SYSCALL_64_after_hwframe+0x4b/0x53",,"[{""url"":""https://git.kernel.org/stable/c/087a9eb9e5978e3ba362e1163691e41097e8ca20"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2d4a121296aa3940d2df9906f955c2b6b4e38bc3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3576e9a80b6c4381b01ce0cbaa07f5e92d4492ed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/470206205588559e60035fceb5f256640cb45f99"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5cb9e07f84e527974b12e82e2549fa6c0cc6eef0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37922,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:28.827,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: book3s64/radix : Align section vmemmap start address to PAGE_SIZE A vmemmap altmap is a device-provided region used to provide backing storage for struct pages. For each namespace, the altmap should belong to that same namespace. If the namespaces are created unaligned, there is a chance that the section vmemmap start address could also be unaligned. If the section vmemmap start address is unaligned, the altmap page allocated from the current namespace might be used by the previous namespace also. During the free operation, since the altmap is shared between two namespaces, the previous namespace may detect that the page does not belong to its altmap and incorrectly assume that the page is a normal page. It then attempts to free the normal page, which leads to a kernel crash. Kernel attempted to read user page (18) - exploit attempt? (uid: 0) BUG: Kernel NULL pointer dereference on read at 0x00000018 Faulting instruction address: 0xc000000000530c7c Oops: Kernel access of bad area, sig: 11 [#1] LE PAGE_SIZE=64K MMU=Radix SMP NR_CPUS=2048 NUMA pSeries CPU: 32 PID: 2104 Comm: ndctl Kdump: loaded Tainted: G W NIP: c000000000530c7c LR: c000000000530e00 CTR: 0000000000007ffe REGS: c000000015e57040 TRAP: 0300 Tainted: G W MSR: 800000000280b033 <SF,VEC,VSX,EE,FP,ME,IR,DR,RI,LE> CR: 84482404 CFAR: c000000000530dfc DAR: 0000000000000018 DSISR: 40000000 IRQMASK: 0 GPR00: c000000000530e00 c000000015e572e0 c000000002c5cb00 c00c000101008040 GPR04: 0000000000000000 0000000000000007 0000000000000001 000000000000001f GPR08: 0000000000000005 0000000000000000 0000000000000018 0000000000002000 GPR12: c0000000001d2fb0 c0000060de6b0080 0000000000000000 c0000060dbf90020 GPR16: c00c000101008000 0000000000000001 0000000000000000 c000000125b20f00 GPR20: 0000000000000001 0000000000000000 ffffffffffffffff c00c000101007fff GPR24: 0000000000000001 0000000000000000 0000000000000000 0000000000000000 GPR28: 0000000004040201 0000000000000001 0000000000000000 c00c000101008040 NIP [c000000000530c7c] get_pfnblock_flags_mask+0x7c/0xd0 LR [c000000000530e00] free_unref_page_prepare+0x130/0x4f0 Call Trace: free_unref_page+0x50/0x1e0 free_reserved_page+0x40/0x68 free_vmemmap_pages+0x98/0xe0 remove_pte_table+0x164/0x1e8 remove_pmd_table+0x204/0x2c8 remove_pud_table+0x1c4/0x288 remove_pagetable+0x1c8/0x310 vmemmap_free+0x24/0x50 section_deactivate+0x28c/0x2a0 __remove_pages+0x84/0x110 arch_remove_memory+0x38/0x60 memunmap_pages+0x18c/0x3d0 devm_action_release+0x30/0x50 release_nodes+0x68/0x140 devres_release_group+0x100/0x190 dax_pmem_compat_release+0x44/0x80 [dax_pmem_compat] device_for_each_child+0x8c/0x100 [dax_pmem_compat_remove+0x2c/0x50 [dax_pmem_compat] nvdimm_bus_remove+0x78/0x140 [libnvdimm] device_remove+0x70/0xd0 Another issue is that if there is no altmap, a PMD-sized vmemmap page will be allocated from RAM, regardless of the alignment of the section start address. If the section start address is not aligned to the PMD size, a VM_BUG_ON will be triggered when setting the PMD-sized page to page table. In this patch, we are aligning the section vmemmap start address to PAGE_SIZE. After alignment, the start address will not be part of the current namespace, and a normal page will be allocated for the vmemmap mapping of the current section. For the remaining sections, altmaps will be allocated. During the free operation, the normal page will be correctly freed. In the same way, a PMD_SIZE vmemmap page will be allocated only if the section start address is PMD_SIZE-aligned; otherwise, it will fall back to a PAGE-sized vmemmap allocation. Without this patch ================== NS1 start NS2 start _________________________________________________________ | NS1 | NS2 | --------------------------------------------------------- | Altmap| Altmap | .....|Altmap| Altmap | ........... | NS1 | NS1 ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/400be767deaf31a073c6d14c5d151ae5ac2a60e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f5476d80f2cb364701cd1fa138a14b241ca99e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9a8d4d7072d4df108479b1adc4b0840e96f6f61d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9cf7e13fecbab0894f6986fc6986ab2eba8de52e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37923,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:28.930,2025-06-04T13:15:26.850,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tracing: Fix oob write in trace_seq_to_buffer() syzbot reported this bug: ================================================================== BUG: KASAN: slab-out-of-bounds in trace_seq_to_buffer kernel/trace/trace.c:1830 [inline] BUG: KASAN: slab-out-of-bounds in tracing_splice_read_pipe+0x6be/0xdd0 kernel/trace/trace.c:6822 Write of size 4507 at addr ffff888032b6b000 by task syz.2.320/7260 CPU: 1 UID: 0 PID: 7260 Comm: syz.2.320 Not tainted 6.15.0-rc1-syzkaller-00301-g3bde70a2c827 #0 PREEMPT(full) Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 02/12/2025 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:408 [inline] print_report+0xc3/0x670 mm/kasan/report.c:521 kasan_report+0xe0/0x110 mm/kasan/report.c:634 check_region_inline mm/kasan/generic.c:183 [inline] kasan_check_range+0xef/0x1a0 mm/kasan/generic.c:189 __asan_memcpy+0x3c/0x60 mm/kasan/shadow.c:106 trace_seq_to_buffer kernel/trace/trace.c:1830 [inline] tracing_splice_read_pipe+0x6be/0xdd0 kernel/trace/trace.c:6822 .... ================================================================== It has been reported that trace_seq_to_buffer() tries to copy more data than PAGE_SIZE to buf. Therefore, to prevent this, we should use the smaller of trace_seq_used(&iter->seq) and PAGE_SIZE as an argument.",,"[{""url"":""https://git.kernel.org/stable/c/056ebbddb8faf4ddf83d005454dd78fc25c2d897"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1a3f9482b50b74fa9421bff8ceecfefd0dc06f8f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1f27a3e93b8d674b24b27fcdbc6f72743cd96c0d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/441021e5b3c7d9bd1b963590652c415929f3b157"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/665ce421041890571852422487f4c613d1824ba9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c5d2b66c5ef5037b4b4360e5447605ff00ba1bd4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f4b0174e9f18aaba59ee6ffdaf8827a7f94eb606"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f5178c41bb43444a6008150fe6094497135d07cb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37924,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:29.037,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix use-after-free in kerberos authentication Setting sess->user = NULL was introduced to fix the dangling pointer created by ksmbd_free_user. However, it is possible another thread could be operating on the session and make use of sess->user after it has been passed to ksmbd_free_user but before sess->user is set to NULL.",,"[{""url"":""https://git.kernel.org/stable/c/28c756738af44a404a91b77830d017bb0c525890"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b447463562238428503cfba1c913261047772f90"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e18c616718018dfc440e4a2d2b94e28fe91b1861"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e34a33d5d7e87399af0a138bb32f6a3e95dd83d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e86e9134e1d1c90a960dd57f59ce574d27b9a124"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37925,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-04-18T07:15:43.090,2025-08-28T15:15:47.333,Modified,[],"In the Linux kernel, the following vulnerability has been resolved: jfs: reject on-disk inodes of an unsupported type Syzbot has reported the following BUG: kernel BUG at fs/inode.c:668! Oops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI CPU: 3 UID: 0 PID: 139 Comm: jfsCommit Not tainted 6.12.0-rc4-syzkaller-00085-g4e46774408d9 #0 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-3.fc41 04/01/2014 RIP: 0010:clear_inode+0x168/0x190 Code: 4c 89 f7 e8 ba fe e5 ff e9 61 ff ff ff 44 89 f1 80 e1 07 80 c1 03 38 c1 7c c1 4c 89 f7 e8 90 ff e5 ff eb b7 0b e8 01 5d 7f ff 90 0f 0b e8 f9 5c 7f ff 90 0f 0b e8 f1 5c 7f RSP: 0018:ffffc900027dfae8 EFLAGS: 00010093 RAX: ffffffff82157a87 RBX: 0000000000000001 RCX: ffff888104d4b980 RDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000000000000 RBP: ffffc900027dfc90 R08: ffffffff82157977 R09: fffff520004fbf38 R10: dffffc0000000000 R11: fffff520004fbf38 R12: dffffc0000000000 R13: ffff88811315bc00 R14: ffff88811315bda8 R15: ffff88811315bb80 FS: 0000000000000000(0000) GS:ffff888135f00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00005565222e0578 CR3: 0000000026ef0000 CR4: 00000000000006f0 Call Trace: <TASK> ? __die_body+0x5f/0xb0 ? die+0x9e/0xc0 ? do_trap+0x15a/0x3a0 ? clear_inode+0x168/0x190 ? do_error_trap+0x1dc/0x2c0 ? clear_inode+0x168/0x190 ? __pfx_do_error_trap+0x10/0x10 ? report_bug+0x3cd/0x500 ? handle_invalid_op+0x34/0x40 ? clear_inode+0x168/0x190 ? exc_invalid_op+0x38/0x50 ? asm_exc_invalid_op+0x1a/0x20 ? clear_inode+0x57/0x190 ? clear_inode+0x167/0x190 ? clear_inode+0x168/0x190 ? clear_inode+0x167/0x190 jfs_evict_inode+0xb5/0x440 ? __pfx_jfs_evict_inode+0x10/0x10 evict+0x4ea/0x9b0 ? __pfx_evict+0x10/0x10 ? iput+0x713/0xa50 txUpdateMap+0x931/0xb10 ? __pfx_txUpdateMap+0x10/0x10 jfs_lazycommit+0x49a/0xb80 ? _raw_spin_unlock_irqrestore+0x8f/0x140 ? lockdep_hardirqs_on+0x99/0x150 ? __pfx_jfs_lazycommit+0x10/0x10 ? __pfx_default_wake_function+0x10/0x10 ? __kthread_parkme+0x169/0x1d0 ? __pfx_jfs_lazycommit+0x10/0x10 kthread+0x2f2/0x390 ? __pfx_jfs_lazycommit+0x10/0x10 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x4d/0x80 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK> This happens when 'clear_inode()' makes an attempt to finalize an underlying JFS inode of unknown type. According to JFS layout description from https://jfs.sourceforge.net/project/pub/jfslayout.pdf, inode types from 5 to 15 are reserved for future extensions and should not be encountered on a valid filesystem. So add an extra check for valid inode type in 'copy_from_dinode()'.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""NVD-CWE-noinfo""}]}]","[{""url"":""https://git.kernel.org/stable/c/28419a4f3a1eeee33472a1b3856ae62aaa5a649b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/45fd8421081ec79e661e5f3ead2934fdbddb4287"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8987891c4653874d5e3f5d11f063912f4e0b58eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/8c3f9a70d2d4dd6c640afe294b05c6a0a45434d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/afc08b0b5587b553799bc375957706936a3e0088"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa6ce4a9cc9fcc8150b80db6f65186c0ed2b3143"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""3.1"",""versionEndExcluding"":""6.14.2"",""matchCriteriaId"":""2989FFC5-ECF9-4B72-ADBA-78A3A5220C13""}]}]}]",,,,,,,,
CVE-2025-37926,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:29.140,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix use-after-free in ksmbd_session_rpc_open A UAF issue can occur due to a race condition between ksmbd_session_rpc_open() and __session_rpc_close(). Add rpc_lock to the session to protect it.",,"[{""url"":""https://git.kernel.org/stable/c/6323fec65fe54b365961fed260dd579191e46121"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8fb3b6c85b7e3127161623586b62abcc366caa20"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a1f46c99d9ea411f9bf30025b912d881d36fc709"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37927,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:29.240,2025-06-04T13:15:26.970,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iommu/amd: Fix potential buffer overflow in parse_ivrs_acpihid There is a string parsing logic error which can lead to an overflow of hid or uid buffers. Comparing ACPIID_LEN against a total string length doesn't take into account the lengths of individual hid and uid buffers so the check is insufficient in some cases. For example if the length of hid string is 4 and the length of the uid string is 260, the length of str will be equal to ACPIID_LEN + 1 but uid string will overflow uid buffer which size is 256. The same applies to the hid string with length 13 and uid string with length 250. Check the length of hid and uid strings separately to prevent buffer overflow. Found by Linux Verification Center (linuxtesting.org) with SVACE.",,"[{""url"":""https://git.kernel.org/stable/c/10d901a95f8e766e5aa0bb9a983fb41271f64718"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/13d67528e1ae4486e9ab24b70122fab104c73c29"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2b65060c84ee4d8dc64fae6d2728b528e9e832e1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/466d9da267079a8d3b69fa72dfa3a732e1f6dbb5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8dee308e4c01dea48fc104d37f92d5b58c50b96c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a65ebfed65fa62797ec1f5f1dcf7adb157a2de1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c3f37faa71f5d26dd2144b3f2b14525ec8f5e41f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c8bdfc0297965bb13fa439d36ca9c4f7c8447f0f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37928,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:29.363,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dm-bufio: don't schedule in atomic context A BUG was reported as below when CONFIG_DEBUG_ATOMIC_SLEEP and try_verify_in_tasklet are enabled. [ 129.444685][ T934] BUG: sleeping function called from invalid context at drivers/md/dm-bufio.c:2421 [ 129.444723][ T934] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 934, name: kworker/1:4 [ 129.444740][ T934] preempt_count: 201, expected: 0 [ 129.444756][ T934] RCU nest depth: 0, expected: 0 [ 129.444781][ T934] Preemption disabled at: [ 129.444789][ T934] [<ffffffd816231900>] shrink_work+0x21c/0x248 [ 129.445167][ T934] kernel BUG at kernel/sched/walt/walt_debug.c:16! [ 129.445183][ T934] Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP [ 129.445204][ T934] Skip md ftrace buffer dump for: 0x1609e0 [ 129.447348][ T934] CPU: 1 PID: 934 Comm: kworker/1:4 Tainted: G W OE 6.6.56-android15-8-o-g6f82312b30b9-debug #1 1400000003000000474e5500b3187743670464e8 [ 129.447362][ T934] Hardware name: Qualcomm Technologies, Inc. Parrot QRD, Alpha-M (DT) [ 129.447373][ T934] Workqueue: dm_bufio_cache shrink_work [ 129.447394][ T934] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 129.447406][ T934] pc : android_rvh_schedule_bug+0x0/0x8 [sched_walt_debug] [ 129.447435][ T934] lr : __traceiter_android_rvh_schedule_bug+0x44/0x6c [ 129.447451][ T934] sp : ffffffc0843dbc90 [ 129.447459][ T934] x29: ffffffc0843dbc90 x28: ffffffffffffffff x27: 0000000000000c8b [ 129.447479][ T934] x26: 0000000000000040 x25: ffffff804b3d6260 x24: ffffffd816232b68 [ 129.447497][ T934] x23: ffffff805171c5b4 x22: 0000000000000000 x21: ffffffd816231900 [ 129.447517][ T934] x20: ffffff80306ba898 x19: 0000000000000000 x18: ffffffc084159030 [ 129.447535][ T934] x17: 00000000d2b5dd1f x16: 00000000d2b5dd1f x15: ffffffd816720358 [ 129.447554][ T934] x14: 0000000000000004 x13: ffffff89ef978000 x12: 0000000000000003 [ 129.447572][ T934] x11: ffffffd817a823c4 x10: 0000000000000202 x9 : 7e779c5735de9400 [ 129.447591][ T934] x8 : ffffffd81560d004 x7 : 205b5d3938373434 x6 : ffffffd8167397c8 [ 129.447610][ T934] x5 : 0000000000000000 x4 : 0000000000000001 x3 : ffffffc0843db9e0 [ 129.447629][ T934] x2 : 0000000000002f15 x1 : 0000000000000000 x0 : 0000000000000000 [ 129.447647][ T934] Call trace: [ 129.447655][ T934] android_rvh_schedule_bug+0x0/0x8 [sched_walt_debug 1400000003000000474e550080cce8a8a78606b6] [ 129.447681][ T934] __might_resched+0x190/0x1a8 [ 129.447694][ T934] shrink_work+0x180/0x248 [ 129.447706][ T934] process_one_work+0x260/0x624 [ 129.447718][ T934] worker_thread+0x28c/0x454 [ 129.447729][ T934] kthread+0x118/0x158 [ 129.447742][ T934] ret_from_fork+0x10/0x20 [ 129.447761][ T934] Code: ???????? ???????? ???????? d2b5dd1f (d4210000) [ 129.447772][ T934] ---[ end trace 0000000000000000 ]--- dm_bufio_lock will call spin_lock_bh when try_verify_in_tasklet is enabled, and __scan will be called in atomic context.",,"[{""url"":""https://git.kernel.org/stable/c/69a37b3ba85088fc6b903b8e1db7f0a1d4d0b52d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a3d8f0a7f5e8b193db509c7191fefeed3533fc44"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a99f5bf4f7197009859dbce14c12f8e2ce5a5a69"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c8c83052283bcf2fdd467a33d1d2bd5ba36e935a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f45108257280e0a1cc951ce254853721b40c0812"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37929,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:29.483,2025-06-27T11:15:24.827,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: arm64: errata: Add missing sentinels to Spectre-BHB MIDR arrays Commit a5951389e58d (""arm64: errata: Add newer ARM cores to the spectre_bhb_loop_affected() lists"") added some additional CPUs to the Spectre-BHB workaround, including some new arrays for designs that require new 'k' values for the workaround to be effective. Unfortunately, the new arrays omitted the sentinel entry and so is_midr_in_range_list() will walk off the end when it doesn't find a match. With UBSAN enabled, this leads to a crash during boot when is_midr_in_range_list() is inlined (which was more common prior to c8c2647e69be (""arm64: Make _midr_in_range_list() an exported function"")): | Internal error: aarch64 BRK: 00000000f2000001 [#1] PREEMPT SMP | pstate: 804000c5 (Nzcv daIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--) | pc : spectre_bhb_loop_affected+0x28/0x30 | lr : is_spectre_bhb_affected+0x170/0x190 | [...] | Call trace: | spectre_bhb_loop_affected+0x28/0x30 | update_cpu_capabilities+0xc0/0x184 | init_cpu_features+0x188/0x1a4 | cpuinfo_store_boot_cpu+0x4c/0x60 | smp_prepare_boot_cpu+0x38/0x54 | start_kernel+0x8c/0x478 | __primary_switched+0xc8/0xd4 | Code: 6b09011f 54000061 52801080 d65f03c0 (d4200020) | ---[ end trace 0000000000000000 ]--- | Kernel panic - not syncing: aarch64 BRK: Fatal exception Add the missing sentinel entries.",,"[{""url"":""https://git.kernel.org/stable/c/090c8714efe1c3c470301cc2f794c1ee2a57746c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/333579202f09e260e8116321df4c55f80a19b160"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3821cae9bd5a99a42d3d0be1b58e41f072cd4c4c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/446289b8b36b2ee98dabf6388acbddcc33ed41be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6266b3509b2c6ebf2f9daf2239ff8eb60c5f5bd3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e68da90ac00d8b681561aeb8f5d6c47af3a04861"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fee4d171451c1ad9e8aaf65fc0ab7d143a33bd72"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37930,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:29.600,2025-06-04T13:15:27.087,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/nouveau: Fix WARN_ON in nouveau_fence_context_kill() Nouveau is mostly designed in a way that it's expected that fences only ever get signaled through nouveau_fence_signal(). However, in at least one other place, nouveau_fence_done(), can signal fences, too. If that happens (race) a signaled fence remains in the pending list for a while, until it gets removed by nouveau_fence_update(). Should nouveau_fence_context_kill() run in the meantime, this would be a bug because the function would attempt to set an error code on an already signaled fence. Have nouveau_fence_context_kill() check for a fence being signaled.",,"[{""url"":""https://git.kernel.org/stable/c/0453825167ecc816ec15c736e52316f69db0deb9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/126f5c6e0cb84e5c6f7a3a856d799d85668fb38e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2ec0f5f6d4768f292c8406ed92fa699f184577e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/39d6e889c0b19a2c79e1c74c843ea7c2d0f99c28"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/47ca11836c35c5698088fd87f7fb4b0ffa217e17"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b771b2017260ffc3a8d4e81266619649bffcb242"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bbe5679f30d7690a9b6838a583b9690ea73fe0e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37931,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:29.713,2025-09-09T17:15:43.950,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: adjust subpage bit start based on sectorsize When running machines with 64k page size and a 16k nodesize we started seeing tree log corruption in production. This turned out to be because we were not writing out dirty blocks sometimes, so this in fact affects all metadata writes. When writing out a subpage EB we scan the subpage bitmap for a dirty range. If the range isn't dirty we do bit_start++; to move onto the next bit. The problem is the bitmap is based on the number of sectors that an EB has. So in this case, we have a 64k pagesize, 16k nodesize, but a 4k sectorsize. This means our bitmap is 4 bits for every node. With a 64k page size we end up with 4 nodes per page. To make this easier this is how everything looks [0 16k 32k 48k ] logical address [0 4 8 12 ] radix tree offset [ 64k page ] folio [ 16k eb ][ 16k eb ][ 16k eb ][ 16k eb ] extent buffers [ | | | | | | | | | | | | | | | | ] bitmap Now we use all of our addressing based on fs_info->sectorsize_bits, so as you can see the above our 16k eb->start turns into radix entry 4. When we find a dirty range for our eb, we correctly do bit_start += sectors_per_node, because if we start at bit 0, the next bit for the next eb is 4, to correspond to eb->start 16k. However if our range is clean, we will do bit_start++, which will now put us offset from our radix tree entries. In our case, assume that the first time we check the bitmap the block is not dirty, we increment bit_start so now it == 1, and then we loop around and check again. This time it is dirty, and we go to find that start using the following equation start = folio_start + bit_start * fs_info->sectorsize; so in the case above, eb->start 0 is now dirty, and we calculate start as 0 + 1 * fs_info->sectorsize = 4096 4096 >> 12 = 1 Now we're looking up the radix tree for 1, and we won't find an eb. What's worse is now we're using bit_start == 1, so we do bit_start += sectors_per_node, which is now 5. If that eb is dirty we will run into the same thing, we will look at an offset that is not populated in the radix tree, and now we're skipping the writeout of dirty extent buffers. The best fix for this is to not use sectorsize_bits to address nodes, but that's a larger change. Since this is a fs corruption problem fix it simply by always using sectors_per_node to increment the start bit.",,"[{""url"":""https://git.kernel.org/stable/c/396f4002710030ea1cfd4c789ebaf0a6969ab34f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5111b148360f50cac9abbae8fca44cc0ac4bf9bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/977849e8acd2466ac3cb49e04a3ecc73837f6b90"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b80db09b614cb7edec5bada1bc7c7b0eb3b453ea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e08e49d986f82c30f42ad0ed43ebbede1e1e3739"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37932,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:29.817,2025-08-28T15:15:47.513,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: sch_htb: make htb_qlen_notify() idempotent htb_qlen_notify() always deactivates the HTB class and in fact could trigger a warning if it is already deactivated. Therefore, it is not idempotent and not friendly to its callers, like fq_codel_dequeue(). Let's make it idempotent to ease qdisc_tree_reduce_backlog() callers' life.",,"[{""url"":""https://git.kernel.org/stable/c/0a188c0e197383683fd093ab1ea6ce9a5869a6ea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/32ae12ce6a9f6bace186ca7335220ff59b6cc3cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5ba8b837b522d7051ef81bacf3d95383ff8edce5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73cf6af13153d62f9b76eff422eea79dbc70f15e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/967955c9e57f8eebfccc298037d4aaf3d42bc1c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a61f1b5921761fbaf166231418bc1db301e5bf59"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bbbf5e0f87078b715e7a665d662a2c0e77f044ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e6b45f4de763b00dc1c55e685e2dd1aaf525d3c1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37933,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:29.933,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: octeon_ep: Fix host hang issue during device reboot When the host loses heartbeat messages from the device, the driver calls the device-specific ndo_stop function, which frees the resources. If the driver is unloaded in this scenario, it calls ndo_stop again, attempting to free resources that have already been freed, leading to a host hang issue. To resolve this, dev_close should be called instead of the device-specific stop function.dev_close internally calls ndo_stop to stop the network interface and performs additional cleanup tasks. During the driver unload process, if the device is already down, ndo_stop is not called.",,"[{""url"":""https://git.kernel.org/stable/c/34f42736b325287a7b2ce37e415838f539767bda"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6d1052423518e7d0aece9af5e77bbc324face8f1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7e1ca1bed3f66e00377f7d2147be390144924276"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c8d788f800f83b94d9db8b3dacc1d26be38a6ef4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37934,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:30.053,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: simple-card-utils: Fix pointer check in graph_util_parse_link_direction Actually check if the passed pointers are valid, before writing to them. This also fixes a USBAN warning: UBSAN: invalid-load in ../sound/soc/fsl/imx-card.c:687:25 load of value 255 is not a valid value for type '_Bool' This is because playback_only is uninitialized and is not written to, as the playback-only property is absent.",,"[{""url"":""https://git.kernel.org/stable/c/3cc393d2232ec770b5f79bf0673d67702a3536c3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9b5b3088c4d1752253491705919bd7d067964288"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b41a49d5435e0f76da320f231b7252800e8f736f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37935,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:30.170,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: ethernet: mtk_eth_soc: fix SER panic with 4GB+ RAM If the mtk_poll_rx() function detects the MTK_RESETTING flag, it will jump to release_desc and refill the high word of the SDP on the 4GB RFB. Subsequently, mtk_rx_clean will process an incorrect SDP, leading to a panic. Add patch from MediaTek's SDK to resolve this.",,"[{""url"":""https://git.kernel.org/stable/c/317013d1ad13524be02d60b9e98f08fbd13f8c14"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/67619cf69dec5d1d7792808dfa548616742dd51d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6e0490fc36cdac696f96e57b61d93b9ae32e0f4c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cb625f783f70dc6614f03612b8e64ad99cb0a13c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37936,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:30.443,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: perf/x86/intel: KVM: Mask PEBS_ENABLE loaded for guest with vCPU's value. When generating the MSR_IA32_PEBS_ENABLE value that will be loaded on VM-Entry to a KVM guest, mask the value with the vCPU's desired PEBS_ENABLE value. Consulting only the host kernel's host vs. guest masks results in running the guest with PEBS enabled even when the guest doesn't want to use PEBS. Because KVM uses perf events to proxy the guest virtual PMU, simply looking at exclude_host can't differentiate between events created by host userspace, and events created by KVM on behalf of the guest. Running the guest with PEBS unexpectedly enabled typically manifests as crashes due to a near-infinite stream of #PFs. E.g. if the guest hasn't written MSR_IA32_DS_AREA, the CPU will hit page faults on address '0' when trying to record PEBS events. The issue is most easily reproduced by running `perf kvm top` from before commit 7b100989b4f6 (""perf evlist: Remove __evlist__add_default"") (after which, `perf kvm top` effectively stopped using PEBS). The userspace side of perf creates a guest-only PEBS event, which intel_guest_get_msrs() misconstrues a guest-*owned* PEBS event. Arguably, this is a userspace bug, as enabling PEBS on guest-only events simply cannot work, and userspace can kill VMs in many other ways (there is no danger to the host). However, even if this is considered to be bad userspace behavior, there's zero downside to perf/KVM restricting PEBS to guest-owned events. Note, commit 854250329c02 (""KVM: x86/pmu: Disable guest PEBS temporarily in two rare situations"") fixed the case where host userspace is profiling KVM *and* userspace, but missed the case where userspace is profiling only KVM.",,"[{""url"":""https://git.kernel.org/stable/c/160153cf9e4aa875ad086cc094ce34aac8e13d63"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/34b6fa11431aef71045ae5a00d90a7d630597eda"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/44ee0afc9d1e7a7c1932698de01362ed80cfc4b5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/58f6217e5d0132a9f14e401e62796916aa055c1b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/86aa62895fc2fb7ab09d7ca40fae8ad09841f66b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37937,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:30.760,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: objtool, media: dib8000: Prevent divide-by-zero in dib8000_set_dds() If dib8000_set_dds()'s call to dib8000_read32() returns zero, the result is a divide-by-zero. Prevent that from happening. Fixes the following warning with an UBSAN kernel: drivers/media/dvb-frontends/dib8000.o: warning: objtool: dib8000_tune() falls through to next function dib8096p_cfg_DibRx()",,"[{""url"":""https://git.kernel.org/stable/c/536f7f3595ef8187cfa9ea50d7d24fcf4e84e166"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6cfe46036b163e5a0f07c6b705b518148e1a8b2f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/75b42dfe87657ede3da3f279bd6b1b16d69af954"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/976a85782246a29ba0f6d411a7a4f524cb9ea987"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9b76b198cf209797abcb1314c18ddeb90fe0827b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b9249da6b0ed56269d4f21850df8e5b35dab50bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c8430e72b99936c206b37a8e2daebb3f8df7f2d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd80277f652138d2619f149f86ae6d17bce721d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e63d465f59011dede0a0f1d21718b59a64c3ff5c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37938,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:31.127,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tracing: Verify event formats that have ""%*p.."" The trace event verifier checks the formats of trace events to make sure that they do not point at memory that is not in the trace event itself or in data that will never be freed. If an event references data that was allocated when the event triggered and that same data is freed before the event is read, then the kernel can crash by reading freed memory. The verifier runs at boot up (or module load) and scans the print formats of the events and checks their arguments to make sure that dereferenced pointers are safe. If the format uses ""%*p.."" the verifier will ignore it, and that could be dangerous. Cover this case as well. Also add to the sample code a use case of ""%*pbl"".",,"[{""url"":""https://git.kernel.org/stable/c/03127354027508d076073b020d3070990fd6a958"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/04b80d45ecfaf780981d6582899e3ab205e4aa08"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4d11fac941d83509be4e6a21038281d6d96da50c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6854c87ac823181c810f8c07489ba543260c0023"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c7204fd1758c0caf1938e8a59809a1fdf28a8114"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ea8d7647f9ddf1f81e2027ed305299797299aa03"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37939,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:31.467,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: libbpf: Fix accessing BTF.ext core_relo header Update btf_ext_parse_info() to ensure the core_relo header is present before reading its fields. This avoids a potential buffer read overflow reported by the OSS Fuzz project.",,"[{""url"":""https://git.kernel.org/stable/c/0a7c2a84359612e54328aa52030eb202093da6e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3a67f60f0a8be10cea7a884a1a00e9feb6645657"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d529411ec44535308c5d59cbeff74be6fe14b479"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37940,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:31.737,2025-05-21T20:25:16.407,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ftrace: Add cond_resched() to ftrace_graph_set_hash() When the kernel contains a large number of functions that can be traced, the loop in ftrace_graph_set_hash() may take a lot of time to execute. This may trigger the softlockup watchdog. Add cond_resched() within the loop to allow the kernel to remain responsive even when processing a large number of functions. This matches the cond_resched() that is used in other locations of the code that iterates over all functions that can be traced.",,"[{""url"":""https://git.kernel.org/stable/c/1fce9574b9d515bcb8a75379a8053e18602424e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/42ea22e754ba4f2b86f8760ca27f6f71da2d982c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4429535acab750d963fdc3dfcc9e0eee42f4d599"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5d336ac215e5c76e43ef4bca9ba699835e53e2fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/618655d54c5f8af5d57b77491d08c0f0ff77d114"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/72be43ff061a889c6ee648a330a42486cafa15a6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8dd7d7280357596ba63dfdb4c1725d9dd24bd42a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dd38803c9088b848c6b56f4f6d7efc4497bfde61"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e5b4ae6f01d4a510d5725eca7254519a1093920d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37941,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:31.883,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: codecs: wcd937x: fix a potential memory leak in wcd937x_soc_codec_probe() When snd_soc_dapm_new_controls() or snd_soc_dapm_add_routes() fails, wcd937x_soc_codec_probe() returns without releasing 'wcd937x->clsh_info', which is allocated by wcd_clsh_ctrl_alloc. Add wcd_clsh_ctrl_free() to prevent potential memory leak.",,"[{""url"":""https://git.kernel.org/stable/c/3e330acf4efd63876d673c046cd073a1d4ed57a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aafb5325aca3e806b3ea3707402189263473d257"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/acadb2e2b3c5b9977a843a3a94fece9bdcf6aea1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b573e04116fd33b9143fa276bbab2f0afad0a1ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37942,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:32.000,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: HID: pidff: Make sure to fetch pool before checking SIMULTANEOUS_MAX As noted by Anssi some 20 years ago, pool report is sometimes messed up. This worked fine on many devices but casued oops on VRS DirectForce PRO. Here, we're making sure pool report is refetched before trying to access any of it's fields. While loop was replaced with a for loop + exit conditions were moved aroud to decrease the possibility of creating an infinite loop scenario.",,"[{""url"":""https://git.kernel.org/stable/c/1f650dcec32d22deb1d6db12300a2b98483099a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/211861869766a7bb7c72158aee0140ec67e182a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/344d903be8b5c0733ed0f4bc5be34b4a26d905c8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6f5d30a5c7713238c5c65c98ad95dacb73688d5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37943,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:32.133,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: Fix invalid data access in ath12k_dp_rx_h_undecap_nwifi In certain cases, hardware might provide packets with a length greater than the maximum native Wi-Fi header length. This can lead to accessing and modifying fields in the header within the ath12k_dp_rx_h_undecap_nwifi function for DP_RX_DECAP_TYPE_NATIVE_WIFI decap type and potentially resulting in invalid data access and memory corruption. Add a sanity check before processing the SKB to prevent invalid data access in the undecap native Wi-Fi function for the DP_RX_DECAP_TYPE_NATIVE_WIFI decap type. Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1",,"[{""url"":""https://git.kernel.org/stable/c/3abe15e756481c45f6acba3d476cb3ca4afc3b61"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/50be1fb76556e80af9f5da80f28168b6c71bce58"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6ee653194ddb83674913fd2727b8ecfae0597ade"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f1d986da5c6abb75ffe4d0d325fc9b341c41a1c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9a0dddfb30f120db3851627935851d262e4e7acb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37944,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:32.310,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: Fix invalid entry fetch in ath12k_dp_mon_srng_process Currently, ath12k_dp_mon_srng_process uses ath12k_hal_srng_src_get_next_entry to fetch the next entry from the destination ring. This is incorrect because ath12k_hal_srng_src_get_next_entry is intended for source rings, not destination rings. This leads to invalid entry fetches, causing potential data corruption or crashes due to accessing incorrect memory locations. This happens because the source ring and destination ring have different handling mechanisms and using the wrong function results in incorrect pointer arithmetic and ring management. To fix this issue, replace the call to ath12k_hal_srng_src_get_next_entry with ath12k_hal_srng_dst_get_next_entry in ath12k_dp_mon_srng_process. This ensures that the correct function is used for fetching entries from the destination ring, preventing invalid memory accesses. Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1 Tested-on: WCN7850 hw2.0 WLAN.HMT.1.0.c5-00481-QCAHMTSWPL_V1.0_V2.0_SILICONZ-3",,"[{""url"":""https://git.kernel.org/stable/c/298f0aea5cb32b5038f991f5db201a0fcbb9a31b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2c512f2eadabb1e80816116894ffaf7d802a944e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/63fdc4509bcf483e79548de6bc08bf3c8e504bb3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ab7edf42ce800eb34d2f73dd7271b826661a06a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b6a3b2b2cead103089d3bb7a57d8209bdfa5399d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37945,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:32.453,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: phy: allow MDIO bus PM ops to start/stop state machine for phylink-controlled PHY DSA has 2 kinds of drivers: 1. Those who call dsa_switch_suspend() and dsa_switch_resume() from their device PM ops: qca8k-8xxx, bcm_sf2, microchip ksz 2. Those who don't: all others. The above methods should be optional. For type 1, dsa_switch_suspend() calls dsa_user_suspend() -> phylink_stop(), and dsa_switch_resume() calls dsa_user_resume() -> phylink_start(). These seem good candidates for setting mac_managed_pm = true because that is essentially its definition [1], but that does not seem to be the biggest problem for now, and is not what this change focuses on. Talking strictly about the 2nd category of DSA drivers here (which do not have MAC managed PM, meaning that for their attached PHYs, mdio_bus_phy_suspend() and mdio_bus_phy_resume() should run in full), I have noticed that the following warning from mdio_bus_phy_resume() is triggered: WARN_ON(phydev->state != PHY_HALTED && phydev->state != PHY_READY && phydev->state != PHY_UP); because the PHY state machine is running. It's running as a result of a previous dsa_user_open() -> ... -> phylink_start() -> phy_start() having been initiated by the user. The previous mdio_bus_phy_suspend() was supposed to have called phy_stop_machine(), but it didn't. So this is why the PHY is in state PHY_NOLINK by the time mdio_bus_phy_resume() runs. mdio_bus_phy_suspend() did not call phy_stop_machine() because for phylink, the phydev->adjust_link function pointer is NULL. This seems a technicality introduced by commit fddd91016d16 (""phylib: fix PAL state machine restart on resume""). That commit was written before phylink existed, and was intended to avoid crashing with consumer drivers which don't use the PHY state machine - phylink always does, when using a PHY. But phylink itself has historically not been developed with suspend/resume in mind, and apparently not tested too much in that scenario, allowing this bug to exist unnoticed for so long. Plus, prior to the WARN_ON(), it would have likely been invisible. This issue is not in fact restricted to type 2 DSA drivers (according to the above ad-hoc classification), but can be extrapolated to any MAC driver with phylink and MDIO-bus-managed PHY PM ops. DSA is just where the issue was reported. Assuming mac_managed_pm is set correctly, a quick search indicates the following other drivers might be affected: $ grep -Zlr PHYLINK_NETDEV drivers/ | xargs -0 grep -L mac_managed_pm drivers/net/ethernet/atheros/ag71xx.c drivers/net/ethernet/microchip/sparx5/sparx5_main.c drivers/net/ethernet/microchip/lan966x/lan966x_main.c drivers/net/ethernet/freescale/dpaa2/dpaa2-mac.c drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c drivers/net/ethernet/freescale/dpaa/dpaa_eth.c drivers/net/ethernet/freescale/ucc_geth.c drivers/net/ethernet/freescale/enetc/enetc_pf_common.c drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c drivers/net/ethernet/marvell/mvneta.c drivers/net/ethernet/marvell/prestera/prestera_main.c drivers/net/ethernet/mediatek/mtk_eth_soc.c drivers/net/ethernet/altera/altera_tse_main.c drivers/net/ethernet/wangxun/txgbe/txgbe_phy.c drivers/net/ethernet/meta/fbnic/fbnic_phylink.c drivers/net/ethernet/tehuti/tn40_phy.c drivers/net/ethernet/mscc/ocelot_net.c Make the existing conditions dependent on the PHY device having a phydev->phy_link_change() implementation equal to the default phy_link_change() provided by phylib. Otherwise, we implicitly know that the phydev has the phylink-provided phylink_phy_change() callback, and when phylink is used, the PHY state machine always needs to be stopped/ started on the suspend/resume path. The code is structured as such that if phydev->phy_link_change() is absent, it is a matter of time until the kernel will crash - no need to further complicate the test. Thus, for the situation where the PM is not managed b ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/54e5d00a8de6c13f6c01a94ed48025e882cd15f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6ed6f8ec81b8ca7100dcd9e62bdbc0dff1b2259"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd4037d51d3f6667636a1383e78e48a5b7b60755"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc75ea20ffb452652f0d4033f38fe88d7cfdae35"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37946,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:32.577,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: s390/pci: Fix duplicate pci_dev_put() in disable_slot() when PF has child VFs With commit bcb5d6c76903 (""s390/pci: introduce lock to synchronize state of zpci_dev's"") the code to ignore power off of a PF that has child VFs was changed from a direct return to a goto to the unlock and pci_dev_put() section. The change however left the existing pci_dev_put() untouched resulting in a doubple put. This can subsequently cause a use after free if the struct pci_dev is released in an unexpected state. Fix this by removing the extra pci_dev_put().",,"[{""url"":""https://git.kernel.org/stable/c/05a2538f2b48500cf4e8a0a0ce76623cc5bafcf1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/957529baef142d95e0d1b1bea786675bd47dbe53"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c488f8b53e156d6dcc0514ef0afa3a33376b8f9e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37947,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:32.677,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: prevent out-of-bounds stream writes by validating *pos ksmbd_vfs_stream_write() did not validate whether the write offset (*pos) was within the bounds of the existing stream data length (v_len). If *pos was greater than or equal to v_len, this could lead to an out-of-bounds memory write. This patch adds a check to ensure *pos is less than v_len before proceeding. If the condition fails, -EINVAL is returned.",,"[{""url"":""https://git.kernel.org/stable/c/04c8a38c60346bb5a7c49b276de7233f703ce9cb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0ca6df4f40cf4c32487944aaf48319cb6c25accc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f61da79df86fd140c7768e668ad846bfa7ec8e1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d62ba16563a86aae052f96d270b3b6f78fca154c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e6356499fd216ed6343ae0363f4c9303f02c5034"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37948,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:32.800,2025-06-27T11:15:24.947,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: arm64: bpf: Add BHB mitigation to the epilogue for cBPF programs A malicious BPF program may manipulate the branch history to influence what the hardware speculates will happen next. On exit from a BPF program, emit the BHB mititgation sequence. This is only applied for 'classic' cBPF programs that are loaded by seccomp.",,"[{""url"":""https://git.kernel.org/stable/c/0dfefc2ea2f29ced2416017d7e5b1253a54c2735"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/38c345fd54afd9d6ed8d3fcddf3f6ea23887bf78"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/42a20cf51011788f04cf2adbcd7681f02bdb6c27"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/852b8ae934b5cbdc62496fa56ce9969aa2edda7f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8fe5c37b0e08a97cf0210bb75970e945aaaeebab"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/993f63239c219696aef8887a4e7d3a16bf5a8ece"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c6a8735d841bcb7649734bb3a787bb174c67c0d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37949,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:32.920,2025-06-04T13:15:27.320,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: xenbus: Use kref to track req lifetime Marek reported seeing a NULL pointer fault in the xenbus_thread callstack: BUG: kernel NULL pointer dereference, address: 0000000000000000 RIP: e030:__wake_up_common+0x4c/0x180 Call Trace: <TASK> __wake_up_common_lock+0x82/0xd0 process_msg+0x18e/0x2f0 xenbus_thread+0x165/0x1c0 process_msg+0x18e is req->cb(req). req->cb is set to xs_wake_up(), a thin wrapper around wake_up(), or xenbus_dev_queue_reply(). It seems like it was xs_wake_up() in this case. It seems like req may have woken up the xs_wait_for_reply(), which kfree()ed the req. When xenbus_thread resumes, it faults on the zero-ed data. Linux Device Drivers 2nd edition states: ""Normally, a wake_up call can cause an immediate reschedule to happen, meaning that other processes might run before wake_up returns."" ... which would match the behaviour observed. Change to keeping two krefs on each request. One for the caller, and one for xenbus_thread. Each will kref_put() when finished, and the last will free it. This use of kref matches the description in Documentation/core-api/kref.rst",,"[{""url"":""https://git.kernel.org/stable/c/0e94a246bb6d9538010b6c02d2b1d4717a97b2e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1f0304dfd9d217c2f8b04a9ef4b3258a66eedd27"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2466b0f66795c3c426cacc8998499f38031dbb59"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4d260a5558df4650eb87bc41b2c9ac2d6b2ba447"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8b02f85e84dc6f7c150cef40ddb69af5a25659e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e9c8a0393b5f85f1820c565ab8105660f4e8f92"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cbfaf46b88a4c01b64c4186cdccd766c19ae644c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1bcac367bc95631afbb918348f30dec887d0e1b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37950,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:33.107,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ocfs2: fix panic in failed foilio allocation commit 7e119cff9d0a (""ocfs2: convert w_pages to w_folios"") and commit 9a5e08652dc4b (""ocfs2: use an array of folios instead of an array of pages"") save -ENOMEM in the folio array upon allocation failure and call the folio array free code. The folio array free code expects either valid folio pointers or NULL. Finding the -ENOMEM will result in a panic. Fix by NULLing the error folio entry.",,"[{""url"":""https://git.kernel.org/stable/c/31d4cd4eb2f8d9b87ebfa6a5e443a59e3b3d7b8c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/80d18f060d5bdf2c5eb3d1d00dcb744d6a879222"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37951,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:33.220,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/v3d: Add job to pending list if the reset was skipped When a CL/CSD job times out, we check if the GPU has made any progress since the last timeout. If so, instead of resetting the hardware, we skip the reset and let the timer get rearmed. This gives long-running jobs a chance to complete. However, when `timedout_job()` is called, the job in question is removed from the pending list, which means it won't be automatically freed through `free_job()`. Consequently, when we skip the reset and keep the job running, the job won't be freed when it finally completes. This situation leads to a memory leak, as exposed in [1] and [2]. Similarly to commit 704d3d60fec4 (""drm/etnaviv: don't block scheduler when GPU is still active""), this patch ensures the job is put back on the pending list when extending the timeout.",,"[{""url"":""https://git.kernel.org/stable/c/12125f7d9c15e6d8ac91d10373b2db2f17dcf767"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/35e4079bf1a2570abffce6ababa631afcf8ea0e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/422a8b10ba42097a704d6909ada2956f880246f2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5235b56b7e5449d990d21d78723b1a5e7bb5738e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a5f162727b91e480656da1876247a91f651f76de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37952,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:33.353,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: Fix UAF in __close_file_table_ids A use-after-free is possible if one thread destroys the file via __ksmbd_close_fd while another thread holds a reference to it. The existing checks on fp->refcount are not sufficient to prevent this. The fix takes ft->lock around the section which removes the file from the file table. This prevents two threads acquiring the same file pointer via __close_file_table_ids, as well as the other functions which retrieve a file from the IDR and which already use this same lock.",,"[{""url"":""https://git.kernel.org/stable/c/16727e442568a46d9cca69fe2595896de86e120d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/36991c1ccde2d5a521577c448ffe07fcccfe104d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9e9841e232b51171ddf3bc4ee517d5d28dc8cad6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fec1f9e9a650e8e7011330a085c77e7bf2a08ea9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37953,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:33.483,2025-08-28T15:15:47.660,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: sch_htb: make htb_deactivate() idempotent Alan reported a NULL pointer dereference in htb_next_rb_node() after we made htb_qlen_notify() idempotent. It turns out in the following case it introduced some regression: htb_dequeue_tree(): |-> fq_codel_dequeue() |-> qdisc_tree_reduce_backlog() |-> htb_qlen_notify() |-> htb_deactivate() |-> htb_next_rb_node() |-> htb_deactivate() For htb_next_rb_node(), after calling the 1st htb_deactivate(), the clprio[prio]->ptr could be already set to NULL, which means htb_next_rb_node() is vulnerable here. For htb_deactivate(), although we checked qlen before calling it, in case of qlen==0 after qdisc_tree_reduce_backlog(), we may call it again which triggers the warning inside. To fix the issues here, we need to: 1) Make htb_deactivate() idempotent, that is, simply return if we already call it before. 2) Make htb_next_rb_node() safe against ptr==NULL. Many thanks to Alan for testing and for the reproducer.",,"[{""url"":""https://git.kernel.org/stable/c/31ff70ad39485698cf779f2078132d80b57f6c07"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3769478610135e82b262640252d90f6efb05be71"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/98cd7ed92753090a714f0802d4434314526fe61d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/99ff8a20fd61315bf9ae627440a5ff07d22ee153"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9945f7cf1709adc5d2d31cb6cfc85627ce299a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c2d25fddd867ce20a266806634eeeb5c30cb520c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c4792b9e38d2f61b07eac72f10909fa76130314b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c928dd4f6bf0c25c72b11824a1e9ac9bd37296a0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37954,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:33.603,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: smb: client: Avoid race in open_cached_dir with lease breaks A pre-existing valid cfid returned from find_or_create_cached_dir might race with a lease break, meaning open_cached_dir doesn't consider it valid, and thinks it's newly-constructed. This leaks a dentry reference if the allocation occurs before the queued lease break work runs. Avoid the race by extending holding the cfid_list_lock across find_or_create_cached_dir and when the result is checked.",,"[{""url"":""https://git.kernel.org/stable/c/2407265dc32bc8cc45b62a612c2a214ba9038e8b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2ed98e89ebc2e1bc73534dc3c18cb7843a889ff9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ca02e63edccb78ef3659bebc68579c7224a6ca2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/571dcf3d27b24800c171aea7b5e04ff06d10e2e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37955,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:33.710,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: virtio-net: free xsk_buffs on error in virtnet_xsk_pool_enable() The selftests added to our CI by Bui Quang Minh recently reveals that there is a mem leak on the error path of virtnet_xsk_pool_enable(): unreferenced object 0xffff88800a68a000 (size 2048): comm ""xdp_helper"", pid 318, jiffies 4294692778 hex dump (first 32 bytes): 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ backtrace (crc 0): __kvmalloc_node_noprof+0x402/0x570 virtnet_xsk_pool_enable+0x293/0x6a0 (drivers/net/virtio_net.c:5882) xp_assign_dev+0x369/0x670 (net/xdp/xsk_buff_pool.c:226) xsk_bind+0x6a5/0x1ae0 __sys_bind+0x15e/0x230 __x64_sys_bind+0x72/0xb0 do_syscall_64+0xc1/0x1d0 entry_SYSCALL_64_after_hwframe+0x77/0x7f",,"[{""url"":""https://git.kernel.org/stable/c/4397684a292a71fbc1e815c3e283f7490ddce5ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/94a6f6c204abb2b2dcd2ce287536cc924469cfb5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba6917810bb4a5a32661fa941717399052b3f0d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37956,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:33.813,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: prevent rename with empty string Client can send empty newname string to ksmbd server. It will cause a kernel oops from d_alloc. This patch return the error when attempting to rename a file or directory with an empty new name string.",,"[{""url"":""https://git.kernel.org/stable/c/53e3e5babc0963a92d856a5ec0ce92c59f54bc12"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6ee551672c8cf36108b0cfba92ec0c7c28ac3439"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c57301e332cc413fe0a7294a90725f4e21e9549d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d7f2c00acb1ef64304fd40ac507e9213ff1d9b5c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37957,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:33.917,2025-05-22T13:15:55.897,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: KVM: SVM: Forcibly leave SMM mode on SHUTDOWN interception Previously, commit ed129ec9057f (""KVM: x86: forcibly leave nested mode on vCPU reset"") addressed an issue where a triple fault occurring in nested mode could lead to use-after-free scenarios. However, the commit did not handle the analogous situation for System Management Mode (SMM). This omission results in triggering a WARN when KVM forces a vCPU INIT after SHUTDOWN interception while the vCPU is in SMM. This situation was reprodused using Syzkaller by: 1) Creating a KVM VM and vCPU 2) Sending a KVM_SMI ioctl to explicitly enter SMM 3) Executing invalid instructions causing consecutive exceptions and eventually a triple fault The issue manifests as follows: WARNING: CPU: 0 PID: 25506 at arch/x86/kvm/x86.c:12112 kvm_vcpu_reset+0x1d2/0x1530 arch/x86/kvm/x86.c:12112 Modules linked in: CPU: 0 PID: 25506 Comm: syz-executor.0 Not tainted 6.1.130-syzkaller-00157-g164fe5dde9b6 #0 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014 RIP: 0010:kvm_vcpu_reset+0x1d2/0x1530 arch/x86/kvm/x86.c:12112 Call Trace: <TASK> shutdown_interception+0x66/0xb0 arch/x86/kvm/svm/svm.c:2136 svm_invoke_exit_handler+0x110/0x530 arch/x86/kvm/svm/svm.c:3395 svm_handle_exit+0x424/0x920 arch/x86/kvm/svm/svm.c:3457 vcpu_enter_guest arch/x86/kvm/x86.c:10959 [inline] vcpu_run+0x2c43/0x5a90 arch/x86/kvm/x86.c:11062 kvm_arch_vcpu_ioctl_run+0x50f/0x1cf0 arch/x86/kvm/x86.c:11283 kvm_vcpu_ioctl+0x570/0xf00 arch/x86/kvm/../../../virt/kvm/kvm_main.c:4122 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:870 [inline] __se_sys_ioctl fs/ioctl.c:856 [inline] __x64_sys_ioctl+0x19a/0x210 fs/ioctl.c:856 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_64+0x35/0x80 arch/x86/entry/common.c:81 entry_SYSCALL_64_after_hwframe+0x6e/0xd8 Architecturally, INIT is blocked when the CPU is in SMM, hence KVM's WARN() in kvm_vcpu_reset() to guard against KVM bugs, e.g. to detect improper emulation of INIT. SHUTDOWN on SVM is a weird edge case where KVM needs to do _something_ sane with the VMCB, since it's technically undefined, and INIT is the least awful choice given KVM's ABI. So, double down on stuffing INIT on SHUTDOWN, and force the vCPU out of SMM to avoid any weirdness (and the WARN). Found by Linux Verification Center (linuxtesting.org) with Syzkaller. [sean: massage changelog, make it clear this isn't architectural behavior]",,"[{""url"":""https://git.kernel.org/stable/c/a2620f8932fa9fdabc3d78ed6efb004ca409019f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d362b21fefcef7eda8f1cd78a5925735d2b3287c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e9b28bc65fd3a56755ba503258024608292b4ab1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec24e62a1dd3540ee696314422040180040c1e4a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37958,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:34.027,2025-06-27T11:15:25.057,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm/huge_memory: fix dereferencing invalid pmd migration entry When migrating a THP, concurrent access to the PMD migration entry during a deferred split scan can lead to an invalid address access, as illustrated below. To prevent this invalid access, it is necessary to check the PMD migration entry and return early. In this context, there is no need to use pmd_to_swp_entry and pfn_swap_entry_to_page to verify the equality of the target folio. Since the PMD migration entry is locked, it cannot be served as the target. Mailing list discussion and explanation from Hugh Dickins: ""An anon_vma lookup points to a location which may contain the folio of interest, but might instead contain another folio: and weeding out those other folios is precisely what the ""folio != pmd_folio((*pmd)"" check (and the ""risk of replacing the wrong folio"" comment a few lines above it) is for."" BUG: unable to handle page fault for address: ffffea60001db008 CPU: 0 UID: 0 PID: 2199114 Comm: tee Not tainted 6.14.0+ #4 NONE Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 RIP: 0010:split_huge_pmd_locked+0x3b5/0x2b60 Call Trace: <TASK> try_to_migrate_one+0x28c/0x3730 rmap_walk_anon+0x4f6/0x770 unmap_folio+0x196/0x1f0 split_huge_page_to_list_to_order+0x9f6/0x1560 deferred_split_scan+0xac5/0x12a0 shrinker_debugfs_scan_write+0x376/0x470 full_proxy_write+0x15c/0x220 vfs_write+0x2fc/0xcb0 ksys_write+0x146/0x250 do_syscall_64+0x6a/0x120 entry_SYSCALL_64_after_hwframe+0x76/0x7e The bug is found by syzkaller on an internal kernel, then confirmed on upstream.",,"[{""url"":""https://git.kernel.org/stable/c/22f6368768340260e862f35151d2e1c55cb1dc75"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3977946f61cdba87b6b5aaf7d7094e96089583a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6166c3cf405441f7147b322980144feb3cefc617"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/753f142f7ff7d2223a47105b61e1efd91587d711"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9468afbda3fbfcec21ac8132364dff3dab945faf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be6e843fc51a584672dfd9c4a6a24c8cb81d5fb7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ef5706bed97e240b4abf4233ceb03da7336bc775"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fbab262b0c8226c697af1851a424896ed47dedcc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37959,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:34.143,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf: Scrub packet on bpf_redirect_peer When bpf_redirect_peer is used to redirect packets to a device in another network namespace, the skb isn't scrubbed. That can lead skb information from one namespace to be ""misused"" in another namespace. As one example, this is causing Cilium to drop traffic when using bpf_redirect_peer to redirect packets that just went through IPsec decryption to a container namespace. The following pwru trace shows (1) the packet path from the host's XFRM layer to the container's XFRM layer where it's dropped and (2) the number of active skb extensions at each function. NETNS MARK IFACE TUPLE FUNC 4026533547 d00 eth0 10.244.3.124:35473->10.244.2.158:53 xfrm_rcv_cb .active_extensions = (__u8)2, 4026533547 d00 eth0 10.244.3.124:35473->10.244.2.158:53 xfrm4_rcv_cb .active_extensions = (__u8)2, 4026533547 d00 eth0 10.244.3.124:35473->10.244.2.158:53 gro_cells_receive .active_extensions = (__u8)2, [...] 4026533547 0 eth0 10.244.3.124:35473->10.244.2.158:53 skb_do_redirect .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.124:35473->10.244.2.158:53 ip_rcv .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.124:35473->10.244.2.158:53 ip_rcv_core .active_extensions = (__u8)2, [...] 4026534999 0 eth0 10.244.3.124:35473->10.244.2.158:53 udp_queue_rcv_one_skb .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.124:35473->10.244.2.158:53 __xfrm_policy_check .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.124:35473->10.244.2.158:53 __xfrm_decode_session .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.124:35473->10.244.2.158:53 security_xfrm_decode_session .active_extensions = (__u8)2, 4026534999 0 eth0 10.244.3.124:35473->10.244.2.158:53 kfree_skb_reason(SKB_DROP_REASON_XFRM_POLICY) .active_extensions = (__u8)2, In this case, there are no XFRM policies in the container's network namespace so the drop is unexpected. When we decrypt the IPsec packet, the XFRM state used for decryption is set in the skb extensions. This information is preserved across the netns switch. When we reach the XFRM policy check in the container's netns, __xfrm_policy_check drops the packet with LINUX_MIB_XFRMINNOPOLS because a (container-side) XFRM policy can't be found that matches the (host-side) XFRM state used for decryption. This patch fixes this by scrubbing the packet when using bpf_redirect_peer, as is done on typical netns switches via veth devices except skb->mark and skb->tstamp are not zeroed.",,"[{""url"":""https://git.kernel.org/stable/c/355b0526336c0bf2bf7feaca033568ede524f763"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9e15ef33ba39fb6d9d1f51445957f16983a9437a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b37e54259cab4f78b53953d6f6268b85f07bef3e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c4327229948879814229b46aa26a750718888503"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de1067cc8cf0e8c11ae20cbe5c467aef19d04ded"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37960,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:34.267,2025-05-22T13:15:56.003,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: memblock: Accept allocated memory before use in memblock_double_array() When increasing the array size in memblock_double_array() and the slab is not yet available, a call to memblock_find_in_range() is used to reserve/allocate memory. However, the range returned may not have been accepted, which can result in a crash when booting an SNP guest: RIP: 0010:memcpy_orig+0x68/0x130 Code: ... RSP: 0000:ffffffff9cc03ce8 EFLAGS: 00010006 RAX: ff11001ff83e5000 RBX: 0000000000000000 RCX: fffffffffffff000 RDX: 0000000000000bc0 RSI: ffffffff9dba8860 RDI: ff11001ff83e5c00 RBP: 0000000000002000 R08: 0000000000000000 R09: 0000000000002000 R10: 000000207fffe000 R11: 0000040000000000 R12: ffffffff9d06ef78 R13: ff11001ff83e5000 R14: ffffffff9dba7c60 R15: 0000000000000c00 memblock_double_array+0xff/0x310 memblock_add_range+0x1fb/0x2f0 memblock_reserve+0x4f/0xa0 memblock_alloc_range_nid+0xac/0x130 memblock_alloc_internal+0x53/0xc0 memblock_alloc_try_nid+0x3d/0xa0 swiotlb_init_remap+0x149/0x2f0 mem_init+0xb/0xb0 mm_core_init+0x8f/0x350 start_kernel+0x17e/0x5d0 x86_64_start_reservations+0x14/0x30 x86_64_start_kernel+0x92/0xa0 secondary_startup_64_no_verify+0x194/0x19b Mitigate this by calling accept_memory() on the memory range returned before the slab is available. Prior to v6.12, the accept_memory() interface used a 'start' and 'end' parameter instead of 'start' and 'size', therefore the accept_memory() call must be adjusted to specify 'start + size' for 'end' when applying to kernels prior to v6.12.",,"[{""url"":""https://git.kernel.org/stable/c/7bcd29181bab8d508d2adfdbb132de8b1e088698"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa513e69e011a2b19fa22ce62ce35effbd5e0c81"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d66a22f6a432a9dd376c9b365d7dc89bd416909c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da8bf5daa5e55a6af2b285ecda460d6454712ff4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37961,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:34.367,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ipvs: fix uninit-value for saddr in do_output_route4 syzbot reports for uninit-value for the saddr argument [1]. commit 4754957f04f5 (""ipvs: do not use random local source address for tunnels"") already implies that the input value of saddr should be ignored but the code is still reading it which can prevent to connect the route. Fix it by changing the argument to ret_saddr. [1] BUG: KMSAN: uninit-value in do_output_route4+0x42c/0x4d0 net/netfilter/ipvs/ip_vs_xmit.c:147 do_output_route4+0x42c/0x4d0 net/netfilter/ipvs/ip_vs_xmit.c:147 __ip_vs_get_out_rt+0x403/0x21d0 net/netfilter/ipvs/ip_vs_xmit.c:330 ip_vs_tunnel_xmit+0x205/0x2380 net/netfilter/ipvs/ip_vs_xmit.c:1136 ip_vs_in_hook+0x1aa5/0x35b0 net/netfilter/ipvs/ip_vs_core.c:2063 nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline] nf_hook_slow+0xf7/0x400 net/netfilter/core.c:626 nf_hook include/linux/netfilter.h:269 [inline] __ip_local_out+0x758/0x7e0 net/ipv4/ip_output.c:118 ip_local_out net/ipv4/ip_output.c:127 [inline] ip_send_skb+0x6a/0x3c0 net/ipv4/ip_output.c:1501 udp_send_skb+0xfda/0x1b70 net/ipv4/udp.c:1195 udp_sendmsg+0x2fe3/0x33c0 net/ipv4/udp.c:1483 inet_sendmsg+0x1fc/0x280 net/ipv4/af_inet.c:851 sock_sendmsg_nosec net/socket.c:712 [inline] __sock_sendmsg+0x267/0x380 net/socket.c:727 ____sys_sendmsg+0x91b/0xda0 net/socket.c:2566 ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2620 __sys_sendmmsg+0x41d/0x880 net/socket.c:2702 __compat_sys_sendmmsg net/compat.c:360 [inline] __do_compat_sys_sendmmsg net/compat.c:367 [inline] __se_compat_sys_sendmmsg net/compat.c:364 [inline] __ia32_compat_sys_sendmmsg+0xc8/0x140 net/compat.c:364 ia32_sys_call+0x3ffa/0x41f0 arch/x86/include/generated/asm/syscalls_32.h:346 do_syscall_32_irqs_on arch/x86/entry/syscall_32.c:83 [inline] __do_fast_syscall_32+0xb0/0x110 arch/x86/entry/syscall_32.c:306 do_fast_syscall_32+0x38/0x80 arch/x86/entry/syscall_32.c:331 do_SYSENTER_32+0x1f/0x30 arch/x86/entry/syscall_32.c:369 entry_SYSENTER_compat_after_hwframe+0x84/0x8e Uninit was created at: slab_post_alloc_hook mm/slub.c:4167 [inline] slab_alloc_node mm/slub.c:4210 [inline] __kmalloc_cache_noprof+0x8fa/0xe00 mm/slub.c:4367 kmalloc_noprof include/linux/slab.h:905 [inline] ip_vs_dest_dst_alloc net/netfilter/ipvs/ip_vs_xmit.c:61 [inline] __ip_vs_get_out_rt+0x35d/0x21d0 net/netfilter/ipvs/ip_vs_xmit.c:323 ip_vs_tunnel_xmit+0x205/0x2380 net/netfilter/ipvs/ip_vs_xmit.c:1136 ip_vs_in_hook+0x1aa5/0x35b0 net/netfilter/ipvs/ip_vs_core.c:2063 nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline] nf_hook_slow+0xf7/0x400 net/netfilter/core.c:626 nf_hook include/linux/netfilter.h:269 [inline] __ip_local_out+0x758/0x7e0 net/ipv4/ip_output.c:118 ip_local_out net/ipv4/ip_output.c:127 [inline] ip_send_skb+0x6a/0x3c0 net/ipv4/ip_output.c:1501 udp_send_skb+0xfda/0x1b70 net/ipv4/udp.c:1195 udp_sendmsg+0x2fe3/0x33c0 net/ipv4/udp.c:1483 inet_sendmsg+0x1fc/0x280 net/ipv4/af_inet.c:851 sock_sendmsg_nosec net/socket.c:712 [inline] __sock_sendmsg+0x267/0x380 net/socket.c:727 ____sys_sendmsg+0x91b/0xda0 net/socket.c:2566 ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2620 __sys_sendmmsg+0x41d/0x880 net/socket.c:2702 __compat_sys_sendmmsg net/compat.c:360 [inline] __do_compat_sys_sendmmsg net/compat.c:367 [inline] __se_compat_sys_sendmmsg net/compat.c:364 [inline] __ia32_compat_sys_sendmmsg+0xc8/0x140 net/compat.c:364 ia32_sys_call+0x3ffa/0x41f0 arch/x86/include/generated/asm/syscalls_32.h:346 do_syscall_32_irqs_on arch/x86/entry/syscall_32.c:83 [inline] __do_fast_syscall_32+0xb0/0x110 arch/x86/entry/syscall_32.c:306 do_fast_syscall_32+0x38/0x80 arch/x86/entry/syscall_32.c:331 do_SYSENTER_32+0x1f/0x30 arch/x86/entry/syscall_32.c:369 entry_SYSENTER_compat_after_hwframe+0x84/0x8e CPU: 0 UID: 0 PID: 22408 Comm: syz.4.5165 Not tainted 6.15.0-rc3-syzkaller-00019-gbc3372351d0c #0 PREEMPT(undef) Hardware name: Google Google Compute Engi ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/0160ac84fb03a0bd8dce8a42cb25bfaeedd110f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d0032112a0380d0b8d7c9005f621928a9b9fc76"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a3a1b784791a3cbfc6e05c4d8a3c321ac5136e25"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/adbc8cc1162951cb152ed7f147d5fbd35ce3e62f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e34090d7214e0516eb8722aee295cb2507317c07"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37962,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:34.473,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix memory leak in parse_lease_state() The previous patch that added bounds check for create lease context introduced a memory leak. When the bounds check fails, the function returns NULL without freeing the previously allocated lease_ctx_info structure. This patch fixes the issue by adding kfree(lreq) before returning NULL in both boundary check cases.",,"[{""url"":""https://git.kernel.org/stable/c/2148d34371b06dac696c0497a98a6bf905a51650"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/829e19ef741d9e9932abdc3bee5466195e0852cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/af9e2d4732a548db8f6f5a90c2c20a789a3d7240"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb4447bcce915b43b691123118893fca4f372a8f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/facf22c1a394c1e023dab5daf9a494f722771e1c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37963,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:34.580,2025-06-27T11:15:25.160,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: arm64: bpf: Only mitigate cBPF programs loaded by unprivileged users Support for eBPF programs loaded by unprivileged users is typically disabled. This means only cBPF programs need to be mitigated for BHB. In addition, only mitigate cBPF programs that were loaded by an unprivileged user. Privileged users can also load the same program via eBPF, making the mitigation pointless.",,"[{""url"":""https://git.kernel.org/stable/c/038866e01ea5e5a3d948898ac216e531e7848669"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/477481c4348268136227348984b6699d6370b685"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6e52d043f7dbf1839a24a3fab2b12b0d3839de7a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/80251f62028f1ab2e09be5ca3123f84e8b00389a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/df53d418709205450a02bb4d71cbfb4ff86f2c1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e5f5100f1c64ac6c72671b2cf6b46542fce93706"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f300769ead032513a68e4a02e806393402e626f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37964,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T16:15:34.683,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: x86/mm: Eliminate window where TLB flushes may be inadvertently skipped tl;dr: There is a window in the mm switching code where the new CR3 is set and the CPU should be getting TLB flushes for the new mm. But should_flush_tlb() has a bug and suppresses the flush. Fix it by widening the window where should_flush_tlb() sends an IPI. Long Version: === History === There were a few things leading up to this. First, updating mm_cpumask() was observed to be too expensive, so it was made lazier. But being lazy caused too many unnecessary IPIs to CPUs due to the now-lazy mm_cpumask(). So code was added to cull mm_cpumask() periodically[2]. But that culling was a bit too aggressive and skipped sending TLB flushes to CPUs that need them. So here we are again. === Problem === The too-aggressive code in should_flush_tlb() strikes in this window: // Turn on IPIs for this CPU/mm combination, but only // if should_flush_tlb() agrees: cpumask_set_cpu(cpu, mm_cpumask(next)); next_tlb_gen = atomic64_read(&next->context.tlb_gen); choose_new_asid(next, next_tlb_gen, &new_asid, &need_flush); load_new_mm_cr3(need_flush); // ^ After 'need_flush' is set to false, IPIs *MUST* // be sent to this CPU and not be ignored. this_cpu_write(cpu_tlbstate.loaded_mm, next); // ^ Not until this point does should_flush_tlb() // become true! should_flush_tlb() will suppress TLB flushes between load_new_mm_cr3() and writing to 'loaded_mm', which is a window where they should not be suppressed. Whoops. === Solution === Thankfully, the fuzzy ""just about to write CR3"" window is already marked with loaded_mm==LOADED_MM_SWITCHING. Simply checking for that state in should_flush_tlb() is sufficient to ensure that the CPU is targeted with an IPI. This will cause more TLB flush IPIs. But the window is relatively small and I do not expect this to cause any kind of measurable performance impact. Update the comment where LOADED_MM_SWITCHING is written since it grew yet another user. Peter Z also raised a concern that should_flush_tlb() might not observe 'loaded_mm' and 'is_lazy' in the same order that switch_mm_irqs_off() writes them. Add a barrier to ensure that they are observed in the order they are written.",,"[{""url"":""https://git.kernel.org/stable/c/02ad4ce144bd27f71f583f667fdf3b3ba0753477"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/12f703811af043d32b1c8a30001b2fa04d5cd0ac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/399ec9ca8fc4999e676ff89a90184ec40031cf59"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d41072906abec8bb8e01ed16afefbaa558908c89"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d87392094f96e162fa5fa5a8640d70cc0952806f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fea4e317f9e7e1f449ce90dedc27a2d2a95bee5a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37965,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T17:15:46.900,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix invalid context error in dml helper [Why] ""BUG: sleeping function called from invalid context"" error. after: ""drm/amd/display: Protect FPU in dml2_validate()/dml21_validate()"" The populate_dml_plane_cfg_from_plane_state() uses the GFP_KERNEL flag for memory allocation, which shouldn't be used in atomic contexts. The allocation is needed only for using another helper function get_scaler_data_for_plane(). [How] Modify helpers to pass a pointer to scaler_data within existing context, eliminating the need for dynamic memory allocation/deallocation and copying. (cherry picked from commit bd3e84bc98f81b44f2c43936bdadc3241d654259)",,"[{""url"":""https://git.kernel.org/stable/c/9984db63742099ee3f3cff35cf71306d10e64356"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b371f8f6d89ec8dfea796e00a44a57c44fc8fcc0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d8c4afe78385cd355e4d80299d785379d6e874df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37966,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T17:15:47.020,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: riscv: Fix kernel crash due to PR_SET_TAGGED_ADDR_CTRL When userspace does PR_SET_TAGGED_ADDR_CTRL, but Supm extension is not available, the kernel crashes: Oops - illegal instruction [#1] [snip] epc : set_tagged_addr_ctrl+0x112/0x15a ra : set_tagged_addr_ctrl+0x74/0x15a epc : ffffffff80011ace ra : ffffffff80011a30 sp : ffffffc60039be10 [snip] status: 0000000200000120 badaddr: 0000000010a79073 cause: 0000000000000002 set_tagged_addr_ctrl+0x112/0x15a __riscv_sys_prctl+0x352/0x73c do_trap_ecall_u+0x17c/0x20c andle_exception+0x150/0x15c Fix it by checking if Supm is available.",,"[{""url"":""https://git.kernel.org/stable/c/4b595a2f5656cd45d534ed2160c94f7662adefe5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ae08d55807c099357c047dba17624b09414635dd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37967,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T17:15:47.130,2025-05-22T13:15:56.110,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: typec: ucsi: displayport: Fix deadlock This patch introduces the ucsi_con_mutex_lock / ucsi_con_mutex_unlock functions to the UCSI driver. ucsi_con_mutex_lock ensures the connector mutex is only locked if a connection is established and the partner pointer is valid. This resolves a deadlock scenario where ucsi_displayport_remove_partner holds con->mutex waiting for dp_altmode_work to complete while dp_altmode_work attempts to acquire it.",,"[{""url"":""https://git.kernel.org/stable/c/364618c89d4c57c85e5fc51a2446cd939bf57802"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5924b324468845fc795bd76f588f51d7ab4f202d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/61fc1a8e1e10cc784cab5829930838aaf1d37af5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/962ce9028ca6eb450d5c205238a3ee27de9d214d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f32451ca4cb7dc53f2a0e2e66b84d34162747eb7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f4bd982563c2fd41ec9ca6c517c392d759db801c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37968,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T17:15:47.250,2025-09-09T17:15:44.100,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iio: light: opt3001: fix deadlock due to concurrent flag access The threaded IRQ function in this driver is reading the flag twice: once to lock a mutex and once to unlock it. Even though the code setting the flag is designed to prevent it, there are subtle cases where the flag could be true at the mutex_lock stage and false at the mutex_unlock stage. This results in the mutex not being unlocked, resulting in a deadlock. Fix it by making the opt3001_irq() code generally more robust, reading the flag into a variable and using the variable value at both stages.",,"[{""url"":""https://git.kernel.org/stable/c/1d7def97e7eb65865ccc01bbdf4eb9e6bbe8a5b5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2c95c8f0959d0a72575eabf2ff888f47ed6d8b77"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/748ebd8e61d0bc182c331b8df3887af7285c8a8f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ca84f6a22d50bf8b31efe9eb05f9859947266d7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/957e8be112636d9bc692917286e81e54bd87decc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9c56ccb7cddfca754291fb24b108a5350a5fbe9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e791bf216c9e236b34dabf514ec0ede140cca719"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f063a28002e3350088b4577c5640882bf4ea17ea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37969,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T17:15:47.363,2025-06-04T13:15:27.550,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iio: imu: st_lsm6dsx: fix possible lockup in st_lsm6dsx_read_tagged_fifo Prevent st_lsm6dsx_read_tagged_fifo from falling in an infinite loop in case pattern_len is equal to zero and the device FIFO is not empty.",,"[{""url"":""https://git.kernel.org/stable/c/16857370b3a30663515956b3bd27f3def6a2cf06"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/35b8c0a284983b71d92d082c54b7eb655ed4194f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4db7d923a8c298788181b796f71adf6ca499f966"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/76727a1d81afde77d21ea8feaeb12d34605be6f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8114ef86e2058e2554111b793596f17bee23fa15"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ce662851380fe2018e36e15c0bdcb1ad177ed95"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ddb4cf2192c213e4dba1733bbcdc94cf6d85bf7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dadf9116108315f2eb14c7415c7805f392c476b4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37970,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T17:15:47.490,2025-06-04T13:15:27.677,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iio: imu: st_lsm6dsx: fix possible lockup in st_lsm6dsx_read_fifo Prevent st_lsm6dsx_read_fifo from falling in an infinite loop in case pattern_len is equal to zero and the device FIFO is not empty.",,"[{""url"":""https://git.kernel.org/stable/c/159ca7f18129834b6f4c7eae67de48e96c752fc9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3bb6c02d6fe8347ce1785016d135ff539c20043c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c4a5000618a8c44200d455c92e2f2a4db264717"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/84e39f628a3a3333add99076e4d6c8b42b12d3a0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a1cad8a3bca41dead9980615d35efc7bff1fd534"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da33c4167b9cc1266a97215114cb74679f881d0c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f06a1a1954527cc4ed086d926c81ff236b2adde9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f3cf233c946531a92fe651ff2bd15ebbe60630a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37971,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T17:15:47.630,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: staging: bcm2835-camera: Initialise dev in v4l2_dev Commit 42a2f6664e18 (""staging: vc04_services: Move global g_state to vchiq_state"") changed mmal_init to pass dev->v4l2_dev.dev to vchiq_mmal_init, however nothing iniitialised dev->v4l2_dev, so we got a NULL pointer dereference. Set dev->v4l2_dev.dev during bcm2835_mmal_probe. The device pointer could be passed into v4l2_device_register to set it, however that also has other effects that would need additional changes.",,"[{""url"":""https://git.kernel.org/stable/c/06753f49336ab161ea0e249a0720125b81b7b31b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/98698ca0e58734bc5c1c24e5bbc7429f981cd186"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b70bdd4923e8b8edbacde2af83ca337bb7005261"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37972,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T17:15:47.743,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Input: mtk-pmic-keys - fix possible null pointer dereference In mtk_pmic_keys_probe, the regs parameter is only set if the button is parsed in the device tree. However, on hardware where the button is left floating, that node will most likely be removed not to enable that input. In that case the code will try to dereference a null pointer. Let's use the regs struct instead as it is defined for all supported platforms. Note that it is ok setting the key reg even if that latter is disabled as the interrupt won't be enabled anyway.",,"[{""url"":""https://git.kernel.org/stable/c/09429ddb5a91e9e8f72cd18c012ec4171c2f85ec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/11cdb506d0fbf5ac05bf55f5afcb3a215c316490"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/334d74a798463ceec02a41eb0e2354aaac0d6249"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/619c05fb176c272ac6cecf723446b39723ee6d97"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90fa6015ff83ef1c373cc61b7c924ab2bcbe1801"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37973,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T17:15:47.870,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: cfg80211: fix out-of-bounds access during multi-link element defragmentation Currently during the multi-link element defragmentation process, the multi-link element length added to the total IEs length when calculating the length of remaining IEs after the multi-link element in cfg80211_defrag_mle(). This could lead to out-of-bounds access if the multi-link element or its corresponding fragment elements are the last elements in the IEs buffer. To address this issue, correctly calculate the remaining IEs length by deducting the multi-link element end offset from total IEs end offset.",,"[{""url"":""https://git.kernel.org/stable/c/023c1f2f0609218103cbcb48e0104b144d4a16dc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73dde269a1a43e6b1aa92eba13ad2df58bfdd38e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9423f6da825172b8dc60d4688ed3d147291c3be9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e1c6d0c6199bd5f4cfc7a66ae7032b6e805f904d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37974,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T17:15:47.987,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: s390/pci: Fix missing check for zpci_create_device() error return The zpci_create_device() function returns an error pointer that needs to be checked before dereferencing it as a struct zpci_dev pointer. Add the missing check in __clp_add() where it was missed when adding the scan_list in the fixed commit. Simply not adding the device to the scan list results in the previous behavior.",,"[{""url"":""https://git.kernel.org/stable/c/2769b718e164df983c20c314b263a71a699be6cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/42420c50c68f3e95e90de2479464f420602229fc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be54b750c333a9db7c3b3686846bb06b07b011fe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37975,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T17:15:48.093,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: riscv: module: Fix out-of-bounds relocation access The current code allows rel[j] to access one element past the end of the relocation section. Simplify to num_relocations which is equivalent to the existing size expression.",,"[{""url"":""https://git.kernel.org/stable/c/0b4cce68efb93e31a8e51795d696df6e379cb41c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/95e4e1c1cf614d125f159db9726b7abb32e18385"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a068ea00009d373d825c528f9c168501519211b4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37976,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T17:15:48.210,2025-06-18T14:15:43.967,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,[],,,,,,,,,,
CVE-2025-37977,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T17:15:48.320,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: ufs: exynos: Disable iocc if dma-coherent property isn't set If dma-coherent property isn't set then descriptors are non-cacheable and the iocc shareability bits should be disabled. Without this UFS can end up in an incompatible configuration and suffer from random cache related stability issues.",,"[{""url"":""https://git.kernel.org/stable/c/869749e48115ef944eeabec8e84138908471fa51"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f0c6728a6f2e269ebb234a9b5bb6c2c24aafeb51"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f92bb7436802f8eb7ee72dc911a33c8897fde366"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37978,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T17:15:48.423,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: block: integrity: Do not call set_page_dirty_lock() Placing multiple protection information buffers inside the same page can lead to oopses because set_page_dirty_lock() can't be called from interrupt context. Since a protection information buffer is not backed by a file there is no point in setting its page dirty, there is nothing to synchronize. Drop the call to set_page_dirty_lock() and remove the last argument to bio_integrity_unpin_bvec().",,"[{""url"":""https://git.kernel.org/stable/c/39e160505198ff8c158f11bce2ba19809a756e8b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9487fc1a10b3aa89feb24e7cedeccaaf63074617"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c38a005e6efb9ddfa06bd8353b82379d6fd5d6c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37979,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T17:15:48.540,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: qcom: Fix sc7280 lpass potential buffer overflow Case values introduced in commit 5f78e1fb7a3e (""ASoC: qcom: Add driver support for audioreach solution"") cause out of bounds access in arrays of sc7280 driver data (e.g. in case of RX_CODEC_DMA_RX_0 in sc7280_snd_hw_params()). Redefine LPASS_MAX_PORTS to consider the maximum possible port id for q6dsp as sc7280 driver utilizes some of those values. Found by Linux Verification Center (linuxtesting.org) with SVACE.",,"[{""url"":""https://git.kernel.org/stable/c/a12c14577882b1f2b4cff0f86265682f16e97b0c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a31a4934b31faea76e735bab17e63d02fcd8e029"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b807b7c81a6d066757a94af7b8fa5b6a37e4d0b3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c0ce01e0ff8a0d61a7b089ab309cdc12bc527c39"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d78888853eb53f47ae16cf3aa5d0444d0331b9f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37980,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T17:15:48.650,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: block: fix resource leak in blk_register_queue() error path When registering a queue fails after blk_mq_sysfs_register() is successful but the function later encounters an error, we need to clean up the blk_mq_sysfs resources. Add the missing blk_mq_sysfs_unregister() call in the error path to properly clean up these resources and prevent a memory leak.",,"[{""url"":""https://git.kernel.org/stable/c/40f2eb9b531475dd01b683fdaf61ca3cfd03a51e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/41e43134ddda35949974be40520460a12dda3502"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/549cbbd14bbec12469ceb279b79c763c8a24224e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/55a7bb2708f7c7c5b366d4e40916113168a3824c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37981,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T17:15:48.763,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: smartpqi: Use is_kdump_kernel() to check for kdump The smartpqi driver checks the reset_devices variable to determine whether special adjustments need to be made for kdump. This has the effect that after a regular kexec reboot, some driver parameters such as max_transfer_size are much lower than usual. More importantly, kexec reboot tests have revealed memory corruption caused by the driver log being written to system memory after a kexec. Fix this by testing is_kdump_kernel() rather than reset_devices where appropriate.",,"[{""url"":""https://git.kernel.org/stable/c/7cc670e8ebaa5241dd99c0ad75eceb8f8f64f607"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a2d5a0072235a69749ceb04c1a26dc75df66a31a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ebf673c76ce91e612a882dfaa9a3824962994aae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37982,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T17:15:48.873,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: wl1251: fix memory leak in wl1251_tx_work The skb dequeued from tx_queue is lost when wl1251_ps_elp_wakeup fails with a -ETIMEDOUT error. Fix that by queueing the skb back to tx_queue.",,"[{""url"":""https://git.kernel.org/stable/c/13c9744c1bcdb5de4e7dc1a78784788ecec52add"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2996144be660d930d5e394652abe08fe89dbe00e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4a43fd36710669d67dbb5c16287a58412582ca26"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/52f224009ce1e44805e6ff3ffc2a06af9c1c3c5b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a90c29d0204c5ffc45b43b4eced6eef0e19a33a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8fd4b9551af214d037fbc9d8e179840b8b917841"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a0f0dc96de03ffeefc2a177b7f8acde565cb77f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f08448a885403722c5c77dae51964badfcb69495"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37983,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T18:15:45.137,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: qibfs: fix _another_ leak failure to allocate inode => leaked dentry... this one had been there since the initial merge; to be fair, if we are that far OOM, the odds of failing at that particular allocation are low...",,"[{""url"":""https://git.kernel.org/stable/c/24faa6ea274a2b96d0a78a0996c3137c2b2a65f0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3c2fde33e3e505dfd1a895d1f24bad650c655e14"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/47ab2caba495c1d6a899d284e541a8df656dcfe9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/545defa656568c74590317cd30068f85134a8216"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5d53e88d8370b9ab14dd830abb410d9a2671edb6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e280cce3a29b7fe7b828c6ccd5aa5ba87ceb6b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5fe708c5e3c8b2152c6caaa67243e431a5d6cca3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bdb43af4fdb39f844ede401bdb1258f67a580a27"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37984,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T18:15:45.253,2025-07-25T14:15:31.667,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: crypto: ecdsa - Harden against integer overflows in DIV_ROUND_UP() Herbert notes that DIV_ROUND_UP() may overflow unnecessarily if an ecdsa implementation's ->key_size() callback returns an unusually large value. Herbert instead suggests (for a division by 8): X / 8 + !!(X & 7) Based on this formula, introduce a generic DIV_ROUND_UP_POW2() macro and use it in lieu of DIV_ROUND_UP() for ->key_size() return values. Additionally, use the macro in ecc_digits_from_bytes(), whose ""nbytes"" parameter is a ->key_size() return value in some instances, or a user-specified ASN.1 length in the case of ecdsa_get_signature_rs().",,"[{""url"":""https://git.kernel.org/stable/c/921b8167f10708e38080f84e195cdc68a7a561f1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b16510a530d1e6ab9683f04f8fb34f2e0f538275"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f02f0218be412cff1c844addf58e002071be298b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f2133b849ff273abddb6da622daddd8f6f6fa448"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37985,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T18:15:45.360,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: USB: wdm: close race between wdm_open and wdm_wwan_port_stop Clearing WDM_WWAN_IN_USE must be the last action or we can open a chardev whose URBs are still poisoned",,"[{""url"":""https://git.kernel.org/stable/c/217fe1fc7d112595a793e02b306710e702eac492"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/52ae15c665b5fe5876655aaccc3ef70560b0e314"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/54f7f8978af19f899dec80bcc71c8d4855dfbd72"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b02a3fef3e8c8fe5a0a266f7a14f38cc608fb167"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c1846ed4eb527bdfe6b3b7dd2c78e2af4bf98f4f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3c9adc69357fcbe6253a2bc2588ee4bbaaedbe9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37986,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T18:15:45.470,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: typec: class: Invalidate USB device pointers on partner unregistration To avoid using invalid USB device pointers after a Type-C partner disconnects, this patch clears the pointers upon partner unregistration. This ensures a clean state for future connections.",,"[{""url"":""https://git.kernel.org/stable/c/40966fc9939e85677fdb489dfddfa205baaad03b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/66e1a887273c6b89f09bc11a40d0a71d5a081a8e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74911338f47c13d1b9470fc50718182bffad42e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37987,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T18:15:45.567,2025-06-04T13:15:27.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: pds_core: Prevent possible adminq overflow/stuck condition The pds_core's adminq is protected by the adminq_lock, which prevents more than 1 command to be posted onto it at any one time. This makes it so the client drivers cannot simultaneously post adminq commands. However, the completions happen in a different context, which means multiple adminq commands can be posted sequentially and all waiting on completion. On the FW side, the backing adminq request queue is only 16 entries long and the retry mechanism and/or overflow/stuck prevention is lacking. This can cause the adminq to get stuck, so commands are no longer processed and completions are no longer sent by the FW. As an initial fix, prevent more than 16 outstanding adminq commands so there's no way to cause the adminq from getting stuck. This works because the backing adminq request queue will never have more than 16 pending adminq commands, so it will never overflow. This is done by reducing the adminq depth to 16.",,"[{""url"":""https://git.kernel.org/stable/c/2982e07ad72b48eb12c29a87a3f2126ea552688c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/517f928cc0c133472618cbba18382b46f5f71ba3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e3dc65675faad846420d24762e4faadc12d9392"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d9e2f070d8af60f2c8c02b2ddf0a9e90b4e9220c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37988,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T18:15:45.673,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fix a couple of races in MNT_TREE_BENEATH handling by do_move_mount() Normally do_lock_mount(path, _) is locking a mountpoint pinned by *path and at the time when matching unlock_mount() unlocks that location it is still pinned by the same thing. Unfortunately, for 'beneath' case it's no longer that simple - the object being locked is not the one *path points to. It's the mountpoint of path->mnt. The thing is, without sufficient locking ->mnt_parent may change under us and none of the locks are held at that point. The rules are * mount_lock stabilizes m->mnt_parent for any mount m. * namespace_sem stabilizes m->mnt_parent, provided that m is mounted. * if either of the above holds and refcount of m is positive, we are guaranteed the same for refcount of m->mnt_parent. namespace_sem nests inside inode_lock(), so do_lock_mount() has to take inode_lock() before grabbing namespace_sem. It does recheck that path->mnt is still mounted in the same place after getting namespace_sem, and it does take care to pin the dentry. It is needed, since otherwise we might end up with racing mount --move (or umount) happening while we were getting locks; in that case dentry would no longer be a mountpoint and could've been evicted on memory pressure along with its inode - not something you want when grabbing lock on that inode. However, pinning a dentry is not enough - the matching mount is also pinned only by the fact that path->mnt is mounted on top it and at that point we are not holding any locks whatsoever, so the same kind of races could end up with all references to that mount gone just as we are about to enter inode_lock(). If that happens, we are left with filesystem being shut down while we are holding a dentry reference on it; results are not pretty. What we need to do is grab both dentry and mount at the same time; that makes inode_lock() safe *and* avoids the problem with fs getting shut down under us. After taking namespace_sem we verify that path->mnt is still mounted (which stabilizes its ->mnt_parent) and check that it's still mounted at the same place. From that point on to the matching namespace_unlock() we are guaranteed that mount/dentry pair we'd grabbed are also pinned by being the mountpoint of path->mnt, so we can quietly drop both the dentry reference (as the current code does) and mnt one - it's OK to do under namespace_sem, since we are not dropping the final refs. That solves the problem on do_lock_mount() side; unlock_mount() also has one, since dentry is guaranteed to stay pinned only until the namespace_unlock(). That's easy to fix - just have inode_unlock() done earlier, while it's still pinned by mp->m_dentry.",,"[{""url"":""https://git.kernel.org/stable/c/0d039eac6e5950f9d1ecc9e410c2fd1feaeab3b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4f435c1f4c48ff84968e2d9159f6fa41f46cf998"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a61afd54826ac24c2c93845c4f441dbc344875b1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d4b21e8cd3d7efa2deb9cff534f0133e84f35086"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37989,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T18:15:45.773,2025-05-21T20:24:58.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: phy: leds: fix memory leak A network restart test on a router led to an out-of-memory condition, which was traced to a memory leak in the PHY LED trigger code. The root cause is misuse of the devm API. The registration function (phy_led_triggers_register) is called from phy_attach_direct, not phy_probe, and the unregister function (phy_led_triggers_unregister) is called from phy_detach, not phy_remove. This means the register and unregister functions can be called multiple times for the same PHY device, but devm-allocated memory is not freed until the driver is unbound. This also prevents kmemleak from detecting the leak, as the devm API internally stores the allocated pointer. Fix this by replacing devm_kzalloc/devm_kcalloc with standard kzalloc/kcalloc, and add the corresponding kfree calls in the unregister path.",,"[{""url"":""https://git.kernel.org/stable/c/41143e71052a00d654c15dc924fda50c1e7357d0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/618541a6cc1511064dfa58c89b3445e21844092f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/663c3da86e807c6c07ed48f911c7526fad6fe1ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f3d5880800f962c347777c4f8358f29f5fc403c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/95bed65cc0eb2a610550abf849a8b94374da80a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/966d6494e2ed9be9052fcd9815afba830896aaf8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b7f0ee992adf601aa00c252418266177eb7ac2bc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f41f097f68a33d392579885426d0734a81219501"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37990,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T18:15:45.883,2025-06-04T13:15:27.940,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: brcm80211: fmac: Add error handling for brcmf_usb_dl_writeimage() The function brcmf_usb_dl_writeimage() calls the function brcmf_usb_dl_cmd() but dose not check its return value. The 'state.state' and the 'state.bytes' are uninitialized if the function brcmf_usb_dl_cmd() fails. It is dangerous to use uninitialized variables in the conditions. Add error handling for brcmf_usb_dl_cmd() to jump to error handling path if the brcmf_usb_dl_cmd() fails and the 'state.state' and the 'state.bytes' are uninitialized. Improve the error message to report more detailed error information.",,"[{""url"":""https://git.kernel.org/stable/c/08424a0922fb9e32a19b09d852ee87fb6c497538"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/508be7c001437bacad7b9a43f08a723887bcd1ea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/524b70441baba453b193c418e3142bd31059cc1f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/62a4f2955d9a1745bdb410bf83fb16666d8865d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e089e7b585d95122c8122d732d1d5ef8f879396"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/972bf75e53f778c78039c5d139dd47443a6d66a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bdb435ef9815b1ae28eefffa01c6959d0fcf1fa7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa9b9f02212574ee1867fbefb0a675362a71b31d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37991,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-20T18:15:45.997,2025-06-04T13:15:28.053,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: parisc: Fix double SIGFPE crash Camm noticed that on parisc a SIGFPE exception will crash an application with a second SIGFPE in the signal handler. Dave analyzed it, and it happens because glibc uses a double-word floating-point store to atomically update function descriptors. As a result of lazy binding, we hit a floating-point store in fpe_func almost immediately. When the T bit is set, an assist exception trap occurs when when the co-processor encounters *any* floating-point instruction except for a double store of register %fr0. The latter cancels all pending traps. Let's fix this by clearing the Trap (T) bit in the FP status register before returning to the signal handler in userspace. The issue can be reproduced with this test program: root@parisc:~# cat fpe.c static void fpe_func(int sig, siginfo_t *i, void *v) { sigset_t set; sigemptyset(&set); sigaddset(&set, SIGFPE); sigprocmask(SIG_UNBLOCK, &set, NULL); printf(""GOT signal %d with si_code %ld\n"", sig, i->si_code); } int main() { struct sigaction action = { .sa_sigaction = fpe_func, .sa_flags = SA_RESTART|SA_SIGINFO }; sigaction(SIGFPE, &action, 0); feenableexcept(FE_OVERFLOW); return printf(""%lf\n"",1.7976931348623158E308*1.7976931348623158E308); } root@parisc:~# gcc fpe.c -lm root@parisc:~# ./a.out Floating point exception root@parisc:~# strace -f ./a.out execve(""./a.out"", [""./a.out""], 0xf9ac7034 /* 20 vars */) = 0 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0 ... rt_sigaction(SIGFPE, {sa_handler=0x1110a, sa_mask=[], sa_flags=SA_RESTART|SA_SIGINFO}, NULL, 8) = 0 --- SIGFPE {si_signo=SIGFPE, si_code=FPE_FLTOVF, si_addr=0x1078f} --- --- SIGFPE {si_signo=SIGFPE, si_code=FPE_FLTOVF, si_addr=0xf8f21237} --- +++ killed by SIGFPE +++ Floating point exception",,"[{""url"":""https://git.kernel.org/stable/c/2a1aff3616b3b57aa4a5f8a7762cce1e82493fe6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6a098c51d18ec99485668da44294565c43dbc106"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c639af49e9e5615a8395981eaf5943fb40acd6f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/757ba4d17b868482837c566cfefca59e2296c608"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cf21e890f56b7d0038ddaf25224e4f4c69ecd143"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de3629baf5a33af1919dec7136d643b0662e85ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/df3592e493d7f29bae4ffde9a9325de50ddf962e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec4584495868bd465fe60a3f771915c0e7ce7951"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37992,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-26T15:15:19.770,2025-06-04T13:15:28.170,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net_sched: Flush gso_skb list too during ->change() Previously, when reducing a qdisc's limit via the ->change() operation, only the main skb queue was trimmed, potentially leaving packets in the gso_skb list. This could result in NULL pointer dereference when we only check sch->limit against sch->q.qlen. This patch introduces a new helper, qdisc_dequeue_internal(), which ensures both the gso_skb list and the main queue are properly flushed when trimming excess packets. All relevant qdiscs (codel, fq, fq_codel, fq_pie, hhf, pie) are updated to use this helper in their ->change() routines.",,"[{""url"":""https://git.kernel.org/stable/c/2d3cbfd6d54a2c39ce3244f33f85c595844bd7b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a7d6e0ac0a8861f6b1027488062251a8e28150fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d1365ca80b012d8a7863e45949e413fb61fa4861"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3336f746f196c6a53e0480923ae93939f047b6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d38939ebe0d992d581acb6885c1723fa83c1fb2c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ea1132ccb112f51ba749c56a912f67970c2cd542"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe88c7e4fc2c1cd75a278a15ffbf1689efad4e76"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37993,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-29T14:15:35.767,2025-05-29T14:29:50.247,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: can: m_can: m_can_class_allocate_dev(): initialize spin lock on device probe The spin lock tx_handling_spinlock in struct m_can_classdev is not being initialized. This leads the following spinlock bad magic complaint from the kernel, eg. when trying to send CAN frames with cansend from can-utils: | BUG: spinlock bad magic on CPU#0, cansend/95 | lock: 0xff60000002ec1010, .magic: 00000000, .owner: <none>/-1, .owner_cpu: 0 | CPU: 0 UID: 0 PID: 95 Comm: cansend Not tainted 6.15.0-rc3-00032-ga79be02bba5c #5 NONE | Hardware name: MachineWare SIM-V (DT) | Call Trace: | [<ffffffff800133e0>] dump_backtrace+0x1c/0x24 | [<ffffffff800022f2>] show_stack+0x28/0x34 | [<ffffffff8000de3e>] dump_stack_lvl+0x4a/0x68 | [<ffffffff8000de70>] dump_stack+0x14/0x1c | [<ffffffff80003134>] spin_dump+0x62/0x6e | [<ffffffff800883ba>] do_raw_spin_lock+0xd0/0x142 | [<ffffffff807a6fcc>] _raw_spin_lock_irqsave+0x20/0x2c | [<ffffffff80536dba>] m_can_start_xmit+0x90/0x34a | [<ffffffff806148b0>] dev_hard_start_xmit+0xa6/0xee | [<ffffffff8065b730>] sch_direct_xmit+0x114/0x292 | [<ffffffff80614e2a>] __dev_queue_xmit+0x3b0/0xaa8 | [<ffffffff8073b8fa>] can_send+0xc6/0x242 | [<ffffffff8073d1c0>] raw_sendmsg+0x1a8/0x36c | [<ffffffff805ebf06>] sock_write_iter+0x9a/0xee | [<ffffffff801d06ea>] vfs_write+0x184/0x3a6 | [<ffffffff801d0a88>] ksys_write+0xa0/0xc0 | [<ffffffff801d0abc>] __riscv_sys_write+0x14/0x1c | [<ffffffff8079ebf8>] do_trap_ecall_u+0x168/0x212 | [<ffffffff807a830a>] handle_exception+0x146/0x152 Initializing the spin lock in m_can_class_allocate_dev solves that problem.",,"[{""url"":""https://git.kernel.org/stable/c/2ecce25ea296f328d79070ee36229a15aeeb7aca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d5379cfecfdd665e4206bc4f19824656388779f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dcaeeb8ae84c5506ebc574732838264f3887738c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37994,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-29T14:15:35.897,2025-06-04T13:15:28.283,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: typec: ucsi: displayport: Fix NULL pointer access This patch ensures that the UCSI driver waits for all pending tasks in the ucsi_displayport_work workqueue to finish executing before proceeding with the partner removal.",,"[{""url"":""https://git.kernel.org/stable/c/076ab0631ed4928905736f1701e25f1e722bc086"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/14f298c52188c34acde9760bf5abc669c5c36fdb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/312d79669e71283d05c05cc49a1a31e59e3d9e0e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5ad298d6d4aebe1229adba6427e417e89a5208d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7804c4d63edfdd5105926cc291e806e8f4ce01b5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9dda1e2a666a8a32ce0f153b5dee05c7351f1020"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9931f1b52b2d0bf3952e003fd5901ea7eb851ed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e9b63faf5c97deb43fc39a52edbc39d626cc14bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37995,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-29T14:15:36.043,2025-06-04T13:15:28.403,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: module: ensure that kobject_put() is safe for module type kobjects In 'lookup_or_create_module_kobject()', an internal kobject is created using 'module_ktype'. So call to 'kobject_put()' on error handling path causes an attempt to use an uninitialized completion pointer in 'module_kobject_release()'. In this scenario, we just want to release kobject without an extra synchronization required for a regular module unloading process, so adding an extra check whether 'complete()' is actually required makes 'kobject_put()' safe.",,"[{""url"":""https://git.kernel.org/stable/c/31d8df3f303c3ae9115230820977ef8c35c88808"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/93799fb988757cdacf19acba57807746c00378e6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9e7b49ce4f9d0cb5b6e87db9e07a2fb9e754b0dd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a63d99873547d8b39eb2f6db79dd235761e7098a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6aeb739974ec73e5217c75a7c008a688d3d5cf1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d63851049f412cdfadaeef7a7eaef5031d11c1e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1c71b4bd721a4ea21da408806964b10468623f2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/faa9059631d3491d699c69ecf512de9e1a3d6649"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37996,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-29T14:15:36.183,2025-05-29T14:29:50.247,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: KVM: arm64: Fix uninitialized memcache pointer in user_mem_abort() Commit fce886a60207 (""KVM: arm64: Plumb the pKVM MMU in KVM"") made the initialization of the local memcache variable in user_mem_abort() conditional, leaving a codepath where it is used uninitialized via kvm_pgtable_stage2_map(). This can fail on any path that requires a stage-2 allocation without transition via a permission fault or dirty logging. Fix this by making sure that memcache is always valid.",,"[{""url"":""https://git.kernel.org/stable/c/157dbc4a321f5bb6f8b6c724d12ba720a90f1a7c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a26d50f8a4a5049e956984797b5d0dedea4bbb18"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37997,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-29T14:15:36.317,2025-06-04T13:15:28.513,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: ipset: fix region locking in hash types Region locking introduced in v5.6-rc4 contained three macros to handle the region locks: ahash_bucket_start(), ahash_bucket_end() which gave back the start and end hash bucket values belonging to a given region lock and ahash_region() which should give back the region lock belonging to a given hash bucket. The latter was incorrect which can lead to a race condition between the garbage collector and adding new elements when a hash type of set is defined with timeouts.",,"[{""url"":""https://git.kernel.org/stable/c/00cfc5fad1491796942a948808afb968a0a3f35b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/226ce0ec38316d9e3739e73a64b6b8304646c658"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6e002ecc1c8cfdfc866b9104ab7888da54613e59"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/82c1eb32693bc48251d92532975e19160987e5b9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8478a729c0462273188263136880480729e9efca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a3dfec485401943e315c394c29afe2db8f9481d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa77294b0f73bb8265987591460cd25b8722c3df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e2ab67672b2288521a6146034a971f9a82ffc5c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37998,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-29T14:15:36.450,2025-08-09T15:15:28.327,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: openvswitch: Fix unsafe attribute parsing in output_userspace() This patch replaces the manual Netlink attribute iteration in output_userspace() with nla_for_each_nested(), which ensures that only well-formed attributes are processed.",,"[{""url"":""https://git.kernel.org/stable/c/0236742bd959332181c1fcc41a05b7b709180501"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/06b4f110c79716c181a8c5da007c259807840232"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/47f7f00cf2fa3137d5c0416ef1a71bdf77901395"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4fa672cbce9c86c3efb8621df1ae580d47813430"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6712dc21506738f5f22b4f68b7c0d9e0df819dbd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6beb6835c1fbb3f676aebb51a5fee6b77fed9308"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bca8df998cce1fead8cbc69144862eadc2e34c87"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec334aaab74705cc515205e1da3cb369fdfd93cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://www.zerodayinitiative.com/advisories/ZDI-25-307/"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-37999,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-29T14:15:36.597,2025-05-29T14:29:50.247,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fs/erofs/fileio: call erofs_onlinefolio_split() after bio_add_folio() If bio_add_folio() fails (because it is full), erofs_fileio_scan_folio() needs to submit the I/O request via erofs_fileio_rq_submit() and allocate a new I/O request with an empty `struct bio`. Then it retries the bio_add_folio() call. However, at this point, erofs_onlinefolio_split() has already been called which increments `folio->private`; the retry will call erofs_onlinefolio_split() again, but there will never be a matching erofs_onlinefolio_end() call. This leaves the folio locked forever and all waiters will be stuck in folio_wait_bit_common(). This bug has been added by commit ce63cb62d794 (""erofs: support unencoded inodes for fileio""), but was practically unreachable because there was room for 256 folios in the `struct bio` - until commit 9f74ae8c9ac9 (""erofs: shorten bvecs[] for file-backed mounts"") which reduced the array capacity to 16 folios. It was now trivial to trigger the bug by manually invoking readahead from userspace, e.g.: posix_fadvise(fd, 0, st.st_size, POSIX_FADV_WILLNEED); This should be fixed by invoking erofs_onlinefolio_split() only after bio_add_folio() has succeeded. This is safe: asynchronous completions invoking erofs_onlinefolio_end() will not unlock the folio because erofs_fileio_scan_folio() is still holding a reference to be released by erofs_onlinefolio_end() at the end.",,"[{""url"":""https://git.kernel.org/stable/c/61e0fc3312309867e5a3495329dad0286d2a5703"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bbfe756dc3062c1e934f06e5ba39c239aa953b92"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c26076197df348c84cc23e5962d61902e072a0f5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
