id,sourceIdentifier,published,lastModified,vulnStatus,cveTags,descriptions,weaknesses,references,metrics_cvssMetricV31,configurations,metrics_cvssMetricV40,cisaExploitAdd,cisaActionDue,cisaRequiredAction,cisaVulnerabilityName,metrics_cvssMetricV2,metrics_cvssMetricV30,evaluatorComment
CVE-2025-38000,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-06T13:15:39.870,2025-06-06T14:06:58.193,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: sch_hfsc: Fix qlen accounting bug when using peek in hfsc_enqueue() When enqueuing the first packet to an HFSC class, hfsc_enqueue() calls the child qdisc's peek() operation before incrementing sch->q.qlen and sch->qstats.backlog. If the child qdisc uses qdisc_peek_dequeued(), this may trigger an immediate dequeue and potential packet drop. In such cases, qdisc_tree_reduce_backlog() is called, but the HFSC qdisc's qlen and backlog have not yet been updated, leading to inconsistent queue accounting. This can leave an empty HFSC class in the active list, causing further consequences like use-after-free. This patch fixes the bug by moving the increment of sch->q.qlen and sch->qstats.backlog before the call to the child qdisc's peek() operation. This ensures that queue length and backlog are always accurate when packet drops or dequeues are triggered during the peek.",,"[{""url"":""https://git.kernel.org/stable/c/1034e3310752e8675e313f7271b348914008719a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f3a22eebbc32b4fa8ce9c1d5f9db214b45b9335"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f981138109f63232a5fb7165938d4c945cc1b9d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/49b21795b8e5654a7df3d910a12e1060da4c04cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/89c301e929a0db14ebd94b4d97764ce1d6981653"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/93c276942e75de0e5bc91576300d292e968f5a02"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1dde3eb17dc1b8bd07aed00004b1e05fc87a3d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f9f593e34d2fb67644372c8f7b033bdc622ad228"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38001,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-06T14:15:22.183,2025-07-13T19:15:23.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net_sched: hfsc: Address reentrant enqueue adding class to eltree twice Savino says: ""We are writing to report that this recent patch (141d34391abbb315d68556b7c67ad97885407547) [1] can be bypassed, and a UAF can still occur when HFSC is utilized with NETEM. The patch only checks the cl->cl_nactive field to determine whether it is the first insertion or not [2], but this field is only incremented by init_vf [3]. By using HFSC_RSC (which uses init_ed) [4], it is possible to bypass the check and insert the class twice in the eltree. Under normal conditions, this would lead to an infinite loop in hfsc_dequeue for the reasons we already explained in this report [5]. However, if TBF is added as root qdisc and it is configured with a very low rate, it can be utilized to prevent packets from being dequeued. This behavior can be exploited to perform subsequent insertions in the HFSC eltree and cause a UAF."" To fix both the UAF and the infinite loop, with netem as an hfsc child, check explicitly in hfsc_enqueue whether the class is already in the eltree whenever the HFSC_RSC flag is set. [1] https://web.git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=141d34391abbb315d68556b7c67ad97885407547 [2] https://elixir.bootlin.com/linux/v6.15-rc5/source/net/sched/sch_hfsc.c#L1572 [3] https://elixir.bootlin.com/linux/v6.15-rc5/source/net/sched/sch_hfsc.c#L677 [4] https://elixir.bootlin.com/linux/v6.15-rc5/source/net/sched/sch_hfsc.c#L1574 [5] https://lore.kernel.org/netdev/8DuRWwfqjoRDLDmBMlIfbrsZg9Gx50DHJc1ilxsEBNe2D6NMoigR_eIRIG0LOjMc3r10nUUZtArXx4oZBIdUfZQrwjcQhdinnMis_0G7VEk=@willsroot.io/T/#u",,"[{""url"":""https://git.kernel.org/stable/c/295f7c579b07b5b7cf2dffe485f71cc2f27647cb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2c928b3a0b04a431ffcd6c8b7d88a267124a3a28"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2f2190ce4ca972051cac6a8d7937448f8cb9673c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/39ed887b1dd2d6b720f87e86692ac3006cc111c8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4e38eaaabfb7fffbb371a51150203e19eee5d70e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6672e6c00810056acaac019fe26cdc26fee8a66c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a0ec22fa20b252edbe070a9de8501eef63c17ef5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac9fe7dd8e730a103ae4481147395cc73492d786"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e5bee633cc276410337d54b99f77fbc1ad8801e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://syst3mfailure.io/rbtree-family-drama/"",""source"":""af854a3a-2127-422b-91ae-364da2661108""}]",,,,,,,,,,
CVE-2025-38002,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-06T14:15:22.313,2025-06-26T15:15:22.843,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: io_uring/fdinfo: grab ctx->uring_lock around io_uring_show_fdinfo() Not everything requires locking in there, which is why the 'has_lock' variable exists. But enough does that it's a bit unwieldy to manage. Wrap the whole thing in a ->uring_lock trylock, and just return with no output if we fail to grab it. The existing trylock() will already have greatly diminished utility/output for the failure case. This fixes an issue with reading the SQE fields, if the ring is being actively resized at the same time.",,"[{""url"":""https://git.kernel.org/stable/c/bdb7d2ec2e31c46c45d1f32667dfa8216a72705e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d871198ee431d90f5308d53998c1ba1d5db5619a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://project-zero.issues.chromium.org/issues/417522668"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38003,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-08T11:15:20.990,2025-06-09T12:15:47.880,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: can: bcm: add missing rcu read protection for procfs content When the procfs content is generated for a bcm_op which is in the process to be removed the procfs output might show unreliable data (UAF). As the removal of bcm_op's is already implemented with rcu handling this patch adds the missing rcu_read_lock() and makes sure the list entries are properly removed under rcu protection.",,"[{""url"":""https://git.kernel.org/stable/c/0622846db728a5332b917c797c733e202c4620ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/19f553a1ddf260da6570ed8f8d91a8c87f49b63a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1f912f8484e9c4396378c39460bbea0af681f319"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/63567ecd99a24495208dc860d50fb17440043006"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/659701c0b954ccdb4a916a4ad59bbc16e726d42c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6d7d458c41b98a5c1670cbd36f2923c37de51cf5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c9db92d5f0eadca30884af75c53d601edc512ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dac5e6249159ac255dad9781793dbe5908ac9ddb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38004,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-08T11:15:22.210,2025-06-09T12:15:47.880,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: can: bcm: add locking for bcm_op runtime updates The CAN broadcast manager (CAN BCM) can send a sequence of CAN frames via hrtimer. The content and also the length of the sequence can be changed resp reduced at runtime where the 'currframe' counter is then set to zero. Although this appeared to be a safe operation the updates of 'currframe' can be triggered from user space and hrtimer context in bcm_can_tx(). Anderson Nascimento created a proof of concept that triggered a KASAN slab-out-of-bounds read access which can be prevented with a spin_lock_bh. At the rework of bcm_can_tx() the 'count' variable has been moved into the protected section as this variable can be modified from both contexts too.",,"[{""url"":""https://git.kernel.org/stable/c/2a437b86ac5a9893c902f30ef66815bf13587bf6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7595de7bc56e0e52b74e56c90f7e247bf626d628"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/76c84c3728178b2d38d5604e399dfe8b0752645e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8f1c022541bf5a923c8d6fa483112c15250f30a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c2aba69d0c36a496ab4f2e81e9c2b271f2693fd7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c4e8a172501e677ebd8ea9d9161d97dc4df56fbd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc55dd28c20a6611e30596019b3b2f636819a4c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fbd8fdc2b218e979cfe422b139b8f74c12419d1f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38005,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:31.617,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dmaengine: ti: k3-udma: Add missing locking Recent kernels complain about a missing lock in k3-udma.c when the lock validator is enabled: [ 4.128073] WARNING: CPU: 0 PID: 746 at drivers/dma/ti/../virt-dma.h:169 udma_start.isra.0+0x34/0x238 [ 4.137352] CPU: 0 UID: 0 PID: 746 Comm: kworker/0:3 Not tainted 6.12.9-arm64 #28 [ 4.144867] Hardware name: pp-v12 (DT) [ 4.148648] Workqueue: events udma_check_tx_completion [ 4.153841] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 4.160834] pc : udma_start.isra.0+0x34/0x238 [ 4.165227] lr : udma_start.isra.0+0x30/0x238 [ 4.169618] sp : ffffffc083cabcf0 [ 4.172963] x29: ffffffc083cabcf0 x28: 0000000000000000 x27: ffffff800001b005 [ 4.180167] x26: ffffffc0812f0000 x25: 0000000000000000 x24: 0000000000000000 [ 4.187370] x23: 0000000000000001 x22: 00000000e21eabe9 x21: ffffff8000fa0670 [ 4.194571] x20: ffffff8001b6bf00 x19: ffffff8000fa0430 x18: ffffffc083b95030 [ 4.201773] x17: 0000000000000000 x16: 00000000f0000000 x15: 0000000000000048 [ 4.208976] x14: 0000000000000048 x13: 0000000000000000 x12: 0000000000000001 [ 4.216179] x11: ffffffc08151a240 x10: 0000000000003ea1 x9 : ffffffc08046ab68 [ 4.223381] x8 : ffffffc083cabac0 x7 : ffffffc081df3718 x6 : 0000000000029fc8 [ 4.230583] x5 : ffffffc0817ee6d8 x4 : 0000000000000bc0 x3 : 0000000000000000 [ 4.237784] x2 : 0000000000000000 x1 : 00000000001fffff x0 : 0000000000000000 [ 4.244986] Call trace: [ 4.247463] udma_start.isra.0+0x34/0x238 [ 4.251509] udma_check_tx_completion+0xd0/0xdc [ 4.256076] process_one_work+0x244/0x3fc [ 4.260129] process_scheduled_works+0x6c/0x74 [ 4.264610] worker_thread+0x150/0x1dc [ 4.268398] kthread+0xd8/0xe8 [ 4.271492] ret_from_fork+0x10/0x20 [ 4.275107] irq event stamp: 220 [ 4.278363] hardirqs last enabled at (219): [<ffffffc080a27c7c>] _raw_spin_unlock_irq+0x38/0x50 [ 4.287183] hardirqs last disabled at (220): [<ffffffc080a1c154>] el1_dbg+0x24/0x50 [ 4.294879] softirqs last enabled at (182): [<ffffffc080037e68>] handle_softirqs+0x1c0/0x3cc [ 4.303437] softirqs last disabled at (177): [<ffffffc080010170>] __do_softirq+0x1c/0x28 [ 4.311559] ---[ end trace 0000000000000000 ]--- This commit adds the missing locking.",,"[{""url"":""https://git.kernel.org/stable/c/0ea0433f822ed0549715f7044c9cd1cf132ff7fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/26e63b2fe30c61bd25981c6084f67a8af79945d0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/27e71fa08711e09d81e06a54007b362a5426fd22"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/99df1edf17493cb49a8c01f6bde55c3abb6a2a6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d87f1cddc592387359fde157cc4296556f6403c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/df5987e76a4ae4cbd705d81ab4b15ed232250a4a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fca280992af8c2fbd511bc43f65abb4a17363f2f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38006,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:31.773,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: mctp: Don't access ifa_index when missing In mctp_dump_addrinfo, ifa_index can be used to filter interfaces, but only when the struct ifaddrmsg is provided. Otherwise it will be comparing to uninitialised memory - reproducible in the syzkaller case from dhcpd, or busybox ""ip addr show"". The kernel MCTP implementation has always filtered by ifa_index, so existing userspace programs expecting to dump MCTP addresses must already be passing a valid ifa_index value (either 0 or a real index). BUG: KMSAN: uninit-value in mctp_dump_addrinfo+0x208/0xac0 net/mctp/device.c:128 mctp_dump_addrinfo+0x208/0xac0 net/mctp/device.c:128 rtnl_dump_all+0x3ec/0x5b0 net/core/rtnetlink.c:4380 rtnl_dumpit+0xd5/0x2f0 net/core/rtnetlink.c:6824 netlink_dump+0x97b/0x1690 net/netlink/af_netlink.c:2309",,"[{""url"":""https://git.kernel.org/stable/c/24fa213dffa470166ec014f979f36c6ff44afb45"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/acab78ae12c7fefb4f3bfe22e00770a5faa42724"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d4d1561d17eb72908e4489c0900d96e0484fac20"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f11cf946c0a92c560a890d68e4775723353599e1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38007,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:31.907,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: HID: uclogic: Add NULL check in uclogic_input_configured() devm_kasprintf() returns NULL when memory allocation fails. Currently, uclogic_input_configured() does not check for this case, which results in a NULL pointer dereference. Add NULL check after devm_kasprintf() to prevent this issue.",,"[{""url"":""https://git.kernel.org/stable/c/01b76cc8ca243fc3376b035aa326bbc4f03d384b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/94e7272b636a0677082e0604609e4c471e0a2caf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad6caaf29bc26a48b1241ce82561fcbcf0a75aa9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b616453d719ee1b8bf2ea6f6cc6c6258a572a590"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd07f751208ba190f9b0db5e5b7f35d5bb4a8a1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38008,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:32.037,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm/page_alloc: fix race condition in unaccepted memory handling The page allocator tracks the number of zones that have unaccepted memory using static_branch_enc/dec() and uses that static branch in hot paths to determine if it needs to deal with unaccepted memory. Borislav and Thomas pointed out that the tracking is racy: operations on static_branch are not serialized against adding/removing unaccepted pages to/from the zone. Sanity checks inside static_branch machinery detects it: WARNING: CPU: 0 PID: 10 at kernel/jump_label.c:276 __static_key_slow_dec_cpuslocked+0x8e/0xa0 The comment around the WARN() explains the problem: /* * Warn about the '-1' case though; since that means a * decrement is concurrent with a first (0->1) increment. IOW * people are trying to disable something that wasn't yet fully * enabled. This suggests an ordering problem on the user side. */ The effect of this static_branch optimization is only visible on microbenchmark. Instead of adding more complexity around it, remove it altogether.",,"[{""url"":""https://git.kernel.org/stable/c/71dda1cb10702dc2859f00eb789b0502de2176a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74953f93f47a45296cc2a3fd04e2a3202ff3fa53"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/98fdd2f612e949c652693f6df00442c81037776d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fefc075182275057ce607effaa3daa9e6e3bdc73"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38009,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:32.160,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: disable napi on driver removal A warning on driver removal started occurring after commit 9dd05df8403b (""net: warn if NAPI instance wasn't shut down""). Disable tx napi before deleting it in mt76_dma_cleanup(). WARNING: CPU: 4 PID: 18828 at net/core/dev.c:7288 __netif_napi_del_locked+0xf0/0x100 CPU: 4 UID: 0 PID: 18828 Comm: modprobe Not tainted 6.15.0-rc4 #4 PREEMPT(lazy) Hardware name: ASUS System Product Name/PRIME X670E-PRO WIFI, BIOS 3035 09/05/2024 RIP: 0010:__netif_napi_del_locked+0xf0/0x100 Call Trace: <TASK> mt76_dma_cleanup+0x54/0x2f0 [mt76] mt7921_pci_remove+0xd5/0x190 [mt7921e] pci_device_remove+0x47/0xc0 device_release_driver_internal+0x19e/0x200 driver_detach+0x48/0x90 bus_remove_driver+0x6d/0xf0 pci_unregister_driver+0x2e/0xb0 __do_sys_delete_module.isra.0+0x197/0x2e0 do_syscall_64+0x7b/0x160 entry_SYSCALL_64_after_hwframe+0x76/0x7e Tested with mt7921e but the same pattern can be actually applied to other mt76 drivers calling mt76_dma_cleanup() during removal. Tx napi is enabled in their *_dma_init() functions and only toggled off and on again inside their suspend/resume/reset paths. So it should be okay to disable tx napi in such a generic way. Found by Linux Verification Center (linuxtesting.org).",,"[{""url"":""https://git.kernel.org/stable/c/2b81e76db3667d1f7f2ad44e9835cdaf8dea95a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e700b06b970fc19e3a1ecb244e14785f3fbb8e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/78ab4be549533432d97ea8989d2f00b508fa68d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b892e830d1ea8c5475254b98827771f7366f1039"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca5b213bf4b4224335a8131a26805d16503fca5f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e7bfbda5fddd27f3158e723d641c0fcdfb0552a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff0f820fa5b99035b3c654dd531226d8d83aec5f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38010,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:32.283,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: phy: tegra: xusb: Use a bitmask for UTMI pad power state tracking The current implementation uses bias_pad_enable as a reference count to manage the shared bias pad for all UTMI PHYs. However, during system suspension with connected USB devices, multiple power-down requests for the UTMI pad result in a mismatch in the reference count, which in turn produces warnings such as: [ 237.762967] WARNING: CPU: 10 PID: 1618 at tegra186_utmi_pad_power_down+0x160/0x170 [ 237.763103] Call trace: [ 237.763104] tegra186_utmi_pad_power_down+0x160/0x170 [ 237.763107] tegra186_utmi_phy_power_off+0x10/0x30 [ 237.763110] phy_power_off+0x48/0x100 [ 237.763113] tegra_xusb_enter_elpg+0x204/0x500 [ 237.763119] tegra_xusb_suspend+0x48/0x140 [ 237.763122] platform_pm_suspend+0x2c/0xb0 [ 237.763125] dpm_run_callback.isra.0+0x20/0xa0 [ 237.763127] __device_suspend+0x118/0x330 [ 237.763129] dpm_suspend+0x10c/0x1f0 [ 237.763130] dpm_suspend_start+0x88/0xb0 [ 237.763132] suspend_devices_and_enter+0x120/0x500 [ 237.763135] pm_suspend+0x1ec/0x270 The root cause was traced back to the dynamic power-down changes introduced in commit a30951d31b25 (""xhci: tegra: USB2 pad power controls""), where the UTMI pad was being powered down without verifying its current state. This unbalanced behavior led to discrepancies in the reference count. To rectify this issue, this patch replaces the single reference counter with a bitmask, renamed to utmi_pad_enabled. Each bit in the mask corresponds to one of the four USB2 PHYs, allowing us to track each pad's enablement status individually. With this change: - The bias pad is powered on only when the mask is clear. - Each UTMI pad is powered on or down based on its corresponding bit in the mask, preventing redundant operations. - The overall power state of the shared bias pad is maintained correctly during suspend/resume cycles. The mutex used to prevent race conditions during UTMI pad enable/disable operations has been moved from the tegra186_utmi_bias_pad_power_on/off functions to the parent functions tegra186_utmi_pad_power_on/down. This change ensures that there are no race conditions when updating the bitmask.",,"[{""url"":""https://git.kernel.org/stable/c/1db527f0cb8f677adadd4e28e5bc77aaf5d4e4c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/628bec9ed68a2204184fc8230a2609075b08666e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b47158fb42959c417ff2662075c0d46fb783d5d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba25131b3c1ceec303839b2462586d7673788197"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38011,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:32.417,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: csa unmap use uninterruptible lock After process exit to unmap csa and free GPU vm, if signal is accepted and then waiting to take vm lock is interrupted and return, it causes memory leaking and below warning backtrace. Change to use uninterruptible wait lock fix the issue. WARNING: CPU: 69 PID: 167800 at amd/amdgpu/amdgpu_kms.c:1525 amdgpu_driver_postclose_kms+0x294/0x2a0 [amdgpu] Call Trace: <TASK> drm_file_free.part.0+0x1da/0x230 [drm] drm_close_helper.isra.0+0x65/0x70 [drm] drm_release+0x6a/0x120 [drm] amdgpu_drm_release+0x51/0x60 [amdgpu] __fput+0x9f/0x280 ____fput+0xe/0x20 task_work_run+0x67/0xa0 do_exit+0x217/0x3c0 do_group_exit+0x3b/0xb0 get_signal+0x14a/0x8d0 arch_do_signal_or_restart+0xde/0x100 exit_to_user_mode_loop+0xc1/0x1a0 exit_to_user_mode_prepare+0xf4/0x100 syscall_exit_to_user_mode+0x17/0x40 do_syscall_64+0x69/0xc0 (cherry picked from commit 7dbbfb3c171a6f63b01165958629c9c26abf38ab)",,"[{""url"":""https://git.kernel.org/stable/c/8d71c3231b33e24a911b8f2d8c3a17ee40aa32d5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a0fa7873f2f869087b1e7793f7fac3713a1e3afe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a1adc8d9a0d219d4e88672c30dbc9ea960d73136"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38012,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:32.560,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: sched_ext: bpf_iter_scx_dsq_new() should always initialize iterator BPF programs may call next() and destroy() on BPF iterators even after new() returns an error value (e.g. bpf_for_each() macro ignores error returns from new()). bpf_iter_scx_dsq_new() could leave the iterator in an uninitialized state after an error return causing bpf_iter_scx_dsq_next() to dereference garbage data. Make bpf_iter_scx_dsq_new() always clear $kit->dsq so that next() and destroy() become noops.",,"[{""url"":""https://git.kernel.org/stable/c/0102989af4c334d1d98b2a0fd4d61a5152e39b72"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/255dd31bfc4a67a19b1fc2cd130a50284dadfe3a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/428dc9fc0873989d73918d4a9cc22745b7bbc799"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38013,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:32.797,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mac80211: Set n_channels after allocating struct cfg80211_scan_request Make sure that n_channels is set after allocating the struct cfg80211_registered_device::int_scan_req member. Seen with syzkaller: UBSAN: array-index-out-of-bounds in net/mac80211/scan.c:1208:5 index 0 is out of range for type 'struct ieee80211_channel *[] __counted_by(n_channels)' (aka 'struct ieee80211_channel *[]') This was missed in the initial conversions because I failed to locate the allocation likely due to the ""sizeof(void *)"" not matching the ""channels"" array type.",,"[{""url"":""https://git.kernel.org/stable/c/07c737d9ab02c07b562aefcca16aa95077368e24"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/82bbe02b2500ef0a62053fe2eb84773fe31c5a0a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3192e999a0d05ea0ba2c59c09afaf0b8ee70b81"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fde33ab3c052a302ee8a0b739094b88ceae4dd67"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38014,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:32.927,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dmaengine: idxd: Refactor remove call with idxd_cleanup() helper The idxd_cleanup() helper cleans up perfmon, interrupts, internals and so on. Refactor remove call with the idxd_cleanup() helper to avoid code duplication. Note, this also fixes the missing put_device() for idxd groups, enginces and wqs.",,"[{""url"":""https://git.kernel.org/stable/c/23dc14c52d84b02b39d816bf16a754c0e7d48f9c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a409e919ca321cc0e28f8abf96fde299f0072a81"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a7bd00f7e9bd075f3e4fbcc608d8ea445aed8692"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d530dd65f6f3c04bbf141702ecccd70170ed04ad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38015,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:33.060,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dmaengine: idxd: fix memory leak in error handling path of idxd_alloc Memory allocated for idxd is not freed if an error occurs during idxd_alloc(). To fix it, free the allocated memory in the reverse order of allocation before exiting the function in case of an error.",,"[{""url"":""https://git.kernel.org/stable/c/46a5cca76c76c86063000a12936f8e7875295838"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4f005eb68890698e5abc6a3af04dab76f175c50c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/64afd9a1f644b27661420257dcc007d5009c99dd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6e94a2c3e4c166cd2736ac225fba5889fb1e8ac0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/868dbce755ec92855362d213f47e045a8388361a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38016,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:33.187,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: HID: bpf: abort dispatch if device destroyed The current HID bpf implementation assumes no output report/request will go through it after hid_bpf_destroy_device() has been called. This leads to a bug that unplugging certain types of HID devices causes a cleaned- up SRCU to be accessed. The bug was previously a hidden failure until a recent x86 percpu change [1] made it access not-present pages. The bug will be triggered if the conditions below are met: A) a device under the driver has some LEDs on B) hid_ll_driver->request() is uninplemented (e.g., logitech-djreceiver) If condition A is met, hidinput_led_worker() is always scheduled *after* hid_bpf_destroy_device(). hid_destroy_device ` hid_bpf_destroy_device ` cleanup_srcu_struct(&hdev->bpf.srcu) ` hid_remove_device ` ... ` led_classdev_unregister ` led_trigger_set(led_cdev, NULL) ` led_set_brightness(led_cdev, LED_OFF) ` ... ` input_inject_event ` input_event_dispose ` hidinput_input_event ` schedule_work(&hid->led_work) [hidinput_led_worker] This is fine when condition B is not met, where hidinput_led_worker() calls hid_ll_driver->request(). This is the case for most HID drivers, which implement it or use the generic one from usbhid. The driver itself or an underlying driver will then abort processing the request. Otherwise, hidinput_led_worker() tries hid_hw_output_report() and leads to the bug. hidinput_led_worker ` hid_hw_output_report ` dispatch_hid_bpf_output_report ` srcu_read_lock(&hdev->bpf.srcu) ` srcu_read_unlock(&hdev->bpf.srcu, idx) The bug has existed since the introduction [2] of dispatch_hid_bpf_output_report(). However, the same bug also exists in dispatch_hid_bpf_raw_requests(), and I've reproduced (no visible effect because of the lack of [1], but confirmed bpf.destroyed == 1) the bug against the commit (i.e., the Fixes:) introducing the function. This is because hidinput_led_worker() falls back to hid_hw_raw_request() when hid_ll_driver->output_report() is uninplemented (e.g., logitech- djreceiver). hidinput_led_worker ` hid_hw_output_report: -ENOSYS ` hid_hw_raw_request ` dispatch_hid_bpf_raw_requests ` srcu_read_lock(&hdev->bpf.srcu) ` srcu_read_unlock(&hdev->bpf.srcu, idx) Fix the issue by returning early in the two mentioned functions if hid_bpf has been marked as destroyed. Though dispatch_hid_bpf_device_event() handles input events, and there is no evidence that it may be called after the destruction, the same check, as a safety net, is also added to it to maintain the consistency among all dispatch functions. The impact of the bug on other architectures is unclear. Even if it acts as a hidden failure, this is still dangerous because it corrupts whatever is on the address calculated by SRCU. Thus, CC'ing the stable list. [1]: commit 9d7de2aa8b41 (""x86/percpu/64: Use relative percpu offsets"") [2]: commit 9286675a2aed (""HID: bpf: add HID-BPF hooks for hid_hw_output_report"")",,"[{""url"":""https://git.kernel.org/stable/c/578e1b96fad7402ff7e9c7648c8f1ad0225147c8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e4b4fe25a4101d1ddb5884f40e149a3618983b66"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8544be7e8e55b0ef23e1ab90e23e8d4d4aad3d3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38017,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:33.310,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fs/eventpoll: fix endless busy loop after timeout has expired After commit 0a65bc27bd64 (""eventpoll: Set epoll timeout if it's in the future""), the following program would immediately enter a busy loop in the kernel: ``` int main() { int e = epoll_create1(0); struct epoll_event event = {.events = EPOLLIN}; epoll_ctl(e, EPOLL_CTL_ADD, 0, &event); const struct timespec timeout = {.tv_nsec = 1}; epoll_pwait2(e, &event, 1, &timeout, 0); } ``` This happens because the given (non-zero) timeout of 1 nanosecond usually expires before ep_poll() is entered and then ep_schedule_timeout() returns false, but `timed_out` is never set because the code line that sets it is skipped. This quickly turns into a soft lockup, RCU stalls and deadlocks, inflicting severe headaches to the whole system. When the timeout has expired, we don't need to schedule a hrtimer, but we should set the `timed_out` variable. Therefore, I suggest moving the ep_schedule_timeout() check into the `timed_out` expression instead of skipping it. brauner: Note that there was an earlier fix by Joe Damato in response to my bug report in [1].",,"[{""url"":""https://git.kernel.org/stable/c/7631dca012593c95d36199082546a24a0058fc50"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d9ec73301099ec5975505e1c3effbe768bab9490"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38018,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:33.433,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/tls: fix kernel panic when alloc_page failed We cannot set frag_list to NULL pointer when alloc_page failed. It will be used in tls_strp_check_queue_ok when the next time tls_strp_read_sock is called. This is because we don't reset full_len in tls_strp_flush_anchor_copy() so the recv path will try to continue handling the partial record on the next call but we dettached the rcvq from the frag list. Alternative fix would be to reset full_len. Unable to handle kernel NULL pointer dereference at virtual address 0000000000000028 Call trace: tls_strp_check_rcv+0x128/0x27c tls_strp_data_ready+0x34/0x44 tls_data_ready+0x3c/0x1f0 tcp_data_ready+0x9c/0xe4 tcp_data_queue+0xf6c/0x12d0 tcp_rcv_established+0x52c/0x798",,"[{""url"":""https://git.kernel.org/stable/c/406d05da26835943568e61bb751c569efae071d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/491deb9b8c4ad12fe51d554a69b8165b9ef9429f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5f1f833cb388592bb46104463a1ec1b7c41975b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8f7f96549bc55e4ef3a6b499bc5011e5de2f46c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a11b8c0be6acd0505a58ff40d474bd778b25b93a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38019,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:33.563,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mlxsw: spectrum_router: Fix use-after-free when deleting GRE net devices The driver only offloads neighbors that are constructed on top of net devices registered by it or their uppers (which are all Ethernet). The device supports GRE encapsulation and decapsulation of forwarded traffic, but the driver will not offload dummy neighbors constructed on top of GRE net devices as they are not uppers of its net devices: # ip link add name gre1 up type gre tos inherit local 192.0.2.1 remote 198.51.100.1 # ip neigh add 0.0.0.0 lladdr 0.0.0.0 nud noarp dev gre1 $ ip neigh show dev gre1 nud noarp 0.0.0.0 lladdr 0.0.0.0 NOARP (Note that the neighbor is not marked with 'offload') When the driver is reloaded and the existing configuration is replayed, the driver does not perform the same check regarding existing neighbors and offloads the previously added one: # devlink dev reload pci/0000:01:00.0 $ ip neigh show dev gre1 nud noarp 0.0.0.0 lladdr 0.0.0.0 offload NOARP If the neighbor is later deleted, the driver will ignore the notification (given the GRE net device is not its upper) and will therefore keep referencing freed memory, resulting in a use-after-free [1] when the net device is deleted: # ip neigh del 0.0.0.0 lladdr 0.0.0.0 dev gre1 # ip link del dev gre1 Fix by skipping neighbor replay if the net device for which the replay is performed is not our upper. [1] BUG: KASAN: slab-use-after-free in mlxsw_sp_neigh_entry_update+0x1ea/0x200 Read of size 8 at addr ffff888155b0e420 by task ip/2282 [...] Call Trace: <TASK> dump_stack_lvl+0x6f/0xa0 print_address_description.constprop.0+0x6f/0x350 print_report+0x108/0x205 kasan_report+0xdf/0x110 mlxsw_sp_neigh_entry_update+0x1ea/0x200 mlxsw_sp_router_rif_gone_sync+0x2a8/0x440 mlxsw_sp_rif_destroy+0x1e9/0x750 mlxsw_sp_netdevice_ipip_ol_event+0x3c9/0xdc0 mlxsw_sp_router_netdevice_event+0x3ac/0x15e0 notifier_call_chain+0xca/0x150 call_netdevice_notifiers_info+0x7f/0x100 unregister_netdevice_many_notify+0xc8c/0x1d90 rtnl_dellink+0x34e/0xa50 rtnetlink_rcv_msg+0x6fb/0xb70 netlink_rcv_skb+0x131/0x360 netlink_unicast+0x426/0x710 netlink_sendmsg+0x75a/0xc20 __sock_sendmsg+0xc1/0x150 ____sys_sendmsg+0x5aa/0x7b0 ___sys_sendmsg+0xfc/0x180 __sys_sendmsg+0x121/0x1b0 do_syscall_64+0xbb/0x1d0 entry_SYSCALL_64_after_hwframe+0x4b/0x53",,"[{""url"":""https://git.kernel.org/stable/c/92ec4855034b2c4d13f117558dc73d20581fa9ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ab7945f3a61ed23da412e30f1e56414c05c4f06"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/abc43c1ffdbc801b0b04ac845bfaf1d42b8f68f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1ecccb5cdda39bca8cd17bb0b6cf61361e33578"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38020,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:33.700,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/mlx5e: Disable MACsec offload for uplink representor profile MACsec offload is not supported in switchdev mode for uplink representors. When switching to the uplink representor profile, the MACsec offload feature must be cleared from the netdevice's features. If left enabled, attempts to add offloads result in a null pointer dereference, as the uplink representor does not support MACsec offload even though the feature bit remains set. Clear NETIF_F_HW_MACSEC in mlx5e_fix_uplink_rep_features(). Kernel log: Oops: general protection fault, probably for non-canonical address 0xdffffc000000000f: 0000 [#1] SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000078-0x000000000000007f] CPU: 29 UID: 0 PID: 4714 Comm: ip Not tainted 6.14.0-rc4_for_upstream_debug_2025_03_02_17_35 #1 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014 RIP: 0010:__mutex_lock+0x128/0x1dd0 Code: d0 7c 08 84 d2 0f 85 ad 15 00 00 8b 35 91 5c fe 03 85 f6 75 29 49 8d 7e 60 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 <80> 3c 02 00 0f 85 a6 15 00 00 4d 3b 76 60 0f 85 fd 0b 00 00 65 ff RSP: 0018:ffff888147a4f160 EFLAGS: 00010206 RAX: dffffc0000000000 RBX: 0000000000000000 RCX: 0000000000000001 RDX: 000000000000000f RSI: 0000000000000000 RDI: 0000000000000078 RBP: ffff888147a4f2e0 R08: ffffffffa05d2c19 R09: 0000000000000000 R10: 0000000000000001 R11: 0000000000000000 R12: 0000000000000000 R13: dffffc0000000000 R14: 0000000000000018 R15: ffff888152de0000 FS: 00007f855e27d800(0000) GS:ffff88881ee80000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00000000004e5768 CR3: 000000013ae7c005 CR4: 0000000000372eb0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe07f0 DR7: 0000000000000400 Call Trace: <TASK> ? die_addr+0x3d/0xa0 ? exc_general_protection+0x144/0x220 ? asm_exc_general_protection+0x22/0x30 ? mlx5e_macsec_add_secy+0xf9/0x700 [mlx5_core] ? __mutex_lock+0x128/0x1dd0 ? lockdep_set_lock_cmp_fn+0x190/0x190 ? mlx5e_macsec_add_secy+0xf9/0x700 [mlx5_core] ? mutex_lock_io_nested+0x1ae0/0x1ae0 ? lock_acquire+0x1c2/0x530 ? macsec_upd_offload+0x145/0x380 ? lockdep_hardirqs_on_prepare+0x400/0x400 ? kasan_save_stack+0x30/0x40 ? kasan_save_stack+0x20/0x40 ? kasan_save_track+0x10/0x30 ? __kasan_kmalloc+0x77/0x90 ? __kmalloc_noprof+0x249/0x6b0 ? genl_family_rcv_msg_attrs_parse.constprop.0+0xb5/0x240 ? mlx5e_macsec_add_secy+0xf9/0x700 [mlx5_core] mlx5e_macsec_add_secy+0xf9/0x700 [mlx5_core] ? mlx5e_macsec_add_rxsa+0x11a0/0x11a0 [mlx5_core] macsec_update_offload+0x26c/0x820 ? macsec_set_mac_address+0x4b0/0x4b0 ? lockdep_hardirqs_on_prepare+0x284/0x400 ? _raw_spin_unlock_irqrestore+0x47/0x50 macsec_upd_offload+0x2c8/0x380 ? macsec_update_offload+0x820/0x820 ? __nla_parse+0x22/0x30 ? genl_family_rcv_msg_attrs_parse.constprop.0+0x15e/0x240 genl_family_rcv_msg_doit+0x1cc/0x2a0 ? genl_family_rcv_msg_attrs_parse.constprop.0+0x240/0x240 ? cap_capable+0xd4/0x330 genl_rcv_msg+0x3ea/0x670 ? genl_family_rcv_msg_dumpit+0x2a0/0x2a0 ? lockdep_set_lock_cmp_fn+0x190/0x190 ? macsec_update_offload+0x820/0x820 netlink_rcv_skb+0x12b/0x390 ? genl_family_rcv_msg_dumpit+0x2a0/0x2a0 ? netlink_ack+0xd80/0xd80 ? rwsem_down_read_slowpath+0xf90/0xf90 ? netlink_deliver_tap+0xcd/0xac0 ? netlink_deliver_tap+0x155/0xac0 ? _copy_from_iter+0x1bb/0x12c0 genl_rcv+0x24/0x40 netlink_unicast+0x440/0x700 ? netlink_attachskb+0x760/0x760 ? lock_acquire+0x1c2/0x530 ? __might_fault+0xbb/0x170 netlink_sendmsg+0x749/0xc10 ? netlink_unicast+0x700/0x700 ? __might_fault+0xbb/0x170 ? netlink_unicast+0x700/0x700 __sock_sendmsg+0xc5/0x190 ____sys_sendmsg+0x53f/0x760 ? import_iovec+0x7/0x10 ? kernel_sendmsg+0x30/0x30 ? __copy_msghdr+0x3c0/0x3c0 ? filter_irq_stacks+0x90/0x90 ? stack_depot_save_flags+0x28/0xa30 ___sys_sen ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/1a69d53922c1221351739f17837d38e317234e5d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1e577aeb51e9deba4f2c10edfcb07cb3cb406598"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1f80e6ff026041721d8089da8c269b1963628325"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/588431474eb7572e57a927fa8558c9ba2f8af143"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b48a47e137cedfd79655accaeeea6b296ad0b9e1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38021,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:33.827,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix null check of pipe_ctx->plane_state for update_dchubp_dpp Similar to commit 6a057072ddd1 (""drm/amd/display: Fix null check for pipe_ctx->plane_state in dcn20_program_pipe"") that addresses a null pointer dereference on dcn20_update_dchubp_dpp. This is the same function hooked for update_dchubp_dpp in dcn401, with the same issue. Fix possible null pointer deference on dcn401_program_pipe too. (cherry picked from commit d8d47f739752227957d8efc0cb894761bfe1d879)",,"[{""url"":""https://git.kernel.org/stable/c/4679061fb25344d6010ce7b9bebac21c91a0b75a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a3b7e65b6be59e686e163fa1ceb0922f996897c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38022,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:33.950,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/core: Fix ""KASAN: slab-use-after-free Read in ib_register_device"" problem Call Trace: __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:408 [inline] print_report+0xc3/0x670 mm/kasan/report.c:521 kasan_report+0xe0/0x110 mm/kasan/report.c:634 strlen+0x93/0xa0 lib/string.c:420 __fortify_strlen include/linux/fortify-string.h:268 [inline] get_kobj_path_length lib/kobject.c:118 [inline] kobject_get_path+0x3f/0x2a0 lib/kobject.c:158 kobject_uevent_env+0x289/0x1870 lib/kobject_uevent.c:545 ib_register_device drivers/infiniband/core/device.c:1472 [inline] ib_register_device+0x8cf/0xe00 drivers/infiniband/core/device.c:1393 rxe_register_device+0x275/0x320 drivers/infiniband/sw/rxe/rxe_verbs.c:1552 rxe_net_add+0x8e/0xe0 drivers/infiniband/sw/rxe/rxe_net.c:550 rxe_newlink+0x70/0x190 drivers/infiniband/sw/rxe/rxe.c:225 nldev_newlink+0x3a3/0x680 drivers/infiniband/core/nldev.c:1796 rdma_nl_rcv_msg+0x387/0x6e0 drivers/infiniband/core/netlink.c:195 rdma_nl_rcv_skb.constprop.0.isra.0+0x2e5/0x450 netlink_unicast_kernel net/netlink/af_netlink.c:1313 [inline] netlink_unicast+0x53a/0x7f0 net/netlink/af_netlink.c:1339 netlink_sendmsg+0x8d1/0xdd0 net/netlink/af_netlink.c:1883 sock_sendmsg_nosec net/socket.c:712 [inline] __sock_sendmsg net/socket.c:727 [inline] ____sys_sendmsg+0xa95/0xc70 net/socket.c:2566 ___sys_sendmsg+0x134/0x1d0 net/socket.c:2620 __sys_sendmsg+0x16d/0x220 net/socket.c:2652 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xcd/0x260 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f This problem is similar to the problem that the commit 1d6a9e7449e2 (""RDMA/core: Fix use-after-free when rename device name"") fixes. The root cause is: the function ib_device_rename() renames the name with lock. But in the function kobject_uevent(), this name is accessed without lock protection at the same time. The solution is to add the lock protection when this name is accessed in the function kobject_uevent().",,"[{""url"":""https://git.kernel.org/stable/c/03df57ad4b0ff9c5a93ff981aba0b42578ad1571"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/10c7f1c647da3b77ef8827d974a97b6530b64df0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d0706bfd3ee40923c001c6827b786a309e2a8713"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38023,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:34.100,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nfs: handle failure of nfs_get_lock_context in unlock path When memory is insufficient, the allocation of nfs_lock_context in nfs_get_lock_context() fails and returns -ENOMEM. If we mistakenly treat an nfs4_unlockdata structure (whose l_ctx member has been set to -ENOMEM) as valid and proceed to execute rpc_run_task(), this will trigger a NULL pointer dereference in nfs4_locku_prepare. For example: BUG: kernel NULL pointer dereference, address: 000000000000000c PGD 0 P4D 0 Oops: Oops: 0000 [#1] SMP PTI CPU: 15 UID: 0 PID: 12 Comm: kworker/u64:0 Not tainted 6.15.0-rc2-dirty #60 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-2.fc40 Workqueue: rpciod rpc_async_schedule RIP: 0010:nfs4_locku_prepare+0x35/0xc2 Code: 89 f2 48 89 fd 48 c7 c7 68 69 ef b5 53 48 8b 8e 90 00 00 00 48 89 f3 RSP: 0018:ffffbbafc006bdb8 EFLAGS: 00010246 RAX: 000000000000004b RBX: ffff9b964fc1fa00 RCX: 0000000000000000 RDX: 0000000000000000 RSI: fffffffffffffff4 RDI: ffff9ba53fddbf40 RBP: ffff9ba539934000 R08: 0000000000000000 R09: ffffbbafc006bc38 R10: ffffffffb6b689c8 R11: 0000000000000003 R12: ffff9ba539934030 R13: 0000000000000001 R14: 0000000004248060 R15: ffffffffb56d1c30 FS: 0000000000000000(0000) GS:ffff9ba5881f0000(0000) knlGS:00000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000000000000000c CR3: 000000093f244000 CR4: 00000000000006f0 Call Trace: <TASK> __rpc_execute+0xbc/0x480 rpc_async_schedule+0x2f/0x40 process_one_work+0x232/0x5d0 worker_thread+0x1da/0x3d0 ? __pfx_worker_thread+0x10/0x10 kthread+0x10d/0x240 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x34/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK> Modules linked in: CR2: 000000000000000c ---[ end trace 0000000000000000 ]--- Free the allocated nfs4_unlockdata when nfs_get_lock_context() fails and return NULL to terminate subsequent rpc_run_task, preventing NULL pointer dereference.",,"[{""url"":""https://git.kernel.org/stable/c/4c189fd40a09a03f9a900bedb2d9064f1734d72a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/72f552e00c50f265896d3c19edc6696aa2910081"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/85fb7f8ca5f8c138579fdfc9b97b3083e6077d40"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6879a076b98c99c9fe747816fe1c29543442441"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c457dc1ec770a22636b473ce5d35614adfe97636"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da824f1271633bcb515ca8084cda3eda4b3ace51"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/db6f5ee1fc8f54d079d0751292c2fc2d78e3aad1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f601960af04d2ecb007c928ba153d34051acd9c1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38024,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:34.333,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/rxe: Fix slab-use-after-free Read in rxe_queue_cleanup bug Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x7d/0xa0 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0xcf/0x610 mm/kasan/report.c:489 kasan_report+0xb5/0xe0 mm/kasan/report.c:602 rxe_queue_cleanup+0xd0/0xe0 drivers/infiniband/sw/rxe/rxe_queue.c:195 rxe_cq_cleanup+0x3f/0x50 drivers/infiniband/sw/rxe/rxe_cq.c:132 __rxe_cleanup+0x168/0x300 drivers/infiniband/sw/rxe/rxe_pool.c:232 rxe_create_cq+0x22e/0x3a0 drivers/infiniband/sw/rxe/rxe_verbs.c:1109 create_cq+0x658/0xb90 drivers/infiniband/core/uverbs_cmd.c:1052 ib_uverbs_create_cq+0xc7/0x120 drivers/infiniband/core/uverbs_cmd.c:1095 ib_uverbs_write+0x969/0xc90 drivers/infiniband/core/uverbs_main.c:679 vfs_write fs/read_write.c:677 [inline] vfs_write+0x26a/0xcc0 fs/read_write.c:659 ksys_write+0x1b8/0x200 fs/read_write.c:731 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xaa/0x1b0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f In the function rxe_create_cq, when rxe_cq_from_init fails, the function rxe_cleanup will be called to handle the allocated resources. In fact, some memory resources have already been freed in the function rxe_cq_from_init. Thus, this problem will occur. The solution is to let rxe_cleanup do all the work.",,"[{""url"":""https://git.kernel.org/stable/c/16c45ced0b3839d3eee72a86bb172bef6cf58980"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/336edd6b0f5b7fbffc3e065285610624f59e88df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3a3b73e135e3bd18423d0baa72571319c7feb759"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/52daccfc3fa68ee1902d52124921453d7a335591"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c7c80c32e00665234e373ab03fe82f5c5c2c230"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee4c5a2a38596d548566560c0c022ab797e6f71a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f81b33582f9339d2dc17c69b92040d3650bb4bae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8f470e3a757425a8f98fb9a5991e3cf62fc7134"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38025,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:34.467,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iio: adc: ad7606: check for NULL before calling sw_mode_config() Check that the sw_mode_config function pointer is not NULL before calling it. Not all buses define this callback, which resulted in a NULL pointer dereference.",,"[{""url"":""https://git.kernel.org/stable/c/5257d80e22bf27009d6742e4c174f42cfe54e425"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c28ad63aa55eaadad2b1793b90bfbe7296cc03ba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38026,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:34.590,2025-06-18T12:15:18.620,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,[],,,,,,,,,,
CVE-2025-38027,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:34.720,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: regulator: max20086: fix invalid memory access max20086_parse_regulators_dt() calls of_regulator_match() using an array of struct of_regulator_match allocated on the stack for the matches argument. of_regulator_match() calls devm_of_regulator_put_matches(), which calls devres_alloc() to allocate a struct devm_of_regulator_matches which will be de-allocated using devm_of_regulator_put_matches(). struct devm_of_regulator_matches is populated with the stack allocated matches array. If the device fails to probe, devm_of_regulator_put_matches() will be called and will try to call of_node_put() on that stack pointer, generating the following dmesg entries: max20086 6-0028: Failed to read DEVICE_ID reg: -121 kobject: '\xc0$\xa5\x03' (000000002cebcb7a): is not initialized, yet kobject_put() is being called. Followed by a stack trace matching the call flow described above. Switch to allocating the matches array using devm_kcalloc() to avoid accessing the stack pointer long after it's out of scope. This also has the advantage of allowing multiple max20086 to probe without overriding the data stored inside the global of_regulator_match.",,"[{""url"":""https://git.kernel.org/stable/c/5578ab04bd7732f470fc614bbc0a924900399fb8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6b0cd72757c69bc2d45da42b41023e288d02e772"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6ba30f7aa2c550b2ac04f16b81a19a8c045b8660"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7bddac8603d4e396872c2fbf4403ec08e7b1d7c8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d2a9a92bb4cc7568cff68241b0051dc7268bdc68"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38028,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:34.850,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: NFS/localio: Fix a race in nfs_local_open_fh() Once the clp->cl_uuid.lock has been dropped, another CPU could come in and free the struct nfsd_file that was just added. To prevent that from happening, take the RCU read lock before dropping the spin lock.",,"[{""url"":""https://git.kernel.org/stable/c/185a2f2ddabdcf999823f61de67f86376883920d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa7ab64f1e2fdc8f2603aab8e0dd20de89cb10d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38029,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:34.970,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: kasan: avoid sleepable page allocation from atomic context apply_to_pte_range() enters the lazy MMU mode and then invokes kasan_populate_vmalloc_pte() callback on each page table walk iteration. However, the callback can go into sleep when trying to allocate a single page, e.g. if an architecutre disables preemption on lazy MMU mode enter. On s390 if make arch_enter_lazy_mmu_mode() -> preempt_enable() and arch_leave_lazy_mmu_mode() -> preempt_disable(), such crash occurs: [ 0.663336] BUG: sleeping function called from invalid context at ./include/linux/sched/mm.h:321 [ 0.663348] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 2, name: kthreadd [ 0.663358] preempt_count: 1, expected: 0 [ 0.663366] RCU nest depth: 0, expected: 0 [ 0.663375] no locks held by kthreadd/2. [ 0.663383] Preemption disabled at: [ 0.663386] [<0002f3284cbb4eda>] apply_to_pte_range+0xfa/0x4a0 [ 0.663405] CPU: 0 UID: 0 PID: 2 Comm: kthreadd Not tainted 6.15.0-rc5-gcc-kasan-00043-gd76bb1ebb558-dirty #162 PREEMPT [ 0.663408] Hardware name: IBM 3931 A01 701 (KVM/Linux) [ 0.663409] Call Trace: [ 0.663410] [<0002f3284c385f58>] dump_stack_lvl+0xe8/0x140 [ 0.663413] [<0002f3284c507b9e>] __might_resched+0x66e/0x700 [ 0.663415] [<0002f3284cc4f6c0>] __alloc_frozen_pages_noprof+0x370/0x4b0 [ 0.663419] [<0002f3284ccc73c0>] alloc_pages_mpol+0x1a0/0x4a0 [ 0.663421] [<0002f3284ccc8518>] alloc_frozen_pages_noprof+0x88/0xc0 [ 0.663424] [<0002f3284ccc8572>] alloc_pages_noprof+0x22/0x120 [ 0.663427] [<0002f3284cc341ac>] get_free_pages_noprof+0x2c/0xc0 [ 0.663429] [<0002f3284cceba70>] kasan_populate_vmalloc_pte+0x50/0x120 [ 0.663433] [<0002f3284cbb4ef8>] apply_to_pte_range+0x118/0x4a0 [ 0.663435] [<0002f3284cbc7c14>] apply_to_pmd_range+0x194/0x3e0 [ 0.663437] [<0002f3284cbc99be>] __apply_to_page_range+0x2fe/0x7a0 [ 0.663440] [<0002f3284cbc9e88>] apply_to_page_range+0x28/0x40 [ 0.663442] [<0002f3284ccebf12>] kasan_populate_vmalloc+0x82/0xa0 [ 0.663445] [<0002f3284cc1578c>] alloc_vmap_area+0x34c/0xc10 [ 0.663448] [<0002f3284cc1c2a6>] __get_vm_area_node+0x186/0x2a0 [ 0.663451] [<0002f3284cc1e696>] __vmalloc_node_range_noprof+0x116/0x310 [ 0.663454] [<0002f3284cc1d950>] __vmalloc_node_noprof+0xd0/0x110 [ 0.663457] [<0002f3284c454b88>] alloc_thread_stack_node+0xf8/0x330 [ 0.663460] [<0002f3284c458d56>] dup_task_struct+0x66/0x4d0 [ 0.663463] [<0002f3284c45be90>] copy_process+0x280/0x4b90 [ 0.663465] [<0002f3284c460940>] kernel_clone+0xd0/0x4b0 [ 0.663467] [<0002f3284c46115e>] kernel_thread+0xbe/0xe0 [ 0.663469] [<0002f3284c4e440e>] kthreadd+0x50e/0x7f0 [ 0.663472] [<0002f3284c38c04a>] __ret_from_fork+0x8a/0xf0 [ 0.663475] [<0002f3284ed57ff2>] ret_from_fork+0xa/0x38 Instead of allocating single pages per-PTE, bulk-allocate the shadow memory prior to applying kasan_populate_vmalloc_pte() callback on a page range.",,"[{""url"":""https://git.kernel.org/stable/c/6748dd09196248b985cca39eaf651d5317271977"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b6ea95a34cbd014ab6ade4248107b86b0aaf2d6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38030,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:35.100,2025-06-19T13:15:51.760,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,[],,,,,,,,,,
CVE-2025-38031,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:35.230,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: padata: do not leak refcount in reorder_work A recent patch that addressed a UAF introduced a reference count leak: the parallel_data refcount is incremented unconditionally, regardless of the return value of queue_work(). If the work item is already queued, the incremented refcount is never decremented. Fix this by checking the return value of queue_work() and decrementing the refcount when necessary. Resolves: Unreferenced object 0xffff9d9f421e3d80 (size 192): comm ""cryptomgr_probe"", pid 157, jiffies 4294694003 hex dump (first 32 bytes): 80 8b cf 41 9f 9d ff ff b8 97 e0 89 ff ff ff ff ...A............ d0 97 e0 89 ff ff ff ff 19 00 00 00 1f 88 23 00 ..............#. backtrace (crc 838fb36): __kmalloc_cache_noprof+0x284/0x320 padata_alloc_pd+0x20/0x1e0 padata_alloc_shell+0x3b/0xa0 0xffffffffc040a54d cryptomgr_probe+0x43/0xc0 kthread+0xf6/0x1f0 ret_from_fork+0x2f/0x50 ret_from_fork_asm+0x1a/0x30",,"[{""url"":""https://git.kernel.org/stable/c/1a426abdf1c86882c9203dd8182f3b8274b89938"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1c65ae4988714716101555fe2b9830e33136d6fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5300e487487d7a2e3e1e6e9d8f03ed9452e4019e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/584a729615fa92f4de45480efb7e569d14be1516"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b9ad8e50e8589607e68e6c4cefa7f72bf35a2cb1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cceb15864e1612ebfbc10ec4e4dcd19a10c0056c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d6ebcde6d4ecf34f8495fb30516645db3aea8993"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38032,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:35.357,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mr: consolidate the ipmr_can_free_table() checks. Guoyu Yin reported a splat in the ipmr netns cleanup path: WARNING: CPU: 2 PID: 14564 at net/ipv4/ipmr.c:440 ipmr_free_table net/ipv4/ipmr.c:440 [inline] WARNING: CPU: 2 PID: 14564 at net/ipv4/ipmr.c:440 ipmr_rules_exit+0x135/0x1c0 net/ipv4/ipmr.c:361 Modules linked in: CPU: 2 UID: 0 PID: 14564 Comm: syz.4.838 Not tainted 6.14.0 #1 Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 RIP: 0010:ipmr_free_table net/ipv4/ipmr.c:440 [inline] RIP: 0010:ipmr_rules_exit+0x135/0x1c0 net/ipv4/ipmr.c:361 Code: ff df 48 c1 ea 03 80 3c 02 00 75 7d 48 c7 83 60 05 00 00 00 00 00 00 5b 5d 41 5c 41 5d 41 5e e9 71 67 7f 00 e8 4c 2d 8a fd 90 <0f> 0b 90 eb 93 e8 41 2d 8a fd 0f b6 2d 80 54 ea 01 31 ff 89 ee e8 RSP: 0018:ffff888109547c58 EFLAGS: 00010293 RAX: 0000000000000000 RBX: ffff888108c12dc0 RCX: ffffffff83e09868 RDX: ffff8881022b3300 RSI: ffffffff83e098d4 RDI: 0000000000000005 RBP: ffff888104288000 R08: 0000000000000000 R09: ffffed10211825c9 R10: 0000000000000001 R11: ffff88801816c4a0 R12: 0000000000000001 R13: ffff888108c13320 R14: ffff888108c12dc0 R15: fffffbfff0b74058 FS: 00007f84f39316c0(0000) GS:ffff88811b100000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f84f3930f98 CR3: 0000000113b56000 CR4: 0000000000350ef0 Call Trace: <TASK> ipmr_net_exit_batch+0x50/0x90 net/ipv4/ipmr.c:3160 ops_exit_list+0x10c/0x160 net/core/net_namespace.c:177 setup_net+0x47d/0x8e0 net/core/net_namespace.c:394 copy_net_ns+0x25d/0x410 net/core/net_namespace.c:516 create_new_namespaces+0x3f6/0xaf0 kernel/nsproxy.c:110 unshare_nsproxy_namespaces+0xc3/0x180 kernel/nsproxy.c:228 ksys_unshare+0x78d/0x9a0 kernel/fork.c:3342 __do_sys_unshare kernel/fork.c:3413 [inline] __se_sys_unshare kernel/fork.c:3411 [inline] __x64_sys_unshare+0x31/0x40 kernel/fork.c:3411 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xa6/0x1a0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7f84f532cc29 Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007f84f3931038 EFLAGS: 00000246 ORIG_RAX: 0000000000000110 RAX: ffffffffffffffda RBX: 00007f84f5615fa0 RCX: 00007f84f532cc29 RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000040000400 RBP: 00007f84f53fba18 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 0000000000000000 R14: 00007f84f5615fa0 R15: 00007fff51c5f328 </TASK> The running kernel has CONFIG_IP_MROUTE_MULTIPLE_TABLES disabled, and the sanity check for such build is still too loose. Address the issue consolidating the relevant sanity check in a single helper regardless of the kernel configuration. Also share it between the ipv4 and ipv6 code.",,"[{""url"":""https://git.kernel.org/stable/c/1c518ae98302ab37786d5ba5d43e9ac6d6f894e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c46286fdd6aa1d0e33c245bcffe9ff2428a777bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38033,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:35.470,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: x86/Kconfig: make CFI_AUTO_DEFAULT depend on !RUST or Rust >= 1.88 Calling core::fmt::write() from rust code while FineIBT is enabled results in a kernel panic: [ 4614.199779] kernel BUG at arch/x86/kernel/cet.c:132! [ 4614.205343] Oops: invalid opcode: 0000 [#1] PREEMPT SMP NOPTI [ 4614.211781] CPU: 2 UID: 0 PID: 6057 Comm: dmabuf_dump Tainted: G U O 6.12.17-android16-0-g6ab38c534a43 #1 9da040f27673ec3945e23b998a0f8bd64c846599 [ 4614.227832] Tainted: [U]=USER, [O]=OOT_MODULE [ 4614.241247] RIP: 0010:do_kernel_cp_fault+0xea/0xf0 ... [ 4614.398144] RIP: 0010:_RNvXs5_NtNtNtCs3o2tGsuHyou_4core3fmt3num3impyNtB9_7Display3fmt+0x0/0x20 [ 4614.407792] Code: 48 f7 df 48 0f 48 f9 48 89 f2 89 c6 5d e9 18 fd ff ff 0f 1f 84 00 00 00 00 00 f3 0f 1e fa 41 81 ea 14 61 af 2c 74 03 0f 0b 90 <66> 0f 1f 00 55 48 89 e5 48 89 f2 48 8b 3f be 01 00 00 00 5d e9 e7 [ 4614.428775] RSP: 0018:ffffb95acfa4ba68 EFLAGS: 00010246 [ 4614.434609] RAX: 0000000000000000 RBX: 0000000000000010 RCX: 0000000000000000 [ 4614.442587] RDX: 0000000000000007 RSI: ffffb95acfa4ba70 RDI: ffffb95acfa4bc88 [ 4614.450557] RBP: ffffb95acfa4bae0 R08: ffff0a00ffffff05 R09: 0000000000000070 [ 4614.458527] R10: 0000000000000000 R11: ffffffffab67eaf0 R12: ffffb95acfa4bcc8 [ 4614.466493] R13: ffffffffac5d50f0 R14: 0000000000000000 R15: 0000000000000000 [ 4614.474473] ? __cfi__RNvXs5_NtNtNtCs3o2tGsuHyou_4core3fmt3num3impyNtB9_7Display3fmt+0x10/0x10 [ 4614.484118] ? _RNvNtCs3o2tGsuHyou_4core3fmt5write+0x1d2/0x250 This happens because core::fmt::write() calls core::fmt::rt::Argument::fmt(), which currently has CFI disabled: library/core/src/fmt/rt.rs: 171 // FIXME: Transmuting formatter in new and indirectly branching to/calling 172 // it here is an explicit CFI violation. 173 #[allow(inline_no_sanitize)] 174 #[no_sanitize(cfi, kcfi)] 175 #[inline] 176 pub(super) unsafe fn fmt(&self, f: &mut Formatter<'_>) -> Result { This causes a Control Protection exception, because FineIBT has sealed off the original function's endbr64. This makes rust currently incompatible with FineIBT. Add a Kconfig dependency that prevents FineIBT from getting turned on by default if rust is enabled. [ Rust 1.88.0 (scheduled for 2025-06-26) should have this fixed [1], and thus we relaxed the condition with Rust >= 1.88. When `objtool` lands checking for this with e.g. [2], the plan is to ideally run that in upstream Rust's CI to prevent regressions early [3], since we do not control `core`'s source code. Alice tested the Rust PR backported to an older compiler. Peter would like that Rust provides a stable `core` which can be pulled into the kernel: ""Relying on that much out of tree code is 'unfortunate'"". - Miguel ] [ Reduced splat. - Miguel ]",,"[{""url"":""https://git.kernel.org/stable/c/5595c31c370957aabe739ac3996aedba8267603f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a8d073d87da4ad1496b35adaee5719e94665d81"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6b9956d09382bcbd5fd260c4b60ec48680a4cffb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38034,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:35.593,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: correct the order of prelim_ref arguments in btrfs__prelim_ref btrfs_prelim_ref() calls the old and new reference variables in the incorrect order. This causes a NULL pointer dereference because oldref is passed as NULL to trace_btrfs_prelim_ref_insert(). Note, trace_btrfs_prelim_ref_insert() is being called with newref as oldref (and oldref as NULL) on purpose in order to print out the values of newref. To reproduce: echo 1 > /sys/kernel/debug/tracing/events/btrfs/btrfs_prelim_ref_insert/enable Perform some writeback operations. Backtrace: BUG: kernel NULL pointer dereference, address: 0000000000000018 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 115949067 P4D 115949067 PUD 11594a067 PMD 0 Oops: Oops: 0000 [#1] SMP NOPTI CPU: 1 UID: 0 PID: 1188 Comm: fsstress Not tainted 6.15.0-rc2-tester+ #47 PREEMPT(voluntary) 7ca2cef72d5e9c600f0c7718adb6462de8149622 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.3-2-gc13ff2cd-prebuilt.qemu.org 04/01/2014 RIP: 0010:trace_event_raw_event_btrfs__prelim_ref+0x72/0x130 Code: e8 43 81 9f ff 48 85 c0 74 78 4d 85 e4 0f 84 8f 00 00 00 49 8b 94 24 c0 06 00 00 48 8b 0a 48 89 48 08 48 8b 52 08 48 89 50 10 <49> 8b 55 18 48 89 50 18 49 8b 55 20 48 89 50 20 41 0f b6 55 28 88 RSP: 0018:ffffce44820077a0 EFLAGS: 00010286 RAX: ffff8c6b403f9014 RBX: ffff8c6b55825730 RCX: 304994edf9cf506b RDX: d8b11eb7f0fdb699 RSI: ffff8c6b403f9010 RDI: ffff8c6b403f9010 RBP: 0000000000000001 R08: 0000000000000001 R09: 0000000000000010 R10: 00000000ffffffff R11: 0000000000000000 R12: ffff8c6b4e8fb000 R13: 0000000000000000 R14: ffffce44820077a8 R15: ffff8c6b4abd1540 FS: 00007f4dc6813740(0000) GS:ffff8c6c1d378000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000018 CR3: 000000010eb42000 CR4: 0000000000750ef0 PKRU: 55555554 Call Trace: <TASK> prelim_ref_insert+0x1c1/0x270 find_parent_nodes+0x12a6/0x1ee0 ? __entry_text_end+0x101f06/0x101f09 ? srso_alias_return_thunk+0x5/0xfbef5 ? srso_alias_return_thunk+0x5/0xfbef5 ? srso_alias_return_thunk+0x5/0xfbef5 ? srso_alias_return_thunk+0x5/0xfbef5 btrfs_is_data_extent_shared+0x167/0x640 ? fiemap_process_hole+0xd0/0x2c0 extent_fiemap+0xa5c/0xbc0 ? __entry_text_end+0x101f05/0x101f09 btrfs_fiemap+0x7e/0xd0 do_vfs_ioctl+0x425/0x9d0 __x64_sys_ioctl+0x75/0xc0",,"[{""url"":""https://git.kernel.org/stable/c/0528bba48dce7820d2da72e1a114e1c4552367eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/137bfa08c6441f324d00692d1e9d22cfd773329b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5755b6731655e248c4f1d52a2e1b18795b4a2a3a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7a97f961a568a8f72472dc804af02a0f73152c5f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f7c8c03feba5f2454792fab3bb8bd45bd6883f9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a641154cedf9d69730f8af5d0a901fe86e6486bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a876703894a6dd6e8c04b0635d86e9f7a7c81b79"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bc7e0975093567f51be8e1bdf4aa5900a3cf0b1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38035,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:35.750,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nvmet-tcp: don't restore null sk_state_change queue->state_change is set as part of nvmet_tcp_set_queue_sock(), but if the TCP connection isn't established when nvmet_tcp_set_queue_sock() is called then queue->state_change isn't set and sock->sk->sk_state_change isn't replaced. As such we don't need to restore sock->sk->sk_state_change if queue->state_change is NULL. This avoids NULL pointer dereferences such as this: [ 286.462026][ C0] BUG: kernel NULL pointer dereference, address: 0000000000000000 [ 286.462814][ C0] #PF: supervisor instruction fetch in kernel mode [ 286.463796][ C0] #PF: error_code(0x0010) - not-present page [ 286.464392][ C0] PGD 8000000140620067 P4D 8000000140620067 PUD 114201067 PMD 0 [ 286.465086][ C0] Oops: Oops: 0010 [#1] SMP KASAN PTI [ 286.465559][ C0] CPU: 0 UID: 0 PID: 1628 Comm: nvme Not tainted 6.15.0-rc2+ #11 PREEMPT(voluntary) [ 286.466393][ C0] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-3.fc41 04/01/2014 [ 286.467147][ C0] RIP: 0010:0x0 [ 286.467420][ C0] Code: Unable to access opcode bytes at 0xffffffffffffffd6. [ 286.467977][ C0] RSP: 0018:ffff8883ae008580 EFLAGS: 00010246 [ 286.468425][ C0] RAX: 0000000000000000 RBX: ffff88813fd34100 RCX: ffffffffa386cc43 [ 286.469019][ C0] RDX: 1ffff11027fa68b6 RSI: 0000000000000008 RDI: ffff88813fd34100 [ 286.469545][ C0] RBP: ffff88813fd34160 R08: 0000000000000000 R09: ffffed1027fa682c [ 286.470072][ C0] R10: ffff88813fd34167 R11: 0000000000000000 R12: ffff88813fd344c3 [ 286.470585][ C0] R13: ffff88813fd34112 R14: ffff88813fd34aec R15: ffff888132cdd268 [ 286.471070][ C0] FS: 00007fe3c04c7d80(0000) GS:ffff88840743f000(0000) knlGS:0000000000000000 [ 286.471644][ C0] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 286.472543][ C0] CR2: ffffffffffffffd6 CR3: 000000012daca000 CR4: 00000000000006f0 [ 286.473500][ C0] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 286.474467][ C0] DR3: 0000000000000000 DR6: 00000000ffff07f0 DR7: 0000000000000400 [ 286.475453][ C0] Call Trace: [ 286.476102][ C0] <IRQ> [ 286.476719][ C0] tcp_fin+0x2bb/0x440 [ 286.477429][ C0] tcp_data_queue+0x190f/0x4e60 [ 286.478174][ C0] ? __build_skb_around+0x234/0x330 [ 286.478940][ C0] ? rcu_is_watching+0x11/0xb0 [ 286.479659][ C0] ? __pfx_tcp_data_queue+0x10/0x10 [ 286.480431][ C0] ? tcp_try_undo_loss+0x640/0x6c0 [ 286.481196][ C0] ? seqcount_lockdep_reader_access.constprop.0+0x82/0x90 [ 286.482046][ C0] ? kvm_clock_get_cycles+0x14/0x30 [ 286.482769][ C0] ? ktime_get+0x66/0x150 [ 286.483433][ C0] ? rcu_is_watching+0x11/0xb0 [ 286.484146][ C0] tcp_rcv_established+0x6e4/0x2050 [ 286.484857][ C0] ? rcu_is_watching+0x11/0xb0 [ 286.485523][ C0] ? ipv4_dst_check+0x160/0x2b0 [ 286.486203][ C0] ? __pfx_tcp_rcv_established+0x10/0x10 [ 286.486917][ C0] ? lock_release+0x217/0x2c0 [ 286.487595][ C0] tcp_v4_do_rcv+0x4d6/0x9b0 [ 286.488279][ C0] tcp_v4_rcv+0x2af8/0x3e30 [ 286.488904][ C0] ? raw_local_deliver+0x51b/0xad0 [ 286.489551][ C0] ? rcu_is_watching+0x11/0xb0 [ 286.490198][ C0] ? __pfx_tcp_v4_rcv+0x10/0x10 [ 286.490813][ C0] ? __pfx_raw_local_deliver+0x10/0x10 [ 286.491487][ C0] ? __pfx_nf_confirm+0x10/0x10 [nf_conntrack] [ 286.492275][ C0] ? rcu_is_watching+0x11/0xb0 [ 286.492900][ C0] ip_protocol_deliver_rcu+0x8f/0x370 [ 286.493579][ C0] ip_local_deliver_finish+0x297/0x420 [ 286.494268][ C0] ip_local_deliver+0x168/0x430 [ 286.494867][ C0] ? __pfx_ip_local_deliver+0x10/0x10 [ 286.495498][ C0] ? __pfx_ip_local_deliver_finish+0x10/0x10 [ 286.496204][ C0] ? ip_rcv_finish_core+0x19a/0x1f20 [ 286.496806][ C0] ? lock_release+0x217/0x2c0 [ 286.497414][ C0] ip_rcv+0x455/0x6e0 [ 286.497945][ C0] ? __pfx_ip_rcv+0x10/0x10 [ ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/17e58be5b49f58bf17799a504f55c2d05ab2ecdc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3a982ada411b8c52695f1784c3f4784771f30209"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/46d22b47df2741996af277a2838b95f130436c13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6265538446e2426f4bf3b57e91d7680b2047ddd9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a21cb31642ffc84ca4ce55028212a96f72f54d30"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c240375587ddcc80e1022f52ee32b946bbc3a639"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec462449f4cf616b0aa2ed119f5f44b5fdfcefab"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc01b547c3f8bfa6e1d23cd5a2c63c736e8c3e4e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38036,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:35.897,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/xe/vf: Perform early GT MMIO initialization to read GMDID VFs need to communicate with the GuC to obtain the GMDID value and existing GuC functions used for that assume that the GT has it's MMIO members already setup. However, due to recent refactoring the gt->mmio is initialized later, and any attempt by the VF to use xe_mmio_read|write() from GuC functions will lead to NPD crash due to unset MMIO register address: [] xe 0000:00:02.1: [drm] Running in SR-IOV VF mode [] xe 0000:00:02.1: [drm] GT0: sending H2G MMIO 0x5507 [] BUG: unable to handle page fault for address: 0000000000190240 Since we are already tweaking the id and type of the primary GT to mimic it's a Media GT before initializing the GuC communication, we can also call xe_gt_mmio_init() to perform early setup of the gt->mmio which will make those GuC functions work again.",,"[{""url"":""https://git.kernel.org/stable/c/13265fe7426ec9ba5aa86baab913417ca361e8a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ef6e950aea76a5009ccc79ebfa955ecc66cd85a2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38037,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:36.030,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: vxlan: Annotate FDB data races The 'used' and 'updated' fields in the FDB entry structure can be accessed concurrently by multiple threads, leading to reports such as [1]. Can be reproduced using [2]. Suppress these reports by annotating these accesses using READ_ONCE() / WRITE_ONCE(). [1] BUG: KCSAN: data-race in vxlan_xmit / vxlan_xmit write to 0xffff942604d263a8 of 8 bytes by task 286 on cpu 0: vxlan_xmit+0xb29/0x2380 dev_hard_start_xmit+0x84/0x2f0 __dev_queue_xmit+0x45a/0x1650 packet_xmit+0x100/0x150 packet_sendmsg+0x2114/0x2ac0 __sys_sendto+0x318/0x330 __x64_sys_sendto+0x76/0x90 x64_sys_call+0x14e8/0x1c00 do_syscall_64+0x9e/0x1a0 entry_SYSCALL_64_after_hwframe+0x77/0x7f read to 0xffff942604d263a8 of 8 bytes by task 287 on cpu 2: vxlan_xmit+0xadf/0x2380 dev_hard_start_xmit+0x84/0x2f0 __dev_queue_xmit+0x45a/0x1650 packet_xmit+0x100/0x150 packet_sendmsg+0x2114/0x2ac0 __sys_sendto+0x318/0x330 __x64_sys_sendto+0x76/0x90 x64_sys_call+0x14e8/0x1c00 do_syscall_64+0x9e/0x1a0 entry_SYSCALL_64_after_hwframe+0x77/0x7f value changed: 0x00000000fffbac6e -> 0x00000000fffbac6f Reported by Kernel Concurrency Sanitizer on: CPU: 2 UID: 0 PID: 287 Comm: mausezahn Not tainted 6.13.0-rc7-01544-gb4b270f11a02 #5 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-3.fc41 04/01/2014 [2] #!/bin/bash set +H echo whitelist > /sys/kernel/debug/kcsan echo !vxlan_xmit > /sys/kernel/debug/kcsan ip link add name vx0 up type vxlan id 10010 dstport 4789 local 192.0.2.1 bridge fdb add 00:11:22:33:44:55 dev vx0 self static dst 198.51.100.1 taskset -c 0 mausezahn vx0 -a own -b 00:11:22:33:44:55 -c 0 -q & taskset -c 2 mausezahn vx0 -a own -b 00:11:22:33:44:55 -c 0 -q &",,"[{""url"":""https://git.kernel.org/stable/c/02a33b1035a307453a1da6ce0a1bf3676be287d7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/13cba3f837903f7184d6e9b6137d5165ffe82a8f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4eceb7eae6ea7c950384c34e6dbbe872c981935f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/784b78295a3a58bf052339dd669e6e03710220d3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/87d076987a9ba106c83412fcd113656f71af05a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6644aeb8ddf196dec5f8e782293c36f065df4d7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e033da39fc6abbddab6c29624acef80757f273fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f6205f8215f12a96518ac9469ff76294ae7bd612"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38038,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:36.160,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: cpufreq: amd-pstate: Remove unnecessary driver_lock in set_boost set_boost is a per-policy function call, hence a driver wide lock is unnecessary. Also this mutex_acquire can collide with the mutex_acquire from the mode-switch path in status_store(), which can lead to a deadlock. So, remove it.",,"[{""url"":""https://git.kernel.org/stable/c/61e931ee145eeab8196e585ff4334870b130b744"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd347d071713234586762d79c5a691785e9be418"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/db1cafc77aaaf871509da06f4a864e9af6d6791f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38039,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:36.280,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/mlx5e: Avoid WARN_ON when configuring MQPRIO with HTB offload enabled When attempting to enable MQPRIO while HTB offload is already configured, the driver currently returns `-EINVAL` and triggers a `WARN_ON`, leading to an unnecessary call trace. Update the code to handle this case more gracefully by returning `-EOPNOTSUPP` instead, while also providing a helpful user message.",,"[{""url"":""https://git.kernel.org/stable/c/090c0ba179eaf7b670e720aa054533756a43d565"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/689805dcc474c2accb5cffbbcea1c06ee4a54570"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9e2bac6835f73895598df5a3a125a19497fad46b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b82e496531c571caf8a2ef247f51c160bab2162e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38040,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:36.400,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: serial: mctrl_gpio: split disable_ms into sync and no_sync APIs The following splat has been observed on a SAMA5D27 platform using atmel_serial: BUG: sleeping function called from invalid context at kernel/irq/manage.c:738 in_atomic(): 1, irqs_disabled(): 128, non_block: 0, pid: 27, name: kworker/u5:0 preempt_count: 1, expected: 0 INFO: lockdep is turned off. irq event stamp: 0 hardirqs last enabled at (0): [<00000000>] 0x0 hardirqs last disabled at (0): [<c01588f0>] copy_process+0x1c4c/0x7bec softirqs last enabled at (0): [<c0158944>] copy_process+0x1ca0/0x7bec softirqs last disabled at (0): [<00000000>] 0x0 CPU: 0 UID: 0 PID: 27 Comm: kworker/u5:0 Not tainted 6.13.0-rc7+ #74 Hardware name: Atmel SAMA5 Workqueue: hci0 hci_power_on [bluetooth] Call trace: unwind_backtrace from show_stack+0x18/0x1c show_stack from dump_stack_lvl+0x44/0x70 dump_stack_lvl from __might_resched+0x38c/0x598 __might_resched from disable_irq+0x1c/0x48 disable_irq from mctrl_gpio_disable_ms+0x74/0xc0 mctrl_gpio_disable_ms from atmel_disable_ms.part.0+0x80/0x1f4 atmel_disable_ms.part.0 from atmel_set_termios+0x764/0x11e8 atmel_set_termios from uart_change_line_settings+0x15c/0x994 uart_change_line_settings from uart_set_termios+0x2b0/0x668 uart_set_termios from tty_set_termios+0x600/0x8ec tty_set_termios from ttyport_set_flow_control+0x188/0x1e0 ttyport_set_flow_control from wilc_setup+0xd0/0x524 [hci_wilc] wilc_setup [hci_wilc] from hci_dev_open_sync+0x330/0x203c [bluetooth] hci_dev_open_sync [bluetooth] from hci_dev_do_open+0x40/0xb0 [bluetooth] hci_dev_do_open [bluetooth] from hci_power_on+0x12c/0x664 [bluetooth] hci_power_on [bluetooth] from process_one_work+0x998/0x1a38 process_one_work from worker_thread+0x6e0/0xfb4 worker_thread from kthread+0x3d4/0x484 kthread from ret_from_fork+0x14/0x28 This warning is emitted when trying to toggle, at the highest level, some flow control (with serdev_device_set_flow_control) in a device driver. At the lowest level, the atmel_serial driver is using serial_mctrl_gpio lib to enable/disable the corresponding IRQs accordingly. The warning emitted by CONFIG_DEBUG_ATOMIC_SLEEP is due to disable_irq (called in mctrl_gpio_disable_ms) being possibly called in some atomic context (some tty drivers perform modem lines configuration in regions protected by port lock). Split mctrl_gpio_disable_ms into two differents APIs, a non-blocking one and a blocking one. Replace mctrl_gpio_disable_ms calls with the relevant version depending on whether the call is protected by some port lock.",,"[{""url"":""https://git.kernel.org/stable/c/1bd2aad57da95f7f2d2bb52f7ad15c0f4993a685"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/68435c1fa3db696db4f480385db9e50e26691d0d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7187ec6b0b9ff22ebac2c3bb4178b7dbbdc0a55a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c504c11b94d6e4ad818ca5578dffa8ff29ad0f20"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e6a46719a2369eb5186d4f7e6c0478720ca1ec3d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38041,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:36.533,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: clk: sunxi-ng: h616: Reparent GPU clock during frequency changes The H616 manual does not state that the GPU PLL supports dynamic frequency configuration, so we must take extra care when changing the frequency. Currently any attempt to do device DVFS on the GPU lead to panfrost various ooops, and GPU hangs. The manual describes the algorithm for changing the PLL frequency, which the CPU PLL notifier code already support, so we reuse that to reparent the GPU clock to GPU1 clock during frequency changes.",,"[{""url"":""https://git.kernel.org/stable/c/1439673b78185eaaa5fae444b3a9d58c434ee78e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb963d7948ce6571939c6875424b557b25f16610"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38042,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:36.657,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dmaengine: ti: k3-udma-glue: Drop skip_fdq argument from k3_udma_glue_reset_rx_chn The user of k3_udma_glue_reset_rx_chn() e.g. ti_am65_cpsw_nuss can run on multiple platforms having different DMA architectures. On some platforms there can be one FDQ for all flows in the RX channel while for others there is a separate FDQ for each flow in the RX channel. So far we have been relying on the skip_fdq argument of k3_udma_glue_reset_rx_chn(). Instead of relying on the user to provide this information, infer it based on DMA architecture during k3_udma_glue_request_rx_chn() and save it in an internal flag 'single_fdq'. Use that flag at k3_udma_glue_reset_rx_chn() to deicide if the FDQ needs to be cleared for every flow or just for flow 0. Fixes the below issue on ti_am65_cpsw_nuss driver on AM62-SK. > ip link set eth1 down > ip link set eth0 down > ethtool -L eth0 rx 8 > ip link set eth0 up > modprobe -r ti_am65_cpsw_nuss [ 103.045726] ------------[ cut here ]------------ [ 103.050505] k3_knav_desc_pool size 512000 != avail 64000 [ 103.050703] WARNING: CPU: 1 PID: 450 at drivers/net/ethernet/ti/k3-cppi-desc-pool.c:33 k3_cppi_desc_pool_destroy+0xa0/0xa8 [k3_cppi_desc_pool] [ 103.068810] Modules linked in: ti_am65_cpsw_nuss(-) k3_cppi_desc_pool snd_soc_hdmi_codec crct10dif_ce snd_soc_simple_card snd_soc_simple_card_utils display_connector rtc_ti_k3 k3_j72xx_bandgap tidss drm_client_lib snd_soc_davinci_mcas p drm_dma_helper tps6598x phylink snd_soc_ti_udma rti_wdt drm_display_helper snd_soc_tlv320aic3x_i2c typec at24 phy_gmii_sel snd_soc_ti_edma snd_soc_tlv320aic3x sii902x snd_soc_ti_sdma sa2ul omap_mailbox drm_kms_helper authenc cfg80211 r fkill fuse drm drm_panel_orientation_quirks backlight ip_tables x_tables ipv6 [last unloaded: k3_cppi_desc_pool] [ 103.119950] CPU: 1 UID: 0 PID: 450 Comm: modprobe Not tainted 6.13.0-rc7-00001-g9c5e3435fa66 #1011 [ 103.119968] Hardware name: Texas Instruments AM625 SK (DT) [ 103.119974] pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 103.119983] pc : k3_cppi_desc_pool_destroy+0xa0/0xa8 [k3_cppi_desc_pool] [ 103.148007] lr : k3_cppi_desc_pool_destroy+0xa0/0xa8 [k3_cppi_desc_pool] [ 103.154709] sp : ffff8000826ebbc0 [ 103.158015] x29: ffff8000826ebbc0 x28: ffff0000090b6300 x27: 0000000000000000 [ 103.165145] x26: 0000000000000000 x25: 0000000000000000 x24: ffff0000019df6b0 [ 103.172271] x23: ffff0000019df6b8 x22: ffff0000019df410 x21: ffff8000826ebc88 [ 103.179397] x20: 000000000007d000 x19: ffff00000a3b3000 x18: 0000000000000000 [ 103.186522] x17: 0000000000000000 x16: 0000000000000000 x15: 000001e8c35e1cde [ 103.193647] x14: 0000000000000396 x13: 000000000000035c x12: 0000000000000000 [ 103.200772] x11: 000000000000003a x10: 00000000000009c0 x9 : ffff8000826eba20 [ 103.207897] x8 : ffff0000090b6d20 x7 : ffff00007728c180 x6 : ffff00007728c100 [ 103.215022] x5 : 0000000000000001 x4 : ffff000000508a50 x3 : ffff7ffff6146000 [ 103.222147] x2 : 0000000000000000 x1 : e300b4173ee6b200 x0 : 0000000000000000 [ 103.229274] Call trace: [ 103.231714] k3_cppi_desc_pool_destroy+0xa0/0xa8 [k3_cppi_desc_pool] (P) [ 103.238408] am65_cpsw_nuss_free_rx_chns+0x28/0x4c [ti_am65_cpsw_nuss] [ 103.244942] devm_action_release+0x14/0x20 [ 103.249040] release_nodes+0x3c/0x68 [ 103.252610] devres_release_all+0x8c/0xdc [ 103.256614] device_unbind_cleanup+0x18/0x60 [ 103.260876] device_release_driver_internal+0xf8/0x178 [ 103.266004] driver_detach+0x50/0x9c [ 103.269571] bus_remove_driver+0x6c/0xbc [ 103.273485] driver_unregister+0x30/0x60 [ 103.277401] platform_driver_unregister+0x14/0x20 [ 103.282096] am65_cpsw_nuss_driver_exit+0x18/0xff4 [ti_am65_cpsw_nuss] [ 103.288620] __arm64_sys_delete_module+0x17c/0x25c [ 103.293404] invoke_syscall+0x44/0x100 [ 103.297149] el0_svc_common.constprop.0+0xc0/0xe0 [ 103.301845] do_el0_svc+0x1c/0x28 [ 103.305155] el0_svc+0x28/0x98 ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/0da30874729baeb01889b0eca16cfda122687503"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d0dd9d133ef8fdc894e0be9aa27dc49ef5f813cb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38043,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:36.783,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: firmware: arm_ffa: Set dma_mask for ffa devices Set dma_mask for FFA devices, otherwise DMA allocation using the device pointer lead to following warning: WARNING: CPU: 1 PID: 1 at kernel/dma/mapping.c:597 dma_alloc_attrs+0xe0/0x124",,"[{""url"":""https://git.kernel.org/stable/c/2e62c803feec1ef5847d8fa47dd0de039abfa378"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3a3efeef64364c2a028cf0d03d68c831813a97fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/97bab02f0b64ba6bcdf6a8fae561db07f509aee9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c6aa1d6bd6ccff4ecdf064d288817657ec8532f0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc0aac7ca17e0ea3ca84b552fc79f3e86fd07f53"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e2de76c34a8a925efe80fccae4810427bc144ed0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38044,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:36.913,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: cx231xx: set device_caps for 417 The video_device for the MPEG encoder did not set device_caps. Add this, otherwise the video device can't be registered (you get a WARN_ON instead). Not seen before since currently 417 support is disabled, but I found this while experimenting with it.",,"[{""url"":""https://git.kernel.org/stable/c/0884dd3abbe80307a2d4cbdbe5e312be164f8adb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2ad41beb7df3bd63b209842d16765ec59dafe6e4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4731d5328f507ae8fd8a57abbca9119ec7a8d665"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5c9eca180a4235abd56cc7f7308ca72128d93dce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d1a5be86dbe074bd8dd6bdd63a99d6bb66d5930"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a79efc44b51432490538a55b9753a721f7d3ea42"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c91447e35b9bea60bda4408c48e7891d14351021"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e43fd82bb2110bf9d13d800cdc49cceddfd0ede5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38045,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:37.070,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: iwlwifi: fix debug actions order The order of actions taken for debug was implemented incorrectly. Now we implemented the dump split and do the FW reset only in the middle of the dump (rather than the FW killing itself on error.) As a result, some of the actions taken when applying the config will now crash the device, so we need to fix the order.",,"[{""url"":""https://git.kernel.org/stable/c/181e8b56b74ad3920456dcdc8a361520d9007956"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2b790fe67ed483d86c1aeb8be6735bf792caa7e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/328fbc96ecbee16c5fcbfcb3ac57b476f94da2f0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb29b4ffafb20281624dcd2cbb768d6f30edf600"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38046,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:37.187,2025-06-18T12:15:19.173,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,[],,,,,,,,,,
CVE-2025-38047,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:37.317,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: x86/fred: Fix system hang during S4 resume with FRED enabled Upon a wakeup from S4, the restore kernel starts and initializes the FRED MSRs as needed from its perspective. It then loads a hibernation image, including the image kernel, and attempts to load image pages directly into their original page frames used before hibernation unless those frames are currently in use. Once all pages are moved to their original locations, it jumps to a ""trampoline"" page in the image kernel. At this point, the image kernel takes control, but the FRED MSRs still contain values set by the restore kernel, which may differ from those set by the image kernel before hibernation. Therefore, the image kernel must ensure the FRED MSRs have the same values as before hibernation. Since these values depend only on the location of the kernel text and data, they can be recomputed from scratch.",,"[{""url"":""https://git.kernel.org/stable/c/c42f740a07eea4807e98d2d8febc549c957a7b49"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e5f1e8af9c9e151ecd665f6d2e36fb25fec3b110"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e7090fe75a2826363c71ad1fb4e95e58141478df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38048,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:37.450,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: virtio_ring: Fix data race by tagging event_triggered as racy for KCSAN syzbot reports a data-race when accessing the event_triggered, here is the simplified stack when the issue occurred: ================================================================== BUG: KCSAN: data-race in virtqueue_disable_cb / virtqueue_enable_cb_delayed write to 0xffff8881025bc452 of 1 bytes by task 3288 on cpu 0: virtqueue_enable_cb_delayed+0x42/0x3c0 drivers/virtio/virtio_ring.c:2653 start_xmit+0x230/0x1310 drivers/net/virtio_net.c:3264 __netdev_start_xmit include/linux/netdevice.h:5151 [inline] netdev_start_xmit include/linux/netdevice.h:5160 [inline] xmit_one net/core/dev.c:3800 [inline] read to 0xffff8881025bc452 of 1 bytes by interrupt on cpu 1: virtqueue_disable_cb_split drivers/virtio/virtio_ring.c:880 [inline] virtqueue_disable_cb+0x92/0x180 drivers/virtio/virtio_ring.c:2566 skb_xmit_done+0x5f/0x140 drivers/net/virtio_net.c:777 vring_interrupt+0x161/0x190 drivers/virtio/virtio_ring.c:2715 __handle_irq_event_percpu+0x95/0x490 kernel/irq/handle.c:158 handle_irq_event_percpu kernel/irq/handle.c:193 [inline] value changed: 0x01 -> 0x00 ================================================================== When the data race occurs, the function virtqueue_enable_cb_delayed() sets event_triggered to false, and virtqueue_disable_cb_split/packed() reads it as false due to the race condition. Since event_triggered is an unreliable hint used for optimization, this should only cause the driver temporarily suggest that the device not send an interrupt notification when the event index is used. Fix this KCSAN reported data-race issue by explicitly tagging the access as data_racy.",,"[{""url"":""https://git.kernel.org/stable/c/02d2d6caee3abc9335cfca35f8eb4492173ae6f2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2e2f925fe737576df2373931c95e1a2b66efdfef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4ed8f0e808b3fcc71c5b8be7902d8738ed595b17"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b49b5132e4c7307599492aee1cdc6d89f7f2a7da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b6d6419548286b2b9d2b90df824d3cab797f6ae8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b730cb109633c455ce8a7cd6934986c6a16d88d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38049,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-04-18T07:15:43.187,2025-04-29T14:39:34.517,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: x86/resctrl: Fix allocation of cleanest CLOSID on platforms with no monitors Commit 6eac36bb9eb0 (""x86/resctrl: Allocate the cleanest CLOSID by searching closid_num_dirty_rmid"") added logic that causes resctrl to search for the CLOSID with the fewest dirty cache lines when creating a new control group, if requested by the arch code. This depends on the values read from the llc_occupancy counters. The logic is applicable to architectures where the CLOSID effectively forms part of the monitoring identifier and so do not allow complete freedom to choose an unused monitoring identifier for a given CLOSID. This support missed that some platforms may not have these counters. This causes a NULL pointer dereference when creating a new control group as the array was not allocated by dom_data_init(). As this feature isn't necessary on platforms that don't have cache occupancy monitors, add this to the check that occurs when a new control group is allocated.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-476""}]}]","[{""url"":""https://git.kernel.org/stable/c/93a418fc61da13d1ee4047d4d1327990f7a2816a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/a121798ae669351ec0697c94f71c3a692b2a755b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/a8a1bcc27d4607227088d80483164289b5348293"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/ed5addb55e403ad6598102bcf546e068ae01fef6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.9"",""versionEndExcluding"":""6.12.23"",""matchCriteriaId"":""10F3EB18-ACA3-4775-AC8D-C1CC227D2763""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.13"",""versionEndExcluding"":""6.13.11"",""matchCriteriaId"":""E7E864B0-8C00-4679-BA55-659B4C9C3AD3""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.14"",""versionEndExcluding"":""6.14.2"",""matchCriteriaId"":""FADAE5D8-4808-442C-B218-77B2CE8780A0""}]}]}]",,,,,,,,
CVE-2025-38050,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:37.570,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm/hugetlb: fix kernel NULL pointer dereference when replacing free hugetlb folios A kernel crash was observed when replacing free hugetlb folios: BUG: kernel NULL pointer dereference, address: 0000000000000028 PGD 0 P4D 0 Oops: Oops: 0000 [#1] SMP NOPTI CPU: 28 UID: 0 PID: 29639 Comm: test_cma.sh Tainted 6.15.0-rc6-zp #41 PREEMPT(voluntary) RIP: 0010:alloc_and_dissolve_hugetlb_folio+0x1d/0x1f0 RSP: 0018:ffffc9000b30fa90 EFLAGS: 00010286 RAX: 0000000000000000 RBX: 0000000000342cca RCX: ffffea0043000000 RDX: ffffc9000b30fb08 RSI: ffffea0043000000 RDI: 0000000000000000 RBP: ffffc9000b30fb20 R08: 0000000000001000 R09: 0000000000000000 R10: ffff88886f92eb00 R11: 0000000000000000 R12: ffffea0043000000 R13: 0000000000000000 R14: 00000000010c0200 R15: 0000000000000004 FS: 00007fcda5f14740(0000) GS:ffff8888ec1d8000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000028 CR3: 0000000391402000 CR4: 0000000000350ef0 Call Trace: <TASK> replace_free_hugepage_folios+0xb6/0x100 alloc_contig_range_noprof+0x18a/0x590 ? srso_return_thunk+0x5/0x5f ? down_read+0x12/0xa0 ? srso_return_thunk+0x5/0x5f cma_range_alloc.constprop.0+0x131/0x290 __cma_alloc+0xcf/0x2c0 cma_alloc_write+0x43/0xb0 simple_attr_write_xsigned.constprop.0.isra.0+0xb2/0x110 debugfs_attr_write+0x46/0x70 full_proxy_write+0x62/0xa0 vfs_write+0xf8/0x420 ? srso_return_thunk+0x5/0x5f ? filp_flush+0x86/0xa0 ? srso_return_thunk+0x5/0x5f ? filp_close+0x1f/0x30 ? srso_return_thunk+0x5/0x5f ? do_dup2+0xaf/0x160 ? srso_return_thunk+0x5/0x5f ksys_write+0x65/0xe0 do_syscall_64+0x64/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e There is a potential race between __update_and_free_hugetlb_folio() and replace_free_hugepage_folios(): CPU1 CPU2 __update_and_free_hugetlb_folio replace_free_hugepage_folios folio_test_hugetlb(folio) -- It's still hugetlb folio. __folio_clear_hugetlb(folio) hugetlb_free_folio(folio) h = folio_hstate(folio) -- Here, h is NULL pointer When the above race condition occurs, folio_hstate(folio) returns NULL, and subsequent access to this NULL pointer will cause the system to crash. To resolve this issue, execute folio_hstate(folio) under the protection of the hugetlb_lock lock, ensuring that folio_hstate(folio) does not return NULL.",,"[{""url"":""https://git.kernel.org/stable/c/113ed54ad276c352ee5ce109bdcf0df118a43bda"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e97283978a9848190d451f7038ac399613445f79"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38051,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:37.693,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: smb: client: Fix use-after-free in cifs_fill_dirent There is a race condition in the readdir concurrency process, which may access the rsp buffer after it has been released, triggering the following KASAN warning. ================================================================== BUG: KASAN: slab-use-after-free in cifs_fill_dirent+0xb03/0xb60 [cifs] Read of size 4 at addr ffff8880099b819c by task a.out/342975 CPU: 2 UID: 0 PID: 342975 Comm: a.out Not tainted 6.15.0-rc6+ #240 PREEMPT(full) Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.1-2.fc37 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x53/0x70 print_report+0xce/0x640 kasan_report+0xb8/0xf0 cifs_fill_dirent+0xb03/0xb60 [cifs] cifs_readdir+0x12cb/0x3190 [cifs] iterate_dir+0x1a1/0x520 __x64_sys_getdents+0x134/0x220 do_syscall_64+0x4b/0x110 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7f996f64b9f9 Code: ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 0d f7 c3 0c 00 f7 d8 64 89 8 RSP: 002b:00007f996f53de78 EFLAGS: 00000207 ORIG_RAX: 000000000000004e RAX: ffffffffffffffda RBX: 00007f996f53ecdc RCX: 00007f996f64b9f9 RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000003 RBP: 00007f996f53dea0 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000207 R12: ffffffffffffff88 R13: 0000000000000000 R14: 00007ffc8cd9a500 R15: 00007f996f51e000 </TASK> Allocated by task 408: kasan_save_stack+0x20/0x40 kasan_save_track+0x14/0x30 __kasan_slab_alloc+0x6e/0x70 kmem_cache_alloc_noprof+0x117/0x3d0 mempool_alloc_noprof+0xf2/0x2c0 cifs_buf_get+0x36/0x80 [cifs] allocate_buffers+0x1d2/0x330 [cifs] cifs_demultiplex_thread+0x22b/0x2690 [cifs] kthread+0x394/0x720 ret_from_fork+0x34/0x70 ret_from_fork_asm+0x1a/0x30 Freed by task 342979: kasan_save_stack+0x20/0x40 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x60 __kasan_slab_free+0x37/0x50 kmem_cache_free+0x2b8/0x500 cifs_buf_release+0x3c/0x70 [cifs] cifs_readdir+0x1c97/0x3190 [cifs] iterate_dir+0x1a1/0x520 __x64_sys_getdents64+0x134/0x220 do_syscall_64+0x4b/0x110 entry_SYSCALL_64_after_hwframe+0x76/0x7e The buggy address belongs to the object at ffff8880099b8000 which belongs to the cache cifs_request of size 16588 The buggy address is located 412 bytes inside of freed 16588-byte region [ffff8880099b8000, ffff8880099bc0cc) The buggy address belongs to the physical page: page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x99b8 head: order:3 mapcount:0 entire_mapcount:0 nr_pages_mapped:0 pincount:0 anon flags: 0x80000000000040(head|node=0|zone=1) page_type: f5(slab) raw: 0080000000000040 ffff888001e03400 0000000000000000 dead000000000001 raw: 0000000000000000 0000000000010001 00000000f5000000 0000000000000000 head: 0080000000000040 ffff888001e03400 0000000000000000 dead000000000001 head: 0000000000000000 0000000000010001 00000000f5000000 0000000000000000 head: 0080000000000003 ffffea0000266e01 00000000ffffffff 00000000ffffffff head: ffffffffffffffff 0000000000000000 00000000ffffffff 0000000000000008 page dumped because: kasan: bad access detected Memory state around the buggy address: ffff8880099b8080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ffff8880099b8100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb >ffff8880099b8180: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ^ ffff8880099b8200: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ffff8880099b8280: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ================================================================== POC is available in the link [1]. The problem triggering process is as follows: Process 1 Process 2 ----------------------------------- ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/1b197931fbc821bc7e9e91bf619400db563e3338"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73cadde98f67f76c5eba00ac0b72c453383cec8b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9bea368648ac46f8593a780760362e40291d22a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9c9aafbacc183598f064902365e107b5e856531f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a24c2f05ac3c5b0aaa539d9d913826d2643dfd0e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a7a8fe56e932a36f43e031b398aef92341bf5ea0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aee067e88d61eb72e966f094e4749c6b14e7008f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c8623231e0edfcccb7cc6add0288fa0f0594282f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38052,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:37.830,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/tipc: fix slab-use-after-free Read in tipc_aead_encrypt_done Syzbot reported a slab-use-after-free with the following call trace: ================================================================== BUG: KASAN: slab-use-after-free in tipc_aead_encrypt_done+0x4bd/0x510 net/tipc/crypto.c:840 Read of size 8 at addr ffff88807a733000 by task kworker/1:0/25 Call Trace: kasan_report+0xd9/0x110 mm/kasan/report.c:601 tipc_aead_encrypt_done+0x4bd/0x510 net/tipc/crypto.c:840 crypto_request_complete include/crypto/algapi.h:266 aead_request_complete include/crypto/internal/aead.h:85 cryptd_aead_crypt+0x3b8/0x750 crypto/cryptd.c:772 crypto_request_complete include/crypto/algapi.h:266 cryptd_queue_worker+0x131/0x200 crypto/cryptd.c:181 process_one_work+0x9fb/0x1b60 kernel/workqueue.c:3231 Allocated by task 8355: kzalloc_noprof include/linux/slab.h:778 tipc_crypto_start+0xcc/0x9e0 net/tipc/crypto.c:1466 tipc_init_net+0x2dd/0x430 net/tipc/core.c:72 ops_init+0xb9/0x650 net/core/net_namespace.c:139 setup_net+0x435/0xb40 net/core/net_namespace.c:343 copy_net_ns+0x2f0/0x670 net/core/net_namespace.c:508 create_new_namespaces+0x3ea/0xb10 kernel/nsproxy.c:110 unshare_nsproxy_namespaces+0xc0/0x1f0 kernel/nsproxy.c:228 ksys_unshare+0x419/0x970 kernel/fork.c:3323 __do_sys_unshare kernel/fork.c:3394 Freed by task 63: kfree+0x12a/0x3b0 mm/slub.c:4557 tipc_crypto_stop+0x23c/0x500 net/tipc/crypto.c:1539 tipc_exit_net+0x8c/0x110 net/tipc/core.c:119 ops_exit_list+0xb0/0x180 net/core/net_namespace.c:173 cleanup_net+0x5b7/0xbf0 net/core/net_namespace.c:640 process_one_work+0x9fb/0x1b60 kernel/workqueue.c:3231 After freed the tipc_crypto tx by delete namespace, tipc_aead_encrypt_done may still visit it in cryptd_queue_worker workqueue. I reproduce this issue by: ip netns add ns1 ip link add veth1 type veth peer name veth2 ip link set veth1 netns ns1 ip netns exec ns1 tipc bearer enable media eth dev veth1 ip netns exec ns1 tipc node set key this_is_a_master_key master ip netns exec ns1 tipc bearer disable media eth dev veth1 ip netns del ns1 The key of reproduction is that, simd_aead_encrypt is interrupted, leading to crypto_simd_usable() return false. Thus, the cryptd_queue_worker is triggered, and the tipc_crypto tx will be visited. tipc_disc_timeout tipc_bearer_xmit_skb tipc_crypto_xmit tipc_aead_encrypt crypto_aead_encrypt // encrypt() simd_aead_encrypt // crypto_simd_usable() is false child = &ctx->cryptd_tfm->base; simd_aead_encrypt crypto_aead_encrypt // encrypt() cryptd_aead_encrypt_enqueue cryptd_aead_enqueue cryptd_enqueue_request // trigger cryptd_queue_worker queue_work_on(smp_processor_id(), cryptd_wq, &cpu_queue->work) Fix this by holding net reference count before encrypt.",,"[{""url"":""https://git.kernel.org/stable/c/4a0fddc2c0d5c28aec8c262ad4603be0bef1938c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/689a205cd968a1572ab561b0c4c2d50a10e9d3b0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b19fc1d0be3c3397e5968fe2627f22e7f84673b1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b8fcae6d2e93c54cacb8f579a77d827c1c643eb5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d42ed4de6aba232d946d20653a70f79158a6535b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e279024617134c94fd3e37470156534d5f2b3472"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f5c2c4eaaa5a8e7e0685ec031d480e588e263e59"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38053,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:37.953,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: idpf: fix null-ptr-deref in idpf_features_check idpf_features_check is used to validate the TX packet. skb header length is compared with the hardware supported value received from the device control plane. The value is stored in the adapter structure and to access it, vport pointer is used. During reset all the vports are released and the vport pointer that the netdev private structure points to is NULL. To avoid null-ptr-deref, store the max header length value in netdev private structure. This also helps to cache the value and avoid accessing adapter pointer in hot path. BUG: kernel NULL pointer dereference, address: 0000000000000068 ... RIP: 0010:idpf_features_check+0x6d/0xe0 [idpf] Call Trace: <TASK> ? __die+0x23/0x70 ? page_fault_oops+0x154/0x520 ? exc_page_fault+0x76/0x190 ? asm_exc_page_fault+0x26/0x30 ? idpf_features_check+0x6d/0xe0 [idpf] netif_skb_features+0x88/0x310 validate_xmit_skb+0x2a/0x2b0 validate_xmit_skb_list+0x4c/0x70 sch_direct_xmit+0x19d/0x3a0 __dev_queue_xmit+0xb74/0xe70 ...",,"[{""url"":""https://git.kernel.org/stable/c/2dabe349f7882ff1407a784d54d8541909329088"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf1e751c5a5611aa037ab44cca955c141eb68dcc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f6f5e9c8cb680c3cb9771fd9fa114319cbc4f514"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38054,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:38.083,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ptp: ocp: Limit signal/freq counts in summary output functions The debugfs summary output could access uninitialized elements in the freq_in[] and signal_out[] arrays, causing NULL pointer dereferences and triggering a kernel Oops (page_fault_oops). This patch adds u8 fields (nr_freq_in, nr_signal_out) to track the number of initialized elements, with a maximum of 4 per array. The summary output functions are updated to respect these limits, preventing out-of-bounds access and ensuring safe array handling. Widen the label variables because the change confuses GCC about max length of the strings.",,"[{""url"":""https://git.kernel.org/stable/c/0b7d3e782027ac3b6fec56159e8e348042000aef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c9e455581e2ba87ee38c126e8dc49a424b9df0cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fcad74f894ac89790084cc2e1ec61b08220941d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38055,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:38.213,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: perf/x86/intel: Fix segfault with PEBS-via-PT with sample_freq Currently, using PEBS-via-PT with a sample frequency instead of a sample period, causes a segfault. For example: BUG: kernel NULL pointer dereference, address: 0000000000000195 <NMI> ? __die_body.cold+0x19/0x27 ? page_fault_oops+0xca/0x290 ? exc_page_fault+0x7e/0x1b0 ? asm_exc_page_fault+0x26/0x30 ? intel_pmu_pebs_event_update_no_drain+0x40/0x60 ? intel_pmu_pebs_event_update_no_drain+0x32/0x60 intel_pmu_drain_pebs_icl+0x333/0x350 handle_pmi_common+0x272/0x3c0 intel_pmu_handle_irq+0x10a/0x2e0 perf_event_nmi_handler+0x2a/0x50 That happens because intel_pmu_pebs_event_update_no_drain() assumes all the pebs_enabled bits represent counter indexes, which is not always the case. In this particular case, bits 60 and 61 are set for PEBS-via-PT purposes. The behaviour of PEBS-via-PT with sample frequency is questionable because although a PMI is generated (PEBS_PMI_AFTER_EACH_RECORD), the period is not adjusted anyway. Putting that aside, fix intel_pmu_pebs_event_update_no_drain() by passing the mask of counter bits instead of 'size'. Note, prior to the Fixes commit, 'size' would be limited to the maximum counter index, so the issue was not hit.",,"[{""url"":""https://git.kernel.org/stable/c/0b1874a5b1173fbcb2185ab828f4c33d067e551e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/99bcd91fabada0dbb1d5f0de44532d8008db93c6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca51db23166767a8445deb8331c9b8d5205d9287"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38056,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:38.340,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: SOF: Intel: hda: Fix UAF when reloading module hda_generic_machine_select() appends -idisp to the tplg filename by allocating a new string with devm_kasprintf(), then stores the string right back into the global variable snd_soc_acpi_intel_hda_machines. When the module is unloaded, this memory is freed, resulting in a global variable pointing to freed memory. Reloading the module then triggers a use-after-free: BUG: KFENCE: use-after-free read in string+0x48/0xe0 Use-after-free read at 0x00000000967e0109 (in kfence-#99): string+0x48/0xe0 vsnprintf+0x329/0x6e0 devm_kvasprintf+0x54/0xb0 devm_kasprintf+0x58/0x80 hda_machine_select.cold+0x198/0x17a2 [snd_sof_intel_hda_generic] sof_probe_work+0x7f/0x600 [snd_sof] process_one_work+0x17b/0x330 worker_thread+0x2ce/0x3f0 kthread+0xcf/0x100 ret_from_fork+0x31/0x50 ret_from_fork_asm+0x1a/0x30 kfence-#99: 0x00000000198a940f-0x00000000ace47d9d, size=64, cache=kmalloc-64 allocated by task 333 on cpu 8 at 17.798069s (130.453553s ago): devm_kmalloc+0x52/0x120 devm_kvasprintf+0x66/0xb0 devm_kasprintf+0x58/0x80 hda_machine_select.cold+0x198/0x17a2 [snd_sof_intel_hda_generic] sof_probe_work+0x7f/0x600 [snd_sof] process_one_work+0x17b/0x330 worker_thread+0x2ce/0x3f0 kthread+0xcf/0x100 ret_from_fork+0x31/0x50 ret_from_fork_asm+0x1a/0x30 freed by task 1543 on cpu 4 at 141.586686s (6.665010s ago): release_nodes+0x43/0xb0 devres_release_all+0x90/0xf0 device_unbind_cleanup+0xe/0x70 device_release_driver_internal+0x1c1/0x200 driver_detach+0x48/0x90 bus_remove_driver+0x6d/0xf0 pci_unregister_driver+0x42/0xb0 __do_sys_delete_module+0x1d1/0x310 do_syscall_64+0x82/0x190 entry_SYSCALL_64_after_hwframe+0x76/0x7e Fix it by copying the match array with devm_kmemdup_array() before we modify it.",,"[{""url"":""https://git.kernel.org/stable/c/2b49e68360eb6a1c03dc1642a51f7d9f6784c034"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7dd7f39fce0022b386ef1ea5ffef92ecc7dfc6af"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f9670b2e81e8a3cbf2e1e757190dd0b920a9d43f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38057,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:38.477,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: espintcp: fix skb leaks A few error paths are missing a kfree_skb.",,"[{""url"":""https://git.kernel.org/stable/c/28756f22de48d25256ed89234b66b9037a3f0157"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/63c1f19a3be3169e51a5812d22a6d0c879414076"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb058693dfc93ed7a9c365adb899fedd648b9d9f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38058,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:38.590,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: __legitimize_mnt(): check for MNT_SYNC_UMOUNT should be under mount_lock ... or we risk stealing final mntput from sync umount - raising mnt_count after umount(2) has verified that victim is not busy, but before it has set MNT_SYNC_UMOUNT; in that case __legitimize_mnt() doesn't see that it's safe to quietly undo mnt_count increment and leaves dropping the reference to caller, where it'll be a full-blown mntput(). Check under mount_lock is needed; leaving the current one done before taking that makes no sense - it's nowhere near common enough to bother with.",,"[{""url"":""https://git.kernel.org/stable/c/250cf3693060a5f803c5f1ddc082bb06b16112a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/628fb00195ce21a90cf9e4e3d105cd9e58f77b40"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8cafd7266fa02e0863bacbf872fe635c0b9725eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9b0915e72b3cf52474dcee0b24a2f99d93e604a3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b55996939c71a3e1a38f3cdc6a8859797efc9083"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b89eb56a378b7b2c1176787fc228d0a57172bdd5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d8ece4ced3b051e656c77180df2e69e19e24edc1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f6d45fd92f62845cbd1eb5128fd8f0ed7d0c5a42"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38059,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:38.703,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: avoid NULL pointer dereference if no valid csum tree [BUG] When trying read-only scrub on a btrfs with rescue=idatacsums mount option, it will crash with the following call trace: BUG: kernel NULL pointer dereference, address: 0000000000000208 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page CPU: 1 UID: 0 PID: 835 Comm: btrfs Tainted: G O 6.15.0-rc3-custom+ #236 PREEMPT(full) Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS unknown 02/02/2022 RIP: 0010:btrfs_lookup_csums_bitmap+0x49/0x480 [btrfs] Call Trace: <TASK> scrub_find_fill_first_stripe+0x35b/0x3d0 [btrfs] scrub_simple_mirror+0x175/0x290 [btrfs] scrub_stripe+0x5f7/0x6f0 [btrfs] scrub_chunk+0x9a/0x150 [btrfs] scrub_enumerate_chunks+0x333/0x660 [btrfs] btrfs_scrub_dev+0x23e/0x600 [btrfs] btrfs_ioctl+0x1dcf/0x2f80 [btrfs] __x64_sys_ioctl+0x97/0xc0 do_syscall_64+0x4f/0x120 entry_SYSCALL_64_after_hwframe+0x76/0x7e [CAUSE] Mount option ""rescue=idatacsums"" will completely skip loading the csum tree, so that any data read will not find any data csum thus we will ignore data checksum verification. Normally call sites utilizing csum tree will check the fs state flag NO_DATA_CSUMS bit, but unfortunately scrub does not check that bit at all. This results in scrub to call btrfs_search_slot() on a NULL pointer and triggered above crash. [FIX] Check both extent and csum tree root before doing any tree search.",,"[{""url"":""https://git.kernel.org/stable/c/50d0de59f66cbe6d597481e099bf1c70fd07e0a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6e9770de024964b1017f99ee94f71967bd6edaeb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d35bed14b0bc95c6845863a3744ecd10b888c830"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f95d186255b319c48a365d47b69bd997fecb674e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38060,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:38.830,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf: copy_verifier_state() should copy 'loop_entry' field The bpf_verifier_state.loop_entry state should be copied by copy_verifier_state(). Otherwise, .loop_entry values from unrelated states would poison env->cur_state. Additionally, env->stack should not contain any states with .loop_entry != NULL. The states in env->stack are yet to be verified, while .loop_entry is set for states that reached an equivalent state. This means that env->cur_state->loop_entry should always be NULL after pop_stack(). See the selftest in the next commit for an example of the program that is not safe yet is accepted by verifier w/o this fix. This change has some verification performance impact for selftests: File Program Insns (A) Insns (B) Insns (DIFF) States (A) States (B) States (DIFF) ---------------------------------- ---------------------------- --------- --------- -------------- ---------- ---------- ------------- arena_htab.bpf.o arena_htab_llvm 717 426 -291 (-40.59%) 57 37 -20 (-35.09%) arena_htab_asm.bpf.o arena_htab_asm 597 445 -152 (-25.46%) 47 37 -10 (-21.28%) arena_list.bpf.o arena_list_del 309 279 -30 (-9.71%) 23 14 -9 (-39.13%) iters.bpf.o iter_subprog_check_stacksafe 155 141 -14 (-9.03%) 15 14 -1 (-6.67%) iters.bpf.o iter_subprog_iters 1094 1003 -91 (-8.32%) 88 83 -5 (-5.68%) iters.bpf.o loop_state_deps2 479 725 +246 (+51.36%) 46 63 +17 (+36.96%) kmem_cache_iter.bpf.o open_coded_iter 63 59 -4 (-6.35%) 7 6 -1 (-14.29%) verifier_bits_iter.bpf.o max_words 92 84 -8 (-8.70%) 8 7 -1 (-12.50%) verifier_iterating_callbacks.bpf.o cond_break2 113 107 -6 (-5.31%) 12 12 +0 (+0.00%) And significant negative impact for sched_ext: File Program Insns (A) Insns (B) Insns (DIFF) States (A) States (B) States (DIFF) ----------------- ---------------------- --------- --------- -------------------- ---------- ---------- ------------------ bpf.bpf.o lavd_init 7039 14723 +7684 (+109.16%) 490 1139 +649 (+132.45%) bpf.bpf.o layered_dispatch 11485 10548 -937 (-8.16%) 848 762 -86 (-10.14%) bpf.bpf.o layered_dump 7422 1000001 +992579 (+13373.47%) 681 31178 +30497 (+4478.27%) bpf.bpf.o layered_enqueue 16854 71127 +54273 (+322.02%) 1611 6450 +4839 (+300.37%) bpf.bpf.o p2dq_dispatch 665 791 +126 (+18.95%) 68 78 +10 (+14.71%) bpf.bpf.o p2dq_init 2343 2980 +637 (+27.19%) 201 237 +36 (+17.91%) bpf.bpf.o refresh_layer_cpumasks 16487 674760 +658273 (+3992.68%) 1770 65370 +63600 (+3593.22%) bpf.bpf.o rusty_select_cpu 1937 40872 +38935 (+2010.07%) 177 3210 +3033 (+1713.56%) scx_central.bpf.o central_dispatch 636 2687 +2051 (+322.48%) 63 227 +164 (+260.32%) scx_nest.bpf.o nest_init 636 815 +179 (+28.14%) 60 73 +13 (+21.67%) scx_qmap.bpf.o qmap_dispatch ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/46ba5757a7a4714e7d3f68cfe118208822cb3d78"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8b4afd89fa75f738a80ca849126fd3cad77bcbf1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bbbc02b7445ebfda13e4847f4f1413c6480a85a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38061,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:38.960,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: pktgen: fix access outside of user given buffer in pktgen_thread_write() Honour the user given buffer size for the strn_len() calls (otherwise strn_len() will access memory outside of the user given buffer).",,"[{""url"":""https://git.kernel.org/stable/c/128cdb617a87767c29be43e4431129942fce41df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/425e64440ad0a2f03bdaf04be0ae53dededbaa77"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5bfa81539e22af4c40ae5d43d7212253462383a6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6b1d3e9db82d01a88de1795b879df67c2116b4f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8fef258b555c75a467a6b4b7e3a3cbc46d5f4102"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a3d89f1cfe1e6d4bb164db2595511fd33db21900"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c81c2ee1c3b050ed5c4e92876590cc7a259183f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ef1158a6a650ecee72ab40851b1d52e04d3f9cb5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38062,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:39.080,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: genirq/msi: Store the IOMMU IOVA directly in msi_desc instead of iommu_cookie The IOMMU translation for MSI message addresses has been a 2-step process, separated in time: 1) iommu_dma_prepare_msi(): A cookie pointer containing the IOVA address is stored in the MSI descriptor when an MSI interrupt is allocated. 2) iommu_dma_compose_msi_msg(): this cookie pointer is used to compute a translated message address. This has an inherent lifetime problem for the pointer stored in the cookie that must remain valid between the two steps. However, there is no locking at the irq layer that helps protect the lifetime. Today, this works under the assumption that the iommu domain is not changed while MSI interrupts being programmed. This is true for normal DMA API users within the kernel, as the iommu domain is attached before the driver is probed and cannot be changed while a driver is attached. Classic VFIO type1 also prevented changing the iommu domain while VFIO was running as it does not support changing the ""container"" after starting up. However, iommufd has improved this so that the iommu domain can be changed during VFIO operation. This potentially allows userspace to directly race VFIO_DEVICE_ATTACH_IOMMUFD_PT (which calls iommu_attach_group()) and VFIO_DEVICE_SET_IRQS (which calls into iommu_dma_compose_msi_msg()). This potentially causes both the cookie pointer and the unlocked call to iommu_get_domain_for_dev() on the MSI translation path to become UAFs. Fix the MSI cookie UAF by removing the cookie pointer. The translated IOVA address is already known during iommu_dma_prepare_msi() and cannot change. Thus, it can simply be stored as an integer in the MSI descriptor. The other UAF related to iommu_get_domain_for_dev() will be addressed in patch ""iommu: Make iommu_dma_prepare_msi() into a generic operation"" by using the IOMMU group mutex.",,"[{""url"":""https://git.kernel.org/stable/c/1f7df3a691740a7736bbc99dc4ed536120eb4746"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/53f42776e435f63e5f8e61955e4c205dbfeaf524"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/856152eb91e67858a09e30a7149a1f29b04b7384"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba41e4e627db51d914444aee0b93eb67f31fa330"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e4d3763223c7b72ded53425207075e7453b4e3d5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38063,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:39.207,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dm: fix unconditional IO throttle caused by REQ_PREFLUSH When a bio with REQ_PREFLUSH is submitted to dm, __send_empty_flush() generates a flush_bio with REQ_OP_WRITE | REQ_PREFLUSH | REQ_SYNC, which causes the flush_bio to be throttled by wbt_wait(). An example from v5.4, similar problem also exists in upstream: crash> bt 2091206 PID: 2091206 TASK: ffff2050df92a300 CPU: 109 COMMAND: ""kworker/u260:0"" #0 [ffff800084a2f7f0] __switch_to at ffff80004008aeb8 #1 [ffff800084a2f820] __schedule at ffff800040bfa0c4 #2 [ffff800084a2f880] schedule at ffff800040bfa4b4 #3 [ffff800084a2f8a0] io_schedule at ffff800040bfa9c4 #4 [ffff800084a2f8c0] rq_qos_wait at ffff8000405925bc #5 [ffff800084a2f940] wbt_wait at ffff8000405bb3a0 #6 [ffff800084a2f9a0] __rq_qos_throttle at ffff800040592254 #7 [ffff800084a2f9c0] blk_mq_make_request at ffff80004057cf38 #8 [ffff800084a2fa60] generic_make_request at ffff800040570138 #9 [ffff800084a2fae0] submit_bio at ffff8000405703b4 #10 [ffff800084a2fb50] xlog_write_iclog at ffff800001280834 [xfs] #11 [ffff800084a2fbb0] xlog_sync at ffff800001280c3c [xfs] #12 [ffff800084a2fbf0] xlog_state_release_iclog at ffff800001280df4 [xfs] #13 [ffff800084a2fc10] xlog_write at ffff80000128203c [xfs] #14 [ffff800084a2fcd0] xlog_cil_push at ffff8000012846dc [xfs] #15 [ffff800084a2fda0] xlog_cil_push_work at ffff800001284a2c [xfs] #16 [ffff800084a2fdb0] process_one_work at ffff800040111d08 #17 [ffff800084a2fe00] worker_thread at ffff8000401121cc #18 [ffff800084a2fe70] kthread at ffff800040118de4 After commit 2def2845cc33 (""xfs: don't allow log IO to be throttled""), the metadata submitted by xlog_write_iclog() should not be throttled. But due to the existence of the dm layer, throttling flush_bio indirectly causes the metadata bio to be throttled. Fix this by conditionally adding REQ_IDLE to flush_bio.bi_opf, which makes wbt_should_throttle() return false to avoid wbt_wait().",,"[{""url"":""https://git.kernel.org/stable/c/2858cda9a8d95e6deee7e3b0a26adde696a9a4f5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/52aa28f7b1708d76e315d78b5ed397932a1a97c3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/88f7f56d16f568f19e1a695af34a7f4a6ce537a6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/95d08924335f3b6f4ea0b92ebfe4fe0731c502d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b55a97d1bd4083729a60d19beffe85d4c96680de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38064,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:39.340,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: virtio: break and reset virtio devices on device_shutdown() Hongyu reported a hang on kexec in a VM. QEMU reported invalid memory accesses during the hang. Invalid read at addr 0x102877002, size 2, region '(null)', reason: rejected Invalid write at addr 0x102877A44, size 2, region '(null)', reason: rejected ... It was traced down to virtio-console. Kexec works fine if virtio-console is not in use. The issue is that virtio-console continues to write to the MMIO even after underlying virtio-pci device is reset. Additionally, Eric noticed that IOMMUs are reset before devices, if devices are not reset on shutdown they continue to poke at guest memory and get errors from the IOMMU. Some devices get wedged then. The problem can be solved by breaking all virtio devices on virtio bus shutdown, then resetting them.",,"[{""url"":""https://git.kernel.org/stable/c/8bd2fa086a04886798b505f28db4002525895203"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aee42f3d57bfa37b2716df4584edeecf63b9df4c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38065,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:39.460,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: orangefs: Do not truncate file size 'len' is used to store the result of i_size_read(), so making 'len' a size_t results in truncation to 4GiB on 32-bit systems.",,"[{""url"":""https://git.kernel.org/stable/c/062e8093592fb866b8e016641a8b27feb6ac509d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/121f0335d91e46369bf55b5da4167d82b099a166"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/15602508ad2f923e228b9521960b4addcd27d9c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2323b806221e6268a4e17711bc72e2fc87c191a3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/341e3a5984cf5761f3dab16029d7e9fb1641d5ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5111227d7f1f57f6804666b3abf780a23f44fc1d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd918ec24168fe08c6aafc077dd3b6d88364c5cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ceaf195ed285b77791e29016ee6344b3ded609b3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38066,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:39.620,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dm cache: prevent BUG_ON by blocking retries on failed device resumes A cache device failing to resume due to mapping errors should not be retried, as the failure leaves a partially initialized policy object. Repeating the resume operation risks triggering BUG_ON when reloading cache mappings into the incomplete policy object. Reproduce steps: 1. create a cache metadata consisting of 512 or more cache blocks, with some mappings stored in the first array block of the mapping array. Here we use cache_restore v1.0 to build the metadata. cat <<EOF >> cmeta.xml <superblock uuid="""" block_size=""128"" nr_cache_blocks=""512"" \ policy=""smq"" hint_width=""4""> <mappings> <mapping cache_block=""0"" origin_block=""0"" dirty=""false""/> </mappings> </superblock> EOF dmsetup create cmeta --table ""0 8192 linear /dev/sdc 0"" cache_restore -i cmeta.xml -o /dev/mapper/cmeta --metadata-version=2 dmsetup remove cmeta 2. wipe the second array block of the mapping array to simulate data degradations. mapping_root=$(dd if=/dev/sdc bs=1c count=8 skip=192 \ 2>/dev/null | hexdump -e '1/8 ""%u\n""') ablock=$(dd if=/dev/sdc bs=1c count=8 skip=$((4096*mapping_root+2056)) \ 2>/dev/null | hexdump -e '1/8 ""%u\n""') dd if=/dev/zero of=/dev/sdc bs=4k count=1 seek=$ablock 3. try bringing up the cache device. The resume is expected to fail due to the broken array block. dmsetup create cmeta --table ""0 8192 linear /dev/sdc 0"" dmsetup create cdata --table ""0 65536 linear /dev/sdc 8192"" dmsetup create corig --table ""0 524288 linear /dev/sdc 262144"" dmsetup create cache --notable dmsetup load cache --table ""0 524288 cache /dev/mapper/cmeta \ /dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0"" dmsetup resume cache 4. try resuming the cache again. An unexpected BUG_ON is triggered while loading cache mappings. dmsetup resume cache Kernel logs: (snip) ------------[ cut here ]------------ kernel BUG at drivers/md/dm-cache-policy-smq.c:752! Oops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN NOPTI CPU: 0 UID: 0 PID: 332 Comm: dmsetup Not tainted 6.13.4 #3 RIP: 0010:smq_load_mapping+0x3e5/0x570 Fix by disallowing resume operations for devices that failed the initial attempt.",,"[{""url"":""https://git.kernel.org/stable/c/00586b78eeb7c626a14ca13453a1631f88a7cf36"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/025c8f477625eb39006ded650e7d027bcfb20e79"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3986ef4a9b6a0d9c28bc325d8713beba5e67586f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5da692e2262b8f81993baa9592f57d12c2703dea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c5356a5e80442131e2714d0d26bb110590e4e568"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c614584c2a66b538f469089ac089457a34590c14"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc80a5cc520939d0a7d071cc4ae4b3c55ef171d0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f3128e3074e8af565cc6a66fe3384a56df87f803"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38067,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:39.780,2025-07-17T17:15:36.333,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: rseq: Fix segfault on registration when rseq_cs is non-zero The rseq_cs field is documented as being set to 0 by user-space prior to registration, however this is not currently enforced by the kernel. This can result in a segfault on return to user-space if the value stored in the rseq_cs field doesn't point to a valid struct rseq_cs. The correct solution to this would be to fail the rseq registration when the rseq_cs field is non-zero. However, some older versions of glibc will reuse the rseq area of previous threads without clearing the rseq_cs field and will also terminate the process if the rseq registration fails in a secondary thread. This wasn't caught in testing because in this case the leftover rseq_cs does point to a valid struct rseq_cs. What we can do is clear the rseq_cs field on registration when it's non-zero which will prevent segfaults on registration and won't break the glibc versions that reuse rseq areas on thread creation.",,"[{""url"":""https://git.kernel.org/stable/c/2df285dab00fa03a3ef939b6cb0d0d0aeb0791db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3e4028ef31b69286c9d4878cee0330235f53f218"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/48900d839a3454050fd5822e34be8d54c4ec9b86"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b2b05d0dc2f4f0646922068af435aed5763d16ba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eaf112069a904b6207b4106ff083e0208232a2eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f004f58d18a2d3dc761cf973ad27b4a5997bd876"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd881d0a085fc54354414aed990ccf05f282ba53"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38068,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:39.920,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: crypto: lzo - Fix compression buffer overrun Unlike the decompression code, the compression code in LZO never checked for output overruns. It instead assumes that the caller always provides enough buffer space, disregarding the buffer length provided by the caller. Add a safe compression interface that checks for the end of buffer before each write. Use the safe interface in crypto/lzo.",,"[{""url"":""https://git.kernel.org/stable/c/0acdc4d6e679ba31d01e3e7e2e4124b76d6d8e2a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/167373d77c70c2b558aae3e327b115249bb2652c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4b173bb2c4665c23f8fcf5241c7b06dfa6b5b111"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7caad075acb634a74911830d6386c50ea12566cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a98bd864e16f91c70b2469adf013d713d04d1d13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc47f07234f72cbd8e2c973cdbf2a6730660a463"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38069,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:40.090,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: PCI: endpoint: pci-epf-test: Fix double free that causes kernel to oops Fix a kernel oops found while testing the stm32_pcie Endpoint driver with handling of PERST# deassertion: During EP initialization, pci_epf_test_alloc_space() allocates all BARs, which are further freed if epc_set_bar() fails (for instance, due to no free inbound window). However, when pci_epc_set_bar() fails, the error path: pci_epc_set_bar() -> pci_epf_free_space() does not clear the previous assignment to epf_test->reg[bar]. Then, if the host reboots, the PERST# deassertion restarts the BAR allocation sequence with the same allocation failure (no free inbound window), creating a double free situation since epf_test->reg[bar] was deallocated and is still non-NULL. Thus, make sure that pci_epf_alloc_space() and pci_epf_free_space() invocations are symmetric, and as such, set epf_test->reg[bar] to NULL when memory is freed. [kwilczynski: commit log]",,"[{""url"":""https://git.kernel.org/stable/c/8b83893d1f6c6061a7d58169ecdf9d5ee9f306ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/934e9d137d937706004c325fa1474f9e3f1ba10a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe2329eff5bee461ebcafadb6ca1df0cbf5945fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38070,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:40.320,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: sma1307: Add NULL check in sma1307_setting_loaded() All varibale allocated by kzalloc and devm_kzalloc could be NULL. Multiple pointer checks and their cleanup are added. This issue is found by our static analysis tool",,"[{""url"":""https://git.kernel.org/stable/c/0ec6bd16705fe21d6429d6b8f7981eae2142bba8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8434b8ba437d3f6cbcd9ffe8405bd16ed28fc5c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38071,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:40.450,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: x86/mm: Check return value from memblock_phys_alloc_range() At least with CONFIG_PHYSICAL_START=0x100000, if there is < 4 MiB of contiguous free memory available at this point, the kernel will crash and burn because memblock_phys_alloc_range() returns 0 on failure, which leads memblock_phys_free() to throw the first 4 MiB of physical memory to the wolves. At a minimum it should fail gracefully with a meaningful diagnostic, but in fact everything seems to work fine without the weird reserve allocation.",,"[{""url"":""https://git.kernel.org/stable/c/631ca8909fd5c62b9fda9edda93924311a78a9c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c18c904d301ffeb33b071eadc55cd6131e1e9be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bffd5f2815c5234d609725cd0dc2f4bc5de2fc67"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c6f2694c580c27dca0cf7546ee9b4bfa6b940e38"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dde4800d2b0f68b945fd81d4fc2d4a10ae25f743"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38072,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:40.583,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: libnvdimm/labels: Fix divide error in nd_label_data_init() If a faulty CXL memory device returns a broken zero LSA size in its memory device information (Identify Memory Device (Opcode 4000h), CXL spec. 3.1, 8.2.9.9.1.1), a divide error occurs in the libnvdimm driver: Oops: divide error: 0000 [#1] PREEMPT SMP NOPTI RIP: 0010:nd_label_data_init+0x10e/0x800 [libnvdimm] Code and flow: 1) CXL Command 4000h returns LSA size = 0 2) config_size is assigned to zero LSA size (CXL pmem driver): drivers/cxl/pmem.c: .config_size = mds->lsa_size, 3) max_xfer is set to zero (nvdimm driver): drivers/nvdimm/label.c: max_xfer = min_t(size_t, ndd->nsarea.max_xfer, config_size); 4) A subsequent DIV_ROUND_UP() causes a division by zero: drivers/nvdimm/label.c: /* Make our initial read size a multiple of max_xfer size */ drivers/nvdimm/label.c: read_size = min(DIV_ROUND_UP(read_size, max_xfer) * max_xfer, drivers/nvdimm/label.c- config_size); Fix this by checking the config size parameter by extending an existing check.",,"[{""url"":""https://git.kernel.org/stable/c/1d1e1efad1cf049e888bf175a5c6be85d792620c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2bd4a938d2eda96ab7288b8fa5aae84a1de8c4ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/396c46d3f59a18ebcc500640e749f16e197d472b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/db1aef51b8e66a77f76b1250b914589c31a0a0ed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e14347f647ca6d76fe1509b6703e340f2d5e2716"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ea3d95e05e97ea20fd6513f647393add16fce3b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ef1d3455bbc1922f94a91ed58d3d7db440652959"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f49c337037df029440a8390380dd35d2cf5924d3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38073,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:40.720,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: block: fix race between set_blocksize and read paths With the new large sector size support, it's now the case that set_blocksize can change i_blksize and the folio order in a manner that conflicts with a concurrent reader and causes a kernel crash. Specifically, let's say that udev-worker calls libblkid to detect the labels on a block device. The read call can create an order-0 folio to read the first 4096 bytes from the disk. But then udev is preempted. Next, someone tries to mount an 8k-sectorsize filesystem from the same block device. The filesystem calls set_blksize, which sets i_blksize to 8192 and the minimum folio order to 1. Now udev resumes, still holding the order-0 folio it allocated. It then tries to schedule a read bio and do_mpage_readahead tries to create bufferheads for the folio. Unfortunately, blocks_per_folio == 0 because the page size is 4096 but the blocksize is 8192 so no bufferheads are attached and the bh walk never sets bdev. We then submit the bio with a NULL block device and crash. Therefore, truncate the page cache after flushing but before updating i_blksize. However, that's not enough -- we also need to lock out file IO and page faults during the update. Take both the i_rwsem and the invalidate_lock in exclusive mode for invalidations, and in shared mode for read/write operations. I don't know if this is the correct fix, but xfs/259 found it.",,"[{""url"":""https://git.kernel.org/stable/c/64f505b08e0cfd8163491c8c082d4f47a88e51d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c5cf440a378801d313eb58be996fdc81a8878a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c0e473a0d226479e8e925d5ba93f751d8df628e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38074,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:40.850,2025-07-17T17:15:36.540,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: vhost-scsi: protect vq->log_used with vq->mutex The vhost-scsi completion path may access vq->log_base when vq->log_used is already set to false. vhost-thread QEMU-thread vhost_scsi_complete_cmd_work() -> vhost_add_used() -> vhost_add_used_n() if (unlikely(vq->log_used)) QEMU disables vq->log_used via VHOST_SET_VRING_ADDR. mutex_lock(&vq->mutex); vq->log_used = false now! mutex_unlock(&vq->mutex); QEMU gfree(vq->log_base) log_used() -> log_write(vq->log_base) Assuming the VMM is QEMU. The vq->log_base is from QEMU userpace and can be reclaimed via gfree(). As a result, this causes invalid memory writes to QEMU userspace. The control queue path has the same issue.",,"[{""url"":""https://git.kernel.org/stable/c/59614c5acf6688f7af3c245d359082c0e9e53117"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/80cf68489681c165ded460930e391b1eb37b5f6f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8312a1ccff1566f375191a89b9ba71b6eb48a8cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd8c9404e44adb9f6219c09b3409a61ab7ce3427"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c0039e3afda29be469d29b3013d7f9bdee136834"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca85c2d0db5f8309832be45858b960d933c2131c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f591cf9fce724e5075cc67488c43c6e39e8cbe27"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38075,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:40.980,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: target: iscsi: Fix timeout on deleted connection NOPIN response timer may expire on a deleted connection and crash with such logs: Did not receive response to NOPIN on CID: 0, failing connection for I_T Nexus (null),i,0x00023d000125,iqn.2017-01.com.iscsi.target,t,0x3d BUG: Kernel NULL pointer dereference on read at 0x00000000 NIP strlcpy+0x8/0xb0 LR iscsit_fill_cxn_timeout_err_stats+0x5c/0xc0 [iscsi_target_mod] Call Trace: iscsit_handle_nopin_response_timeout+0xfc/0x120 [iscsi_target_mod] call_timer_fn+0x58/0x1f0 run_timer_softirq+0x740/0x860 __do_softirq+0x16c/0x420 irq_exit+0x188/0x1c0 timer_interrupt+0x184/0x410 That is because nopin response timer may be re-started on nopin timer expiration. Stop nopin timer before stopping the nopin response timer to be sure that no one of them will be re-started.",,"[{""url"":""https://git.kernel.org/stable/c/019ca2804f3fb49a7f8e56ea6aeaa1ff32724c27"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2c5081439c7ab8da08427befe427f0d732ebc9f9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3e6429e3707943078240a2c0c0b3ee99ea9b0d9c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/571ce6b6f5cbaf7d24af03cad592fc0e2a54de35"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6815846e0c3a62116a7da9740e3a7c10edc5c7e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f533cc5ee4c4436cee51dc58e81dfd9c3384418"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/87389bff743c55b6b85282de91109391f43e0814"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe8421e853ef289e1324fcda004751c89dd9c18a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38076,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:41.110,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: alloc_tag: allocate percpu counters for module tags dynamically When a module gets unloaded it checks whether any of its tags are still in use and if so, we keep the memory containing module's allocation tags alive until all tags are unused. However percpu counters referenced by the tags are freed by free_module(). This will lead to UAF if the memory allocated by a module is accessed after module was unloaded. To fix this we allocate percpu counters for module allocation tags dynamically and we keep it alive for tags which are still in use after module unloading. This also removes the requirement of a larger PERCPU_MODULE_RESERVE when memory allocation profiling is enabled because percpu memory for counters does not need to be reserved anymore.",,"[{""url"":""https://git.kernel.org/stable/c/12ca42c237756182aad8ab04654c952765cb9061"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3cc733e6d96c938d2b82be96858a0ab900eb6fdc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38077,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:41.240,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: platform/x86: dell-wmi-sysman: Avoid buffer overflow in current_password_store() If the 'buf' array received from the user contains an empty string, the 'length' variable will be zero. Accessing the 'buf' array element with index 'length - 1' will result in a buffer overflow. Add a check for an empty string. Found by Linux Verification Center (linuxtesting.org) with SVACE.",,"[{""url"":""https://git.kernel.org/stable/c/4e89a4077490f52cde652d17e32519b666abf3a6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/60bd13f8c4b3de2c910ae1cdbef85b9bbc9685f5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8594a123cfa23d708582dc6fb36da34479ef8a5b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/97066373ffd55bd9af0b512ff3dd1f647620a3dc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f86465626917df3b8bdd2756ec0cc9d179c5af0f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fb7cde625872709b8cedad9b241e0ec3d82fa7d3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38078,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:41.380,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ALSA: pcm: Fix race of buffer access at PCM OSS layer The PCM OSS layer tries to clear the buffer with the silence data at initialization (or reconfiguration) of a stream with the explicit call of snd_pcm_format_set_silence() with runtime->dma_area. But this may lead to a UAF because the accessed runtime->dma_area might be freed concurrently, as it's performed outside the PCM ops. For avoiding it, move the code into the PCM core and perform it inside the buffer access lock, so that it won't be changed during the operation.",,"[{""url"":""https://git.kernel.org/stable/c/10217da9644ae75cea7330f902c35fc5ba78bbbf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74d90875f3d43f3eff0e9861c4701418795d3455"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8170d8ec4efd0be352c14cb61f374e30fb0c2a25"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/93a81ca0657758b607c3f4ba889ae806be9beb73"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/afa56c960fcb4db37f2e3399f28e9402e4e1f470"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf85e49aaf3a3c5775ea87369ea5f159c2148db4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c0e05a76fc727929524ef24a19c302e6dd40233f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f3e14d706ec18faf19f5a6e75060e140fea05d4a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38079,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:41.510,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: crypto: algif_hash - fix double free in hash_accept If accept(2) is called on socket type algif_hash with MSG_MORE flag set and crypto_ahash_import fails, sk2 is freed. However, it is also freed in af_alg_release, leading to slab-use-after-free error.",,"[{""url"":""https://git.kernel.org/stable/c/0346f4b742345d1c733c977f3a7aef5a6419a967"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/134daaba93193df9e988524b5cd2f52d15eb1993"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2f45a8d64fb4ed4830a4b3273834ecd6ca504896"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5bff312b59b3f2a54ff504e4f4e47272b64f3633"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b2df03ed4052e97126267e8c13ad4204ea6ba9b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf7bba75b91539e93615f560893a599c1e1c98bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c3059d58f79fdfb2201249c2741514e34562b547"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f0f3d09f53534ea385d55ced408f2b67059b16e4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38080,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:41.647,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Increase block_sequence array size [Why] It's possible to generate more than 50 steps in hwss_build_fast_sequence, for example with a 6-pipe asic where all pipes are in one MPC chain. This overflows the block_sequence buffer and corrupts block_sequence_steps, causing a crash. [How] Expand block_sequence to 100 items. A naive upper bound on the possible number of steps for a 6-pipe asic, ignoring the potential for steps to be mutually exclusive, is 91 with current code, therefore 100 is sufficient.",,"[{""url"":""https://git.kernel.org/stable/c/3a7810c212bcf2f722671dadf4b23ff70a7d23ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf1666072e7482317cf2302621766482a21a62c7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de67e80ab48f1f23663831007a2fa3c1471a7757"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e55c5704b12eeea27e212bfab8f7e51ad3e8ac1f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38081,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:41.767,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: spi-rockchip: Fix register out of bounds access Do not write native chip select stuff for GPIO chip selects. GPIOs can be numbered much higher than native CS. Also, it makes no sense.",,"[{""url"":""https://git.kernel.org/stable/c/254e04ec799c1ff8c1e2bd08a57c6a849895d6ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4a120221661fcecb253448d7b041a52d47f1d91f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7a874e8b54ea21094f7fd2d428b164394c6cb316"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ace57bd1fb49d193edec5f6a1f255f48dd5fca90"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38082,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T10:15:41.890,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: gpio: virtuser: fix potential out-of-bound write If the caller wrote more characters, count is truncated to the max available space in ""simple_write_to_buffer"". Check that the input size does not exceed the buffer size. Write a zero termination afterwards.",,"[{""url"":""https://git.kernel.org/stable/c/7118be7c6072f40391923543fdd1563b8d56377c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/afe090366f470f77e140ff3407db813f57852c04"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b96feaaa0fda1e3871b438143c3446954b32d3a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38083,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-20T12:15:21.470,2025-06-27T11:15:25.267,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net_sched: prio: fix a race in prio_tune() Gerrard Tai reported a race condition in PRIO, whenever SFQ perturb timer fires at the wrong time. The race is as follows: CPU 0 CPU 1 [1]: lock root [2]: qdisc_tree_flush_backlog() [3]: unlock root | | [5]: lock root | [6]: rehash | [7]: qdisc_tree_reduce_backlog() | [4]: qdisc_put() This can be abused to underflow a parent's qlen. Calling qdisc_purge_queue() instead of qdisc_tree_flush_backlog() should fix the race, because all packets will be purged from the qdisc before releasing the lock.",,"[{""url"":""https://git.kernel.org/stable/c/20f68e6a9e41693cb0e55e5b9ebbcb40983a4b8f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3aaa7c01cf19d9b9bb64b88b65c3a6fd05da2eb4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4483d8b9127591c60c4eb789d6cab953bc4522a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/46c15c9d0f65c9ba857d63f53264f4b17e8a715f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/53d11560e957d53ee87a0653d258038ce12361b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/93f9eeb678d4c9c1abf720b3615fa8299a490845"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d35acc1be3480505b5931f17e4ea9b7617fea4d3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3f6745006dc9423d2b065b90f191cfa11b1b584"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38084,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-28T08:15:23.970,2025-07-30T06:15:26.867,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm/hugetlb: unshare page tables during VMA split, not before Currently, __split_vma() triggers hugetlb page table unsharing through vm_ops->may_split(). This happens before the VMA lock and rmap locks are taken - which is too early, it allows racing VMA-locked page faults in our process and racing rmap walks from other processes to cause page tables to be shared again before we actually perform the split. Fix it by explicitly calling into the hugetlb unshare logic from __split_vma() in the same place where THP splitting also happens. At that point, both the VMA and the rmap(s) are write-locked. An annoying detail is that we can now call into the helper hugetlb_unshare_pmds() from two different locking contexts: 1. from hugetlb_split(), holding: - mmap lock (exclusively) - VMA lock - file rmap lock (exclusively) 2. hugetlb_unshare_all_pmds(), which I think is designed to be able to call us with only the mmap lock held (in shared mode), but currently only runs while holding mmap lock (exclusively) and VMA lock Backporting note: This commit fixes a racy protection that was introduced in commit b30c14cd6102 (""hugetlb: unshare some PMDs when splitting VMAs""); that commit claimed to fix an issue introduced in 5.13, but it should actually also go all the way back. [jannh@google.com: v2]",,"[{""url"":""https://git.kernel.org/stable/c/081056dc00a27bccb55ccc3c6f230a3d5fd3f7e0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2511ac64bc1617ca716d3ba8464e481a647c1902"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/366298f2b04d2bf1f2f2b7078405bdf9df9bd5d0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8a21d5584826f4880f45bbf8f72375f4e6c0ff2a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9cf5b2a3b72c23fb7b84736d5d19ee6ea718762b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/af6cfcd0efb7f051af221c418ec8b37a10211947"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e8847d18cd9fff1edbb45e963d9141273c3b539c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://project-zero.issues.chromium.org/issues/420715744"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38085,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-28T08:15:24.843,2025-07-30T06:15:27.177,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm/hugetlb: fix huge_pmd_unshare() vs GUP-fast race huge_pmd_unshare() drops a reference on a page table that may have previously been shared across processes, potentially turning it into a normal page table used in another process in which unrelated VMAs can afterwards be installed. If this happens in the middle of a concurrent gup_fast(), gup_fast() could end up walking the page tables of another process. While I don't see any way in which that immediately leads to kernel memory corruption, it is really weird and unexpected. Fix it with an explicit broadcast IPI through tlb_remove_table_sync_one(), just like we do in khugepaged when removing page tables for a THP collapse.",,"[{""url"":""https://git.kernel.org/stable/c/034a52b5ef57c9c8225d94e9067f3390bb33922f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1013af4f585fccc4d3e5c5824d174de2257f7d6d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/952596b08c74e8fe9e2883d1dc8a8f54a37384ec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a3d864c901a300c295692d129159fc3001a56185"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6bfeb97941a9187833b526bc6cc4ff5706d0ce9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b7754d3aa7bf9f62218d096c0c8f6c13698fac8b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe684290418ef9ef76630072086ee530b92f02b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://project-zero.issues.chromium.org/issues/420715744"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38086,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-28T08:15:24.997,2025-06-30T18:38:23.493,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: ch9200: fix uninitialised access during mii_nway_restart In mii_nway_restart() the code attempts to call mii->mdio_read which is ch9200_mdio_read(). ch9200_mdio_read() utilises a local buffer called ""buff"", which is initialised with control_read(). However ""buff"" is conditionally initialised inside control_read(): if (err == size) { memcpy(data, buf, size); } If the condition of ""err == size"" is not met, then ""buff"" remains uninitialised. Once this happens the uninitialised ""buff"" is accessed and returned during ch9200_mdio_read(): return (buff[0] | buff[1] << 8); The problem stems from the fact that ch9200_mdio_read() ignores the return value of control_read(), leading to uinit-access of ""buff"". To fix this we should check the return value of control_read() and return early on error.",,"[{""url"":""https://git.kernel.org/stable/c/119766de4930ff40db9f36b960cb53b0c400e81b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/33163c68d2e3061fa3935b5f0a1867958b1cdbd2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4da7fcc098218ff92b2e83a43f545c02f714cedd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6bd2569d0b2f918e9581f744df0263caf73ee76c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9a350f30d65197354706b7759b5c89d6c267b1a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ad0452c0277b816a435433cca601304cfac7c21"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9da3e442714f7f4393ff01c265c4959c03e88c2f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cdaa6d1cb2ff1219c6c822b27655dd170ffb0f72"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38087,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-30T08:15:22.607,2025-06-30T18:38:23.493,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/sched: fix use-after-free in taprio_dev_notifier Since taprios taprio_dev_notifier() isnt protected by an RCU read-side critical section, a race with advance_sched() can lead to a use-after-free. Adding rcu_read_lock() inside taprio_dev_notifier() prevents this.",,"[{""url"":""https://git.kernel.org/stable/c/8a008c89e5e5c5332e4c0a33d707db9ddd529f8a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c5713ce1ced75f9e9ed5c642ea3d2ba06ead69c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b1547d28ba468bc3b88764efd13e4319bab63be8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b160766e26d4e2e2d6fe2294e0b02f92baefcec5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38088,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-30T08:15:23.470,2025-06-30T18:38:23.493,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: powerpc/powernv/memtrace: Fix out of bounds issue in memtrace mmap memtrace mmap issue has an out of bounds issue. This patch fixes the by checking that the requested mapping region size should stay within the allocated region size.",,"[{""url"":""https://git.kernel.org/stable/c/620b77b23c41a6546e5548ffe2ea3ad71880dde4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/81260c41b518b6f32c701425f1427562fa92f293"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8635e325b85dfb9ddebdfaa6b5605d40d16cd147"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9c340b56d60545e4a159e41523dd8b23f81d3261"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bbd5a9ddb0f9750783a48a871c9e12c0b68c5f39"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd097df4596f3a1e9d75eb8520162de1eb8485b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38089,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-30T08:15:23.590,2025-07-03T09:15:22.777,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: sunrpc: handle SVC_GARBAGE during svc auth processing as auth error tianshuo han reported a remotely-triggerable crash if the client sends a kernel RPC server a specially crafted packet. If decoding the RPC reply fails in such a way that SVC_GARBAGE is returned without setting the rq_accept_statp pointer, then that pointer can be dereferenced and a value stored there. If it's the first time the thread has processed an RPC, then that pointer will be set to NULL and the kernel will crash. In other cases, it could create a memory scribble. The server sunrpc code treats a SVC_GARBAGE return from svc_authenticate or pg_authenticate as if it should send a GARBAGE_ARGS reply. RFC 5531 says that if authentication fails that the RPC should be rejected instead with a status of AUTH_ERR. Handle a SVC_GARBAGE return as an AUTH_ERROR, with a reason of AUTH_BADCRED instead of returning GARBAGE_ARGS in that case. This sidesteps the whole problem of touching the rpc_accept_statp pointer in this situation and avoids the crash.",,"[{""url"":""https://git.kernel.org/stable/c/353e75b55e583635bf71cde6abcec274dba05edd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/599c489eea793821232a2f69a00fa57d82b0ac98"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/94d10a4dba0bc482f2b01e39f06d5513d0f75742"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c90459cd58bb421d275337093d8e901e0ba748dd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://github.com/keymaker-arch/NFSundown"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://www.openwall.com/lists/oss-security/2025/07/02/2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38090,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-30T08:15:23.707,2025-06-30T18:38:23.493,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drivers/rapidio/rio_cm.c: prevent possible heap overwrite In riocm_cdev_ioctl(RIO_CM_CHAN_SEND) -> cm_chan_msg_send() -> riocm_ch_send() cm_chan_msg_send() checks that userspace didn't send too much data but riocm_ch_send() failed to check that userspace sent sufficient data. The result is that riocm_ch_send() can write to fields in the rio_ch_chan_hdr which were outside the bounds of the space which cm_chan_msg_send() allocated. Address this by teaching riocm_ch_send() to check that the entire rio_ch_chan_hdr was copied in from userspace.",,"[{""url"":""https://git.kernel.org/stable/c/1921781ec4a8824bd0c520bf9363e28a880d14ec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1cce6ac47f4a2ac1766b8a188dc8c8f6d8df2a53"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/50695153d7ddde3b1696dbf0085be0033bf3ddb3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/58f664614f8c3d6142ab81ae551e466dc6e092e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6d5c6711a55c35ce09b90705546050408d9d4b61"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a8b5ea2e302aa5cd00fc7addd8df53c9bde7b5f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c03ddc183249f03fc7e057e02cae6f89144d0123"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ecf5ee280b702270afb02f61b299d3dfe3ec7730"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38091,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-02T15:15:26.070,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: check stream id dml21 wrapper to get plane_id [Why & How] Fix a false positive warning which occurs due to lack of correct checks when querying plane_id in DML21. This fixes the warning when performing a mode1 reset (cat /sys/kernel/debug/dri/1/amdgpu_gpu_recover): [ 35.751250] WARNING: CPU: 11 PID: 326 at /tmp/amd.PHpyAl7v/amd/amdgpu/../display/dc/dml2/dml2_dc_resource_mgmt.c:91 dml2_map_dc_pipes+0x243d/0x3f40 [amdgpu] [ 35.751434] Modules linked in: amdgpu(OE) amddrm_ttm_helper(OE) amdttm(OE) amddrm_buddy(OE) amdxcp(OE) amddrm_exec(OE) amd_sched(OE) amdkcl(OE) drm_suballoc_helper drm_ttm_helper ttm drm_display_helper cec rc_core i2c_algo_bit rfcomm qrtr cmac algif_hash algif_skcipher af_alg bnep amd_atl intel_rapl_msr intel_rapl_common snd_hda_codec_hdmi snd_hda_intel edac_mce_amd snd_intel_dspcfg snd_intel_sdw_acpi snd_hda_codec kvm_amd snd_hda_core snd_hwdep snd_pcm kvm snd_seq_midi snd_seq_midi_event snd_rawmidi crct10dif_pclmul polyval_clmulni polyval_generic btusb ghash_clmulni_intel sha256_ssse3 btrtl sha1_ssse3 snd_seq btintel aesni_intel btbcm btmtk snd_seq_device crypto_simd sunrpc cryptd bluetooth snd_timer ccp binfmt_misc rapl snd i2c_piix4 wmi_bmof gigabyte_wmi k10temp i2c_smbus soundcore gpio_amdpt mac_hid sch_fq_codel msr parport_pc ppdev lp parport efi_pstore nfnetlink dmi_sysfs ip_tables x_tables autofs4 hid_generic usbhid hid crc32_pclmul igc ahci xhci_pci libahci xhci_pci_renesas video wmi [ 35.751501] CPU: 11 UID: 0 PID: 326 Comm: kworker/u64:9 Tainted: G OE 6.11.0-21-generic #21~24.04.1-Ubuntu [ 35.751504] Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE [ 35.751505] Hardware name: Gigabyte Technology Co., Ltd. X670E AORUS PRO X/X670E AORUS PRO X, BIOS F30 05/22/2024 [ 35.751506] Workqueue: amdgpu-reset-dev amdgpu_debugfs_reset_work [amdgpu] [ 35.751638] RIP: 0010:dml2_map_dc_pipes+0x243d/0x3f40 [amdgpu] [ 35.751794] Code: 6d 0c 00 00 8b 84 24 88 00 00 00 41 3b 44 9c 20 0f 84 fc 07 00 00 48 83 c3 01 48 83 fb 06 75 b3 4c 8b 64 24 68 4c 8b 6c 24 40 <0f> 0b b8 06 00 00 00 49 8b 94 24 a0 49 00 00 89 c3 83 f8 07 0f 87 [ 35.751796] RSP: 0018:ffffbfa3805d7680 EFLAGS: 00010246 [ 35.751798] RAX: 0000000000010000 RBX: 0000000000000006 RCX: 0000000000000000 [ 35.751799] RDX: 0000000000000000 RSI: 0000000000000005 RDI: 0000000000000000 [ 35.751800] RBP: ffffbfa3805d78f0 R08: 0000000000000000 R09: 0000000000000000 [ 35.751801] R10: 0000000000000000 R11: 0000000000000000 R12: ffffbfa383249000 [ 35.751802] R13: ffffa0e68f280000 R14: ffffbfa383249658 R15: 0000000000000000 [ 35.751803] FS: 0000000000000000(0000) GS:ffffa0edbe580000(0000) knlGS:0000000000000000 [ 35.751804] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 35.751805] CR2: 00005d847ef96c58 CR3: 000000041de3e000 CR4: 0000000000f50ef0 [ 35.751806] PKRU: 55555554 [ 35.751807] Call Trace: [ 35.751810] <TASK> [ 35.751816] ? show_regs+0x6c/0x80 [ 35.751820] ? __warn+0x88/0x140 [ 35.751822] ? dml2_map_dc_pipes+0x243d/0x3f40 [amdgpu] [ 35.751964] ? report_bug+0x182/0x1b0 [ 35.751969] ? handle_bug+0x6e/0xb0 [ 35.751972] ? exc_invalid_op+0x18/0x80 [ 35.751974] ? asm_exc_invalid_op+0x1b/0x20 [ 35.751978] ? dml2_map_dc_pipes+0x243d/0x3f40 [amdgpu] [ 35.752117] ? math_pow+0x48/0xa0 [amdgpu] [ 35.752256] ? srso_alias_return_thunk+0x5/0xfbef5 [ 35.752260] ? math_pow+0x48/0xa0 [amdgpu] [ 35.752400] ? srso_alias_return_thunk+0x5/0xfbef5 [ 35.752403] ? math_pow+0x11/0xa0 [amdgpu] [ 35.752524] ? srso_alias_return_thunk+0x5/0xfbef5 [ 35.752526] ? core_dcn4_mode_programming+0xe4d/0x20d0 [amdgpu] [ 35.752663] ? srso_alias_return_thunk+0x5/0xfbef5 [ 35.752669] dml21_validate+0x3d4/0x980 [amdgpu] (cherry picked from commit f8ad62c0a93e5dd94243e10f1b742232e4d6411e)",,"[{""url"":""https://git.kernel.org/stable/c/2ddac70fed50485aa4ae49cdb7478ce41d8d4715"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6f47d7408133631a1b178f8a04e79aee189ef046"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c53f23f7075c9f63f14d7ec8f2cc3e33e118d986"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38092,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-02T15:15:26.197,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: use list_first_entry_or_null for opinfo_get_list() The list_first_entry() macro never returns NULL. If the list is empty then it returns an invalid pointer. Use list_first_entry_or_null() to check if the list is empty.",,"[{""url"":""https://git.kernel.org/stable/c/10379171f346e6f61d30d9949500a8de4336444a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/334da674b25fdb7a1a4d4b89dcd7795144fc7e11"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c78abb646ff823e7d22faad4cc0703d4484da9e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cb7e06e9736d73007dc8dab7b353733bb37df86b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38093,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-02T15:15:26.317,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: arm64: dts: qcom: x1e80100: Add GPU cooling Unlike the CPU, the GPU does not throttle its speed automatically when it reaches high temperatures. With certain high GPU loads it is possible to reach the critical hardware shutdown temperature of 120C, endangering the hardware and making it impossible to run certain applications. Set up GPU cooling similar to the ACPI tables, by throttling the GPU speed when reaching 95C and polling every 200ms.",,"[{""url"":""https://git.kernel.org/stable/c/5ba21fa11f473c9827f378ace8c9f983de9e0287"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ae664ca09072857349857530dce12e09c048b12d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd9d354bdd28b20a8f3170dab3bc0f096e66d6b4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d145a6a3e252f093dc243d2944fecb2387a3d690"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38094,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T08:15:25.490,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: cadence: macb: Fix a possible deadlock in macb_halt_tx. There is a situation where after THALT is set high, TGO stays high as well. Because jiffies are never updated, as we are in a context with interrupts disabled, we never exit that loop and have a deadlock. That deadlock was noticed on a sama5d4 device that stayed locked for days. Use retries instead of jiffies so that the timeout really works and we do not have a deadlock anymore.",,"[{""url"":""https://git.kernel.org/stable/c/0772a608d799ac0d127c0a36047a2725777aba9d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1d60c0781c1bbeaa1196b0d8aad5c435f06cb7c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3e64d35475aa21d13dab71da51de51923c1a3a48"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/64675a9c00443b2e8af42af08c38fc1b78b68ba2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/84f98955a9de0e0f591df85aa1a44f3ebcf1cb37"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aace6b63892ce8307e502a60fe2f5a4bc6e1cfe7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c92d6089d8ad7d4d815ebcedee3f3907b539ff1f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38095,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T08:15:26.300,2025-09-09T17:15:44.247,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dma-buf: insert memory barrier before updating num_fences smp_store_mb() inserts memory barrier after storing operation. It is different with what the comment is originally aiming so Null pointer dereference can be happened if memory update is reordered.",,"[{""url"":""https://git.kernel.org/stable/c/08680c4dadc6e736c75bc2409d833f03f9003c51"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3becc659f9cb76b481ad1fb71f54d5c8d6332d3f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/72c7d62583ebce7baeb61acce6057c361f73be4a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90eb79c4ed98a4e24a62ccf61c199ab0f680fa8f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c9d2b9a80d06a58f37e0dc8c827075639b443927"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d0b7f11dd68b593bd970e5735be00e8d89bace30"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe1bebd0edb22e3536cbc920ec713331d1367ad4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38096,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:22.913,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: iwlwifi: don't warn when if there is a FW error iwl_trans_reclaim is warning if it is called when the FW is not alive. But if it is called when there is a pending restart, i.e. after a FW error, there is no need to warn, instead - return silently.",,"[{""url"":""https://git.kernel.org/stable/c/0446d34a853d9576e2a7628c803d2abd2f8cf3a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c7f50d0433a016d43681592836a3d484817bfb34"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d07a08f42dc7230c902e1af2a899a72b0a03aa69"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38097,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:23.030,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: espintcp: remove encap socket caching to avoid reference leak The current scheme for caching the encap socket can lead to reference leaks when we try to delete the netns. The reference chain is: xfrm_state -> enacp_sk -> netns Since the encap socket is a userspace socket, it holds a reference on the netns. If we delete the espintcp state (through flush or individual delete) before removing the netns, the reference on the socket is dropped and the netns is correctly deleted. Otherwise, the netns may not be reachable anymore (if all processes within the ns have terminated), so we cannot delete the xfrm state to drop its reference on the socket. This patch results in a small (~2% in my tests) performance regression. A GC-type mechanism could be added for the socket cache, to clear references if the state hasn't been used ""recently"", but it's a lot more complex than just not caching the socket.",,"[{""url"":""https://git.kernel.org/stable/c/028363685bd0b7a19b4a820f82dd905b1dc83999"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74fd327767fb784c5875cf7c4ba1217f26020943"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9cbca30102028f9ad3d2098f935c4368f581fd07"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b58a295d10065960bcb9d60cb8ca6ead9837cd27"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e4cde54b46a87231c77256a633be1bef62687d69"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38098,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:23.173,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Don't treat wb connector as physical in create_validate_stream_for_sink Don't try to operate on a drm_wb_connector as an amdgpu_dm_connector. While dereferencing aconnector->base will ""work"" it's wrong and might lead to unknown bad things. Just... don't.",,"[{""url"":""https://git.kernel.org/stable/c/18ca68f7c657721583a75cab01f0d0d2ec63a6c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b14e726d57f61085485f107a6203c50a09695abd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cbf4890c6f28fb1ad733e14613fbd33c2004bced"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38099,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:23.307,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: Disable SCO support if READ_VOICE_SETTING is unsupported/broken A SCO connection without the proper voice_setting can cause the controller to lock up.",,"[{""url"":""https://git.kernel.org/stable/c/14d17c78a4b1660c443bae9d38c814edea506f62"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec1f015ec0c6fd250a6564e8452f7bb3160b9cb1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f48ee562c095e552a30b8d9cc0566a267b410f8a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38100,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:23.437,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: x86/iopl: Cure TIF_IO_BITMAP inconsistencies io_bitmap_exit() is invoked from exit_thread() when a task exists or when a fork fails. In the latter case the exit_thread() cleans up resources which were allocated during fork(). io_bitmap_exit() invokes task_update_io_bitmap(), which in turn ends up in tss_update_io_bitmap(). tss_update_io_bitmap() operates on the current task. If current has TIF_IO_BITMAP set, but no bitmap installed, tss_update_io_bitmap() crashes with a NULL pointer dereference. There are two issues, which lead to that problem: 1) io_bitmap_exit() should not invoke task_update_io_bitmap() when the task, which is cleaned up, is not the current task. That's a clear indicator for a cleanup after a failed fork(). 2) A task should not have TIF_IO_BITMAP set and neither a bitmap installed nor IOPL emulation level 3 activated. This happens when a kernel thread is created in the context of a user space thread, which has TIF_IO_BITMAP set as the thread flags are copied and the IO bitmap pointer is cleared. Other than in the failed fork() case this has no impact because kernel threads including IO workers never return to user space and therefore never invoke tss_update_io_bitmap(). Cure this by adding the missing cleanups and checks: 1) Prevent io_bitmap_exit() to invoke task_update_io_bitmap() if the to be cleaned up task is not the current task. 2) Clear TIF_IO_BITMAP in copy_thread() unconditionally. For user space forks it is set later, when the IO bitmap is inherited in io_bitmap_share(). For paranoia sake, add a warning into tss_update_io_bitmap() to catch the case, when that code is invoked with inconsistent state.",,"[{""url"":""https://git.kernel.org/stable/c/2cfcbe1554c119402e7382de974c26b0549899fe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2dace5e016c991424a3dc6e83b1ae5dca8992d08"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73cfcc8445585b8af7e18be3c9246b851fdf336c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8b68e978718f14fdcb080c2a7791c52a0d09bc6d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa5ce1485562f20235b4c759eee5ab0c41d2c220"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3b3b6366dc8eb5b22edba9adc4bff3cdacfd64c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d64b7b05a827f98d068f412969eef65489b0cf03"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38101,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:23.573,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ring-buffer: Fix buffer locking in ring_buffer_subbuf_order_set() Enlarge the critical section in ring_buffer_subbuf_order_set() to ensure that error handling takes place with per-buffer mutex held, thus preventing list corruption and other concurrency-related issues.",,"[{""url"":""https://git.kernel.org/stable/c/0fc9a295cd8e59c3636e97395e7c74a9c89fee42"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/40ee2afafc1d9fe3aa44a6fbe440d78a5c96a72e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e09c0600beea469b3ebf974464e526a02d59ad62"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38102,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:23.710,2025-07-17T17:15:36.687,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: VMCI: fix race between vmci_host_setup_notify and vmci_ctx_unset_notify During our test, it is found that a warning can be trigger in try_grab_folio as follow: ------------[ cut here ]------------ WARNING: CPU: 0 PID: 1678 at mm/gup.c:147 try_grab_folio+0x106/0x130 Modules linked in: CPU: 0 UID: 0 PID: 1678 Comm: syz.3.31 Not tainted 6.15.0-rc5 #163 PREEMPT(undef) RIP: 0010:try_grab_folio+0x106/0x130 Call Trace: <TASK> follow_huge_pmd+0x240/0x8e0 follow_pmd_mask.constprop.0.isra.0+0x40b/0x5c0 follow_pud_mask.constprop.0.isra.0+0x14a/0x170 follow_page_mask+0x1c2/0x1f0 __get_user_pages+0x176/0x950 __gup_longterm_locked+0x15b/0x1060 ? gup_fast+0x120/0x1f0 gup_fast_fallback+0x17e/0x230 get_user_pages_fast+0x5f/0x80 vmci_host_unlocked_ioctl+0x21c/0xf80 RIP: 0033:0x54d2cd ---[ end trace 0000000000000000 ]--- Digging into the source, context->notify_page may init by get_user_pages_fast and can be seen in vmci_ctx_unset_notify which will try to put_page. However get_user_pages_fast is not finished here and lead to following try_grab_folio warning. The race condition is shown as follow: cpu0 cpu1 vmci_host_do_set_notify vmci_host_setup_notify get_user_pages_fast(uva, 1, FOLL_WRITE, &context->notify_page); lockless_pages_from_mm gup_pgd_range gup_huge_pmd // update &context->notify_page vmci_host_do_set_notify vmci_ctx_unset_notify notify_page = context->notify_page; if (notify_page) put_page(notify_page); // page is freed __gup_longterm_locked __get_user_pages follow_trans_huge_pmd try_grab_folio // warn here To slove this, use local variable page to make notify_page can be seen after finish get_user_pages_fast.",,"[{""url"":""https://git.kernel.org/stable/c/00ddc7dad55b7bbb78df80d6e174d0c4764dea0c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1bd6406fb5f36c2bb1e96e27d4c3e9f4d09edde4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/468aec888f838ce5174b96e0cb4396790d6f60ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/58a90db70aa6616411e5f69d1982d9b1dd97d774"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6e3af836805ed1d7a699f76ec798626198917aa4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74095bbbb19ca74a0368d857603a2438c88ca86c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/75b5313c80c39a26d27cbb602f968a05576c36f9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b4209e4b778e4e57d0636e1c9fc07a924dbc6043"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38103,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:23.847,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: HID: usbhid: Eliminate recurrent out-of-bounds bug in usbhid_parse() Update struct hid_descriptor to better reflect the mandatory and optional parts of the HID Descriptor as per USB HID 1.11 specification. Note: the kernel currently does not parse any optional HID class descriptors, only the mandatory report descriptor. Update all references to member element desc[0] to rpt_desc. Add test to verify bLength and bNumDescriptors values are valid. Replace the for loop with direct access to the mandatory HID class descriptor member for the report descriptor. This eliminates the possibility of getting an out-of-bounds fault. Add a warning message if the HID descriptor contains any unsupported optional HID class descriptors.",,"[{""url"":""https://git.kernel.org/stable/c/1df80d748f984290c895e843401824215dcfbfb0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/41827a2dbdd7880df9881506dee13bc88d4230bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/485e1b741eb838cbe1d6b0e81e5ab62ae6c095cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4fa7831cf0ac71a0a345369d1a6084f2b096e55e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74388368927e9c52a69524af5bbd6c55eb4690de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7a6d6b68db128da2078ccd9a751dfa3f75c9cf5b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a8f842534807985d3a676006d140541b87044345"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe7f7ac8e0c708446ff017453add769ffc15deed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38104,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-04-18T07:15:43.290,2025-07-17T17:15:36.830,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Replace Mutex with Spinlock for RLCG register access to avoid Priority Inversion in SRIOV RLCG Register Access is a way for virtual functions to safely access GPU registers in a virtualized environment., including TLB flushes and register reads. When multiple threads or VFs try to access the same registers simultaneously, it can lead to race conditions. By using the RLCG interface, the driver can serialize access to the registers. This means that only one thread can access the registers at a time, preventing conflicts and ensuring that operations are performed correctly. Additionally, when a low-priority task holds a mutex that a high-priority task needs, ie., If a thread holding a spinlock tries to acquire a mutex, it can lead to priority inversion. register access in amdgpu_virt_rlcg_reg_rw especially in a fast code path is critical. The call stack shows that the function amdgpu_virt_rlcg_reg_rw is being called, which attempts to acquire the mutex. This function is invoked from amdgpu_sriov_wreg, which in turn is called from gmc_v11_0_flush_gpu_tlb. The [ BUG: Invalid wait context ] indicates that a thread is trying to acquire a mutex while it is in a context that does not allow it to sleep (like holding a spinlock). Fixes the below: [ 253.013423] ============================= [ 253.013434] [ BUG: Invalid wait context ] [ 253.013446] 6.12.0-amdstaging-drm-next-lol-050225 #14 Tainted: G U OE [ 253.013464] ----------------------------- [ 253.013475] kworker/0:1/10 is trying to lock: [ 253.013487] ffff9f30542e3cf8 (&adev->virt.rlcg_reg_lock){+.+.}-{3:3}, at: amdgpu_virt_rlcg_reg_rw+0xf6/0x330 [amdgpu] [ 253.013815] other info that might help us debug this: [ 253.013827] context-{4:4} [ 253.013835] 3 locks held by kworker/0:1/10: [ 253.013847] #0: ffff9f3040050f58 ((wq_completion)events){+.+.}-{0:0}, at: process_one_work+0x3f5/0x680 [ 253.013877] #1: ffffb789c008be40 ((work_completion)(&wfc.work)){+.+.}-{0:0}, at: process_one_work+0x1d6/0x680 [ 253.013905] #2: ffff9f3054281838 (&adev->gmc.invalidate_lock){+.+.}-{2:2}, at: gmc_v11_0_flush_gpu_tlb+0x198/0x4f0 [amdgpu] [ 253.014154] stack backtrace: [ 253.014164] CPU: 0 UID: 0 PID: 10 Comm: kworker/0:1 Tainted: G U OE 6.12.0-amdstaging-drm-next-lol-050225 #14 [ 253.014189] Tainted: [U]=USER, [O]=OOT_MODULE, [E]=UNSIGNED_MODULE [ 253.014203] Hardware name: Microsoft Corporation Virtual Machine/Virtual Machine, BIOS Hyper-V UEFI Release v4.1 11/18/2024 [ 253.014224] Workqueue: events work_for_cpu_fn [ 253.014241] Call Trace: [ 253.014250] <TASK> [ 253.014260] dump_stack_lvl+0x9b/0xf0 [ 253.014275] dump_stack+0x10/0x20 [ 253.014287] __lock_acquire+0xa47/0x2810 [ 253.014303] ? srso_alias_return_thunk+0x5/0xfbef5 [ 253.014321] lock_acquire+0xd1/0x300 [ 253.014333] ? amdgpu_virt_rlcg_reg_rw+0xf6/0x330 [amdgpu] [ 253.014562] ? __lock_acquire+0xa6b/0x2810 [ 253.014578] __mutex_lock+0x85/0xe20 [ 253.014591] ? amdgpu_virt_rlcg_reg_rw+0xf6/0x330 [amdgpu] [ 253.014782] ? sched_clock_noinstr+0x9/0x10 [ 253.014795] ? srso_alias_return_thunk+0x5/0xfbef5 [ 253.014808] ? local_clock_noinstr+0xe/0xc0 [ 253.014822] ? amdgpu_virt_rlcg_reg_rw+0xf6/0x330 [amdgpu] [ 253.015012] ? srso_alias_return_thunk+0x5/0xfbef5 [ 253.015029] mutex_lock_nested+0x1b/0x30 [ 253.015044] ? mutex_lock_nested+0x1b/0x30 [ 253.015057] amdgpu_virt_rlcg_reg_rw+0xf6/0x330 [amdgpu] [ 253.015249] amdgpu_sriov_wreg+0xc5/0xd0 [amdgpu] [ 253.015435] gmc_v11_0_flush_gpu_tlb+0x44b/0x4f0 [amdgpu] [ 253.015667] gfx_v11_0_hw_init+0x499/0x29c0 [amdgpu] [ 253.015901] ? __pfx_smu_v13_0_update_pcie_parameters+0x10/0x10 [amdgpu] [ 253.016159] ? srso_alias_return_thunk+0x5/0xfbef5 [ 253.016173] ? smu_hw_init+0x18d/0x300 [amdgpu] [ 253.016403] amdgpu_device_init+0x29ad/0x36a0 [amdgpu] [ 253.016614] amdgpu_driver_load_kms+0x1a/0xc0 [amdgpu] [ 253.0170 ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/07ed75bfa7ede8bfcfa303fd6efc85db1c8684c7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1c0378830e42c98acd69e0289882c8637d92f285"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5c1741a0c176ae11675a64cb7f2dd21d72db6b91"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc0297f3198bd60108ccbd167ee5d9fa4af31ed0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38105,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:23.997,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ALSA: usb-audio: Kill timer properly at removal The USB-audio MIDI code initializes the timer, but in a rare case, the driver might be freed without the disconnect call. This leaves the timer in an active state while the assigned object is released via snd_usbmidi_free(), which ends up with a kernel warning when the debug configuration is enabled, as spotted by fuzzer. For avoiding the problem, put timer_shutdown_sync() at snd_usbmidi_free(), so that the timer can be killed properly. While we're at it, replace the existing timer_delete_sync() at the disconnect callback with timer_shutdown_sync(), too.",,"[{""url"":""https://git.kernel.org/stable/c/0718a78f6a9f04b88d0dc9616cc216b31c5f3cf1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/62066758d2ae169278e5d6aea5995b1b6f6ddeb5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38106,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:24.123,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: io_uring: fix use-after-free of sq->thread in __io_uring_show_fdinfo() syzbot reports: BUG: KASAN: slab-use-after-free in getrusage+0x1109/0x1a60 Read of size 8 at addr ffff88810de2d2c8 by task a.out/304 CPU: 0 UID: 0 PID: 304 Comm: a.out Not tainted 6.16.0-rc1 #1 PREEMPT(voluntary) Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x53/0x70 print_report+0xd0/0x670 ? __pfx__raw_spin_lock_irqsave+0x10/0x10 ? getrusage+0x1109/0x1a60 kasan_report+0xce/0x100 ? getrusage+0x1109/0x1a60 getrusage+0x1109/0x1a60 ? __pfx_getrusage+0x10/0x10 __io_uring_show_fdinfo+0x9fe/0x1790 ? ksys_read+0xf7/0x1c0 ? do_syscall_64+0xa4/0x260 ? vsnprintf+0x591/0x1100 ? __pfx___io_uring_show_fdinfo+0x10/0x10 ? __pfx_vsnprintf+0x10/0x10 ? mutex_trylock+0xcf/0x130 ? __pfx_mutex_trylock+0x10/0x10 ? __pfx_show_fd_locks+0x10/0x10 ? io_uring_show_fdinfo+0x57/0x80 io_uring_show_fdinfo+0x57/0x80 seq_show+0x38c/0x690 seq_read_iter+0x3f7/0x1180 ? inode_set_ctime_current+0x160/0x4b0 seq_read+0x271/0x3e0 ? __pfx_seq_read+0x10/0x10 ? __pfx__raw_spin_lock+0x10/0x10 ? __mark_inode_dirty+0x402/0x810 ? selinux_file_permission+0x368/0x500 ? file_update_time+0x10f/0x160 vfs_read+0x177/0xa40 ? __pfx___handle_mm_fault+0x10/0x10 ? __pfx_vfs_read+0x10/0x10 ? mutex_lock+0x81/0xe0 ? __pfx_mutex_lock+0x10/0x10 ? fdget_pos+0x24d/0x4b0 ksys_read+0xf7/0x1c0 ? __pfx_ksys_read+0x10/0x10 ? do_user_addr_fault+0x43b/0x9c0 do_syscall_64+0xa4/0x260 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7f0f74170fc9 Code: 00 c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 8 RSP: 002b:00007fffece049e8 EFLAGS: 00000206 ORIG_RAX: 0000000000000000 RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f0f74170fc9 RDX: 0000000000001000 RSI: 00007fffece049f0 RDI: 0000000000000004 RBP: 00007fffece05ad0 R08: 0000000000000000 R09: 00007fffece04d90 R10: 0000000000000000 R11: 0000000000000206 R12: 00005651720a1100 R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000 </TASK> Allocated by task 298: kasan_save_stack+0x33/0x60 kasan_save_track+0x14/0x30 __kasan_slab_alloc+0x6e/0x70 kmem_cache_alloc_node_noprof+0xe8/0x330 copy_process+0x376/0x5e00 create_io_thread+0xab/0xf0 io_sq_offload_create+0x9ed/0xf20 io_uring_setup+0x12b0/0x1cc0 do_syscall_64+0xa4/0x260 entry_SYSCALL_64_after_hwframe+0x77/0x7f Freed by task 22: kasan_save_stack+0x33/0x60 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x60 __kasan_slab_free+0x37/0x50 kmem_cache_free+0xc4/0x360 rcu_core+0x5ff/0x19f0 handle_softirqs+0x18c/0x530 run_ksoftirqd+0x20/0x30 smpboot_thread_fn+0x287/0x6c0 kthread+0x30d/0x630 ret_from_fork+0xef/0x1a0 ret_from_fork_asm+0x1a/0x30 Last potentially related work creation: kasan_save_stack+0x33/0x60 kasan_record_aux_stack+0x8c/0xa0 __call_rcu_common.constprop.0+0x68/0x940 __schedule+0xff2/0x2930 __cond_resched+0x4c/0x80 mutex_lock+0x5c/0xe0 io_uring_del_tctx_node+0xe1/0x2b0 io_uring_clean_tctx+0xb7/0x160 io_uring_cancel_generic+0x34e/0x760 do_exit+0x240/0x2350 do_group_exit+0xab/0x220 __x64_sys_exit_group+0x39/0x40 x64_sys_call+0x1243/0x1840 do_syscall_64+0xa4/0x260 entry_SYSCALL_64_after_hwframe+0x77/0x7f The buggy address belongs to the object at ffff88810de2cb00 which belongs to the cache task_struct of size 3712 The buggy address is located 1992 bytes inside of freed 3712-byte region [ffff88810de2cb00, ffff88810de2d980) which is caused by the task_struct pointed to by sq->thread being released while it is being used in the function __io_uring_show_fdinfo(). Holding ctx->uring_lock does not prevent ehre relase or exit of sq->thread. Fix this by assigning and looking up ->thread under RCU, and grabbing a reference to the task_struct. This e ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/ac0b8b327a5677dc6fecdf353d808161525b1ff0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/af8c13f9ee040b9a287ba246cf0055f7c77b7cc8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d0932758a0a77b38ba1b39564f3b7aba12407061"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38107,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:24.273,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net_sched: ets: fix a race in ets_qdisc_change() Gerrard Tai reported a race condition in ETS, whenever SFQ perturb timer fires at the wrong time. The race is as follows: CPU 0 CPU 1 [1]: lock root [2]: qdisc_tree_flush_backlog() [3]: unlock root | | [5]: lock root | [6]: rehash | [7]: qdisc_tree_reduce_backlog() | [4]: qdisc_put() This can be abused to underflow a parent's qlen. Calling qdisc_purge_queue() instead of qdisc_tree_flush_backlog() should fix the race, because all packets will be purged from the qdisc before releasing the lock.",,"[{""url"":""https://git.kernel.org/stable/c/0383b25488a545be168744336847549d4a2d3d6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/073f64c03516bcfaf790f8edc772e0cfb8a84ec3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0b479d0aa488cb478eb2e1d8868be946ac8afb4f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/347867cb424edae5fec1622712c8dd0a2c42918f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d92adacdd8c2960be856e0b82acc5b7c5395fddb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb7b74e9754e1ba2088f914ad1f57a778b11894b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fed94bd51d62d2e0e006aa61480e94e5cd0582b0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38108,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:24.413,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net_sched: red: fix a race in __red_change() Gerrard Tai reported a race condition in RED, whenever SFQ perturb timer fires at the wrong time. The race is as follows: CPU 0 CPU 1 [1]: lock root [2]: qdisc_tree_flush_backlog() [3]: unlock root | | [5]: lock root | [6]: rehash | [7]: qdisc_tree_reduce_backlog() | [4]: qdisc_put() This can be abused to underflow a parent's qlen. Calling qdisc_purge_queue() instead of qdisc_tree_flush_backlog() should fix the race, because all packets will be purged from the qdisc before releasing the lock.",,"[{""url"":""https://git.kernel.org/stable/c/110a47efcf23438ff8d31dbd9c854fae2a48bf98"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2790c4ec481be45a80948d059cd7c9a06bc37493"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2a71924ca4af59ffc00f0444732b6cd54b153d0e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/444ad445df5496a785705019268a8a84b84484bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4b755305b2b0618e857fdadb499365b5f2e478d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/85a3e0ede38450ea3053b8c45d28cf55208409b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a1bf6a4e9264a685b0e642994031f9c5aad72414"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f569984417a4e12c67366e69bdcb752970de921d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38109,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:24.553,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/mlx5: Fix ECVF vports unload on shutdown flow Fix shutdown flow UAF when a virtual function is created on the embedded chip (ECVF) of a BlueField device. In such case the vport acl ingress table is not properly destroyed. ECVF functionality is independent of ecpf_vport_exists capability and thus functions mlx5_eswitch_(enable|disable)_pf_vf_vports() should not test it when enabling/disabling ECVF vports. kernel log: [] refcount_t: underflow; use-after-free. [] WARNING: CPU: 3 PID: 1 at lib/refcount.c:28 refcount_warn_saturate+0x124/0x220 ---------------- [] Call trace: [] refcount_warn_saturate+0x124/0x220 [] tree_put_node+0x164/0x1e0 [mlx5_core] [] mlx5_destroy_flow_table+0x98/0x2c0 [mlx5_core] [] esw_acl_ingress_table_destroy+0x28/0x40 [mlx5_core] [] esw_acl_ingress_lgcy_cleanup+0x80/0xf4 [mlx5_core] [] esw_legacy_vport_acl_cleanup+0x44/0x60 [mlx5_core] [] esw_vport_cleanup+0x64/0x90 [mlx5_core] [] mlx5_esw_vport_disable+0xc0/0x1d0 [mlx5_core] [] mlx5_eswitch_unload_ec_vf_vports+0xcc/0x150 [mlx5_core] [] mlx5_eswitch_disable_sriov+0x198/0x2a0 [mlx5_core] [] mlx5_device_disable_sriov+0xb8/0x1e0 [mlx5_core] [] mlx5_sriov_detach+0x40/0x50 [mlx5_core] [] mlx5_unload+0x40/0xc4 [mlx5_core] [] mlx5_unload_one_devl_locked+0x6c/0xe4 [mlx5_core] [] mlx5_unload_one+0x3c/0x60 [mlx5_core] [] shutdown+0x7c/0xa4 [mlx5_core] [] pci_device_shutdown+0x3c/0xa0 [] device_shutdown+0x170/0x340 [] __do_sys_reboot+0x1f4/0x2a0 [] __arm64_sys_reboot+0x2c/0x40 [] invoke_syscall+0x78/0x100 [] el0_svc_common.constprop.0+0x54/0x184 [] do_el0_svc+0x30/0xac [] el0_svc+0x48/0x160 [] el0t_64_sync_handler+0xa4/0x12c [] el0t_64_sync+0x1a4/0x1a8 [] --[ end trace 9c4601d68c70030e ]---",,"[{""url"":""https://git.kernel.org/stable/c/24db585d369f949f698e03d7d8017e5ae19d0497"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5953ae44dfe5dbad374318875be834c3b7b71ee6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/687560d8a9a2d654829ad0da1ec24242f1de711d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da15ca0553325acf68039015f2f4db750c8e2b96"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38110,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:24.680,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/mdiobus: Fix potential out-of-bounds clause 45 read/write access When using publicly available tools like 'mdio-tools' to read/write data from/to network interface and its PHY via C45 (clause 45) mdiobus, there is no verification of parameters passed to the ioctl and it accepts any mdio address. Currently there is support for 32 addresses in kernel via PHY_MAX_ADDR define, but it is possible to pass higher value than that via ioctl. While read/write operation should generally fail in this case, mdiobus provides stats array, where wrong address may allow out-of-bounds read/write. Fix that by adding address verification before C45 read/write operation. While this excludes this access from any statistics, it improves security of read/write operation.",,"[{""url"":""https://git.kernel.org/stable/c/260388f79e94fb3026c419a208ece8358bb7b555"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/31bf7b2b92563a352788cf9df3698682f659bacc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4ded22f7f3ce9714ed72c3e9c68fea1cb9388ae7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/abb0605ca00979a49572a6516f6db22c3dc57223"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38111,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:24.810,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/mdiobus: Fix potential out-of-bounds read/write access When using publicly available tools like 'mdio-tools' to read/write data from/to network interface and its PHY via mdiobus, there is no verification of parameters passed to the ioctl and it accepts any mdio address. Currently there is support for 32 addresses in kernel via PHY_MAX_ADDR define, but it is possible to pass higher value than that via ioctl. While read/write operation should generally fail in this case, mdiobus provides stats array, where wrong address may allow out-of-bounds read/write. Fix that by adding address verification before read/write operation. While this excludes this access from any statistics, it improves security of read/write operation.",,"[{""url"":""https://git.kernel.org/stable/c/014ad9210373d2104f6ef10e6bb999a7a0a4c50e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/049af7ac45a6b407748ee0995278fd861e36df8f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0e629694126ca388916f059453a1c36adde219c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/19c5875e26c4ed5686d82a7d8f7051385461b9eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73d478234a619f3476028cb02dee699c30ae8262"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b02d9d2732483e670bc34cb233d28e1d43b15da4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bab6bca0834cbb5be2a7cfe59ec6ad016ec72608"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38112,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:24.960,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: Fix TOCTOU issue in sk_is_readable() sk->sk_prot->sock_is_readable is a valid function pointer when sk resides in a sockmap. After the last sk_psock_put() (which usually happens when socket is removed from sockmap), sk->sk_prot gets restored and sk->sk_prot->sock_is_readable becomes NULL. This makes sk_is_readable() racy, if the value of sk->sk_prot is reloaded after the initial check. Which in turn may lead to a null pointer dereference. Ensure the function pointer does not turn NULL after the check.",,"[{""url"":""https://git.kernel.org/stable/c/1b367ba2f94251822577daed031d6b9a9e11ba91"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1e0de7582ceccbdbb227d4e0ddf65732f92526da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2660a544fdc0940bba15f70508a46cf9a6491230"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6fa68d7eab34d448a61aa24ea31e68b3231ed20d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8926a7ef1977a832dd6bf702f1a99303dbf15b15"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c2b26638476baee154920bb587fc94ff1bf04336"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff55c85a923e043d59d26b20a673a1b4a219c310"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38113,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:25.103,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ACPI: CPPC: Fix NULL pointer dereference when nosmp is used With nosmp in cmdline, other CPUs are not brought up, leaving their cpc_desc_ptr NULL. CPU0's iteration via for_each_possible_cpu() dereferences these NULL pointers, causing panic. Panic backtrace: [ 0.401123] Unable to handle kernel NULL pointer dereference at virtual address 00000000000000b8 ... [ 0.403255] [<ffffffff809a5818>] cppc_allow_fast_switch+0x6a/0xd4 ... Kernel panic - not syncing: Attempted to kill init! [ rjw: New subject ]",,"[{""url"":""https://git.kernel.org/stable/c/15eece6c5b05e5f9db0711978c3e3b7f1a2cfe12"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1a677d0ceb4a5d62117b711a8b2e0aee80d33015"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/32a48db4cf28ea087214c261da8476db218d08bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/356d09c7f5bf525086002a34f8bae40b134d1611"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c6dad167aade4bf0bef9130f2f149f4249fc4ad0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38114,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:25.227,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: e1000: Move cancel_work_sync to avoid deadlock Previously, e1000_down called cancel_work_sync for the e1000 reset task (via e1000_down_and_stop), which takes RTNL. As reported by users and syzbot, a deadlock is possible in the following scenario: CPU 0: - RTNL is held - e1000_close - e1000_down - cancel_work_sync (cancel / wait for e1000_reset_task()) CPU 1: - process_one_work - e1000_reset_task - take RTNL To remedy this, avoid calling cancel_work_sync from e1000_down (e1000_reset_task does nothing if the device is down anyway). Instead, call cancel_work_sync for e1000_reset_task when the device is being removed.",,"[{""url"":""https://git.kernel.org/stable/c/1fd4438ddcc4958ed24662d5125114299e19bae4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b4a8085ceefb7bbb12c2b71c55e71fc946c6929f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38115,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:25.350,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net_sched: sch_sfq: fix a potential crash on gso_skb handling SFQ has an assumption of always being able to queue at least one packet. However, after the blamed commit, sch->q.len can be inflated by packets in sch->gso_skb, and an enqueue() on an empty SFQ qdisc can be followed by an immediate drop. Fix sfq_drop() to properly clear q->tail in this situation. ip netns add lb ip link add dev to-lb type veth peer name in-lb netns lb ethtool -K to-lb tso off # force qdisc to requeue gso_skb ip netns exec lb ethtool -K in-lb gro on # enable NAPI ip link set dev to-lb up ip -netns lb link set dev in-lb up ip addr add dev to-lb 192.168.20.1/24 ip -netns lb addr add dev in-lb 192.168.20.2/24 tc qdisc replace dev to-lb root sfq limit 100 ip netns exec lb netserver netperf -H 192.168.20.2 -l 100 & netperf -H 192.168.20.2 -l 100 & netperf -H 192.168.20.2 -l 100 & netperf -H 192.168.20.2 -l 100 &",,"[{""url"":""https://git.kernel.org/stable/c/5814a7fc3abb41f63f2d44c9d3ff9d4e62965b72"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/82448d4dcd8406dec688632a405fdcf7f170ec69"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/82ffbe7776d0ac084031f114167712269bf3d832"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9c19498bdd7cb9d854bd3c54260f71cf7408495e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b44f791f27b14c9eb6b907fbe51f2ba8bec32085"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b4e9bab6011b9559b7c157b16b91ae46d4d8c533"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c337efb20d6d9f9bbb4746f6b119917af5c886dc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d1bc80da75c789f2f6830df89d91fb2f7a509943"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38116,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:25.490,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: fix uaf in ath12k_core_init() When the execution of ath12k_core_hw_group_assign() or ath12k_core_hw_group_create() fails, the registered notifier chain is not unregistered properly. Its memory is freed after rmmod, which may trigger to a use-after-free (UAF) issue if there is a subsequent access to this notifier chain. Fixes the issue by calling ath12k_core_panic_notifier_unregister() in failure cases. Call trace: notifier_chain_register+0x4c/0x1f0 (P) atomic_notifier_chain_register+0x38/0x68 ath12k_core_init+0x50/0x4e8 [ath12k] ath12k_pci_probe+0x5f8/0xc28 [ath12k] pci_device_probe+0xbc/0x1a8 really_probe+0xc8/0x3a0 __driver_probe_device+0x84/0x1b0 driver_probe_device+0x44/0x130 __driver_attach+0xcc/0x208 bus_for_each_dev+0x84/0x100 driver_attach+0x2c/0x40 bus_add_driver+0x130/0x260 driver_register+0x70/0x138 __pci_register_driver+0x68/0x80 ath12k_pci_init+0x30/0x68 [ath12k] ath12k_init+0x28/0x78 [ath12k] Tested-on: WCN7850 hw2.0 PCI WLAN.HMT.1.0.c5-00481-QCAHMTSWPL_V1.0_V2.0_SILICONZ-3",,"[{""url"":""https://git.kernel.org/stable/c/65e1b3404c211dcfaea02698539cdcd26647130f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f3fe49dbddd73f0155a8935af47cb63693069dbe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38117,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:25.617,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: MGMT: Protect mgmt_pending list with its own lock This uses a mutex to protect from concurrent access of mgmt_pending list which can cause crashes like: ================================================================== BUG: KASAN: slab-use-after-free in hci_sock_get_channel+0x60/0x68 net/bluetooth/hci_sock.c:91 Read of size 2 at addr ffff0000c48885b2 by task syz.4.334/7318 CPU: 0 UID: 0 PID: 7318 Comm: syz.4.334 Not tainted 6.15.0-rc7-syzkaller-g187899f4124a #0 PREEMPT Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 02/12/2025 Call trace: show_stack+0x2c/0x3c arch/arm64/kernel/stacktrace.c:466 (C) __dump_stack+0x30/0x40 lib/dump_stack.c:94 dump_stack_lvl+0xd8/0x12c lib/dump_stack.c:120 print_address_description+0xa8/0x254 mm/kasan/report.c:408 print_report+0x68/0x84 mm/kasan/report.c:521 kasan_report+0xb0/0x110 mm/kasan/report.c:634 __asan_report_load2_noabort+0x20/0x2c mm/kasan/report_generic.c:379 hci_sock_get_channel+0x60/0x68 net/bluetooth/hci_sock.c:91 mgmt_pending_find+0x7c/0x140 net/bluetooth/mgmt_util.c:223 pending_find net/bluetooth/mgmt.c:947 [inline] remove_adv_monitor+0x44/0x1a4 net/bluetooth/mgmt.c:5445 hci_mgmt_cmd+0x780/0xc00 net/bluetooth/hci_sock.c:1712 hci_sock_sendmsg+0x544/0xbb0 net/bluetooth/hci_sock.c:1832 sock_sendmsg_nosec net/socket.c:712 [inline] __sock_sendmsg net/socket.c:727 [inline] sock_write_iter+0x25c/0x378 net/socket.c:1131 new_sync_write fs/read_write.c:591 [inline] vfs_write+0x62c/0x97c fs/read_write.c:684 ksys_write+0x120/0x210 fs/read_write.c:736 __do_sys_write fs/read_write.c:747 [inline] __se_sys_write fs/read_write.c:744 [inline] __arm64_sys_write+0x7c/0x90 fs/read_write.c:744 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline] invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151 el0_svc+0x58/0x17c arch/arm64/kernel/entry-common.c:767 el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:786 el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600 Allocated by task 7037: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x40/0x78 mm/kasan/common.c:68 kasan_save_alloc_info+0x44/0x54 mm/kasan/generic.c:562 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0x9c/0xb4 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __do_kmalloc_node mm/slub.c:4327 [inline] __kmalloc_noprof+0x2fc/0x4c8 mm/slub.c:4339 kmalloc_noprof include/linux/slab.h:909 [inline] sk_prot_alloc+0xc4/0x1f0 net/core/sock.c:2198 sk_alloc+0x44/0x3ac net/core/sock.c:2254 bt_sock_alloc+0x4c/0x300 net/bluetooth/af_bluetooth.c:148 hci_sock_create+0xa8/0x194 net/bluetooth/hci_sock.c:2202 bt_sock_create+0x14c/0x24c net/bluetooth/af_bluetooth.c:132 __sock_create+0x43c/0x91c net/socket.c:1541 sock_create net/socket.c:1599 [inline] __sys_socket_create net/socket.c:1636 [inline] __sys_socket+0xd4/0x1c0 net/socket.c:1683 __do_sys_socket net/socket.c:1697 [inline] __se_sys_socket net/socket.c:1695 [inline] __arm64_sys_socket+0x7c/0x94 net/socket.c:1695 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline] invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151 el0_svc+0x58/0x17c arch/arm64/kernel/entry-common.c:767 el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:786 el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600 Freed by task 6607: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x40/0x78 mm/kasan/common.c:68 kasan_save_free_info+0x58/0x70 mm/kasan/generic.c:576 poison_slab_object mm/kasan/common.c:247 [inline] __kasan_slab_free+0x68/0x88 mm/kasan/common.c:264 kasan_slab_free include/linux/kasan.h:233 [inline ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/4e83f2dbb2bf677e614109df24426c4dded472d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6fe26f694c824b8a4dbf50c635bee1302e3f099c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bdd56875c6926d8009914f427df71797693e90d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d7882db79135c829a922daf3571f33ea1e056ae3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38118,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:25.757,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: MGMT: Fix UAF on mgmt_remove_adv_monitor_complete This reworks MGMT_OP_REMOVE_ADV_MONITOR to not use mgmt_pending_add to avoid crashes like bellow: ================================================================== BUG: KASAN: slab-use-after-free in mgmt_remove_adv_monitor_complete+0xe5/0x540 net/bluetooth/mgmt.c:5406 Read of size 8 at addr ffff88801c53f318 by task kworker/u5:5/5341 CPU: 0 UID: 0 PID: 5341 Comm: kworker/u5:5 Not tainted 6.15.0-syzkaller-10402-g4cb6c8af8591 #0 PREEMPT(full) Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 Workqueue: hci0 hci_cmd_sync_work Call Trace: <TASK> dump_stack_lvl+0x189/0x250 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:408 [inline] print_report+0xd2/0x2b0 mm/kasan/report.c:521 kasan_report+0x118/0x150 mm/kasan/report.c:634 mgmt_remove_adv_monitor_complete+0xe5/0x540 net/bluetooth/mgmt.c:5406 hci_cmd_sync_work+0x261/0x3a0 net/bluetooth/hci_sync.c:334 process_one_work kernel/workqueue.c:3238 [inline] process_scheduled_works+0xade/0x17b0 kernel/workqueue.c:3321 worker_thread+0x8a0/0xda0 kernel/workqueue.c:3402 kthread+0x711/0x8a0 kernel/kthread.c:464 ret_from_fork+0x3fc/0x770 arch/x86/kernel/process.c:148 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:245 </TASK> Allocated by task 5987: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3e/0x80 mm/kasan/common.c:68 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0x93/0xb0 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __kmalloc_cache_noprof+0x230/0x3d0 mm/slub.c:4358 kmalloc_noprof include/linux/slab.h:905 [inline] kzalloc_noprof include/linux/slab.h:1039 [inline] mgmt_pending_new+0x65/0x240 net/bluetooth/mgmt_util.c:252 mgmt_pending_add+0x34/0x120 net/bluetooth/mgmt_util.c:279 remove_adv_monitor+0x103/0x1b0 net/bluetooth/mgmt.c:5454 hci_mgmt_cmd+0x9c9/0xef0 net/bluetooth/hci_sock.c:1719 hci_sock_sendmsg+0x6ca/0xef0 net/bluetooth/hci_sock.c:1839 sock_sendmsg_nosec net/socket.c:712 [inline] __sock_sendmsg+0x219/0x270 net/socket.c:727 sock_write_iter+0x258/0x330 net/socket.c:1131 new_sync_write fs/read_write.c:593 [inline] vfs_write+0x548/0xa90 fs/read_write.c:686 ksys_write+0x145/0x250 fs/read_write.c:738 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xfa/0x3b0 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f Freed by task 5989: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3e/0x80 mm/kasan/common.c:68 kasan_save_free_info+0x46/0x50 mm/kasan/generic.c:576 poison_slab_object mm/kasan/common.c:247 [inline] __kasan_slab_free+0x62/0x70 mm/kasan/common.c:264 kasan_slab_free include/linux/kasan.h:233 [inline] slab_free_hook mm/slub.c:2380 [inline] slab_free mm/slub.c:4642 [inline] kfree+0x18e/0x440 mm/slub.c:4841 mgmt_pending_foreach+0xc9/0x120 net/bluetooth/mgmt_util.c:242 mgmt_index_removed+0x10d/0x2f0 net/bluetooth/mgmt.c:9366 hci_sock_bind+0xbe9/0x1000 net/bluetooth/hci_sock.c:1314 __sys_bind_socket net/socket.c:1810 [inline] __sys_bind+0x2c3/0x3e0 net/socket.c:1841 __do_sys_bind net/socket.c:1846 [inline] __se_sys_bind net/socket.c:1844 [inline] __x64_sys_bind+0x7a/0x90 net/socket.c:1844 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xfa/0x3b0 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f",,"[{""url"":""https://git.kernel.org/stable/c/32aa2fbe319f33b0318ec6f4fceb63879771a286"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3c9aba9cbdf163e2654be9f82d43ff8a04273962"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9df3e5e7f7e4653fd9802878cedc36defc5ef42d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9f66b6531c2b4e996bb61720ee94adb4b2e8d1be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e6ed54e86aae9e4f7286ce8d5c73780f91b48d1c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38119,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:25.903,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: core: ufs: Fix a hang in the error handler ufshcd_err_handling_prepare() calls ufshcd_rpm_get_sync(). The latter function can only succeed if UFSHCD_EH_IN_PROGRESS is not set because resuming involves submitting a SCSI command and ufshcd_queuecommand() returns SCSI_MLQUEUE_HOST_BUSY if UFSHCD_EH_IN_PROGRESS is set. Fix this hang by setting UFSHCD_EH_IN_PROGRESS after ufshcd_rpm_get_sync() has been called instead of before. Backtrace: __switch_to+0x174/0x338 __schedule+0x600/0x9e4 schedule+0x7c/0xe8 schedule_timeout+0xa4/0x1c8 io_schedule_timeout+0x48/0x70 wait_for_common_io+0xa8/0x160 //waiting on START_STOP wait_for_completion_io_timeout+0x10/0x20 blk_execute_rq+0xe4/0x1e4 scsi_execute_cmd+0x108/0x244 ufshcd_set_dev_pwr_mode+0xe8/0x250 __ufshcd_wl_resume+0x94/0x354 ufshcd_wl_runtime_resume+0x3c/0x174 scsi_runtime_resume+0x64/0xa4 rpm_resume+0x15c/0xa1c __pm_runtime_resume+0x4c/0x90 // Runtime resume ongoing ufshcd_err_handler+0x1a0/0xd08 process_one_work+0x174/0x808 worker_thread+0x15c/0x490 kthread+0xf4/0x1ec ret_from_fork+0x10/0x20 [ bvanassche: rewrote patch description ]",,"[{""url"":""https://git.kernel.org/stable/c/21f071261f946c5ca1adf378f818082a112b34d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3464a707d137efc8aea1d4ae234d26a28d82b78c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8a3514d348de87a9d5e2ac00fbac4faae0b97996"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bb37f795d01961286b8f768a6d7152f32b589067"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ded80255c59a57cd3270d98461f6508730f9767c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f592eb12b43f21dbc972cbe583a12d256901e569"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38120,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:26.037,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: nf_set_pipapo_avx2: fix initial map fill If the first field doesn't cover the entire start map, then we must zero out the remainder, else we leak those bits into the next match round map. The early fix was incomplete and did only fix up the generic C implementation. A followup patch adds a test case to nft_concat_range.sh.",,"[{""url"":""https://git.kernel.org/stable/c/251496ce1728c9fd47bd2b20a7b21b20b9a020ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/39bab2d3517b5b50c609b4f8c66129bf619fffa0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8068e1e42b46518ce680dc6470bcd710efc3fa0a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90bc7f5a244aadee4292b28098b7c98aadd4b3aa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b5ad58285f9217d68cd5ea2ad86ce254a3fe7c4d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ea77c397bff8b6d59f6d83dae1425b08f465e8b5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38121,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:26.170,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: iwlwifi: mld: avoid panic on init failure In case of an error during init, in_hw_restart will be set, but it will never get cleared. Instead, we will retry to init again, and then we will act like we are in a restart when we are actually not. This causes (among others) to a NULL pointer dereference when canceling rx_omi::finished_work, that was not even initialized, because we thought that we are in hw_restart. Set in_hw_restart to true only if the fw is running, then we know that FW was loaded successfully and we are not going to the retry loop.",,"[{""url"":""https://git.kernel.org/stable/c/960c7e6d388034d219dafffa6da0a5c2ccd5ff30"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a26ec8e16958b6dd37dac9daf5fb6978fe0cb0b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38122,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:26.297,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: gve: add missing NULL check for gve_alloc_pending_packet() in TX DQO gve_alloc_pending_packet() can return NULL, but gve_tx_add_skb_dqo() did not check for this case before dereferencing the returned pointer. Add a missing NULL check to prevent a potential NULL pointer dereference when allocation fails. This improves robustness in low-memory scenarios.",,"[{""url"":""https://git.kernel.org/stable/c/12c331b29c7397ac3b03584e12902990693bc248"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2e5ead9e4e91fbe7799bd38afd8904543be1cb51"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f6265fce3bd424ded666481b37f106d7915fb6b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a0319c9b1648a67511e947a596ca86888451c0a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ae98a1787fdcb0096d122bc80d93c3c7d812c04b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c741a7ef68023ac800054e2131c3e22e647fd7e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38123,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:26.427,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: wwan: t7xx: Fix napi rx poll issue When driver handles the napi rx polling requests, the netdev might have been released by the dellink logic triggered by the disconnect operation on user plane. However, in the logic of processing skb in polling, an invalid netdev is still being used, which causes a panic. BUG: kernel NULL pointer dereference, address: 00000000000000f1 Oops: 0000 [#1] PREEMPT SMP NOPTI RIP: 0010:dev_gro_receive+0x3a/0x620 [...] Call Trace: <IRQ> ? __die_body+0x68/0xb0 ? page_fault_oops+0x379/0x3e0 ? exc_page_fault+0x4f/0xa0 ? asm_exc_page_fault+0x22/0x30 ? __pfx_t7xx_ccmni_recv_skb+0x10/0x10 [mtk_t7xx (HASH:1400 7)] ? dev_gro_receive+0x3a/0x620 napi_gro_receive+0xad/0x170 t7xx_ccmni_recv_skb+0x48/0x70 [mtk_t7xx (HASH:1400 7)] t7xx_dpmaif_napi_rx_poll+0x590/0x800 [mtk_t7xx (HASH:1400 7)] net_rx_action+0x103/0x470 irq_exit_rcu+0x13a/0x310 sysvec_apic_timer_interrupt+0x56/0x90 </IRQ>",,"[{""url"":""https://git.kernel.org/stable/c/66542e9430c625f878a5b5dc0fe41e3458d614bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/905fe0845bb27e4eed2ca27ea06e6c4847f1b2b1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc89f457d9133a558d4e8ef26dc20843c2d12073"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e2df04e69c3f10b412f54be036dd0ed3b14756cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38124,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:26.547,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: fix udp gso skb_segment after pull from frag_list Commit a1e40ac5b5e9 (""net: gso: fix udp gso fraglist segmentation after pull from frag_list"") detected invalid geometry in frag_list skbs and redirects them from skb_segment_list to more robust skb_segment. But some packets with modified geometry can also hit bugs in that code. We don't know how many such cases exist. Addressing each one by one also requires touching the complex skb_segment code, which risks introducing bugs for other types of skbs. Instead, linearize all these packets that fail the basic invariants on gso fraglist skbs. That is more robust. If only part of the fraglist payload is pulled into head_skb, it will always cause exception when splitting skbs by skb_segment. For detailed call stack information, see below. Valid SKB_GSO_FRAGLIST skbs - consist of two or more segments - the head_skb holds the protocol headers plus first gso_size - one or more frag_list skbs hold exactly one segment - all but the last must be gso_size Optional datapath hooks such as NAT and BPF (bpf_skb_pull_data) can modify fraglist skbs, breaking these invariants. In extreme cases they pull one part of data into skb linear. For UDP, this causes three payloads with lengths of (11,11,10) bytes were pulled tail to become (12,10,10) bytes. The skbs no longer meets the above SKB_GSO_FRAGLIST conditions because payload was pulled into head_skb, it needs to be linearized before pass to regular skb_segment. skb_segment+0xcd0/0xd14 __udp_gso_segment+0x334/0x5f4 udp4_ufo_fragment+0x118/0x15c inet_gso_segment+0x164/0x338 skb_mac_gso_segment+0xc4/0x13c __skb_gso_segment+0xc4/0x124 validate_xmit_skb+0x9c/0x2c0 validate_xmit_skb_list+0x4c/0x80 sch_direct_xmit+0x70/0x404 __dev_queue_xmit+0x64c/0xe5c neigh_resolve_output+0x178/0x1c4 ip_finish_output2+0x37c/0x47c __ip_finish_output+0x194/0x240 ip_finish_output+0x20/0xf4 ip_output+0x100/0x1a0 NF_HOOK+0xc4/0x16c ip_forward+0x314/0x32c ip_rcv+0x90/0x118 __netif_receive_skb+0x74/0x124 process_backlog+0xe8/0x1a4 __napi_poll+0x5c/0x1f8 net_rx_action+0x154/0x314 handle_softirqs+0x154/0x4b8 [118.376811] [C201134] rxq0_pus: [name:bug&]kernel BUG at net/core/skbuff.c:4278! [118.376829] [C201134] rxq0_pus: [name:traps&]Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP [118.470774] [C201134] rxq0_pus: [name:mrdump&]Kernel Offset: 0x178cc00000 from 0xffffffc008000000 [118.470810] [C201134] rxq0_pus: [name:mrdump&]PHYS_OFFSET: 0x40000000 [118.470827] [C201134] rxq0_pus: [name:mrdump&]pstate: 60400005 (nZCv daif +PAN -UAO) [118.470848] [C201134] rxq0_pus: [name:mrdump&]pc : [0xffffffd79598aefc] skb_segment+0xcd0/0xd14 [118.470900] [C201134] rxq0_pus: [name:mrdump&]lr : [0xffffffd79598a5e8] skb_segment+0x3bc/0xd14 [118.470928] [C201134] rxq0_pus: [name:mrdump&]sp : ffffffc008013770",,"[{""url"":""https://git.kernel.org/stable/c/0e65f38bd1aa14ea86e221b7bb814d38278d86c3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3382a1ed7f778db841063f5d7e317ac55f9e7f72"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4399f59a9467a324ed46657555f0e1f209a14acb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/85eef1748c024da1a191aed56b30a3a65958c50c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a04302867094bdc6efac1b598370fc47cf3f2388"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38125,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:26.680,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: stmmac: make sure that ptp_rate is not 0 before configuring EST If the ptp_rate recorded earlier in the driver happens to be 0, this bogus value will propagate up to EST configuration, where it will trigger a division by 0. Prevent this division by 0 by adding the corresponding check and error code.",,"[{""url"":""https://git.kernel.org/stable/c/451ee661d0f6272017fa012f99617101aa8ddf2c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cbefe2ffa7784525ec5d008ba87c7add19ec631a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d5e3bfdba0dc419499b801937128957f77503761"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38126,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:26.800,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: stmmac: make sure that ptp_rate is not 0 before configuring timestamping The stmmac platform drivers that do not open-code the clk_ptp_rate value after having retrieved the default one from the device-tree can end up with 0 in clk_ptp_rate (as clk_get_rate can return 0). It will eventually propagate up to PTP initialization when bringing up the interface, leading to a divide by 0: Division by zero in kernel. CPU: 1 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.12.30-00001-g48313bd5768a #22 Hardware name: STM32 (Device Tree Support) Call trace: unwind_backtrace from show_stack+0x18/0x1c show_stack from dump_stack_lvl+0x6c/0x8c dump_stack_lvl from Ldiv0_64+0x8/0x18 Ldiv0_64 from stmmac_init_tstamp_counter+0x190/0x1a4 stmmac_init_tstamp_counter from stmmac_hw_setup+0xc1c/0x111c stmmac_hw_setup from __stmmac_open+0x18c/0x434 __stmmac_open from stmmac_open+0x3c/0xbc stmmac_open from __dev_open+0xf4/0x1ac __dev_open from __dev_change_flags+0x1cc/0x224 __dev_change_flags from dev_change_flags+0x24/0x60 dev_change_flags from ip_auto_config+0x2e8/0x11a0 ip_auto_config from do_one_initcall+0x84/0x33c do_one_initcall from kernel_init_freeable+0x1b8/0x214 kernel_init_freeable from kernel_init+0x24/0x140 kernel_init from ret_from_fork+0x14/0x28 Exception stack(0xe0815fb0 to 0xe0815ff8) Prevent this division by 0 by adding an explicit check and error log about the actual issue. While at it, remove the same check from stmmac_ptp_register, which then becomes duplicate",,"[{""url"":""https://git.kernel.org/stable/c/030ce919e114a111e83b7976ecb3597cefd33f26"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/32af9c289234990752281c805500dfe03c5b2b8f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/379cd990dfe752b38fcf46034698a9a150626c7a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b263088ee8ab14563817a8be3519af8e25225793"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bb033c6781ce1b0264c3993b767b4aa9021959c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38127,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:26.923,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ice: fix Tx scheduler error handling in XDP callback When the XDP program is loaded, the XDP callback adds new Tx queues. This means that the callback must update the Tx scheduler with the new queue number. In the event of a Tx scheduler failure, the XDP callback should also fail and roll back any changes previously made for XDP preparation. The previous implementation had a bug that not all changes made by the XDP callback were rolled back. This caused the crash with the following call trace: [ +9.549584] ice 0000:ca:00.0: Failed VSI LAN queue config for XDP, error: -5 [ +0.382335] Oops: general protection fault, probably for non-canonical address 0x50a2250a90495525: 0000 [#1] SMP NOPTI [ +0.010710] CPU: 103 UID: 0 PID: 0 Comm: swapper/103 Not tainted 6.14.0-net-next-mar-31+ #14 PREEMPT(voluntary) [ +0.010175] Hardware name: Intel Corporation M50CYP2SBSTD/M50CYP2SBSTD, BIOS SE5C620.86B.01.01.0005.2202160810 02/16/2022 [ +0.010946] RIP: 0010:__ice_update_sample+0x39/0xe0 [ice] [...] [ +0.002715] Call Trace: [ +0.002452] <IRQ> [ +0.002021] ? __die_body.cold+0x19/0x29 [ +0.003922] ? die_addr+0x3c/0x60 [ +0.003319] ? exc_general_protection+0x17c/0x400 [ +0.004707] ? asm_exc_general_protection+0x26/0x30 [ +0.004879] ? __ice_update_sample+0x39/0xe0 [ice] [ +0.004835] ice_napi_poll+0x665/0x680 [ice] [ +0.004320] __napi_poll+0x28/0x190 [ +0.003500] net_rx_action+0x198/0x360 [ +0.003752] ? update_rq_clock+0x39/0x220 [ +0.004013] handle_softirqs+0xf1/0x340 [ +0.003840] ? sched_clock_cpu+0xf/0x1f0 [ +0.003925] __irq_exit_rcu+0xc2/0xe0 [ +0.003665] common_interrupt+0x85/0xa0 [ +0.003839] </IRQ> [ +0.002098] <TASK> [ +0.002106] asm_common_interrupt+0x26/0x40 [ +0.004184] RIP: 0010:cpuidle_enter_state+0xd3/0x690 Fix this by performing the missing unmapping of XDP queues from q_vectors and setting the XDP rings pointer back to NULL after all those queues are released. Also, add an immediate exit from the XDP callback in case of ring preparation failure.",,"[{""url"":""https://git.kernel.org/stable/c/0153f36041b8e52019ebfa8629c13bf8f9b0a951"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0e061abaad1498c5b76c10c594d4359ceb6b9145"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1d3c5d0dec6797eca3a861dab0816fa9505d9c3e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/276849954d7cbe6eec827b21fe2df43f9bf07011"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38128,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:27.043,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: MGMT: reject malformed HCI_CMD_SYNC commands In 'mgmt_hci_cmd_sync()', check whether the size of parameters passed in 'struct mgmt_cp_hci_cmd_sync' matches the total size of the data (i.e. 'sizeof(struct mgmt_cp_hci_cmd_sync)' plus trailing bytes). Otherwise, large invalid 'params_len' will cause 'hci_cmd_sync_alloc()' to do 'skb_put_data()' from an area beyond the one actually passed to 'mgmt_hci_cmd_sync()'.",,"[{""url"":""https://git.kernel.org/stable/c/03f1700b9b4d4f2fed3165370f3c23db76553178"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9eeafd16d76a7642d12b3442a26c15cd345e12f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38129,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:27.170,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: page_pool: Fix use-after-free in page_pool_recycle_in_ring syzbot reported a uaf in page_pool_recycle_in_ring: BUG: KASAN: slab-use-after-free in lock_release+0x151/0xa30 kernel/locking/lockdep.c:5862 Read of size 8 at addr ffff8880286045a0 by task syz.0.284/6943 CPU: 0 UID: 0 PID: 6943 Comm: syz.0.284 Not tainted 6.13.0-rc3-syzkaller-gdfa94ce54f41 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0x169/0x550 mm/kasan/report.c:489 kasan_report+0x143/0x180 mm/kasan/report.c:602 lock_release+0x151/0xa30 kernel/locking/lockdep.c:5862 __raw_spin_unlock_bh include/linux/spinlock_api_smp.h:165 [inline] _raw_spin_unlock_bh+0x1b/0x40 kernel/locking/spinlock.c:210 spin_unlock_bh include/linux/spinlock.h:396 [inline] ptr_ring_produce_bh include/linux/ptr_ring.h:164 [inline] page_pool_recycle_in_ring net/core/page_pool.c:707 [inline] page_pool_put_unrefed_netmem+0x748/0xb00 net/core/page_pool.c:826 page_pool_put_netmem include/net/page_pool/helpers.h:323 [inline] page_pool_put_full_netmem include/net/page_pool/helpers.h:353 [inline] napi_pp_put_page+0x149/0x2b0 net/core/skbuff.c:1036 skb_pp_recycle net/core/skbuff.c:1047 [inline] skb_free_head net/core/skbuff.c:1094 [inline] skb_release_data+0x6c4/0x8a0 net/core/skbuff.c:1125 skb_release_all net/core/skbuff.c:1190 [inline] __kfree_skb net/core/skbuff.c:1204 [inline] sk_skb_reason_drop+0x1c9/0x380 net/core/skbuff.c:1242 kfree_skb_reason include/linux/skbuff.h:1263 [inline] __skb_queue_purge_reason include/linux/skbuff.h:3343 [inline] root cause is: page_pool_recycle_in_ring ptr_ring_produce spin_lock(&r->producer_lock); WRITE_ONCE(r->queue[r->producer++], ptr) //recycle last page to pool page_pool_release page_pool_scrub page_pool_empty_ring ptr_ring_consume page_pool_return_page //release all page __page_pool_destroy free_percpu(pool->recycle_stats); free(pool) //free spin_unlock(&r->producer_lock); //pool->ring uaf read recycle_stat_inc(pool, ring); page_pool can be free while page pool recycle the last page in ring. Add producer-lock barrier to page_pool_release to prevent the page pool from being free before all pages have been recycled. recycle_stat_inc() is empty when CONFIG_PAGE_POOL_STATS is not enabled, which will trigger Wempty-body build warning. Add definition for pool stat macro to fix warning.",,"[{""url"":""https://git.kernel.org/stable/c/271683bb2cf32e5126c592b5d5e6a756fa374fd9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4ab8c0f8905c9c4d05e7f437e65a9a365573ff02"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e869a85acc2e60dc554579b910826a4919d8cd98"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38130,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:27.303,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/connector: only call HDMI audio helper plugged cb if non-null On driver remove, sound/soc/codecs/hdmi-codec.c calls the plugged_cb with NULL as the callback function and codec_dev, as seen in its hdmi_remove function. The HDMI audio helper then happily tries calling said null function pointer, and produces an Oops as a result. Fix this by only executing the callback if fn is non-null. This means the .plugged_cb and .plugged_cb_dev members still get appropriately cleared.",,"[{""url"":""https://git.kernel.org/stable/c/933f3eab1d489af8d734bff855b10d29dd5968a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be9b3f9a54101c19226c25ba7163d291183777a0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38131,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:27.430,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: coresight: prevent deactivate active config while enabling the config While enable active config via cscfg_csdev_enable_active_config(), active config could be deactivated via configfs' sysfs interface. This could make UAF issue in below scenario: CPU0 CPU1 (sysfs enable) load module cscfg_load_config_sets() activate config. // sysfs (sys_active_cnt == 1) ... cscfg_csdev_enable_active_config() lock(csdev->cscfg_csdev_lock) // here load config activate by CPU1 unlock(csdev->cscfg_csdev_lock) deactivate config // sysfs (sys_activec_cnt == 0) cscfg_unload_config_sets() unload module // access to config_desc which freed // while unloading module. cscfg_csdev_enable_config To address this, use cscfg_config_desc's active_cnt as a reference count which will be holded when - activate the config. - enable the activated config. and put the module reference when config_active_cnt == 0.",,"[{""url"":""https://git.kernel.org/stable/c/31028812724cef7bd57a51525ce58a32a6d73b22"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/408c97c4a5e0b634dcd15bf8b8808b382e888164"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3b4efa2e623aecaebd7c9b9e4171f5c659e9724"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dfe8224c9c7a43d356eb9f74b06868aa05f90223"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ed42ee1ed05ff2f4c36938379057413a40c56680"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38132,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:27.563,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: coresight: holding cscfg_csdev_lock while removing cscfg from csdev There'll be possible race scenario for coresight config: CPU0 CPU1 (perf enable) load module cscfg_load_config_sets() activate config. // sysfs (sys_active_cnt == 1) ... cscfg_csdev_enable_active_config() lock(csdev->cscfg_csdev_lock) deactivate config // sysfs (sys_activec_cnt == 0) cscfg_unload_config_sets() <iterating config_csdev_list> cscfg_remove_owned_csdev_configs() // here load config activate by CPU1 unlock(csdev->cscfg_csdev_lock) iterating config_csdev_list could be raced with config_csdev_list's entry delete. To resolve this race , hold csdev->cscfg_csdev_lock() while cscfg_remove_owned_csdev_configs()",,"[{""url"":""https://git.kernel.org/stable/c/42f8afb0b161631fd1d814d017f75f955475ad41"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/53b9e2659719b04f5ba7593f2af0f2335f75e94a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38133,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:27.697,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iio: adc: ad4851: fix ad4858 chan pointer handling The pointer returned from ad4851_parse_channels_common() is incremented internally as each channel is populated. In ad4858_parse_channels(), the same pointer was further incremented while setting ext_scan_type fields for each channel. This resulted in indio_dev->channels being set to a pointer past the end of the allocated array, potentially causing memory corruption or undefined behavior. Fix this by iterating over the channels using an explicit index instead of incrementing the pointer. This preserves the original base pointer and ensures all channel metadata is set correctly.",,"[{""url"":""https://git.kernel.org/stable/c/499a8cee812588905cc940837e69918c1649a19e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c3b9e1167d072ce2d01cafec7866647cf8d3616"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38134,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:27.837,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: acpi: Prevent null pointer dereference in usb_acpi_add_usb4_devlink() As demonstrated by the fix for update_port_device_state, commit 12783c0b9e2c (""usb: core: Prevent null pointer dereference in update_port_device_state""), usb_hub_to_struct_hub() can return NULL in certain scenarios, such as during hub driver unbind or teardown race conditions, even if the underlying usb_device structure exists. Plus, all other places that call usb_hub_to_struct_hub() in the same file do check for NULL return values. If usb_hub_to_struct_hub() returns NULL, the subsequent access to hub->ports[udev->portnum - 1] will cause a null pointer dereference.",,"[{""url"":""https://git.kernel.org/stable/c/73fb0ec9436ae87bcae067ce35d6cdd72bade86c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8fa544bff8466062e42949c93f3e528f4be5624b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3d530173b70514d4390a94f9f979acad689b70a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38135,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:27.963,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: serial: Fix potential null-ptr-deref in mlb_usio_probe() devm_ioremap() can return NULL on error. Currently, mlb_usio_probe() does not check for this case, which could result in a NULL pointer dereference. Add NULL check after devm_ioremap() to prevent this issue.",,"[{""url"":""https://git.kernel.org/stable/c/19fd9f5a69363d33079097d866eb6082d61bf31d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/548b0e81b9a0902a8bc8259430ed965663baadfc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/81159a6b064142b993f2f39828b77e199c77872a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/86bcae88c9209e334b2f8c252f4cc66beb261886"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a05ebe384c7ca75476453f3070c67d9cf1d1a89f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6c7c365734cd0fa1c5aa225a6294fdf80cad2ea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c23d87b43f7dba5eb12820f6cf21a1cd4f63eb3d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e1b144aebe6fb898d96ced8c990d7aa38fda4a7a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38136,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:28.097,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: renesas_usbhs: Reorder clock handling and power management in probe Reorder the initialization sequence in `usbhs_probe()` to enable runtime PM before accessing registers, preventing potential crashes due to uninitialized clocks. Currently, in the probe path, registers are accessed before enabling the clocks, leading to a synchronous external abort on the RZ/V2H SoC. The problematic call flow is as follows: usbhs_probe() usbhs_sys_clock_ctrl() usbhs_bset() usbhs_write() iowrite16() <-- Register access before enabling clocks Since `iowrite16()` is performed without ensuring the required clocks are enabled, this can lead to access errors. To fix this, enable PM runtime early in the probe function and ensure clocks are acquired before register access, preventing crashes like the following on RZ/V2H: [13.272640] Internal error: synchronous external abort: 0000000096000010 [#1] PREEMPT SMP [13.280814] Modules linked in: cec renesas_usbhs(+) drm_kms_helper fuse drm backlight ipv6 [13.289088] CPU: 1 UID: 0 PID: 195 Comm: (udev-worker) Not tainted 6.14.0-rc7+ #98 [13.296640] Hardware name: Renesas RZ/V2H EVK Board based on r9a09g057h44 (DT) [13.303834] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) [13.310770] pc : usbhs_bset+0x14/0x4c [renesas_usbhs] [13.315831] lr : usbhs_probe+0x2e4/0x5ac [renesas_usbhs] [13.321138] sp : ffff8000827e3850 [13.324438] x29: ffff8000827e3860 x28: 0000000000000000 x27: ffff8000827e3ca0 [13.331554] x26: ffff8000827e3ba0 x25: ffff800081729668 x24: 0000000000000025 [13.338670] x23: ffff0000c0f08000 x22: 0000000000000000 x21: ffff0000c0f08010 [13.345783] x20: 0000000000000000 x19: ffff0000c3b52080 x18: 00000000ffffffff [13.352895] x17: 0000000000000000 x16: 0000000000000000 x15: ffff8000827e36ce [13.360009] x14: 00000000000003d7 x13: 00000000000003d7 x12: 0000000000000000 [13.367122] x11: 0000000000000000 x10: 0000000000000aa0 x9 : ffff8000827e3750 [13.374235] x8 : ffff0000c1850b00 x7 : 0000000003826060 x6 : 000000000000001c [13.381347] x5 : 000000030d5fcc00 x4 : ffff8000825c0000 x3 : 0000000000000000 [13.388459] x2 : 0000000000000400 x1 : 0000000000000000 x0 : ffff0000c3b52080 [13.395574] Call trace: [13.398013] usbhs_bset+0x14/0x4c [renesas_usbhs] (P) [13.403076] platform_probe+0x68/0xdc [13.406738] really_probe+0xbc/0x2c0 [13.410306] __driver_probe_device+0x78/0x120 [13.414653] driver_probe_device+0x3c/0x154 [13.418825] __driver_attach+0x90/0x1a0 [13.422647] bus_for_each_dev+0x7c/0xe0 [13.426470] driver_attach+0x24/0x30 [13.430032] bus_add_driver+0xe4/0x208 [13.433766] driver_register+0x68/0x130 [13.437587] __platform_driver_register+0x24/0x30 [13.442273] renesas_usbhs_driver_init+0x20/0x1000 [renesas_usbhs] [13.448450] do_one_initcall+0x60/0x1d4 [13.452276] do_init_module+0x54/0x1f8 [13.456014] load_module+0x1754/0x1c98 [13.459750] init_module_from_file+0x88/0xcc [13.464004] __arm64_sys_finit_module+0x1c4/0x328 [13.468689] invoke_syscall+0x48/0x104 [13.472426] el0_svc_common.constprop.0+0xc0/0xe0 [13.477113] do_el0_svc+0x1c/0x28 [13.480415] el0_svc+0x30/0xcc [13.483460] el0t_64_sync_handler+0x10c/0x138 [13.487800] el0t_64_sync+0x198/0x19c [13.491453] Code: 2a0103e1 12003c42 12003c63 8b010084 (79400084) [13.497522] ---[ end trace 0000000000000000 ]---",,"[{""url"":""https://git.kernel.org/stable/c/095cc0b5888acc228f12344e85b17539b9ce9367"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0a1e16a6cbf4452b46f20b862d6141a1e90844ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/155453ada562c450a4ff5fcf4852b9fa5b6b793a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1637623ad6205162b17804d07512e6f4cbd2a050"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6bab152e817fd41b9e178fa6b275354795c9703d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d4c368e4a638ddf4a9d6d687b0ff691aa46cce53"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/db96a4fd8614d47c0def265e0e6c996b0ee52a38"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ffb34a60ce86656ba12d46e91f1ccc71dd221251"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38137,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:28.240,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: PCI/pwrctrl: Cancel outstanding rescan work when unregistering It's possible to trigger use-after-free here by: (a) forcing rescan_work_func() to take a long time and (b) utilizing a pwrctrl driver that may be unloaded for some reason Cancel outstanding work to ensure it is finished before we allow our data structures to be cleaned up. [bhelgaas: tidy commit log]",,"[{""url"":""https://git.kernel.org/stable/c/8b926f237743f020518162c62b93cb7107a2b5eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3ad6d23fec23fbef382ce9ea640c37446593cf5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38138,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:28.360,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dmaengine: ti: Add NULL check in udma_probe() devm_kasprintf() returns NULL when memory allocation fails. Currently, udma_probe() does not check for this case, which results in a NULL pointer dereference. Add NULL check after devm_kasprintf() to prevent this issue.",,"[{""url"":""https://git.kernel.org/stable/c/643db430f4cbd91dd2b63c49d62d0abb6debc13b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9f133e04c62246353b8b1f0a679535c65161ebcf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b79e10050d9d1e200541d25751dd5cb8ec58483c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bc6ddff79835f71310a21645d8fcf08ec473e969"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d61d5ba5bd5b0e39e30b34dcd92946e084bca0d0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec1ea394c40523835bbedd8fc4934b77b461b6fe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd447415e74bccd7362f760d4ea727f8e1ebfe91"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38139,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:28.500,2025-07-10T15:15:26.740,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfs: Fix oops in write-retry from mis-resetting the subreq iterator Fix the resetting of the subrequest iterator in netfs_retry_write_stream() to use the iterator-reset function as the iterator may have been shortened by a previous retry. In such a case, the amount of data to be written by the subrequest is not ""subreq->len"" but ""subreq->len - subreq->transferred"". Without this, KASAN may see an error in iov_iter_revert(): BUG: KASAN: slab-out-of-bounds in iov_iter_revert lib/iov_iter.c:633 [inline] BUG: KASAN: slab-out-of-bounds in iov_iter_revert+0x443/0x5a0 lib/iov_iter.c:611 Read of size 4 at addr ffff88802912a0b8 by task kworker/u32:7/1147 CPU: 1 UID: 0 PID: 1147 Comm: kworker/u32:7 Not tainted 6.15.0-rc6-syzkaller-00052-g9f35e33144ae #0 PREEMPT(full) Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 Workqueue: events_unbound netfs_write_collection_worker Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:408 [inline] print_report+0xc3/0x670 mm/kasan/report.c:521 kasan_report+0xe0/0x110 mm/kasan/report.c:634 iov_iter_revert lib/iov_iter.c:633 [inline] iov_iter_revert+0x443/0x5a0 lib/iov_iter.c:611 netfs_retry_write_stream fs/netfs/write_retry.c:44 [inline] netfs_retry_writes+0x166d/0x1a50 fs/netfs/write_retry.c:231 netfs_collect_write_results fs/netfs/write_collect.c:352 [inline] netfs_write_collection_worker+0x23fd/0x3830 fs/netfs/write_collect.c:374 process_one_work+0x9cf/0x1b70 kernel/workqueue.c:3238 process_scheduled_works kernel/workqueue.c:3319 [inline] worker_thread+0x6c8/0xf10 kernel/workqueue.c:3400 kthread+0x3c2/0x780 kernel/kthread.c:464 ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:153 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:245 </TASK>",,"[{""url"":""https://git.kernel.org/stable/c/4481f7f2b3df123ec77e828c849138f75cff2bf2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd0edaf99a920b1a9decd773179caacacb61d0fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0fefe9bc07e6101fdc57abda3644f296c114e31"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38140,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:28.617,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dm: limit swapping tables for devices with zone write plugs dm_revalidate_zones() only allowed new or previously unzoned devices to call blk_revalidate_disk_zones(). If the device was already zoned, disk->nr_zones would always equal md->nr_zones, so dm_revalidate_zones() returned without doing any work. This would make the zoned settings for the device not match the new table. If the device had zone write plug resources, it could run into errors like bdev_zone_is_seq() reading invalid memory because disk->conv_zones_bitmap was the wrong size. If the device doesn't have any zone write plug resources, calling blk_revalidate_disk_zones() will always correctly update device. If blk_revalidate_disk_zones() fails, it can still overwrite or clear the current disk->nr_zones value. In this case, DM must restore the previous value of disk->nr_zones, so that the zoned settings will continue to match the previous value that it fell back to. If the device already has zone write plug resources, blk_revalidate_disk_zones() will not correctly update them, if it is called for arbitrary zoned device changes. Since there is not much need for this ability, the easiest solution is to disallow any table reloads that change the zoned settings, for devices that already have zone plug resources. Specifically, if a device already has zone plug resources allocated, it can only switch to another zoned table that also emulates zone append. Also, it cannot change the device size or the zone size. A device can switch to an error target.",,"[{""url"":""https://git.kernel.org/stable/c/121218bef4c1df165181f5cd8fc3a2246bac817e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac8acb0bfd98a1c65f3ca9a3e217a766124eebd8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38141,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:28.740,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dm: fix dm_blk_report_zones If dm_get_live_table() returned NULL, dm_put_live_table() was never called. Also, it is possible that md->zone_revalidate_map will change while calling this function. Only read it once, so that we are always using the same value. Otherwise we might miss a call to dm_put_live_table(). Finally, while md->zone_revalidate_map is set and a process is calling blk_revalidate_disk_zones() to set up the zone append emulation resources, it is possible that another process, perhaps triggered by blkdev_report_zones_ioctl(), will call dm_blk_report_zones(). If blk_revalidate_disk_zones() fails, these resources can be freed while the other process is still using them, causing a use-after-free error. blk_revalidate_disk_zones() will only ever be called when initially setting up the zone append emulation resources, such as when setting up a zoned dm-crypt table for the first time. Further table swaps will not set md->zone_revalidate_map or call blk_revalidate_disk_zones(). However it must be called using the new table (referenced by md->zone_revalidate_map) and the new queue limits while the DM device is suspended. dm_blk_report_zones() needs some way to distinguish between a call from blk_revalidate_disk_zones(), which must be allowed to use md->zone_revalidate_map to access this not yet activated table, and all other calls to dm_blk_report_zones(), which should not be allowed while the device is suspended and cannot use md->zone_revalidate_map, since the zone resources might be freed by the process currently calling blk_revalidate_disk_zones(). Solve this by tracking the process that sets md->zone_revalidate_map in dm_revalidate_zones() and only allowing that process to make use of it in dm_blk_report_zones().",,"[{""url"":""https://git.kernel.org/stable/c/37f53a2c60d03743e0eacf7a0c01c279776fef4e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d19bc1b4dd5f322980b1f05f79b2ea4f0db10920"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f9c1bdf24615303d48a2d0fd629c88f3189563aa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38142,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:28.883,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: hwmon: (asus-ec-sensors) check sensor index in read_string() Prevent a potential invalid memory access when the requested sensor is not found. find_ec_sensor_index() may return a negative value (e.g. -ENOENT), but its result was used without checking, which could lead to undefined behavior when passed to get_sensor_info(). Add a proper check to return -EINVAL if sensor_index is negative. Found by Linux Verification Center (linuxtesting.org) with SVACE. [groeck: Return error code returned from find_ec_sensor_index]",,"[{""url"":""https://git.kernel.org/stable/c/19bd9cde38dd4ca1771aed7afba623e7f4247c8e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/25be318324563c63cbd9cb53186203a08d2f83a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4e9e45746b861ebd54c03ef301da2cb8fc990536"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6bf529ce84dccc0074dbc704e70aee4aa545057e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7eeb3df6f07a886bdfd52757ede127a59a8784dc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38143,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:29.017,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: backlight: pm8941: Add NULL check in wled_configure() devm_kasprintf() returns NULL when memory allocation fails. Currently, wled_configure() does not check for this case, which results in a NULL pointer dereference. Add NULL check after devm_kasprintf() to prevent this issue.",,"[{""url"":""https://git.kernel.org/stable/c/1be2000b703b02e149f8f2061054489f6c18c972"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/21528806560510458378ea52c37e35b0773afaea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4a715be3fe80b68fa55cb3569af3d294be101626"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6a56446595730a5e3f06a30902e23cb037d28146"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d06ac32c202142da40904180f2669ed4f5073ac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e12d3e1624a02706cdd3628bbf5668827214fa33"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fde314445332015273c8f51d2659885c606fe135"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38144,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:29.150,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: watchdog: lenovo_se30_wdt: Fix possible devm_ioremap() NULL pointer dereference in lenovo_se30_wdt_probe() devm_ioremap() returns NULL on error. Currently, lenovo_se30_wdt_probe() does not check for this case, which results in a NULL pointer dereference. Add NULL check after devm_ioremap() to prevent this issue.",,"[{""url"":""https://git.kernel.org/stable/c/57f7a1da0ec06d8579accaf77762d0128d13e4af"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a4e2401438a26131ecff9be6a3a1d4cbfea66f9a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38145,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:29.273,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: soc: aspeed: Add NULL check in aspeed_lpc_enable_snoop() devm_kasprintf() returns NULL when memory allocation fails. Currently, aspeed_lpc_enable_snoop() does not check for this case, which results in a NULL pointer dereference. Add NULL check after devm_kasprintf() to prevent this issue. [arj: Fix Fixes: tag to use subject from 3772e5da4454]",,"[{""url"":""https://git.kernel.org/stable/c/1fd889c145722579aa038c31cbc07cfdd4d75166"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2beee9cf833374550e673d428ad8b6ab37c175b3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/45b2e8b0fdd280aba04c3cc869e9ae500c44e4b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8312b1f776f71979bf33bda7acc05b348e8792c7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c550999f939b529d28a914d5034cc4290066aea6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d62a589eaaec6385e3e2b25cf5a28b4560ace93f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1706e0e1a74b095cbc60375b9b1e6205f5f4c98"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f697ef117ecbf3a367dfc559a6a3589905956530"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38146,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:29.410,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: openvswitch: Fix the dead loop of MPLS parse The unexpected MPLS packet may not end with the bottom label stack. When there are many stacks, The label count value has wrapped around. A dead loop occurs, soft lockup/CPU stuck finally. stack backtrace: UBSAN: array-index-out-of-bounds in /build/linux-0Pa0xK/linux-5.15.0/net/openvswitch/flow.c:662:26 index -1 is out of range for type '__be32 [3]' CPU: 34 PID: 0 Comm: swapper/34 Kdump: loaded Tainted: G OE 5.15.0-121-generic #131-Ubuntu Hardware name: Dell Inc. PowerEdge C6420/0JP9TF, BIOS 2.12.2 07/14/2021 Call Trace: <IRQ> show_stack+0x52/0x5c dump_stack_lvl+0x4a/0x63 dump_stack+0x10/0x16 ubsan_epilogue+0x9/0x36 __ubsan_handle_out_of_bounds.cold+0x44/0x49 key_extract_l3l4+0x82a/0x840 [openvswitch] ? kfree_skbmem+0x52/0xa0 key_extract+0x9c/0x2b0 [openvswitch] ovs_flow_key_extract+0x124/0x350 [openvswitch] ovs_vport_receive+0x61/0xd0 [openvswitch] ? kernel_init_free_pages.part.0+0x4a/0x70 ? get_page_from_freelist+0x353/0x540 netdev_port_receive+0xc4/0x180 [openvswitch] ? netdev_port_receive+0x180/0x180 [openvswitch] netdev_frame_hook+0x1f/0x40 [openvswitch] __netif_receive_skb_core.constprop.0+0x23a/0xf00 __netif_receive_skb_list_core+0xfa/0x240 netif_receive_skb_list_internal+0x18e/0x2a0 napi_complete_done+0x7a/0x1c0 bnxt_poll+0x155/0x1c0 [bnxt_en] __napi_poll+0x30/0x180 net_rx_action+0x126/0x280 ? bnxt_msix+0x67/0x80 [bnxt_en] handle_softirqs+0xda/0x2d0 irq_exit_rcu+0x96/0xc0 common_interrupt+0x8e/0xa0 </IRQ>",,"[{""url"":""https://git.kernel.org/stable/c/0bdc924bfb319fb10d1113cbf091fc26fb7b1f99"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3c1906a3d50cb94fd0a10e97a1c0a40c0f033cb7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4b9a086eedc1fddae632310386098c12155e3d0a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/69541e58323ec3e3904e1fa87a6213961b1f52f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ebcd311b4866ab911d1445ead08690e67f0c488"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad17eb86d042d72a59fd184ad1adf34f5eb36843"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f26fe7c3002516dd3c288f1012786df31f4d89e0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38147,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:29.557,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: calipso: Don't call calipso functions for AF_INET sk. syzkaller reported a null-ptr-deref in txopt_get(). [0] The offset 0x70 was of struct ipv6_txoptions in struct ipv6_pinfo, so struct ipv6_pinfo was NULL there. However, this never happens for IPv6 sockets as inet_sk(sk)->pinet6 is always set in inet6_create(), meaning the socket was not IPv6 one. The root cause is missing validation in netlbl_conn_setattr(). netlbl_conn_setattr() switches branches based on struct sockaddr.sa_family, which is passed from userspace. However, netlbl_conn_setattr() does not check if the address family matches the socket. The syzkaller must have called connect() for an IPv6 address on an IPv4 socket. We have a proper validation in tcp_v[46]_connect(), but security_socket_connect() is called in the earlier stage. Let's copy the validation to netlbl_conn_setattr(). [0]: Oops: general protection fault, probably for non-canonical address 0xdffffc000000000e: 0000 [#1] PREEMPT SMP KASAN NOPTI KASAN: null-ptr-deref in range [0x0000000000000070-0x0000000000000077] CPU: 2 UID: 0 PID: 12928 Comm: syz.9.1677 Not tainted 6.12.0 #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 RIP: 0010:txopt_get include/net/ipv6.h:390 [inline] RIP: 0010: Code: 02 00 00 49 8b ac 24 f8 02 00 00 e8 84 69 2a fd e8 ff 00 16 fd 48 8d 7d 70 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 <80> 3c 02 00 0f 85 53 02 00 00 48 8b 6d 70 48 85 ed 0f 84 ab 01 00 RSP: 0018:ffff88811b8afc48 EFLAGS: 00010212 RAX: dffffc0000000000 RBX: 1ffff11023715f8a RCX: ffffffff841ab00c RDX: 000000000000000e RSI: ffffc90007d9e000 RDI: 0000000000000070 RBP: 0000000000000000 R08: ffffed1023715f9d R09: ffffed1023715f9e R10: ffffed1023715f9d R11: 0000000000000003 R12: ffff888123075f00 R13: ffff88810245bd80 R14: ffff888113646780 R15: ffff888100578a80 FS: 00007f9019bd7640(0000) GS:ffff8882d2d00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f901b927bac CR3: 0000000104788003 CR4: 0000000000770ef0 PKRU: 80000000 Call Trace: <TASK> calipso_sock_setattr+0x56/0x80 net/netlabel/netlabel_calipso.c:557 netlbl_conn_setattr+0x10c/0x280 net/netlabel/netlabel_kapi.c:1177 selinux_netlbl_socket_connect_helper+0xd3/0x1b0 security/selinux/netlabel.c:569 selinux_netlbl_socket_connect_locked security/selinux/netlabel.c:597 [inline] selinux_netlbl_socket_connect+0xb6/0x100 security/selinux/netlabel.c:615 selinux_socket_connect+0x5f/0x80 security/selinux/hooks.c:4931 security_socket_connect+0x50/0xa0 security/security.c:4598 __sys_connect_file+0xa4/0x190 net/socket.c:2067 __sys_connect+0x12c/0x170 net/socket.c:2088 __do_sys_connect net/socket.c:2098 [inline] __se_sys_connect net/socket.c:2095 [inline] __x64_sys_connect+0x73/0xb0 net/socket.c:2095 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xaa/0x1b0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7f901b61a12d Code: 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007f9019bd6fa8 EFLAGS: 00000246 ORIG_RAX: 000000000000002a RAX: ffffffffffffffda RBX: 00007f901b925fa0 RCX: 00007f901b61a12d RDX: 000000000000001c RSI: 0000200000000140 RDI: 0000000000000003 RBP: 00007f901b701505 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 0000000000000000 R14: 00007f901b5b62a0 R15: 00007f9019bb7000 </TASK> Modules linked in:",,"[{""url"":""https://git.kernel.org/stable/c/0c813dbc851dbf418fdc6dc883fd0592d6c555cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/26ce90f1ce60b0ff587de8d6aec399aa55cab28e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6e9f2df1c550ead7cecb3e450af1105735020c92"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/946bfdfcb76ac2bac5b8526447035885ff41c598"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c32ebe33626335a536dbbdd09571c06dd9bc1729"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dd8928897594931d6912ef2f7a43e110b4958d3d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e2ec310c7a50271843c585e27ef14e48c66ce649"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc2da88411470480b8b7e9177e930cedd893cf56"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38148,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:29.703,2025-09-09T17:15:44.393,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: phy: mscc: Fix memory leak when using one step timestamping Fix memory leak when running one-step timestamping. When running one-step sync timestamping, the HW is configured to insert the TX time into the frame, so there is no reason to keep the skb anymore. As in this case the HW will never generate an interrupt to say that the frame was timestamped, then the frame will never released. Fix this by freeing the frame in case of one-step timestamping.",,"[{""url"":""https://git.kernel.org/stable/c/0b40aeaf83ca04d4c9801e235b7533400c8b5f17"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/24b24295464f25fb771d36ed558c7cd942119361"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/66abe22017522dd56b820e41ca3a5b131a637001"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/846992645b25ec4253167e3f931e4597eb84af56"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cdbabd316c5a4a9b0fda6aafe491e2db17fbb95d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/db2a12ddd3a31f668137ff6a4befc1343c79cbc4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38149,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:29.830,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: phy: clear phydev->devlink when the link is deleted There is a potential crash issue when disabling and re-enabling the network port. When disabling the network port, phy_detach() calls device_link_del() to remove the device link, but it does not clear phydev->devlink, so phydev->devlink is not a NULL pointer. Then the network port is re-enabled, but if phy_attach_direct() fails before calling device_link_add(), the code jumps to the ""error"" label and calls phy_detach(). Since phydev->devlink retains the old value from the previous attach/detach cycle, device_link_del() uses the old value, which accesses a NULL pointer and causes a crash. The simplified crash log is as follows. [ 24.702421] Call trace: [ 24.704856] device_link_put_kref+0x20/0x120 [ 24.709124] device_link_del+0x30/0x48 [ 24.712864] phy_detach+0x24/0x168 [ 24.716261] phy_attach_direct+0x168/0x3a4 [ 24.720352] phylink_fwnode_phy_connect+0xc8/0x14c [ 24.725140] phylink_of_phy_connect+0x1c/0x34 Therefore, phydev->devlink needs to be cleared when the device link is deleted.",,"[{""url"":""https://git.kernel.org/stable/c/034bc4a2a72dea2cfcaf24c6bae03c38ad5a0b87"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0795b05a59b1371b18ffbf09d385296b12e9f5d5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/363fdf2777423ad346d781f09548cca14877f729"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ddc654e89ace723b78c34911c65243accbc9b75c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38150,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:29.960,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: af_packet: move notifier's packet_dev_mc out of rcu critical section Syzkaller reports the following issue: BUG: sleeping function called from invalid context at kernel/locking/mutex.c:578 __mutex_lock+0x106/0xe80 kernel/locking/mutex.c:746 team_change_rx_flags+0x38/0x220 drivers/net/team/team_core.c:1781 dev_change_rx_flags net/core/dev.c:9145 [inline] __dev_set_promiscuity+0x3f8/0x590 net/core/dev.c:9189 netif_set_promiscuity+0x50/0xe0 net/core/dev.c:9201 dev_set_promiscuity+0x126/0x260 net/core/dev_api.c:286 packet_dev_mc net/packet/af_packet.c:3698 [inline] packet_dev_mclist_delete net/packet/af_packet.c:3722 [inline] packet_notifier+0x292/0xa60 net/packet/af_packet.c:4247 notifier_call_chain+0x1b3/0x3e0 kernel/notifier.c:85 call_netdevice_notifiers_extack net/core/dev.c:2214 [inline] call_netdevice_notifiers net/core/dev.c:2228 [inline] unregister_netdevice_many_notify+0x15d8/0x2330 net/core/dev.c:11972 rtnl_delete_link net/core/rtnetlink.c:3522 [inline] rtnl_dellink+0x488/0x710 net/core/rtnetlink.c:3564 rtnetlink_rcv_msg+0x7cf/0xb70 net/core/rtnetlink.c:6955 netlink_rcv_skb+0x219/0x490 net/netlink/af_netlink.c:2534 Calling `PACKET_ADD_MEMBERSHIP` on an ops-locked device can trigger the `NETDEV_UNREGISTER` notifier, which may require disabling promiscuous and/or allmulti mode. Both of these operations require acquiring the netdev instance lock. Move the call to `packet_dev_mc` outside of the RCU critical section. The `mclist` modifications (add, del, flush, unregister) are protected by the RTNL, not the RCU. The RCU only protects the `sklist` and its associated `sks`. The delayed operation on the `mclist` entry remains within the RTNL.",,"[{""url"":""https://git.kernel.org/stable/c/2dd4781c5af99415ebbd2f7cc763feb109863c05"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d8d85ef0a631df9127f202e6371bb33a0b589952"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38151,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:30.093,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/cma: Fix hang when cma_netevent_callback fails to queue_work The cited commit fixed a crash when cma_netevent_callback was called for a cma_id while work on that id from a previous call had not yet started. The work item was re-initialized in the second call, which corrupted the work item currently in the work queue. However, it left a problem when queue_work fails (because the item is still pending in the work queue from a previous call). In this case, cma_id_put (which is called in the work handler) is therefore not called. This results in a userspace process hang (zombie process). Fix this by calling cma_id_put() if queue_work fails.",,"[{""url"":""https://git.kernel.org/stable/c/02e45168e0fd6fdc6f8f7c42c4b500857aa5efb0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1ac40736c8c4255d8417b937c9715b193f4a87b3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8b05aa3692e45b8249379dc52b14acc6a104d2e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/92a251c3df8ea1991cd9fe00f1ab0cfce18d7711"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac7897c0124066b9705ffca252a3662d54fc0c9b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38152,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-04-18T07:15:43.403,2025-04-29T14:39:46.800,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: remoteproc: core: Clear table_sz when rproc_shutdown There is case as below could trigger kernel dump: Use U-Boot to start remote processor(rproc) with resource table published to a fixed address by rproc. After Kernel boots up, stop the rproc, load a new firmware which doesn't have resource table ,and start rproc. When starting rproc with a firmware not have resource table, `memcpy(loaded_table, rproc->cached_table, rproc->table_sz)` will trigger dump, because rproc->cache_table is set to NULL during the last stop operation, but rproc->table_sz is still valid. This issue is found on i.MX8MP and i.MX9. Dump as below: Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000 Mem abort info: ESR = 0x0000000096000004 EC = 0x25: DABT (current EL), IL = 32 bits SET = 0, FnV = 0 EA = 0, S1PTW = 0 FSC = 0x04: level 0 translation fault Data abort info: ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000 CM = 0, WnR = 0, TnD = 0, TagAccess = 0 GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 user pgtable: 4k pages, 48-bit VAs, pgdp=000000010af63000 [0000000000000000] pgd=0000000000000000, p4d=0000000000000000 Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP Modules linked in: CPU: 2 UID: 0 PID: 1060 Comm: sh Not tainted 6.14.0-rc7-next-20250317-dirty #38 Hardware name: NXP i.MX8MPlus EVK board (DT) pstate: a0000005 (NzCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : __pi_memcpy_generic+0x110/0x22c lr : rproc_start+0x88/0x1e0 Call trace: __pi_memcpy_generic+0x110/0x22c (P) rproc_boot+0x198/0x57c state_store+0x40/0x104 dev_attr_store+0x18/0x2c sysfs_kf_write+0x7c/0x94 kernfs_fop_write_iter+0x120/0x1cc vfs_write+0x240/0x378 ksys_write+0x70/0x108 __arm64_sys_write+0x1c/0x28 invoke_syscall+0x48/0x10c el0_svc_common.constprop.0+0xc0/0xe0 do_el0_svc+0x1c/0x28 el0_svc+0x30/0xcc el0t_64_sync_handler+0x10c/0x138 el0t_64_sync+0x198/0x19c Clear rproc->table_sz to address the issue.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-476""}]}]","[{""url"":""https://git.kernel.org/stable/c/068f6648ff5b0c7adeb6c363fae7fb188aa178fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/2df19f5f6f72da6f6ebab7cdb3a3b9f7686bb476"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/6e66bca8cd51ebedd5d32426906a38e4a3c69c5f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/7c6bb82a6f3da6ab2d3fbea03901482231708b98"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/8e0fd2a3b9852ac3cf540edb06ccc0153b38b5af"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/e6015ca453b82ec54aec9682dcc38773948fcc48"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/efdde3d73ab25cef4ff2d06783b0aad8b093c0e4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.13"",""versionEndExcluding"":""5.15.180"",""matchCriteriaId"":""95F4A2AB-C94B-4AE3-A40B-F806EE4B8398""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.134"",""matchCriteriaId"":""3985DEC3-0437-4177-BC42-314AB575285A""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.2"",""versionEndExcluding"":""6.6.87"",""matchCriteriaId"":""EFF24260-49B1-4251-9477-C564CFDAD25B""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.7"",""versionEndExcluding"":""6.12.23"",""matchCriteriaId"":""26CAB76D-F00F-43CE-BEAD-7097F8FB1D6C""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.13"",""versionEndExcluding"":""6.13.11"",""matchCriteriaId"":""E7E864B0-8C00-4679-BA55-659B4C9C3AD3""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.14"",""versionEndExcluding"":""6.14.2"",""matchCriteriaId"":""FADAE5D8-4808-442C-B218-77B2CE8780A0""}]}]}]",,,,,,,,
CVE-2025-38153,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:30.230,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: usb: aqc111: fix error handling of usbnet read calls Syzkaller, courtesy of syzbot, identified an error (see report [1]) in aqc111 driver, caused by incomplete sanitation of usb read calls' results. This problem is quite similar to the one fixed in commit 920a9fa27e78 (""net: asix: add proper error handling of usb read errors""). For instance, usbnet_read_cmd() may read fewer than 'size' bytes, even if the caller expected the full amount, and aqc111_read_cmd() will not check its result properly. As [1] shows, this may lead to MAC address in aqc111_bind() being only partly initialized, triggering KMSAN warnings. Fix the issue by verifying that the number of bytes read is as expected and not less. [1] Partial syzbot report: BUG: KMSAN: uninit-value in is_valid_ether_addr include/linux/etherdevice.h:208 [inline] BUG: KMSAN: uninit-value in usbnet_probe+0x2e57/0x4390 drivers/net/usb/usbnet.c:1830 is_valid_ether_addr include/linux/etherdevice.h:208 [inline] usbnet_probe+0x2e57/0x4390 drivers/net/usb/usbnet.c:1830 usb_probe_interface+0xd01/0x1310 drivers/usb/core/driver.c:396 call_driver_probe drivers/base/dd.c:-1 [inline] really_probe+0x4d1/0xd90 drivers/base/dd.c:658 __driver_probe_device+0x268/0x380 drivers/base/dd.c:800 ... Uninit was stored to memory at: dev_addr_mod+0xb0/0x550 net/core/dev_addr_lists.c:582 __dev_addr_set include/linux/netdevice.h:4874 [inline] eth_hw_addr_set include/linux/etherdevice.h:325 [inline] aqc111_bind+0x35f/0x1150 drivers/net/usb/aqc111.c:717 usbnet_probe+0xbe6/0x4390 drivers/net/usb/usbnet.c:1772 usb_probe_interface+0xd01/0x1310 drivers/usb/core/driver.c:396 ... Uninit was stored to memory at: ether_addr_copy include/linux/etherdevice.h:305 [inline] aqc111_read_perm_mac drivers/net/usb/aqc111.c:663 [inline] aqc111_bind+0x794/0x1150 drivers/net/usb/aqc111.c:713 usbnet_probe+0xbe6/0x4390 drivers/net/usb/usbnet.c:1772 usb_probe_interface+0xd01/0x1310 drivers/usb/core/driver.c:396 call_driver_probe drivers/base/dd.c:-1 [inline] ... Local variable buf.i created at: aqc111_read_perm_mac drivers/net/usb/aqc111.c:656 [inline] aqc111_bind+0x221/0x1150 drivers/net/usb/aqc111.c:713 usbnet_probe+0xbe6/0x4390 drivers/net/usb/usbnet.c:1772",,"[{""url"":""https://git.kernel.org/stable/c/11273279012c922f37cfb4dd95d142803fc07b98"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/30a9e834c74e260533b8d0885e3c89f6f32f7993"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/405b0d610745fb5e84fc2961d9b960abb9f3d107"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/60790d287c1a1ced3554d4a87c2f27bf299a932a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c01863b1c47f040d9674171e77789a423b9b128"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c97655275482ef5384ce0501640630a0fc0f6f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/acb47a40b5e38be03ef659b7bacdddc592ed73b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f398d2dfe450ce2c031d10b585448862d74a0501"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38154,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:30.363,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf, sockmap: Avoid using sk_socket after free when sending The sk->sk_socket is not locked or referenced in backlog thread, and during the call to skb_send_sock(), there is a race condition with the release of sk_socket. All types of sockets(tcp/udp/unix/vsock) will be affected. Race conditions: ''' CPU0 CPU1 backlog::skb_send_sock sendmsg_unlocked sock_sendmsg sock_sendmsg_nosec close(fd): ... ops->release() -> sock_map_close() sk_socket->ops = NULL free(socket) sock->ops->sendmsg ^ panic here ''' The ref of psock become 0 after sock_map_close() executed. ''' void sock_map_close() { ... if (likely(psock)) { ... // !! here we remove psock and the ref of psock become 0 sock_map_remove_links(sk, psock) psock = sk_psock_get(sk); if (unlikely(!psock)) goto no_psock; <=== Control jumps here via goto ... cancel_delayed_work_sync(&psock->work); <=== not executed sk_psock_put(sk, psock); ... } ''' Based on the fact that we already wait for the workqueue to finish in sock_map_close() if psock is held, we simply increase the psock reference count to avoid race conditions. With this patch, if the backlog thread is running, sock_map_close() will wait for the backlog thread to complete and cancel all pending work. If no backlog running, any pending work that hasn't started by then will fail when invoked by sk_psock_get(), as the psock reference count have been zeroed, and sk_psock_drop() will cancel all jobs via cancel_delayed_work_sync(). In summary, we require synchronization to coordinate the backlog thread and close() thread. The panic I catched: ''' Workqueue: events sk_psock_backlog RIP: 0010:sock_sendmsg+0x21d/0x440 RAX: 0000000000000000 RBX: ffffc9000521fad8 RCX: 0000000000000001 ... Call Trace: <TASK> ? die_addr+0x40/0xa0 ? exc_general_protection+0x14c/0x230 ? asm_exc_general_protection+0x26/0x30 ? sock_sendmsg+0x21d/0x440 ? sock_sendmsg+0x3e0/0x440 ? __pfx_sock_sendmsg+0x10/0x10 __skb_send_sock+0x543/0xb70 sk_psock_backlog+0x247/0xb80 ... '''",,"[{""url"":""https://git.kernel.org/stable/c/15c0250dae3b48a398447d2b364603821ed4ed90"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c6fa65ab2aec7df94809478c8d28ef38676a1b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4edb40b05cb6a261775abfd8046804ca139a5546"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c0a16f6ea2b1c82a03bccd5d1bdb4a7bbd4d987"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8259eb0e06d8f64c700f5fbdb28a5c18e10de291"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b19cbf0b9a91f5a0d93fbcd761ff71c48ab40ed9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38155,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:30.497,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: mt7915: Fix null-ptr-deref in mt7915_mmio_wed_init() devm_ioremap() returns NULL on error. Currently, mt7915_mmio_wed_init() does not check for this case, which results in a NULL pointer dereference. Prevent null pointer dereference in mt7915_mmio_wed_init().",,"[{""url"":""https://git.kernel.org/stable/c/790d05cde359356feea8915094a51166af1629f5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d825ed9fd768be10d52beba6f57a4b50c0c154aa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e9f9cef1877ac32285dbc1f31b86c8955b712fc2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/efb95439c1477bbc955cacd0179c35e7861b437c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38156,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:30.620,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: mt7996: Fix null-ptr-deref in mt7996_mmio_wed_init() devm_ioremap() returns NULL on error. Currently, mt7996_mmio_wed_init() does not check for this case, which results in a NULL pointer dereference. Prevent null pointer dereference in mt7996_mmio_wed_init()",,"[{""url"":""https://git.kernel.org/stable/c/1072fc0ca1f8d0d5397d24853386876f937b8e63"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8f30e2b059757d8711a823e4c9c023db62a1d171"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/af861c6dea2ef06845a5c7672999a06c06099735"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38157,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:30.757,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath9k_htc: Abort software beacon handling if disabled A malicious USB device can send a WMI_SWBA_EVENTID event from an ath9k_htc-managed device before beaconing has been enabled. This causes a device-by-zero error in the driver, leading to either a crash or an out of bounds read. Prevent this by aborting the handling in ath9k_htc_swba() if beacons are not enabled.",,"[{""url"":""https://git.kernel.org/stable/c/0281c19074976ec48f0078d50530b406ddae75bc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/40471b23147c86ea3ed97faee79937c618250bd0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5482ef9875eaa43f0435e14570e1193823de857e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a85c21f812e02cb00ca07007d88acdd42d08c46"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ee3fb6258da8c890a51b514f60d7570dc703605"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac4e317a95a1092b5da5b9918b7118759342641c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e5ce9df1d68094d37360dbd9b09289d42fa21e54"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee5ee646385f5846dcbc881389f3c44a197c402a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38158,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:30.890,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: hisi_acc_vfio_pci: fix XQE dma address error The dma addresses of EQE and AEQE are wrong after migration and results in guest kernel-mode encryption services failure. Comparing the definition of hardware registers, we found that there was an error when the data read from the register was combined into an address. Therefore, the address combination sequence needs to be corrected. Even after fixing the above problem, we still have an issue where the Guest from an old kernel can get migrated to new kernel and may result in wrong data. In order to ensure that the address is correct after migration, if an old magic number is detected, the dma address needs to be updated.",,"[{""url"":""https://git.kernel.org/stable/c/7710c883eb8cb5cf510ca47ec0e26c6cb7e94a4f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/809a9c10274e1bcf6d05f1c0341459a425a4f05f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/884a76e813178778d271fea59783763d32bb7e72"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8bb7170c5a055ea17c6857c256ee73c10ff872eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f0423873e7aeb69cb68f4e8fa3827832e7b037ba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38159,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:31.163,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: rtw88: fix the 'para' buffer size to avoid reading out of bounds Set the size to 6 instead of 2, since 'para' array is passed to 'rtw_fw_bt_wifi_control(rtwdev, para[0], &para[1])', which reads 5 bytes: void rtw_fw_bt_wifi_control(struct rtw_dev *rtwdev, u8 op_code, u8 *data) { ... SET_BT_WIFI_CONTROL_DATA1(h2c_pkt, *data); SET_BT_WIFI_CONTROL_DATA2(h2c_pkt, *(data + 1)); ... SET_BT_WIFI_CONTROL_DATA5(h2c_pkt, *(data + 4)); Detected using the static analysis tool - Svace.",,"[{""url"":""https://git.kernel.org/stable/c/1ee8ea6937d13b20f90ff35d71ccc03ba448182d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c2c372de2e108319236203cce6de44d70ae15cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/68a1037f0bac4de9a585aa9c879ef886109f3647"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74e18211c2c89ab66c9546baa7408288db61aa0d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9febcc8bded8be0d7efd8237fcef599b6d93b788"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c13255389499275bc5489a0b5b7940ccea3aef04"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38160,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:31.327,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: clk: bcm: rpi: Add NULL check in raspberrypi_clk_register() devm_kasprintf() returns NULL when memory allocation fails. Currently, raspberrypi_clk_register() does not check for this case, which results in a NULL pointer dereference. Add NULL check after devm_kasprintf() to prevent this issue.",,"[{""url"":""https://git.kernel.org/stable/c/0a2712cd24ecfeb520af60f6f859b442c7ab01ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1b69a5299f28ce8e6afa37c3690dbc14c3a1f53f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3c1adc2f8c732ea09e8c4bce5941fec019c6205d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/52562161df3567cdaedada46834a7a8d8c4ab737"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/54ce9bcdaee59d4ef0703f390d55708557818f9e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73c46d9a93d071ca69858dea3f569111b03e549e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/938f625bd3364cfdc93916739add3b637ff90368"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38161,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:31.490,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/mlx5: Fix error flow upon firmware failure for RQ destruction Upon RQ destruction if the firmware command fails which is the last resource to be destroyed some SW resources were already cleaned regardless of the failure. Now properly rollback the object to its original state upon such failure. In order to avoid a use-after free in case someone tries to destroy the object again, which results in the following kernel trace: refcount_t: underflow; use-after-free. WARNING: CPU: 0 PID: 37589 at lib/refcount.c:28 refcount_warn_saturate+0xf4/0x148 Modules linked in: rdma_ucm(OE) rdma_cm(OE) iw_cm(OE) ib_ipoib(OE) ib_cm(OE) ib_umad(OE) mlx5_ib(OE) rfkill mlx5_core(OE) mlxdevm(OE) ib_uverbs(OE) ib_core(OE) psample mlxfw(OE) mlx_compat(OE) macsec tls pci_hyperv_intf sunrpc vfat fat virtio_net net_failover failover fuse loop nfnetlink vsock_loopback vmw_vsock_virtio_transport_common vmw_vsock_vmci_transport vmw_vmci vsock xfs crct10dif_ce ghash_ce sha2_ce sha256_arm64 sha1_ce virtio_console virtio_gpu virtio_blk virtio_dma_buf virtio_mmio dm_mirror dm_region_hash dm_log dm_mod xpmem(OE) CPU: 0 UID: 0 PID: 37589 Comm: python3 Kdump: loaded Tainted: G OE ------- --- 6.12.0-54.el10.aarch64 #1 Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE Hardware name: QEMU KVM Virtual Machine, BIOS 0.0.0 02/06/2015 pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : refcount_warn_saturate+0xf4/0x148 lr : refcount_warn_saturate+0xf4/0x148 sp : ffff80008b81b7e0 x29: ffff80008b81b7e0 x28: ffff000133d51600 x27: 0000000000000001 x26: 0000000000000000 x25: 00000000ffffffea x24: ffff00010ae80f00 x23: ffff00010ae80f80 x22: ffff0000c66e5d08 x21: 0000000000000000 x20: ffff0000c66e0000 x19: ffff00010ae80340 x18: 0000000000000006 x17: 0000000000000000 x16: 0000000000000020 x15: ffff80008b81b37f x14: 0000000000000000 x13: 2e656572662d7265 x12: ffff80008283ef78 x11: ffff80008257efd0 x10: ffff80008283efd0 x9 : ffff80008021ed90 x8 : 0000000000000001 x7 : 00000000000bffe8 x6 : c0000000ffff7fff x5 : ffff0001fb8e3408 x4 : 0000000000000000 x3 : ffff800179993000 x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff000133d51600 Call trace: refcount_warn_saturate+0xf4/0x148 mlx5_core_put_rsc+0x88/0xa0 [mlx5_ib] mlx5_core_destroy_rq_tracked+0x64/0x98 [mlx5_ib] mlx5_ib_destroy_wq+0x34/0x80 [mlx5_ib] ib_destroy_wq_user+0x30/0xc0 [ib_core] uverbs_free_wq+0x28/0x58 [ib_uverbs] destroy_hw_idr_uobject+0x34/0x78 [ib_uverbs] uverbs_destroy_uobject+0x48/0x240 [ib_uverbs] __uverbs_cleanup_ufile+0xd4/0x1a8 [ib_uverbs] uverbs_destroy_ufile_hw+0x48/0x120 [ib_uverbs] ib_uverbs_close+0x2c/0x100 [ib_uverbs] __fput+0xd8/0x2f0 __fput_sync+0x50/0x70 __arm64_sys_close+0x40/0x90 invoke_syscall.constprop.0+0x74/0xd0 do_el0_svc+0x48/0xe8 el0_svc+0x44/0x1d0 el0t_64_sync_handler+0x120/0x130 el0t_64_sync+0x1a4/0x1a8",,"[{""url"":""https://git.kernel.org/stable/c/0a7790cbba654e925243571cf2f24d61603d3ed3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/26d2f662d3a6655a82fd8a287e8b1ce471567f36"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/50ac361ff8914133e3cf6ef184bac90c22cb8d79"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5d2ea5aebbb2f3ebde4403f9c55b2b057e5dd2d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c4c84cdcc19e89d42f6bf117238e5471173423e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cf32affe6f3801cfb72a65e69c4bc7a8ee9be100"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f9784da76ad7be66230e829e743bdf68a2c49e56"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38162,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:31.617,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: nft_set_pipapo: prevent overflow in lookup table allocation When calculating the lookup table size, ensure the following multiplication does not overflow: - desc->field_len[] maximum value is U8_MAX multiplied by NFT_PIPAPO_GROUPS_PER_BYTE(f) that can be 2, worst case. - NFT_PIPAPO_BUCKETS(f->bb) is 2^8, worst case. - sizeof(unsigned long), from sizeof(*f->lt), lt in struct nft_pipapo_field. Then, use check_mul_overflow() to multiply by bucket size and then use check_add_overflow() to the alignment for avx2 (if needed). Finally, add lt_size_check_overflow() helper and use it to consolidate this. While at it, replace leftover allocation using the GFP_KERNEL to GFP_KERNEL_ACCOUNT for consistency, in pipapo_resize().",,"[{""url"":""https://git.kernel.org/stable/c/43fe1181f738295624696ae9ff611790edb65b5e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c5c6aa9967dbe55bd017bb509885928d0f31206"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c1360ac8156c0a3f2385baef91d8d26fd9d39701"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38163,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:31.727,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to do sanity check on sbi->total_valid_block_count syzbot reported a f2fs bug as below: ------------[ cut here ]------------ kernel BUG at fs/f2fs/f2fs.h:2521! RIP: 0010:dec_valid_block_count+0x3b2/0x3c0 fs/f2fs/f2fs.h:2521 Call Trace: f2fs_truncate_data_blocks_range+0xc8c/0x11a0 fs/f2fs/file.c:695 truncate_dnode+0x417/0x740 fs/f2fs/node.c:973 truncate_nodes+0x3ec/0xf50 fs/f2fs/node.c:1014 f2fs_truncate_inode_blocks+0x8e3/0x1370 fs/f2fs/node.c:1197 f2fs_do_truncate_blocks+0x840/0x12b0 fs/f2fs/file.c:810 f2fs_truncate_blocks+0x10d/0x300 fs/f2fs/file.c:838 f2fs_truncate+0x417/0x720 fs/f2fs/file.c:888 f2fs_setattr+0xc4f/0x12f0 fs/f2fs/file.c:1112 notify_change+0xbca/0xe90 fs/attr.c:552 do_truncate+0x222/0x310 fs/open.c:65 handle_truncate fs/namei.c:3466 [inline] do_open fs/namei.c:3849 [inline] path_openat+0x2e4f/0x35d0 fs/namei.c:4004 do_filp_open+0x284/0x4e0 fs/namei.c:4031 do_sys_openat2+0x12b/0x1d0 fs/open.c:1429 do_sys_open fs/open.c:1444 [inline] __do_sys_creat fs/open.c:1522 [inline] __se_sys_creat fs/open.c:1516 [inline] __x64_sys_creat+0x124/0x170 fs/open.c:1516 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/syscall_64.c:94 The reason is: in fuzzed image, sbi->total_valid_block_count is inconsistent w/ mapped blocks indexed by inode, so, we should not trigger panic for such case, instead, let's print log and set fsck flag.",,"[{""url"":""https://git.kernel.org/stable/c/05872a167c2cab80ef186ef23cc34a6776a1a30c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/25f3776b58c1c45ad2e50ab4b263505b4d2378ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/49bc7bf38e42cfa642787e947f5721696ea73ac3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/65b3f76592aed5a43c4d79375ac097acf975972b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6a324d77f7ea1a91d55c4b6ad970e3ac9ab6a20d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a39cc43efc1bca74ed9d6cf9e60b995071f7d178"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ccc28c0397f75a3ec9539cceed9db014d7b73869"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1b743c1955151bd392539b739a3ad155296be13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38164,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:31.863,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: f2fs: zone: fix to avoid inconsistence in between SIT and SSA w/ below testcase, it will cause inconsistence in between SIT and SSA. create_null_blk 512 2 1024 1024 mkfs.f2fs -m /dev/nullb0 mount /dev/nullb0 /mnt/f2fs/ touch /mnt/f2fs/file f2fs_io pinfile set /mnt/f2fs/file fallocate -l 4GiB /mnt/f2fs/file F2FS-fs (nullb0): Inconsistent segment (0) type [1, 0] in SSA and SIT CPU: 5 UID: 0 PID: 2398 Comm: fallocate Tainted: G O 6.13.0-rc1 #84 Tainted: [O]=OOT_MODULE Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006 Call Trace: <TASK> dump_stack_lvl+0xb3/0xd0 dump_stack+0x14/0x20 f2fs_handle_critical_error+0x18c/0x220 [f2fs] f2fs_stop_checkpoint+0x38/0x50 [f2fs] do_garbage_collect+0x674/0x6e0 [f2fs] f2fs_gc_range+0x12b/0x230 [f2fs] f2fs_allocate_pinning_section+0x5c/0x150 [f2fs] f2fs_expand_inode_data+0x1cc/0x3c0 [f2fs] f2fs_fallocate+0x3c3/0x410 [f2fs] vfs_fallocate+0x15f/0x4b0 __x64_sys_fallocate+0x4a/0x80 x64_sys_call+0x15e8/0x1b80 do_syscall_64+0x68/0x130 entry_SYSCALL_64_after_hwframe+0x67/0x6f RIP: 0033:0x7f9dba5197ca F2FS-fs (nullb0): Stopped filesystem due to reason: 4 The reason is f2fs_gc_range() may try to migrate block in curseg, however, its SSA block is not uptodate due to the last summary block data is still in cache of curseg. In this patch, we add a condition in f2fs_gc_range() to check whether section is opened or not, and skip block migration for opened section.",,"[{""url"":""https://git.kernel.org/stable/c/44a51592ac657d8e422585414d7ec17a5b50fb0e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/773704c1ef96a8b70d0d186ab725f50548de82c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8d9431b0d11a5030aa1ce477defee455b3821701"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38165,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:31.990,2025-08-28T15:15:47.967,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf, sockmap: Fix panic when calling skb_linearize The panic can be reproduced by executing the command: ./bench sockmap -c 2 -p 1 -a --rx-verdict-ingress --rx-strp 100000 Then a kernel panic was captured: ''' [ 657.460555] kernel BUG at net/core/skbuff.c:2178! [ 657.462680] Tainted: [W]=WARN [ 657.463287] Workqueue: events sk_psock_backlog ... [ 657.469610] <TASK> [ 657.469738] ? die+0x36/0x90 [ 657.469916] ? do_trap+0x1d0/0x270 [ 657.470118] ? pskb_expand_head+0x612/0xf40 [ 657.470376] ? pskb_expand_head+0x612/0xf40 [ 657.470620] ? do_error_trap+0xa3/0x170 [ 657.470846] ? pskb_expand_head+0x612/0xf40 [ 657.471092] ? handle_invalid_op+0x2c/0x40 [ 657.471335] ? pskb_expand_head+0x612/0xf40 [ 657.471579] ? exc_invalid_op+0x2d/0x40 [ 657.471805] ? asm_exc_invalid_op+0x1a/0x20 [ 657.472052] ? pskb_expand_head+0xd1/0xf40 [ 657.472292] ? pskb_expand_head+0x612/0xf40 [ 657.472540] ? lock_acquire+0x18f/0x4e0 [ 657.472766] ? find_held_lock+0x2d/0x110 [ 657.472999] ? __pfx_pskb_expand_head+0x10/0x10 [ 657.473263] ? __kmalloc_cache_noprof+0x5b/0x470 [ 657.473537] ? __pfx___lock_release.isra.0+0x10/0x10 [ 657.473826] __pskb_pull_tail+0xfd/0x1d20 [ 657.474062] ? __kasan_slab_alloc+0x4e/0x90 [ 657.474707] sk_psock_skb_ingress_enqueue+0x3bf/0x510 [ 657.475392] ? __kasan_kmalloc+0xaa/0xb0 [ 657.476010] sk_psock_backlog+0x5cf/0xd70 [ 657.476637] process_one_work+0x858/0x1a20 ''' The panic originates from the assertion BUG_ON(skb_shared(skb)) in skb_linearize(). A previous commit(see Fixes tag) introduced skb_get() to avoid race conditions between skb operations in the backlog and skb release in the recvmsg path. However, this caused the panic to always occur when skb_linearize is executed. The ""--rx-strp 100000"" parameter forces the RX path to use the strparser module which aggregates data until it reaches 100KB before calling sockmap logic. The 100KB payload exceeds MAX_MSG_FRAGS, triggering skb_linearize. To fix this issue, just move skb_get into sk_psock_skb_ingress_enqueue. ''' sk_psock_backlog: sk_psock_handle_skb skb_get(skb) <== we move it into 'sk_psock_skb_ingress_enqueue' sk_psock_skb_ingress____________  | |  sk_psock_skb_ingress_self | sk_psock_skb_ingress_enqueue sk_psock_verdict_apply_________________ skb_linearize ''' Note that for verdict_apply path, the skb_get operation is unnecessary so we add 'take_ref' param to control it's behavior.",,"[{""url"":""https://git.kernel.org/stable/c/3d25fa2d7f127348c818e1dab9e58534f7ac56cc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4dba44333a11522df54b49aa1f2edfaf6ce35fc7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5ca2e29f6834c64c0e5a9ccf1278c21fb49b827e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9718ba6490732dbe70190d42c21deb1440834402"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/db1d15a26f21f97459508c42ae87cabe8d3afc3b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e9c1299d813fc04668042690f2c3cc76d013959a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38166,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:32.120,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf: fix ktls panic with sockmap [ 2172.936997] ------------[ cut here ]------------ [ 2172.936999] kernel BUG at lib/iov_iter.c:629! ...... [ 2172.944996] PKRU: 55555554 [ 2172.945155] Call Trace: [ 2172.945299] <TASK> [ 2172.945428] ? die+0x36/0x90 [ 2172.945601] ? do_trap+0xdd/0x100 [ 2172.945795] ? iov_iter_revert+0x178/0x180 [ 2172.946031] ? iov_iter_revert+0x178/0x180 [ 2172.946267] ? do_error_trap+0x7d/0x110 [ 2172.946499] ? iov_iter_revert+0x178/0x180 [ 2172.946736] ? exc_invalid_op+0x50/0x70 [ 2172.946961] ? iov_iter_revert+0x178/0x180 [ 2172.947197] ? asm_exc_invalid_op+0x1a/0x20 [ 2172.947446] ? iov_iter_revert+0x178/0x180 [ 2172.947683] ? iov_iter_revert+0x5c/0x180 [ 2172.947913] tls_sw_sendmsg_locked.isra.0+0x794/0x840 [ 2172.948206] tls_sw_sendmsg+0x52/0x80 [ 2172.948420] ? inet_sendmsg+0x1f/0x70 [ 2172.948634] __sys_sendto+0x1cd/0x200 [ 2172.948848] ? find_held_lock+0x2b/0x80 [ 2172.949072] ? syscall_trace_enter+0x140/0x270 [ 2172.949330] ? __lock_release.isra.0+0x5e/0x170 [ 2172.949595] ? find_held_lock+0x2b/0x80 [ 2172.949817] ? syscall_trace_enter+0x140/0x270 [ 2172.950211] ? lockdep_hardirqs_on_prepare+0xda/0x190 [ 2172.950632] ? ktime_get_coarse_real_ts64+0xc2/0xd0 [ 2172.951036] __x64_sys_sendto+0x24/0x30 [ 2172.951382] do_syscall_64+0x90/0x170 ...... After calling bpf_exec_tx_verdict(), the size of msg_pl->sg may increase, e.g., when the BPF program executes bpf_msg_push_data(). If the BPF program sets cork_bytes and sg.size is smaller than cork_bytes, it will return -ENOSPC and attempt to roll back to the non-zero copy logic. However, during rollback, msg->msg_iter is reset, but since msg_pl->sg.size has been increased, subsequent executions will exceed the actual size of msg_iter. ''' iov_iter_revert(&msg->msg_iter, msg_pl->sg.size - orig_size); ''' The changes in this commit are based on the following considerations: 1. When cork_bytes is set, rolling back to non-zero copy logic is pointless and can directly go to zero-copy logic. 2. We can not calculate the correct number of bytes to revert msg_iter. Assume the original data is ""abcdefgh"" (8 bytes), and after 3 pushes by the BPF program, it becomes 11-byte data: ""abc?de?fgh?"". Then, we set cork_bytes to 6, which means the first 6 bytes have been processed, and the remaining 5 bytes ""?fgh?"" will be cached until the length meets the cork_bytes requirement. However, some data in ""?fgh?"" is not within 'sg->msg_iter' (but in msg_pl instead), especially the data ""?"" we pushed. So it doesn't seem as simple as just reverting through an offset of msg_iter. 3. For non-TLS sockets in tcp_bpf_sendmsg, when a ""cork"" situation occurs, the user-space send() doesn't return an error, and the returned length is the same as the input length parameter, even if some data is cached. Additionally, I saw that the current non-zero-copy logic for handling corking is written as: ''' line 1177 else if (ret != -EAGAIN) { if (ret == -ENOSPC) ret = 0; goto send_end; ''' So it's ok to just return 'copied' without error when a ""cork"" situation occurs.",,"[{""url"":""https://git.kernel.org/stable/c/2e36a81d388ec9c3f78b6223f7eda2088cd40adb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/328cac3f9f8ae394748485e769a527518a9137c8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/54a3ecaeeeae8176da8badbd7d72af1017032c39"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/57fbbe29e86042bbaa31c1a30d2afa16c427e3f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/603943f022a7fe5cc83ca7005faf34798fb7853f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38167,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:32.243,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: handle hdr_first_de() return value The hdr_first_de() function returns a pointer to a struct NTFS_DE. This pointer may be NULL. To handle the NULL error effectively, it is important to implement an error handler. This will help manage potential errors consistently. Additionally, error handling for the return value already exists at other points where this function is called. Found by Linux Verification Center (linuxtesting.org) with SVACE.",,"[{""url"":""https://git.kernel.org/stable/c/2d5879f64554181b89f44d4817b9ea86e8e913e1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4ecd0cde89feee26525ccdf1af0c1ae156ca010b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5390b3d4c6d41d05bb9149d094d504cbc9ea85bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/701340a25b1ad210e6b8192195be21fd3fcc22c7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/83cd0aa74793384dbdffc140500b200e9776a302"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/af5cab0e5b6f8edb0be51a9f47f3f620e0b4fd70"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38168,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:32.377,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: perf: arm-ni: Unregister PMUs on probe failure When a resource allocation fails in one clock domain of an NI device, we need to properly roll back all previously registered perf PMUs in other clock domains of the same device. Otherwise, it can lead to kernel panics. Calling arm_ni_init+0x0/0xff8 [arm_ni] @ 2374 arm-ni ARMHCB70:00: Failed to request PMU region 0x1f3c13000 arm-ni ARMHCB70:00: probe with driver arm-ni failed with error -16 list_add corruption: next->prev should be prev (fffffd01e9698a18), but was 0000000000000000. (next=ffff10001a0decc8). pstate: 6340009 (nZCv daif +PAN -UAO +TCO +DIT -SSBS BTYPE=--) pc : list_add_valid_or_report+0x7c/0xb8 lr : list_add_valid_or_report+0x7c/0xb8 Call trace: __list_add_valid_or_report+0x7c/0xb8 perf_pmu_register+0x22c/0x3a0 arm_ni_probe+0x554/0x70c [arm_ni] platform_probe+0x70/0xe8 really_probe+0xc6/0x4d8 driver_probe_device+0x48/0x170 __driver_attach+0x8e/0x1c0 bus_for_each_dev+0x64/0xf0 driver_add+0x138/0x260 bus_add_driver+0x68/0x138 __platform_driver_register+0x2c/0x40 arm_ni_init+0x14/0x2a [arm_ni] do_init_module+0x36/0x298 ---[ end trace 0000000000000000 ]--- Kernel panic - not syncing: Oops - BUG: Fatal exception SMP: stopping secondary CPUs",,"[{""url"":""https://git.kernel.org/stable/c/72caf9886e9c1731cf7bfe3eabc308b9268b21d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7e958e116e3be05a1f869b5a885fc5d674c7725f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f57afde6a44d9e044885e1125034edd4fda02e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38169,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:32.517,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: arm64/fpsimd: Avoid clobbering kernel FPSIMD state with SMSTOP On system with SME, a thread's kernel FPSIMD state may be erroneously clobbered during a context switch immediately after that state is restored. Systems without SME are unaffected. If the CPU happens to be in streaming SVE mode before a context switch to a thread with kernel FPSIMD state, fpsimd_thread_switch() will restore the kernel FPSIMD state using fpsimd_load_kernel_state() while the CPU is still in streaming SVE mode. When fpsimd_thread_switch() subsequently calls fpsimd_flush_cpu_state(), this will execute an SMSTOP, causing an exit from streaming SVE mode. The exit from streaming SVE mode will cause the hardware to reset a number of FPSIMD/SVE/SME registers, clobbering the FPSIMD state. Fix this by calling fpsimd_flush_cpu_state() before restoring the kernel FPSIMD state.",,"[{""url"":""https://git.kernel.org/stable/c/01098d893fa8a6edb2b56e178b798e3e6b674f02"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/55d52af498daea75aa03ba9b7e444c8ae495ac20"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a305821f597ec943849d3e53924adb88c61ed682"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38170,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:32.643,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: arm64/fpsimd: Discard stale CPU state when handling SME traps The logic for handling SME traps manipulates saved FPSIMD/SVE/SME state incorrectly, and a race with preemption can result in a task having TIF_SME set and TIF_FOREIGN_FPSTATE clear even though the live CPU state is stale (e.g. with SME traps enabled). This can result in warnings from do_sme_acc() where SME traps are not expected while TIF_SME is set: | /* With TIF_SME userspace shouldn't generate any traps */ | if (test_and_set_thread_flag(TIF_SME)) | WARN_ON(1); This is very similar to the SVE issue we fixed in commit: 751ecf6afd6568ad (""arm64/sve: Discard stale CPU state when handling SVE traps"") The race can occur when the SME trap handler is preempted before and after manipulating the saved FPSIMD/SVE/SME state, starting and ending on the same CPU, e.g. | void do_sme_acc(unsigned long esr, struct pt_regs *regs) | { | // Trap on CPU 0 with TIF_SME clear, SME traps enabled | // task->fpsimd_cpu is 0. | // per_cpu_ptr(&fpsimd_last_state, 0) is task. | | ... | | // Preempted; migrated from CPU 0 to CPU 1. | // TIF_FOREIGN_FPSTATE is set. | | get_cpu_fpsimd_context(); | | /* With TIF_SME userspace shouldn't generate any traps */ | if (test_and_set_thread_flag(TIF_SME)) | WARN_ON(1); | | if (!test_thread_flag(TIF_FOREIGN_FPSTATE)) { | unsigned long vq_minus_one = | sve_vq_from_vl(task_get_sme_vl(current)) - 1; | sme_set_vq(vq_minus_one); | | fpsimd_bind_task_to_cpu(); | } | | put_cpu_fpsimd_context(); | | // Preempted; migrated from CPU 1 to CPU 0. | // task->fpsimd_cpu is still 0 | // If per_cpu_ptr(&fpsimd_last_state, 0) is still task then: | // - Stale HW state is reused (with SME traps enabled) | // - TIF_FOREIGN_FPSTATE is cleared | // - A return to userspace skips HW state restore | } Fix the case where the state is not live and TIF_FOREIGN_FPSTATE is set by calling fpsimd_flush_task_state() to detach from the saved CPU state. This ensures that a subsequent context switch will not reuse the stale CPU state, and will instead set TIF_FOREIGN_FPSTATE, forcing the new state to be reloaded from memory prior to a return to userspace. Note: this was originallly posted as [1]. [ Rutland: rewrite commit message ]",,"[{""url"":""https://git.kernel.org/stable/c/43be952e885476dafb74aa832c0847b2f4f650c6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6103f9ba51a59afb5a0f32299c837377c5a5a693"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c4a4786d93e99517d6f10ed56b9ffba4ce88d3b3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3eaab3c70905c5467e5c4ea403053d67505adeb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de89368de3894a8db27caeb8fd902ba1c49f696a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38171,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:32.787,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: power: supply: max77705: Fix workqueue error handling in probe The create_singlethread_workqueue() doesn't return error pointers, it returns NULL. Also cleanup the workqueue on the error paths.",,"[{""url"":""https://git.kernel.org/stable/c/11741b8e382d34b13277497ab91123d8b0b5c2db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f16be2b2927fdcfe40b596b7411c46d23a82034"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38172,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:32.910,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: erofs: avoid using multiple devices with different type For multiple devices, both primary and extra devices should be the same type. `erofs_init_device` has already guaranteed that if the primary is a file-backed device, extra devices should also be regular files. However, if the primary is a block device while the extra device is a file-backed device, `erofs_init_device` will get an ENOTBLK, which is not treated as an error in `erofs_fc_get_tree`, and that leads to an UAF: erofs_fc_get_tree get_tree_bdev_flags(erofs_fc_fill_super) erofs_read_superblock erofs_init_device // sbi->dif0 is not inited yet, // return -ENOTBLK deactivate_locked_super free(sbi) if (err is -ENOTBLK) sbi->dif0.file = filp_open() // sbi UAF So if -ENOTBLK is hitted in `erofs_init_device`, it means the primary device must be a block device, and the extra device is not a block device. The error can be converted to -EINVAL.",,"[{""url"":""https://git.kernel.org/stable/c/65115472f741ca000d7ea4a5922214f93cd1516e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9748f2f54f66743ac77275c34886a9f890e18409"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd04beb9ce2773a16057248bb4fa424068ae3807"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38173,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-03T09:15:33.050,2025-07-03T15:13:53.147,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: crypto: marvell/cesa - Handle zero-length skcipher requests Do not access random memory for zero-length skcipher requests. Just return 0.",,"[{""url"":""https://git.kernel.org/stable/c/32d3e8049a8b60f18c5c39f5931bfb1130ac11c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e9666ac8b94c978690f937d59170c5237bd2c45"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7894694b5d5b2ecfd7fb081d6f60b9e169ab4d13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/78ea1ff6cb413a03ff6f7af4e28e24b4461a0965"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8a4e047c6cc07676f637608a9dd675349b5de0a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c064ae2881d839709bd72d484d5f2af157f46024"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c9610dda42bd382a96f97e68825cb5f66cd9e1dc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e1cc69da619588b1488689fe3535a0ba75a2b0e7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38174,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T11:15:51.283,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: thunderbolt: Do not double dequeue a configuration request Some of our devices crash in tb_cfg_request_dequeue(): general protection fault, probably for non-canonical address 0xdead000000000122 CPU: 6 PID: 91007 Comm: kworker/6:2 Tainted: G U W 6.6.65 RIP: 0010:tb_cfg_request_dequeue+0x2d/0xa0 Call Trace: <TASK> ? tb_cfg_request_dequeue+0x2d/0xa0 tb_cfg_request_work+0x33/0x80 worker_thread+0x386/0x8f0 kthread+0xed/0x110 ret_from_fork+0x38/0x50 ret_from_fork_asm+0x1b/0x30 The circumstances are unclear, however, the theory is that tb_cfg_request_work() can be scheduled twice for a request: first time via frame.callback from ring_work() and second time from tb_cfg_request(). Both times kworkers will execute tb_cfg_request_dequeue(), which results in double list_del() from the ctl->request_queue (the list poison deference hints at it: 0xdead000000000122). Do not dequeue requests that don't have TB_CFG_REQUEST_ACTIVE bit set.",,"[{""url"":""https://git.kernel.org/stable/c/0771bcbe2f6e5d5f263cf466efe571d2754a46da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0a3011d47dbc92a33621861c423cb64833d7fe57"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0f73628e9da1ee39daf5f188190cdbaee5e0c98c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2f62eda4d974c26bc595425eafd429067541f2c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a057f261539720165d03d85024da2b52e67f63d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/85286e634ebbaf9c0fb1cdf580add2f33fc7628c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cdb4feab2f39e75a66239e3a112beced279612a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e49e994cd83705f7ca30eda1e304abddfd96a37a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb2d5e794fb966b3ef8bde99eb8561446a53509f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38175,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T11:15:51.420,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: binder: fix yet another UAF in binder_devices Commit e77aff5528a18 (""binderfs: fix use-after-free in binder_devices"") addressed a use-after-free where devices could be released without first being removed from the binder_devices list. However, there is a similar path in binder_free_proc() that was missed: ================================================================== BUG: KASAN: slab-use-after-free in binder_remove_device+0xd4/0x100 Write of size 8 at addr ffff0000c773b900 by task umount/467 CPU: 12 UID: 0 PID: 467 Comm: umount Not tainted 6.15.0-rc7-00138-g57483a362741 #9 PREEMPT Hardware name: linux,dummy-virt (DT) Call trace: binder_remove_device+0xd4/0x100 binderfs_evict_inode+0x230/0x2f0 evict+0x25c/0x5dc iput+0x304/0x480 dentry_unlink_inode+0x208/0x46c __dentry_kill+0x154/0x530 [...] Allocated by task 463: __kmalloc_cache_noprof+0x13c/0x324 binderfs_binder_device_create.isra.0+0x138/0xa60 binder_ctl_ioctl+0x1ac/0x230 [...] Freed by task 215: kfree+0x184/0x31c binder_proc_dec_tmpref+0x33c/0x4ac binder_deferred_func+0xc10/0x1108 process_one_work+0x520/0xba4 [...] ================================================================== Call binder_remove_device() within binder_free_proc() to ensure the device is removed from the binder_devices list before being kfreed.",,"[{""url"":""https://git.kernel.org/stable/c/4a7694f499cae5b83412c5281bf2c961f34f2ed6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/72a726fb5f25fbb31d6060acfb671c1955831245"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9857af0fcff385c75433f2162c30c62eb912ef6d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38176,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T11:15:51.543,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: binder: fix use-after-free in binderfs_evict_inode() Running 'stress-ng --binderfs 16 --timeout 300' under KASAN-enabled kernel, I've noticed the following: BUG: KASAN: slab-use-after-free in binderfs_evict_inode+0x1de/0x2d0 Write of size 8 at addr ffff88807379bc08 by task stress-ng-binde/1699 CPU: 0 UID: 0 PID: 1699 Comm: stress-ng-binde Not tainted 6.14.0-rc7-g586de92313fc-dirty #13 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-3.fc41 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x1c2/0x2a0 ? __pfx_dump_stack_lvl+0x10/0x10 ? __pfx__printk+0x10/0x10 ? __pfx_lock_release+0x10/0x10 ? __virt_addr_valid+0x18c/0x540 ? __virt_addr_valid+0x469/0x540 print_report+0x155/0x840 ? __virt_addr_valid+0x18c/0x540 ? __virt_addr_valid+0x469/0x540 ? __phys_addr+0xba/0x170 ? binderfs_evict_inode+0x1de/0x2d0 kasan_report+0x147/0x180 ? binderfs_evict_inode+0x1de/0x2d0 binderfs_evict_inode+0x1de/0x2d0 ? __pfx_binderfs_evict_inode+0x10/0x10 evict+0x524/0x9f0 ? __pfx_lock_release+0x10/0x10 ? __pfx_evict+0x10/0x10 ? do_raw_spin_unlock+0x4d/0x210 ? _raw_spin_unlock+0x28/0x50 ? iput+0x697/0x9b0 __dentry_kill+0x209/0x660 ? shrink_kill+0x8d/0x2c0 shrink_kill+0xa9/0x2c0 shrink_dentry_list+0x2e0/0x5e0 shrink_dcache_parent+0xa2/0x2c0 ? __pfx_shrink_dcache_parent+0x10/0x10 ? __pfx_lock_release+0x10/0x10 ? __pfx_do_raw_spin_lock+0x10/0x10 do_one_tree+0x23/0xe0 shrink_dcache_for_umount+0xa0/0x170 generic_shutdown_super+0x67/0x390 kill_litter_super+0x76/0xb0 binderfs_kill_super+0x44/0x90 deactivate_locked_super+0xb9/0x130 cleanup_mnt+0x422/0x4c0 ? lockdep_hardirqs_on+0x9d/0x150 task_work_run+0x1d2/0x260 ? __pfx_task_work_run+0x10/0x10 resume_user_mode_work+0x52/0x60 syscall_exit_to_user_mode+0x9a/0x120 do_syscall_64+0x103/0x210 ? asm_sysvec_apic_timer_interrupt+0x1a/0x20 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0xcac57b Code: c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 f3 0f 1e fa 31 f6 e9 05 00 00 00 0f 1f 44 00 00 f3 0f 1e fa b8 RSP: 002b:00007ffecf4226a8 EFLAGS: 00000246 ORIG_RAX: 00000000000000a6 RAX: 0000000000000000 RBX: 00007ffecf422720 RCX: 0000000000cac57b RDX: 0000000000000000 RSI: 0000000000000000 RDI: 00007ffecf422850 RBP: 00007ffecf422850 R08: 0000000028d06ab1 R09: 7fffffffffffffff R10: 3fffffffffffffff R11: 0000000000000246 R12: 00007ffecf422718 R13: 00007ffecf422710 R14: 00007f478f87b658 R15: 00007ffecf422830 </TASK> Allocated by task 1705: kasan_save_track+0x3e/0x80 __kasan_kmalloc+0x8f/0xa0 __kmalloc_cache_noprof+0x213/0x3e0 binderfs_binder_device_create+0x183/0xa80 binder_ctl_ioctl+0x138/0x190 __x64_sys_ioctl+0x120/0x1b0 do_syscall_64+0xf6/0x210 entry_SYSCALL_64_after_hwframe+0x77/0x7f Freed by task 1705: kasan_save_track+0x3e/0x80 kasan_save_free_info+0x46/0x50 __kasan_slab_free+0x62/0x70 kfree+0x194/0x440 evict+0x524/0x9f0 do_unlinkat+0x390/0x5b0 __x64_sys_unlink+0x47/0x50 do_syscall_64+0xf6/0x210 entry_SYSCALL_64_after_hwframe+0x77/0x7f This 'stress-ng' workload causes the concurrent deletions from 'binder_devices' and so requires full-featured synchronization to prevent list corruption. I've found this issue independently but pretty sure that syzbot did the same, so Reported-by: and Closes: should be applicable here as well.",,"[{""url"":""https://git.kernel.org/stable/c/80ed8ab8efa0d18c03968a2321154f10e2d1a2e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c0a559825281764061a127632e5ad273f0466ad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aea61a1a77613d4184d7ebe7c1d7cb606458b43b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38177,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T13:15:24.033,2025-08-28T15:15:48.110,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: sch_hfsc: make hfsc_qlen_notify() idempotent hfsc_qlen_notify() is not idempotent either and not friendly to its callers, like fq_codel_dequeue(). Let's make it idempotent to ease qdisc_tree_reduce_backlog() callers' life: 1. update_vf() decreases cl->cl_nactive, so we can check whether it is non-zero before calling it. 2. eltree_remove() always removes RB node cl->el_node, but we can use RB_EMPTY_NODE() + RB_CLEAR_NODE() to make it safe.",,"[{""url"":""https://git.kernel.org/stable/c/0475c85426b18eccdcb7f9fb58d8f8e9c6c58c87"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/51eb3b65544c9efd6a1026889ee5fb5aa62da3bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/72c61ffbeeb8c50f6d4d70c65d3283aa1bac57a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9030a91235ae4845ec71902c3e0cecfc9ed1f2df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9a5fd5c2f4d4afdd5e405083ee53e0789ce76956"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a5efc95a33bd4fcb879250852828cc58c7862970"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c1175c4ad01dbc9c979d099861fa90a754f72059"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d06476714d2819b550e0cc39222347e2c8941c9d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38178,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:24.233,2025-07-28T05:15:44.407,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,[],,,,,,,,,,
CVE-2025-38179,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:24.553,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: smb: client: fix max_sge overflow in smb_extract_folioq_to_rdma() This fixes the following problem: [ 749.901015] [ T8673] run fstests cifs/001 at 2025-06-17 09:40:30 [ 750.346409] [ T9870] ================================================================== [ 750.346814] [ T9870] BUG: KASAN: slab-out-of-bounds in smb_set_sge+0x2cc/0x3b0 [cifs] [ 750.347330] [ T9870] Write of size 8 at addr ffff888011082890 by task xfs_io/9870 [ 750.347705] [ T9870] [ 750.348077] [ T9870] CPU: 0 UID: 0 PID: 9870 Comm: xfs_io Kdump: loaded Not tainted 6.16.0-rc2-metze.02+ #1 PREEMPT(voluntary) [ 750.348082] [ T9870] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006 [ 750.348085] [ T9870] Call Trace: [ 750.348086] [ T9870] <TASK> [ 750.348088] [ T9870] dump_stack_lvl+0x76/0xa0 [ 750.348106] [ T9870] print_report+0xd1/0x640 [ 750.348116] [ T9870] ? __pfx__raw_spin_lock_irqsave+0x10/0x10 [ 750.348120] [ T9870] ? kasan_complete_mode_report_info+0x26/0x210 [ 750.348124] [ T9870] kasan_report+0xe7/0x130 [ 750.348128] [ T9870] ? smb_set_sge+0x2cc/0x3b0 [cifs] [ 750.348262] [ T9870] ? smb_set_sge+0x2cc/0x3b0 [cifs] [ 750.348377] [ T9870] __asan_report_store8_noabort+0x17/0x30 [ 750.348381] [ T9870] smb_set_sge+0x2cc/0x3b0 [cifs] [ 750.348496] [ T9870] smbd_post_send_iter+0x1990/0x3070 [cifs] [ 750.348625] [ T9870] ? __pfx_smbd_post_send_iter+0x10/0x10 [cifs] [ 750.348741] [ T9870] ? update_stack_state+0x2a0/0x670 [ 750.348749] [ T9870] ? cifs_flush+0x153/0x320 [cifs] [ 750.348870] [ T9870] ? cifs_flush+0x153/0x320 [cifs] [ 750.348990] [ T9870] ? update_stack_state+0x2a0/0x670 [ 750.348995] [ T9870] smbd_send+0x58c/0x9c0 [cifs] [ 750.349117] [ T9870] ? __pfx_smbd_send+0x10/0x10 [cifs] [ 750.349231] [ T9870] ? unwind_get_return_address+0x65/0xb0 [ 750.349235] [ T9870] ? __pfx_stack_trace_consume_entry+0x10/0x10 [ 750.349242] [ T9870] ? arch_stack_walk+0xa7/0x100 [ 750.349250] [ T9870] ? stack_trace_save+0x92/0xd0 [ 750.349254] [ T9870] __smb_send_rqst+0x931/0xec0 [cifs] [ 750.349374] [ T9870] ? kernel_text_address+0x173/0x190 [ 750.349379] [ T9870] ? kasan_save_stack+0x39/0x70 [ 750.349382] [ T9870] ? kasan_save_track+0x18/0x70 [ 750.349385] [ T9870] ? __kasan_slab_alloc+0x9d/0xa0 [ 750.349389] [ T9870] ? __pfx___smb_send_rqst+0x10/0x10 [cifs] [ 750.349508] [ T9870] ? smb2_mid_entry_alloc+0xb4/0x7e0 [cifs] [ 750.349626] [ T9870] ? cifs_call_async+0x277/0xb00 [cifs] [ 750.349746] [ T9870] ? cifs_issue_write+0x256/0x610 [cifs] [ 750.349867] [ T9870] ? netfs_do_issue_write+0xc2/0x340 [netfs] [ 750.349900] [ T9870] ? netfs_advance_write+0x45b/0x1270 [netfs] [ 750.349929] [ T9870] ? netfs_write_folio+0xd6c/0x1be0 [netfs] [ 750.349958] [ T9870] ? netfs_writepages+0x2e9/0xa80 [netfs] [ 750.349987] [ T9870] ? do_writepages+0x21f/0x590 [ 750.349993] [ T9870] ? filemap_fdatawrite_wbc+0xe1/0x140 [ 750.349997] [ T9870] ? entry_SYSCALL_64_after_hwframe+0x76/0x7e [ 750.350002] [ T9870] smb_send_rqst+0x22e/0x2f0 [cifs] [ 750.350131] [ T9870] ? __pfx_smb_send_rqst+0x10/0x10 [cifs] [ 750.350255] [ T9870] ? local_clock_noinstr+0xe/0xd0 [ 750.350261] [ T9870] ? kasan_save_alloc_info+0x37/0x60 [ 750.350268] [ T9870] ? __kasan_check_write+0x14/0x30 [ 750.350271] [ T9870] ? _raw_spin_lock+0x81/0xf0 [ 750.350275] [ T9870] ? __pfx__raw_spin_lock+0x10/0x10 [ 750.350278] [ T9870] ? smb2_setup_async_request+0x293/0x580 [cifs] [ 750.350398] [ T9870] cifs_call_async+0x477/0xb00 [cifs] [ 750.350518] [ T9870] ? __pfx_smb2_writev_callback+0x10/0x10 [cifs] [ 750.350636] [ T9870] ? __pfx_cifs_call_async+0x10/0x10 [cifs] [ 750.350756] [ T9870] ? __pfx__raw_spin_lock+0x10/0x10 [ 750.350760] [ T9870] ? __kasan_check_write+0x14/0x30 [ 750.350763] [ T98 ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/8ae7814589d7bd850294ac14ec4c1725dafd42ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a379a8a2a0032e12e7ef397197c9c2ad011588d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0ba9b2f188166550296005e64b15e80db82ad8a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38180,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:24.700,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: atm: fix /proc/net/atm/lec handling /proc/net/atm/lec must ensure safety against dev_lec[] changes. It appears it had dev_put() calls without prior dev_hold(), leading to imbalance and UAF.",,"[{""url"":""https://git.kernel.org/stable/c/5fe1b23a2f87f43aeeac51e08819cbc6fd808cbc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9b9aeb3ada44d8abea1e31e4446113f460848ae4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a5e3a144268899f1a8c445c8a3bfa15873ba85e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca3829c18c8d0ceb656605d3bff6bb3dfb078589"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d03b79f459c7935cff830d98373474f440bd03ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e612c4b014f5808fbc6beae21f5ccaca5e76a2f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f2d1443b18806640abdb530e88009af7be2588e7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fcfccf56f4eba7d00aa2d33c7bb1b33083237742"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38181,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:24.860,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: calipso: Fix null-ptr-deref in calipso_req_{set,del}attr(). syzkaller reported a null-ptr-deref in sock_omalloc() while allocating a CALIPSO option. [0] The NULL is of struct sock, which was fetched by sk_to_full_sk() in calipso_req_setattr(). Since commit a1a5344ddbe8 (""tcp: avoid two atomic ops for syncookies""), reqsk->rsk_listener could be NULL when SYN Cookie is returned to its client, as hinted by the leading SYN Cookie log. Here are 3 options to fix the bug: 1) Return 0 in calipso_req_setattr() 2) Return an error in calipso_req_setattr() 3) Alaways set rsk_listener 1) is no go as it bypasses LSM, but 2) effectively disables SYN Cookie for CALIPSO. 3) is also no go as there have been many efforts to reduce atomic ops and make TCP robust against DDoS. See also commit 3b24d854cb35 (""tcp/dccp: do not touch listener sk_refcnt under synflood""). As of the blamed commit, SYN Cookie already did not need refcounting, and no one has stumbled on the bug for 9 years, so no CALIPSO user will care about SYN Cookie. Let's return an error in calipso_req_setattr() and calipso_req_delattr() in the SYN Cookie case. This can be reproduced by [1] on Fedora and now connect() of nc times out. [0]: TCP: request_sock_TCPv6: Possible SYN flooding on port [::]:20002. Sending cookies. Oops: general protection fault, probably for non-canonical address 0xdffffc0000000006: 0000 [#1] PREEMPT SMP KASAN NOPTI KASAN: null-ptr-deref in range [0x0000000000000030-0x0000000000000037] CPU: 3 UID: 0 PID: 12262 Comm: syz.1.2611 Not tainted 6.14.0 #2 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014 RIP: 0010:read_pnet include/net/net_namespace.h:406 [inline] RIP: 0010:sock_net include/net/sock.h:655 [inline] RIP: 0010:sock_kmalloc+0x35/0x170 net/core/sock.c:2806 Code: 89 d5 41 54 55 89 f5 53 48 89 fb e8 25 e3 c6 fd e8 f0 91 e3 00 48 8d 7b 30 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 <80> 3c 02 00 0f 85 26 01 00 00 48 b8 00 00 00 00 00 fc ff df 4c 8b RSP: 0018:ffff88811af89038 EFLAGS: 00010216 RAX: dffffc0000000000 RBX: 0000000000000000 RCX: ffff888105266400 RDX: 0000000000000006 RSI: ffff88800c890000 RDI: 0000000000000030 RBP: 0000000000000050 R08: 0000000000000000 R09: ffff88810526640e R10: ffffed1020a4cc81 R11: ffff88810526640f R12: 0000000000000000 R13: 0000000000000820 R14: ffff888105266400 R15: 0000000000000050 FS: 00007f0653a07640(0000) GS:ffff88811af80000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f863ba096f4 CR3: 00000000163c0005 CR4: 0000000000770ef0 PKRU: 80000000 Call Trace: <IRQ> ipv6_renew_options+0x279/0x950 net/ipv6/exthdrs.c:1288 calipso_req_setattr+0x181/0x340 net/ipv6/calipso.c:1204 calipso_req_setattr+0x56/0x80 net/netlabel/netlabel_calipso.c:597 netlbl_req_setattr+0x18a/0x440 net/netlabel/netlabel_kapi.c:1249 selinux_netlbl_inet_conn_request+0x1fb/0x320 security/selinux/netlabel.c:342 selinux_inet_conn_request+0x1eb/0x2c0 security/selinux/hooks.c:5551 security_inet_conn_request+0x50/0xa0 security/security.c:4945 tcp_v6_route_req+0x22c/0x550 net/ipv6/tcp_ipv6.c:825 tcp_conn_request+0xec8/0x2b70 net/ipv4/tcp_input.c:7275 tcp_v6_conn_request+0x1e3/0x440 net/ipv6/tcp_ipv6.c:1328 tcp_rcv_state_process+0xafa/0x52b0 net/ipv4/tcp_input.c:6781 tcp_v6_do_rcv+0x8a6/0x1a40 net/ipv6/tcp_ipv6.c:1667 tcp_v6_rcv+0x505e/0x5b50 net/ipv6/tcp_ipv6.c:1904 ip6_protocol_deliver_rcu+0x17c/0x1da0 net/ipv6/ip6_input.c:436 ip6_input_finish+0x103/0x180 net/ipv6/ip6_input.c:480 NF_HOOK include/linux/netfilter.h:314 [inline] NF_HOOK include/linux/netfilter.h:308 [inline] ip6_input+0x13c/0x6b0 net/ipv6/ip6_input.c:491 dst_input include/net/dst.h:469 [inline] ip6_rcv_finish net/ipv6/ip6_input.c:79 [inline] ip6_rcv_finish+0xb6/0x490 net/ipv6/ip6_input.c:69 NF_HOOK include/linux/netfilter.h:314 [inline] NF_HOOK include/linux/netf ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/058dd4a370f23a5553a9449f2db53d5bfa88d45e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/10876da918fa1aec0227fb4c67647513447f53a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/956f1499412ed0953f6a116df7fdb855e9f1fc66"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/988edde4d52d5c02ea4dd95d7619372a5e2fb7b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bde8833eb075ba8e8674de88e32de6b669966451"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d092c7fd8e220b23d6c47e03d7d0cc79e731f379"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc724bd34d56f5589f7587a091a8cda2386826c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f4ae0f61dd9a63329ecb49b1e6356139d43240b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38182,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:24.990,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ublk: santizize the arguments from userspace when adding a device Sanity check the values for queue depth and number of queues we get from userspace when adding a device.",,"[{""url"":""https://git.kernel.org/stable/c/0f8df5d6f25ac17c52a8bc6418e60a3e63130550"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3162d8235c8c4d585525cee8a59d1c180940a968"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c8472855884355caf3d8e0c50adf825f83454b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e2b2b7cf6368580114851cb3932f2ad9fbf23386"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38183,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:25.113,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: lan743x: fix potential out-of-bounds write in lan743x_ptp_io_event_clock_get() Before calling lan743x_ptp_io_event_clock_get(), the 'channel' value is checked against the maximum value of PCI11X1X_PTP_IO_MAX_CHANNELS(8). This seems correct and aligns with the PTP interrupt status register (PTP_INT_STS) specifications. However, lan743x_ptp_io_event_clock_get() writes to ptp->extts[] with only LAN743X_PTP_N_EXTTS(4) elements, using channel as an index: lan743x_ptp_io_event_clock_get(..., u8 channel,...) { ... /* Update Local timestamp */ extts = &ptp->extts[channel]; extts->ts.tv_sec = sec; ... } To avoid an out-of-bounds write and utilize all the supported GPIO inputs, set LAN743X_PTP_N_EXTTS to 8. Detected using the static analysis tool - Svace.",,"[{""url"":""https://git.kernel.org/stable/c/41017bd66c533f7af912c58273c7dfd5de0065d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4da0d23516857230b8e9b3022e25422ee2e2ba80"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/66bba1fd5bad548c03f7e42669a59f3f4d8211cc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e353b0854d3a1a31cb061df8d022fbfea53a0f24"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e8d48201a132f4aab31351c19a802c5a5ae820fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38184,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:25.237,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tipc: fix null-ptr-deref when acquiring remote ip of ethernet bearer The reproduction steps: 1. create a tun interface 2. enable l2 bearer 3. TIPC_NL_UDP_GET_REMOTEIP with media name set to tun tipc: Started in network mode tipc: Node identity 8af312d38a21, cluster identity 4711 tipc: Enabled bearer <eth:syz_tun>, priority 1 Oops: general protection fault KASAN: null-ptr-deref in range CPU: 1 UID: 1000 PID: 559 Comm: poc Not tainted 6.16.0-rc1+ #117 PREEMPT Hardware name: QEMU Ubuntu 24.04 PC RIP: 0010:tipc_udp_nl_dump_remoteip+0x4a4/0x8f0 the ub was in fact a struct dev. when bid != 0 && skip_cnt != 0, bearer_list[bid] may be NULL or other media when other thread changes it. fix this by checking media_id.",,"[{""url"":""https://git.kernel.org/stable/c/05d332ba075753d569d66333d62d60fff5f57ad8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0d3d91c3500f0c480e016faa4e2259c588616e59"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0f4a72fb266e48dbe928e1d936eab149e4ac3e1b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3998283e4c32c0fe69edd59b0876c193f50abce6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8595350615f952fcf8bc861464a6bf6b1129af50"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c2e17984752b9131061d1a2ca1199da2706337fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3dfe821dfe091c0045044343c8d86596d66e2cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f82727adcf2992822e12198792af450a76ebd5ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38185,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:25.377,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: atm: atmtcp: Free invalid length skb in atmtcp_c_send(). syzbot reported the splat below. [0] vcc_sendmsg() copies data passed from userspace to skb and passes it to vcc->dev->ops->send(). atmtcp_c_send() accesses skb->data as struct atmtcp_hdr after checking if skb->len is 0, but it's not enough. Also, when skb->len == 0, skb and sk (vcc) were leaked because dev_kfree_skb() is not called and sk_wmem_alloc adjustment is missing to revert atm_account_tx() in vcc_sendmsg(), which is expected to be done in atm_pop_raw(). Let's properly free skb with an invalid length in atmtcp_c_send(). [0]: BUG: KMSAN: uninit-value in atmtcp_c_send+0x255/0xed0 drivers/atm/atmtcp.c:294 atmtcp_c_send+0x255/0xed0 drivers/atm/atmtcp.c:294 vcc_sendmsg+0xd7c/0xff0 net/atm/common.c:644 sock_sendmsg_nosec net/socket.c:712 [inline] __sock_sendmsg+0x330/0x3d0 net/socket.c:727 ____sys_sendmsg+0x7e0/0xd80 net/socket.c:2566 ___sys_sendmsg+0x271/0x3b0 net/socket.c:2620 __sys_sendmsg net/socket.c:2652 [inline] __do_sys_sendmsg net/socket.c:2657 [inline] __se_sys_sendmsg net/socket.c:2655 [inline] __x64_sys_sendmsg+0x211/0x3e0 net/socket.c:2655 x64_sys_call+0x32fb/0x3db0 arch/x86/include/generated/asm/syscalls_64.h:47 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xd9/0x210 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f Uninit was created at: slab_post_alloc_hook mm/slub.c:4154 [inline] slab_alloc_node mm/slub.c:4197 [inline] kmem_cache_alloc_node_noprof+0x818/0xf00 mm/slub.c:4249 kmalloc_reserve+0x13c/0x4b0 net/core/skbuff.c:579 __alloc_skb+0x347/0x7d0 net/core/skbuff.c:670 alloc_skb include/linux/skbuff.h:1336 [inline] vcc_sendmsg+0xb40/0xff0 net/atm/common.c:628 sock_sendmsg_nosec net/socket.c:712 [inline] __sock_sendmsg+0x330/0x3d0 net/socket.c:727 ____sys_sendmsg+0x7e0/0xd80 net/socket.c:2566 ___sys_sendmsg+0x271/0x3b0 net/socket.c:2620 __sys_sendmsg net/socket.c:2652 [inline] __do_sys_sendmsg net/socket.c:2657 [inline] __se_sys_sendmsg net/socket.c:2655 [inline] __x64_sys_sendmsg+0x211/0x3e0 net/socket.c:2655 x64_sys_call+0x32fb/0x3db0 arch/x86/include/generated/asm/syscalls_64.h:47 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xd9/0x210 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f CPU: 1 UID: 0 PID: 5798 Comm: syz-executor192 Not tainted 6.16.0-rc1-syzkaller-00010-g2c4a1f3fe03e #0 PREEMPT(undef) Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025",,"[{""url"":""https://git.kernel.org/stable/c/1b0ad18704913c92a3ad53748fbc0f219a75b876"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2f370ae1fb6317985f3497b1bb80d457508ca2f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3261c017a7c5d2815c6a388c5a3280d1fba0e8db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a4b0fd8c25a7583f8564af6cc910418fb8954e89"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c19c0943424b412a84fdf178e6c71fe5480e4f0f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c9260c837de1d2b454960a4a2e44a81272fbcd22"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca00f0e6d733ecd9150716d1fd0138d26e674706"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e996507f59610e5752b8702537f13f551e7a2c96"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38186,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:25.520,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bnxt_en: Fix double invocation of bnxt_ulp_stop()/bnxt_ulp_start() Before the commit under the Fixes tag below, bnxt_ulp_stop() and bnxt_ulp_start() were always invoked in pairs. After that commit, the new bnxt_ulp_restart() can be invoked after bnxt_ulp_stop() has been called. This may result in the RoCE driver's aux driver .suspend() method being invoked twice. The 2nd bnxt_re_suspend() call will crash when it dereferences a NULL pointer: (NULL ib_device): Handle device suspend call BUG: kernel NULL pointer dereference, address: 0000000000000b78 PGD 0 P4D 0 Oops: Oops: 0000 [#1] SMP PTI CPU: 20 UID: 0 PID: 181 Comm: kworker/u96:5 Tainted: G S 6.15.0-rc1 #4 PREEMPT(voluntary) Tainted: [S]=CPU_OUT_OF_SPEC Hardware name: Dell Inc. PowerEdge R730/072T6D, BIOS 2.4.3 01/17/2017 Workqueue: bnxt_pf_wq bnxt_sp_task [bnxt_en] RIP: 0010:bnxt_re_suspend+0x45/0x1f0 [bnxt_re] Code: 8b 05 a7 3c 5b f5 48 89 44 24 18 31 c0 49 8b 5c 24 08 4d 8b 2c 24 e8 ea 06 0a f4 48 c7 c6 04 60 52 c0 48 89 df e8 1b ce f9 ff <48> 8b 83 78 0b 00 00 48 8b 80 38 03 00 00 a8 40 0f 85 b5 00 00 00 RSP: 0018:ffffa2e84084fd88 EFLAGS: 00010246 RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000001 RDX: 0000000000000000 RSI: ffffffffb4b6b934 RDI: 00000000ffffffff RBP: ffffa1760954c9c0 R08: 0000000000000000 R09: c0000000ffffdfff R10: 0000000000000001 R11: ffffa2e84084fb50 R12: ffffa176031ef070 R13: ffffa17609775000 R14: ffffa17603adc180 R15: 0000000000000000 FS: 0000000000000000(0000) GS:ffffa17daa397000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000b78 CR3: 00000004aaa30003 CR4: 00000000003706f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> bnxt_ulp_stop+0x69/0x90 [bnxt_en] bnxt_sp_task+0x678/0x920 [bnxt_en] ? __schedule+0x514/0xf50 process_scheduled_works+0x9d/0x400 worker_thread+0x11c/0x260 ? __pfx_worker_thread+0x10/0x10 kthread+0xfe/0x1e0 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x2b/0x40 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 Check the BNXT_EN_FLAG_ULP_STOPPED flag and do not proceed if the flag is already set. This will preserve the original symmetrical bnxt_ulp_stop() and bnxt_ulp_start(). Also, inside bnxt_ulp_start(), clear the BNXT_EN_FLAG_ULP_STOPPED flag after taking the mutex to avoid any race condition. And for symmetry, only proceed in bnxt_ulp_start() if the BNXT_EN_FLAG_ULP_STOPPED is set.",,"[{""url"":""https://git.kernel.org/stable/c/1e9ac33fa271be0d2480fd732f9642d81542500b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6f2cd309492924b8afd2c62aebff815c1119d124"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cca4ffd4a5b768752b91f6f75d77928e47886913"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38187,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:25.640,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/nouveau: fix a use-after-free in r535_gsp_rpc_push() The RPC container is released after being passed to r535_gsp_rpc_send(). When sending the initial fragment of a large RPC and passing the caller's RPC container, the container will be freed prematurely. Subsequent attempts to send remaining fragments will therefore result in a use-after-free. Allocate a temporary RPC container for holding the initial fragment of a large RPC when sending. Free the caller's container when all fragments are successfully sent. [ Rebase onto Blackwell changes. - Danilo ]",,"[{""url"":""https://git.kernel.org/stable/c/9802f0a63b641f4cddb2139c814c2e95cb825099"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd4677407c0ee250fc21e36439c8a442ddd62cc1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38188,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:25.760,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/msm/a7xx: Call CP_RESET_CONTEXT_STATE Calling this packet is necessary when we switch contexts because there are various pieces of state used by userspace to synchronize between BR and BV that are persistent across submits and we need to make sure that they are in a ""safe"" state when switching contexts. Otherwise a userspace submission in one context could cause another context to function incorrectly and hang, effectively a denial of service (although without leaking data). This was missed during initial a7xx bringup. Patchwork: https://patchwork.freedesktop.org/patch/654924/",,"[{""url"":""https://git.kernel.org/stable/c/2b520c6104f34e3a548525173c38ebca4402cac3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/35fe72f3c425bbf1d580bd9066e2456b1dbae4a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8a1f52651dd8203695d293c6824d8f6c067877d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38189,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:25.883,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/v3d: Avoid NULL pointer dereference in `v3d_job_update_stats()` The following kernel Oops was recently reported by Mesa CI: [ 800.139824] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000588 [ 800.148619] Mem abort info: [ 800.151402] ESR = 0x0000000096000005 [ 800.155141] EC = 0x25: DABT (current EL), IL = 32 bits [ 800.160444] SET = 0, FnV = 0 [ 800.163488] EA = 0, S1PTW = 0 [ 800.166619] FSC = 0x05: level 1 translation fault [ 800.171487] Data abort info: [ 800.174357] ISV = 0, ISS = 0x00000005, ISS2 = 0x00000000 [ 800.179832] CM = 0, WnR = 0, TnD = 0, TagAccess = 0 [ 800.184873] GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 [ 800.190176] user pgtable: 4k pages, 39-bit VAs, pgdp=00000001014c2000 [ 800.196607] [0000000000000588] pgd=0000000000000000, p4d=0000000000000000, pud=0000000000000000 [ 800.205305] Internal error: Oops: 0000000096000005 [#1] PREEMPT SMP [ 800.211564] Modules linked in: vc4 snd_soc_hdmi_codec drm_display_helper v3d cec gpu_sched drm_dma_helper drm_shmem_helper drm_kms_helper drm drm_panel_orientation_quirks snd_soc_core snd_compress snd_pcm_dmaengine snd_pcm i2c_brcmstb snd_timer snd backlight [ 800.234448] CPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.12.25+rpt-rpi-v8 #1 Debian 1:6.12.25-1+rpt1 [ 800.244182] Hardware name: Raspberry Pi 4 Model B Rev 1.4 (DT) [ 800.250005] pstate: 600000c5 (nZCv daIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 800.256959] pc : v3d_job_update_stats+0x60/0x130 [v3d] [ 800.262112] lr : v3d_job_update_stats+0x48/0x130 [v3d] [ 800.267251] sp : ffffffc080003e60 [ 800.270555] x29: ffffffc080003e60 x28: ffffffd842784980 x27: 0224012000000000 [ 800.277687] x26: ffffffd84277f630 x25: ffffff81012fd800 x24: 0000000000000020 [ 800.284818] x23: ffffff8040238b08 x22: 0000000000000570 x21: 0000000000000158 [ 800.291948] x20: 0000000000000000 x19: ffffff8040238000 x18: 0000000000000000 [ 800.299078] x17: ffffffa8c1bd2000 x16: ffffffc080000000 x15: 0000000000000000 [ 800.306208] x14: 0000000000000000 x13: 0000000000000000 x12: 0000000000000000 [ 800.313338] x11: 0000000000000040 x10: 0000000000001a40 x9 : ffffffd83b39757c [ 800.320468] x8 : ffffffd842786420 x7 : 7fffffffffffffff x6 : 0000000000ef32b0 [ 800.327598] x5 : 00ffffffffffffff x4 : 0000000000000015 x3 : ffffffd842784980 [ 800.334728] x2 : 0000000000000004 x1 : 0000000000010002 x0 : 000000ba4c0ca382 [ 800.341859] Call trace: [ 800.344294] v3d_job_update_stats+0x60/0x130 [v3d] [ 800.349086] v3d_irq+0x124/0x2e0 [v3d] [ 800.352835] __handle_irq_event_percpu+0x58/0x218 [ 800.357539] handle_irq_event+0x54/0xb8 [ 800.361369] handle_fasteoi_irq+0xac/0x240 [ 800.365458] handle_irq_desc+0x48/0x68 [ 800.369200] generic_handle_domain_irq+0x24/0x38 [ 800.373810] gic_handle_irq+0x48/0xd8 [ 800.377464] call_on_irq_stack+0x24/0x58 [ 800.381379] do_interrupt_handler+0x88/0x98 [ 800.385554] el1_interrupt+0x34/0x68 [ 800.389123] el1h_64_irq_handler+0x18/0x28 [ 800.393211] el1h_64_irq+0x64/0x68 [ 800.396603] default_idle_call+0x3c/0x168 [ 800.400606] do_idle+0x1fc/0x230 [ 800.403827] cpu_startup_entry+0x40/0x50 [ 800.407742] rest_init+0xe4/0xf0 [ 800.410962] start_kernel+0x5e8/0x790 [ 800.414616] __primary_switched+0x80/0x90 [ 800.418622] Code: 8b170277 8b160296 11000421 b9000861 (b9401ac1) [ 800.424707] ---[ end trace 0000000000000000 ]--- [ 800.457313] ---[ end Kernel panic - not syncing: Oops: Fatal exception in interrupt ]--- This issue happens when the file descriptor is closed before the jobs submitted by it are completed. When the job completes, we update the global GPU stats and the per-fd GPU stats, which are exposed through fdinfo. If the file descriptor was closed, then the struct `v3d_file_priv` and its stats were already freed and we can't update the per-fd stats. Therefore, if the file descriptor was already closed, don't u ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/4f4701489d0f768a232b10d281491184f34bacf0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c886784000934d5486621106da0614c85bcd76a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e1bc3a13bd775791cca0bb144d977b00f3598042"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38190,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:26.017,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: atm: Revert atm_account_tx() if copy_from_iter_full() fails. In vcc_sendmsg(), we account skb->truesize to sk->sk_wmem_alloc by atm_account_tx(). It is expected to be reverted by atm_pop_raw() later called by vcc->dev->ops->send(vcc, skb). However, vcc_sendmsg() misses the same revert when copy_from_iter_full() fails, and then we will leak a socket. Let's factorise the revert part as atm_return_tx() and call it in the failure path. Note that the corresponding sk_wmem_alloc operation can be found in alloc_tx() as of the blamed commit. $ git blame -L:alloc_tx net/atm/common.c c55fa3cccbc2c~",,"[{""url"":""https://git.kernel.org/stable/c/2252c539c43f9a1431a7e8b34e3c18e9dd77a96d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/287b4f085d2ca3375cf1ee672af27410c64777e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3902205eadf35db59dbc2186c2a98b9e6182efa5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3d828519bd69bfcaabdd942a872679617ef06739"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e0d00992118e234ebf29d5145c1cc920342777e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7851263998d4269125fd6cb3fdbfc7c6db853859"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d6bc28cfe5c8e3a279b4b4bdeed6698b2702685"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c12430edd92fd49a4800b0f3fb395b50cb16bcc1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38191,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:26.157,2025-08-09T15:15:28.460,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix null pointer dereference in destroy_previous_session If client set ->PreviousSessionId on kerberos session setup stage, NULL pointer dereference error will happen. Since sess->user is not set yet, It can pass the user argument as NULL to destroy_previous_session. sess->user will be set in ksmbd_krb5_authenticate(). So this patch move calling destroy_previous_session() after ksmbd_krb5_authenticate().",,"[{""url"":""https://git.kernel.org/stable/c/076f1adefb9837977af7ed233883842ddc446644"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0902625a24eea7fdc187faa5d97df244d159dd6e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1193486dffb7432a09f57f5d09049b4d4123538b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/281afc52e2961cd5dd8326ebc9c5bc40904c0468"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ac5b66acafcc9292fb935d7e03790f2b8b2dc0e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://www.zerodayinitiative.com/advisories/ZDI-25-610/"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38192,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:26.280,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: clear the dst when changing skb protocol A not-so-careful NAT46 BPF program can crash the kernel if it indiscriminately flips ingress packets from v4 to v6: BUG: kernel NULL pointer dereference, address: 0000000000000000 ip6_rcv_core (net/ipv6/ip6_input.c:190:20) ipv6_rcv (net/ipv6/ip6_input.c:306:8) process_backlog (net/core/dev.c:6186:4) napi_poll (net/core/dev.c:6906:9) net_rx_action (net/core/dev.c:7028:13) do_softirq (kernel/softirq.c:462:3) netif_rx (net/core/dev.c:5326:3) dev_loopback_xmit (net/core/dev.c:4015:2) ip_mc_finish_output (net/ipv4/ip_output.c:363:8) NF_HOOK (./include/linux/netfilter.h:314:9) ip_mc_output (net/ipv4/ip_output.c:400:5) dst_output (./include/net/dst.h:459:9) ip_local_out (net/ipv4/ip_output.c:130:9) ip_send_skb (net/ipv4/ip_output.c:1496:8) udp_send_skb (net/ipv4/udp.c:1040:8) udp_sendmsg (net/ipv4/udp.c:1328:10) The output interface has a 4->6 program attached at ingress. We try to loop the multicast skb back to the sending socket. Ingress BPF runs as part of netif_rx(), pushes a valid v6 hdr and changes skb->protocol to v6. We enter ip6_rcv_core which tries to use skb_dst(). But the dst is still an IPv4 one left after IPv4 mcast output. Clear the dst in all BPF helpers which change the protocol. Try to preserve metadata dsts, those may carry non-routing metadata.",,"[{""url"":""https://git.kernel.org/stable/c/2a3ad42a57b43145839f2f233fb562247658a6d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba9db6f907ac02215e30128770f85fbd7db2fcf9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bfa4d86e130a09f67607482e988313430e38f6c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e9994e7b9f7bbb882d13c8191731649249150d21"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38193,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:26.403,2025-08-28T15:15:48.243,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net_sched: sch_sfq: reject invalid perturb period Gerrard Tai reported that SFQ perturb_period has no range check yet, and this can be used to trigger a race condition fixed in a separate patch. We want to make sure ctl->perturb_period * HZ will not overflow and is positive. tc qd add dev lo root sfq perturb -10 # negative value : error Error: sch_sfq: invalid perturb period. tc qd add dev lo root sfq perturb 1000000000 # too big : error Error: sch_sfq: invalid perturb period. tc qd add dev lo root sfq perturb 2000000 # acceptable value tc -s -d qd sh dev lo qdisc sfq 8005: root refcnt 2 limit 127p quantum 64Kb depth 127 flows 128 divisor 1024 perturb 2000000sec Sent 0 bytes 0 pkt (dropped 0, overlimits 0 requeues 0) backlog 0b 0p requeues 0",,"[{""url"":""https://git.kernel.org/stable/c/0357da9149eac621f39e235a135ebf155f01f7c3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2254d038dab9c194fe6a4b1ce31034f42e91a6e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/590b2d7d0beadba2aa576708a05a05f0aae39295"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ca52541c05c832d32b112274f81a985101f9ba8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/956b5aebb349449b38d920d444ca1392d43719d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b11a50544af691b787384089b68f740ae20a441b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0936ff56be4e08ad5b60ec26971eae0c40af305"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f9b97d466e6026ccbdda30bb5b71965b67ccbc82"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38194,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:26.530,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: jffs2: check that raw node were preallocated before writing summary Syzkaller detected a kernel bug in jffs2_link_node_ref, caused by fault injection in jffs2_prealloc_raw_node_refs. jffs2_sum_write_sumnode doesn't check return value of jffs2_prealloc_raw_node_refs and simply lets any error propagate into jffs2_sum_write_data, which eventually calls jffs2_link_node_ref in order to link the summary to an expectedly allocated node. kernel BUG at fs/jffs2/nodelist.c:592! invalid opcode: 0000 [#1] PREEMPT SMP KASAN NOPTI CPU: 1 PID: 31277 Comm: syz-executor.7 Not tainted 6.1.128-syzkaller-00139-ge10f83ca10a1 #0 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014 RIP: 0010:jffs2_link_node_ref+0x570/0x690 fs/jffs2/nodelist.c:592 Call Trace: <TASK> jffs2_sum_write_data fs/jffs2/summary.c:841 [inline] jffs2_sum_write_sumnode+0xd1a/0x1da0 fs/jffs2/summary.c:874 jffs2_do_reserve_space+0xa18/0xd60 fs/jffs2/nodemgmt.c:388 jffs2_reserve_space+0x55f/0xaa0 fs/jffs2/nodemgmt.c:197 jffs2_write_inode_range+0x246/0xb50 fs/jffs2/write.c:362 jffs2_write_end+0x726/0x15d0 fs/jffs2/file.c:301 generic_perform_write+0x314/0x5d0 mm/filemap.c:3856 __generic_file_write_iter+0x2ae/0x4d0 mm/filemap.c:3973 generic_file_write_iter+0xe3/0x350 mm/filemap.c:4005 call_write_iter include/linux/fs.h:2265 [inline] do_iter_readv_writev+0x20f/0x3c0 fs/read_write.c:735 do_iter_write+0x186/0x710 fs/read_write.c:861 vfs_iter_write+0x70/0xa0 fs/read_write.c:902 iter_file_splice_write+0x73b/0xc90 fs/splice.c:685 do_splice_from fs/splice.c:763 [inline] direct_splice_actor+0x10c/0x170 fs/splice.c:950 splice_direct_to_actor+0x337/0xa10 fs/splice.c:896 do_splice_direct+0x1a9/0x280 fs/splice.c:1002 do_sendfile+0xb13/0x12c0 fs/read_write.c:1255 __do_sys_sendfile64 fs/read_write.c:1323 [inline] __se_sys_sendfile64 fs/read_write.c:1309 [inline] __x64_sys_sendfile64+0x1cf/0x210 fs/read_write.c:1309 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_64+0x35/0x80 arch/x86/entry/common.c:81 entry_SYSCALL_64_after_hwframe+0x6e/0xd8 Fix this issue by checking return value of jffs2_prealloc_raw_node_refs before calling jffs2_sum_write_data. Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",,"[{""url"":""https://git.kernel.org/stable/c/337f80f3d546e131c7aa90b61d8cde051ae858c7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/346cfb9d19ea7feb6fb57917b21c4797fb444dab"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f46644a5131a4793fc95c32a7d0a769745b06e7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4adee34098a6ee86a54bf3ec885eab620c126a6b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ce46dc5b10b0b6f67663202a4921b0e11ad7367"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c0edcdb4fc106d69a2d1a0ce4868193511c389f3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da12ef7e19048dc5714032c2db587a215852b200"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec9e6f22bce433b260ea226de127ec68042849b0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38195,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:26.667,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: LoongArch: Fix panic caused by NULL-PMD in huge_pte_offset() ERROR INFO: CPU 25 Unable to handle kernel paging request at virtual address 0x0 ... Call Trace: [<900000000023c30c>] huge_pte_offset+0x3c/0x58 [<900000000057fd4c>] hugetlb_follow_page_mask+0x74/0x438 [<900000000051fee8>] __get_user_pages+0xe0/0x4c8 [<9000000000522414>] faultin_page_range+0x84/0x380 [<9000000000564e8c>] madvise_vma_behavior+0x534/0xa48 [<900000000056689c>] do_madvise+0x1bc/0x3e8 [<9000000000566df4>] sys_madvise+0x24/0x38 [<90000000015b9e88>] do_syscall+0x78/0x98 [<9000000000221f18>] handle_syscall+0xb8/0x158 In some cases, pmd may be NULL and rely on NULL as the return value for processing, so it is necessary to determine this situation here.",,"[{""url"":""https://git.kernel.org/stable/c/985f086f281b7bbb6644851e63af1a17ffff9277"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b427d98d55217b53c88643579fbbd8a4c351a105"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b5c7397b7fd125203c60b59860c168ee92291272"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee084fa96123ede8b0563a1b5a9b23adc43cd50d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38196,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:26.787,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: io_uring/rsrc: validate buffer count with offset for cloning syzbot reports that it can trigger a WARN_ON() for kmalloc() attempt that's too big: WARNING: CPU: 0 PID: 6488 at mm/slub.c:5024 __kvmalloc_node_noprof+0x520/0x640 mm/slub.c:5024 Modules linked in: CPU: 0 UID: 0 PID: 6488 Comm: syz-executor312 Not tainted 6.15.0-rc7-syzkaller-gd7fa1af5b33e #0 PREEMPT Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025 pstate: 20400005 (nzCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : __kvmalloc_node_noprof+0x520/0x640 mm/slub.c:5024 lr : __do_kmalloc_node mm/slub.c:-1 [inline] lr : __kvmalloc_node_noprof+0x3b4/0x640 mm/slub.c:5012 sp : ffff80009cfd7a90 x29: ffff80009cfd7ac0 x28: ffff0000dd52a120 x27: 0000000000412dc0 x26: 0000000000000178 x25: ffff7000139faf70 x24: 0000000000000000 x23: ffff800082f4cea8 x22: 00000000ffffffff x21: 000000010cd004a8 x20: ffff0000d75816c0 x19: ffff0000dd52a000 x18: 00000000ffffffff x17: ffff800092f39000 x16: ffff80008adbe9e4 x15: 0000000000000005 x14: 1ffff000139faf1c x13: 0000000000000000 x12: 0000000000000000 x11: ffff7000139faf21 x10: 0000000000000003 x9 : ffff80008f27b938 x8 : 0000000000000002 x7 : 0000000000000000 x6 : 0000000000000000 x5 : 00000000ffffffff x4 : 0000000000400dc0 x3 : 0000000200000000 x2 : 000000010cd004a8 x1 : ffff80008b3ebc40 x0 : 0000000000000001 Call trace: __kvmalloc_node_noprof+0x520/0x640 mm/slub.c:5024 (P) kvmalloc_array_node_noprof include/linux/slab.h:1065 [inline] io_rsrc_data_alloc io_uring/rsrc.c:206 [inline] io_clone_buffers io_uring/rsrc.c:1178 [inline] io_register_clone_buffers+0x484/0xa14 io_uring/rsrc.c:1287 __io_uring_register io_uring/register.c:815 [inline] __do_sys_io_uring_register io_uring/register.c:926 [inline] __se_sys_io_uring_register io_uring/register.c:903 [inline] __arm64_sys_io_uring_register+0x42c/0xea8 io_uring/register.c:903 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline] invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151 el0_svc+0x58/0x17c arch/arm64/kernel/entry-common.c:767 el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:786 el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600 which is due to offset + buffer_count being too large. The registration code checks only the total count of buffers, but given that the indexing is an array, it should also check offset + count. That can't exceed IORING_MAX_REG_BUFFERS either, as there's no way to reach buffers beyond that limit. There's no issue with registrering a table this large, outside of the fact that it's pointless to register buffers that cannot be reached, and that it can trigger this kmalloc() warning for attempting an allocation that is too large.",,"[{""url"":""https://git.kernel.org/stable/c/0e23ac818f3afb16660b0ba384875d56a7013879"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1d27f11bf02b38c431e49a17dee5c10a2b4c2e28"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38197,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:26.913,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: platform/x86: dell_rbu: Fix list usage Pass the correct list head to list_for_each_entry*() when looping through the packet list. Without this patch, reading the packet data via sysfs will show the data incorrectly (because it starts at the wrong packet), and clearing the packet list will result in a NULL pointer dereference.",,"[{""url"":""https://git.kernel.org/stable/c/07d7b8e7ef7d1f812a6211ed531947c56d09e95e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/32d05e6cc3a7bf6c8f16f7b7ef8fe80eca0c233e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4d71f2c1e5263a9f042faa71d59515709869dc79"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e8c658acd1b7c186aeffa46bf08795e121f401a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/61ce04601e0d8265ec6d2ffa6df5a7e1bce64854"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a7b477b64ef5e37cb08dd536ae07c46f9f28262e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f3b840fb1508a80cd8a0efb5c886ae1995a88b24"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38198,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:27.040,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fbcon: Make sure modelist not set on unregistered console It looks like attempting to write to the ""store_modes"" sysfs node will run afoul of unregistered consoles: UBSAN: array-index-out-of-bounds in drivers/video/fbdev/core/fbcon.c:122:28 index -1 is out of range for type 'fb_info *[32]' ... fbcon_info_from_console+0x192/0x1a0 drivers/video/fbdev/core/fbcon.c:122 fbcon_new_modelist+0xbf/0x2d0 drivers/video/fbdev/core/fbcon.c:3048 fb_new_modelist+0x328/0x440 drivers/video/fbdev/core/fbmem.c:673 store_modes+0x1c9/0x3e0 drivers/video/fbdev/core/fbsysfs.c:113 dev_attr_store+0x55/0x80 drivers/base/core.c:2439 static struct fb_info *fbcon_registered_fb[FB_MAX]; ... static signed char con2fb_map[MAX_NR_CONSOLES]; ... static struct fb_info *fbcon_info_from_console(int console) ... return fbcon_registered_fb[con2fb_map[console]]; If con2fb_map contains a -1 things go wrong here. Instead, return NULL, as callers of fbcon_info_from_console() are trying to compare against existing ""info"" pointers, so error handling should kick in correctly.",,"[{""url"":""https://git.kernel.org/stable/c/519ba75728ee8cd561dce25fc52a2ec5c47171dc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/54b28f7c567dd659e5f9562f518e4d7f3f6a367b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3237d451bf3a4490cb1a76f3b7c91d9888f1c4b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cedc1b63394a866bf8663a3e40f4546f1d28c8d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f28f1f578cd810779d01999c60618cda14c281dd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38199,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:27.707,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: Fix memory leak due to multiple rx_stats allocation rx_stats for each arsta is allocated when adding a station. arsta->rx_stats will be freed when a station is removed. Redundant allocations are occurring when the same station is added multiple times. This causes ath12k_mac_station_add() to be called multiple times, and rx_stats is allocated each time. As a result there is memory leaks. Prevent multiple allocations of rx_stats when ath12k_mac_station_add() is called repeatedly by checking if rx_stats is already allocated before allocating again. Allocate arsta->rx_stats if arsta->rx_stats is NULL respectively. Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1 Tested-on: WCN7850 hw2.0 PCI WLAN.HMT.1.0.c5-00481-QCAHMTSWPL_V1.0_V2.0_SILICONZ-3",,"[{""url"":""https://git.kernel.org/stable/c/232f962ae5fca98912a719e64b4964a5aec7c99b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c426497fa2055c8005196922e7d29c41d7e0948a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38200,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:27.877,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: i40e: fix MMIO write access to an invalid page in i40e_clear_hw When the device sends a specific input, an integer underflow can occur, leading to MMIO write access to an invalid page. Prevent the integer underflow by changing the type of related variables.",,"[{""url"":""https://git.kernel.org/stable/c/015bac5daca978448f2671478c553ce1f300c21e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2a1f4f2e36442a9bdf771acf6ee86f3cf876e5ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3502dd42f178dae9d54696013386bb52b4f2e655"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e75c9082987479e647c75ec8fdf18fa68263c42"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/872607632c658d3739e4e7889e4f3c419ae2c193"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8cde755f56163281ec2c46b4ae8b61f532758a6f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d88a1e8f024ba26e19350958fecbf771a9960352"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fecb2fc3fc10c95724407cc45ea35af4a65cdde2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38201,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:28.000,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: nft_set_pipapo: clamp maximum map bucket size to INT_MAX Otherwise, it is possible to hit WARN_ON_ONCE in __kvmalloc_node_noprof() when resizing hashtable because __GFP_NOWARN is unset. Similar to: b541ba7d1f5a (""netfilter: conntrack: clamp maximum hashtable size to INT_MAX"")",,"[{""url"":""https://git.kernel.org/stable/c/0ab3de047808f375a36cd345225572eb3366f3c6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b85e3367a5716ed3662a4fe266525190d2af76df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d2768016f091f8a5264076b433fd7c3fabb6eb97"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38202,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:28.117,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf: Check rcu_read_lock_trace_held() in bpf_map_lookup_percpu_elem() bpf_map_lookup_percpu_elem() helper is also available for sleepable bpf program. When BPF JIT is disabled or under 32-bit host, bpf_map_lookup_percpu_elem() will not be inlined. Using it in a sleepable bpf program will trigger the warning in bpf_map_lookup_percpu_elem(), because the bpf program only holds rcu_read_lock_trace lock. Therefore, add the missed check.",,"[{""url"":""https://git.kernel.org/stable/c/2d834477bbc1e8b8a59ff8b0c081529d6bed7b22"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2f8c69a72e8ad87b36b8052f789da3cc2b2e186c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7bf4461f1c97207fda757014690d55a447ce859f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b522d4d334f206284b1a44b0b0b2f99fd443b39b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d4965578267e2e81f67c86e2608481e77e9c8569"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38203,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:28.247,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: jfs: Fix null-ptr-deref in jfs_ioc_trim [ Syzkaller Report ] Oops: general protection fault, probably for non-canonical address 0xdffffc0000000087: 0000 [#1 KASAN: null-ptr-deref in range [0x0000000000000438-0x000000000000043f] CPU: 2 UID: 0 PID: 10614 Comm: syz-executor.0 Not tainted 6.13.0-rc6-gfbfd64d25c7a-dirty #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 Sched_ext: serialise (enabled+all), task: runnable_at=-30ms RIP: 0010:jfs_ioc_trim+0x34b/0x8f0 Code: e7 e8 59 a4 87 fe 4d 8b 24 24 4d 8d bc 24 38 04 00 00 48 8d 93 90 82 fe ff 4c 89 ff 31 f6 RSP: 0018:ffffc900055f7cd0 EFLAGS: 00010206 RAX: 0000000000000087 RBX: 00005866a9e67ff8 RCX: 000000000000000a RDX: 0000000000000001 RSI: 0000000000000004 RDI: 0000000000000001 RBP: dffffc0000000000 R08: ffff88807c180003 R09: 1ffff1100f830000 R10: dffffc0000000000 R11: ffffed100f830001 R12: 0000000000000000 R13: 0000000000000000 R14: 0000000000000001 R15: 0000000000000438 FS: 00007fe520225640(0000) GS:ffff8880b7e80000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00005593c91b2c88 CR3: 000000014927c000 CR4: 00000000000006f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ? __die_body+0x61/0xb0 ? die_addr+0xb1/0xe0 ? exc_general_protection+0x333/0x510 ? asm_exc_general_protection+0x26/0x30 ? jfs_ioc_trim+0x34b/0x8f0 jfs_ioctl+0x3c8/0x4f0 ? __pfx_jfs_ioctl+0x10/0x10 ? __pfx_jfs_ioctl+0x10/0x10 __se_sys_ioctl+0x269/0x350 ? __pfx___se_sys_ioctl+0x10/0x10 ? do_syscall_64+0xfb/0x210 do_syscall_64+0xee/0x210 ? syscall_exit_to_user_mode+0x1e0/0x330 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7fe51f4903ad Code: c3 e8 a7 2b 00 00 0f 1f 80 00 00 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d RSP: 002b:00007fe5202250c8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 00007fe51f5cbf80 RCX: 00007fe51f4903ad RDX: 0000000020000680 RSI: 00000000c0185879 RDI: 0000000000000005 RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 00007fe520225640 R13: 000000000000000e R14: 00007fe51f44fca0 R15: 00007fe52021d000 </TASK> Modules linked in: ---[ end trace 0000000000000000 ]--- RIP: 0010:jfs_ioc_trim+0x34b/0x8f0 Code: e7 e8 59 a4 87 fe 4d 8b 24 24 4d 8d bc 24 38 04 00 00 48 8d 93 90 82 fe ff 4c 89 ff 31 f6 RSP: 0018:ffffc900055f7cd0 EFLAGS: 00010206 RAX: 0000000000000087 RBX: 00005866a9e67ff8 RCX: 000000000000000a RDX: 0000000000000001 RSI: 0000000000000004 RDI: 0000000000000001 RBP: dffffc0000000000 R08: ffff88807c180003 R09: 1ffff1100f830000 R10: dffffc0000000000 R11: ffffed100f830001 R12: 0000000000000000 R13: 0000000000000000 R14: 0000000000000001 R15: 0000000000000438 FS: 00007fe520225640(0000) GS:ffff8880b7e80000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00005593c91b2c88 CR3: 000000014927c000 CR4: 00000000000006f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Kernel panic - not syncing: Fatal exception [ Analysis ] We believe that we have found a concurrency bug in the `fs/jfs` module that results in a null pointer dereference. There is a closely related issue which has been fixed: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d6c1b3599b2feb5c7291f5ac3a36e5fa7cedb234 ... but, unfortunately, the accepted patch appears to still be susceptible to a null pointer dereference under some interleavings. To trigger the bug, we think that `JFS_SBI(ipbmap->i_sb)->bmap` is set to NULL in `dbFreeBits` and then dereferenced in `jfs_ioc_trim`. This bug manifests quite rarely under normal circumstances, but is triggereable from a syz-program.",,"[{""url"":""https://git.kernel.org/stable/c/0d50231d473f89024158dc62624930de45d13718"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4a8cb9908b51500a76f5156423bd295df53bff89"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9806ae34d7d661c372247cd36f83bfa0523d60ed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a4685408ff6c3e2af366ad9a7274f45ff3f394ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9d41c925069c950e18160e12a7e10e0f58c56fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38204,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:28.383,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: jfs: fix array-index-out-of-bounds read in add_missing_indices stbl is s8 but it must contain offsets into slot which can go from 0 to 127. Added a bound check for that error and return -EIO if the check fails. Also make jfs_readdir return with error if add_missing_indices returns with an error.",,"[{""url"":""https://git.kernel.org/stable/c/44618bee303bed151ef3a525ff79fbd7689593b5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5dff41a86377563f7a2b968aae00d25b4ceb37c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/81af4b34fd72d390d7f237c6a545cc6d09707956"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bfa4655d28f338e68d345aed80d19be7999bbce2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c8399564a58fb6ea2ff21a6fd278417943cb51a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38205,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:28.540,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Avoid divide by zero by initializing dummy pitch to 1 [Why] If the dummy values in `populate_dummy_dml_surface_cfg()` aren't updated then they can lead to a divide by zero in downstream callers like CalculateVMAndRowBytes() [How] Initialize dummy value to a value to avoid divide by zero.",,"[{""url"":""https://git.kernel.org/stable/c/7e40f64896e8e3dca471e287672db5ace12ea0be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8044f981b2cf8c32fe1bd5d1fc991552cdf7ffe0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38206,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:28.703,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: exfat: fix double free in delayed_free The double free could happen in the following path. exfat_create_upcase_table() exfat_create_upcase_table() : return error exfat_free_upcase_table() : free ->vol_utbl exfat_load_default_upcase_table : return error exfat_kill_sb() delayed_free() exfat_free_upcase_table() <--------- double free This patch set ->vol_util as NULL after freeing it.",,"[{""url"":""https://git.kernel.org/stable/c/13d8de1b6568dcc31a95534ced16bc0c9a67bc15"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1f3d9724e16d62c7d42c67d6613b8512f2887c22"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/66e84439ec2af776ce749e8540f8fdd257774152"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3cef0e7a5c1aa6217c51faa9ce8ecac35d6e1fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38207,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:28.823,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm: fix uprobe pte be overwritten when expanding vma Patch series ""Fix uprobe pte be overwritten when expanding vma"". This patch (of 4): We encountered a BUG alert triggered by Syzkaller as follows: BUG: Bad rss-counter state mm:00000000b4a60fca type:MM_ANONPAGES val:1 And we can reproduce it with the following steps: 1. register uprobe on file at zero offset 2. mmap the file at zero offset: addr1 = mmap(NULL, 2 * 4096, PROT_NONE, MAP_PRIVATE, fd, 0); 3. mremap part of vma1 to new vma2: addr2 = mremap(addr1, 4096, 2 * 4096, MREMAP_MAYMOVE); 4. mremap back to orig addr1: mremap(addr2, 4096, 4096, MREMAP_MAYMOVE | MREMAP_FIXED, addr1); In step 3, the vma1 range [addr1, addr1 + 4096] will be remap to new vma2 with range [addr2, addr2 + 8192], and remap uprobe anon page from the vma1 to vma2, then unmap the vma1 range [addr1, addr1 + 4096]. In step 4, the vma2 range [addr2, addr2 + 4096] will be remap back to the addr range [addr1, addr1 + 4096]. Since the addr range [addr1 + 4096, addr1 + 8192] still maps the file, it will take vma_merge_new_range to expand the range, and then do uprobe_mmap in vma_complete. Since the merged vma pgoff is also zero offset, it will install uprobe anon page to the merged vma. However, the upcomming move_page_tables step, which use set_pte_at to remap the vma2 uprobe pte to the merged vma, will overwrite the newly uprobe pte in the merged vma, and lead that pte to be orphan. Since the uprobe pte will be remapped to the merged vma, we can remove the unnecessary uprobe_mmap upon merged vma. This problem was first found in linux-6.6.y and also exists in the community syzkaller: https://lore.kernel.org/all/000000000000ada39605a5e71711@google.com/T/",,"[{""url"":""https://git.kernel.org/stable/c/2b12d06c37fd3a394376f42f026a7478d826ed63"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/58b83b9a9a929611a2a2e7d88f45cb0d786b7ee0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38208,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:28.950,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: smb: client: add NULL check in automount_fullpath page is checked for null in __build_path_from_dentry_optional_prefix when tcon->origin_fullpath is not set. However, the check is missing when it is set. Add a check to prevent a potential NULL pointer dereference.",,"[{""url"":""https://git.kernel.org/stable/c/37166d63e42c34846a16001950ecec96229a8d17"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9e916fa5c7d0ec2256aa44aa24ddd92f529ce35"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cce8e71ca1f7ad9045707f0d22490c1e9ed1df6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1e7a277a1736e12cc4bd6d93b8a5c439b8ca20c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38209,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:29.080,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nvme-tcp: remove tag set when second admin queue config fails Commit 104d0e2f6222 (""nvme-fabrics: reset admin connection for secure concatenation"") modified nvme_tcp_setup_ctrl() to call nvme_tcp_configure_admin_queue() twice. The first call prepares for DH-CHAP negotitation, and the second call is required for secure concatenation. However, this change triggered BUG KASAN slab-use-after- free in blk_mq_queue_tag_busy_iter(). This BUG can be recreated by repeating the blktests test case nvme/063 a few times [1]. When the BUG happens, nvme_tcp_create_ctrl() fails in the call chain below: nvme_tcp_create_ctrl() nvme_tcp_alloc_ctrl() new=true ... Alloc nvme_tcp_ctrl and admin_tag_set nvme_tcp_setup_ctrl() new=true nvme_tcp_configure_admin_queue() new=true ... Succeed nvme_alloc_admin_tag_set() ... Alloc the tag set for admin_tag_set nvme_stop_keep_alive() nvme_tcp_teardown_admin_queue() remove=false nvme_tcp_configure_admin_queue() new=false nvme_tcp_alloc_admin_queue() ... Fail, but do not call nvme_remove_admin_tag_set() nvme_uninit_ctrl() nvme_put_ctrl() ... Free up the nvme_tcp_ctrl and admin_tag_set The first call of nvme_tcp_configure_admin_queue() succeeds with new=true argument. The second call fails with new=false argument. This second call does not call nvme_remove_admin_tag_set() on failure, due to the new=false argument. Then the admin tag set is not removed. However, nvme_tcp_create_ctrl() assumes that nvme_tcp_setup_ctrl() would call nvme_remove_admin_tag_set(). Then it frees up struct nvme_tcp_ctrl which has admin_tag_set field. Later on, the timeout handler accesses the admin_tag_set field and causes the BUG KASAN slab-use-after-free. To not leave the admin tag set, call nvme_remove_admin_tag_set() when the second nvme_tcp_configure_admin_queue() call fails. Do not return from nvme_tcp_setup_ctrl() on failure. Instead, jump to ""destroy_admin"" go-to label to call nvme_tcp_teardown_admin_queue() which calls nvme_remove_admin_tag_set().",,"[{""url"":""https://git.kernel.org/stable/c/db1da838b6012e4570c6f81e28ffe1d0ff595948"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e7143706702a209c814ed2c3fc6486c2a7decf6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38210,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:29.207,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: configfs-tsm-report: Fix NULL dereference of tsm_ops Unlike sysfs, the lifetime of configfs objects is controlled by userspace. There is no mechanism for the kernel to find and delete all created config-items. Instead, the configfs-tsm-report mechanism has an expectation that tsm_unregister() can happen at any time and cause established config-item access to start failing. That expectation is not fully satisfied. While tsm_report_read(), tsm_report_{is,is_bin}_visible(), and tsm_report_make_item() safely fail if tsm_ops have been unregistered, tsm_report_privlevel_store() tsm_report_provider_show() fail to check for ops registration. Add the missing checks for tsm_ops having been removed. Now, in supporting the ability for tsm_unregister() to always succeed, it leaves the problem of what to do with lingering config-items. The expectation is that the admin that arranges for the ->remove() (unbind) of the ${tsm_arch}-guest driver is also responsible for deletion of all open config-items. Until that deletion happens, ->probe() (reload / bind) of the ${tsm_arch}-guest driver fails. This allows for emergency shutdown / revocation of attestation interfaces, and requires coordinated restart.",,"[{""url"":""https://git.kernel.org/stable/c/015f04ac884a454d4d8aaa7b67758f047742b1cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cefbafcbdef011d6ef9414902311afdfba3c33eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fba4ceaa242d2bdf4c04b77bda41d32d02d3925d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38211,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:29.337,2025-07-17T17:15:37.300,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/iwcm: Fix use-after-free of work objects after cm_id destruction The commit 59c68ac31e15 (""iw_cm: free cm_id resources on the last deref"") simplified cm_id resource management by freeing cm_id once all references to the cm_id were removed. The references are removed either upon completion of iw_cm event handlers or when the application destroys the cm_id. This commit introduced the use-after-free condition where cm_id_private object could still be in use by event handler works during the destruction of cm_id. The commit aee2424246f9 (""RDMA/iwcm: Fix a use-after-free related to destroying CM IDs"") addressed this use-after- free by flushing all pending works at the cm_id destruction. However, still another use-after-free possibility remained. It happens with the work objects allocated for each cm_id_priv within alloc_work_entries() during cm_id creation, and subsequently freed in dealloc_work_entries() once all references to the cm_id are removed. If the cm_id's last reference is decremented in the event handler work, the work object for the work itself gets removed, and causes the use- after-free BUG below: BUG: KASAN: slab-use-after-free in __pwq_activate_work+0x1ff/0x250 Read of size 8 at addr ffff88811f9cf800 by task kworker/u16:1/147091 CPU: 2 UID: 0 PID: 147091 Comm: kworker/u16:1 Not tainted 6.15.0-rc2+ #27 PREEMPT(voluntary) Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-3.fc41 04/01/2014 Workqueue: 0x0 (iw_cm_wq) Call Trace: <TASK> dump_stack_lvl+0x6a/0x90 print_report+0x174/0x554 ? __virt_addr_valid+0x208/0x430 ? __pwq_activate_work+0x1ff/0x250 kasan_report+0xae/0x170 ? __pwq_activate_work+0x1ff/0x250 __pwq_activate_work+0x1ff/0x250 pwq_dec_nr_in_flight+0x8c5/0xfb0 process_one_work+0xc11/0x1460 ? __pfx_process_one_work+0x10/0x10 ? assign_work+0x16c/0x240 worker_thread+0x5ef/0xfd0 ? __pfx_worker_thread+0x10/0x10 kthread+0x3b0/0x770 ? __pfx_kthread+0x10/0x10 ? rcu_is_watching+0x11/0xb0 ? _raw_spin_unlock_irq+0x24/0x50 ? rcu_is_watching+0x11/0xb0 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x30/0x70 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK> Allocated by task 147416: kasan_save_stack+0x2c/0x50 kasan_save_track+0x10/0x30 __kasan_kmalloc+0xa6/0xb0 alloc_work_entries+0xa9/0x260 [iw_cm] iw_cm_connect+0x23/0x4a0 [iw_cm] rdma_connect_locked+0xbfd/0x1920 [rdma_cm] nvme_rdma_cm_handler+0x8e5/0x1b60 [nvme_rdma] cma_cm_event_handler+0xae/0x320 [rdma_cm] cma_work_handler+0x106/0x1b0 [rdma_cm] process_one_work+0x84f/0x1460 worker_thread+0x5ef/0xfd0 kthread+0x3b0/0x770 ret_from_fork+0x30/0x70 ret_from_fork_asm+0x1a/0x30 Freed by task 147091: kasan_save_stack+0x2c/0x50 kasan_save_track+0x10/0x30 kasan_save_free_info+0x37/0x60 __kasan_slab_free+0x4b/0x70 kfree+0x13a/0x4b0 dealloc_work_entries+0x125/0x1f0 [iw_cm] iwcm_deref_id+0x6f/0xa0 [iw_cm] cm_work_handler+0x136/0x1ba0 [iw_cm] process_one_work+0x84f/0x1460 worker_thread+0x5ef/0xfd0 kthread+0x3b0/0x770 ret_from_fork+0x30/0x70 ret_from_fork_asm+0x1a/0x30 Last potentially related work creation: kasan_save_stack+0x2c/0x50 kasan_record_aux_stack+0xa3/0xb0 __queue_work+0x2ff/0x1390 queue_work_on+0x67/0xc0 cm_event_handler+0x46a/0x820 [iw_cm] siw_cm_upcall+0x330/0x650 [siw] siw_cm_work_handler+0x6b9/0x2b20 [siw] process_one_work+0x84f/0x1460 worker_thread+0x5ef/0xfd0 kthread+0x3b0/0x770 ret_from_fork+0x30/0x70 ret_from_fork_asm+0x1a/0x30 This BUG is reproducible by repeating the blktests test case nvme/061 for the rdma transport and the siw driver. To avoid the use-after-free of cm_id_private work objects, ensure that the last reference to the cm_id is decremented not in the event handler works, but in the cm_id destruction context. For that purpose, mo ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/013dcdf6f03bcedbaf1669e3db71c34a197715b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/23a707bbcbea468eedb398832eeb7e8e0ceafd21"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3b4a50d733acad6831f6bd9288a76a80f70650ac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6883b680e703c6b2efddb4e7a8d891ce1803d06b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/764c9f69beabef8bdc651a7746c59f7a340d104f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/78381dc8a6b61c9bb9987d37b4d671b99767c4a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf7eff5e3a36c54bbe8aff7fd6dd7c07490b81c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd960b5ddf4faf00da43babdd3acda68842e1f6a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38212,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:29.473,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ipc: fix to protect IPCS lookups using RCU syzbot reported that it discovered a use-after-free vulnerability, [0] [0]: https://lore.kernel.org/all/67af13f8.050a0220.21dd3.0038.GAE@google.com/ idr_for_each() is protected by rwsem, but this is not enough. If it is not protected by RCU read-critical region, when idr_for_each() calls radix_tree_node_free() through call_rcu() to free the radix_tree_node structure, the node will be freed immediately, and when reading the next node in radix_tree_for_each_slot(), the already freed memory may be read. Therefore, we need to add code to make sure that idr_for_each() is protected within the RCU read-critical region when we call it in shm_destroy_orphaned().",,"[{""url"":""https://git.kernel.org/stable/c/5180561afff8e0f029073c8c8117c95c6512d1f9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5f1e1573bf103303944fd7225559de5d8297539c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/68c173ea138b66d7dd1fd980c9bc578a18e11884"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74bc813d11c30e28fc5261dc877cca662ccfac68"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/78297d53d3878d43c1d627d20cd09f611fa4b91d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b0b6bf90ce2699a574b3683e22c44d0dcdd7a057"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b968ba8bfd9f90914957bbbd815413bf6a98eca7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d66adabe91803ef34a8b90613c81267b5ded1472"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38213,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:29.710,2025-08-11T16:15:29.973,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,[],,,,,,,,,,
CVE-2025-38214,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:29.843,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fbdev: Fix fb_set_var to prevent null-ptr-deref in fb_videomode_to_var If fb_add_videomode() in fb_set_var() fails to allocate memory for fb_videomode, later it may lead to a null-ptr dereference in fb_videomode_to_var(), as the fb_info is registered while not having the mode in modelist that is expected to be there, i.e. the one that is described in fb_info->var. ================================================================ general protection fault, probably for non-canonical address 0xdffffc0000000001: 0000 [#1] PREEMPT SMP KASAN NOPTI KASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f] CPU: 1 PID: 30371 Comm: syz-executor.1 Not tainted 5.10.226-syzkaller #0 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014 RIP: 0010:fb_videomode_to_var+0x24/0x610 drivers/video/fbdev/core/modedb.c:901 Call Trace: display_to_var+0x3a/0x7c0 drivers/video/fbdev/core/fbcon.c:929 fbcon_resize+0x3e2/0x8f0 drivers/video/fbdev/core/fbcon.c:2071 resize_screen drivers/tty/vt/vt.c:1176 [inline] vc_do_resize+0x53a/0x1170 drivers/tty/vt/vt.c:1263 fbcon_modechanged+0x3ac/0x6e0 drivers/video/fbdev/core/fbcon.c:2720 fbcon_update_vcs+0x43/0x60 drivers/video/fbdev/core/fbcon.c:2776 do_fb_ioctl+0x6d2/0x740 drivers/video/fbdev/core/fbmem.c:1128 fb_ioctl+0xe7/0x150 drivers/video/fbdev/core/fbmem.c:1203 vfs_ioctl fs/ioctl.c:48 [inline] __do_sys_ioctl fs/ioctl.c:753 [inline] __se_sys_ioctl fs/ioctl.c:739 [inline] __x64_sys_ioctl+0x19a/0x210 fs/ioctl.c:739 do_syscall_64+0x33/0x40 arch/x86/entry/common.c:46 entry_SYSCALL_64_after_hwframe+0x67/0xd1 ================================================================ The reason is that fb_info->var is being modified in fb_set_var(), and then fb_videomode_to_var() is called. If it fails to add the mode to fb_info->modelist, fb_set_var() returns error, but does not restore the old value of fb_info->var. Restore fb_info->var on failure the same way it is done earlier in the function. Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",,"[{""url"":""https://git.kernel.org/stable/c/05f6e183879d9785a3cdf2f08a498bc31b7a20aa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1a10d91766eb6ddfd5414e4785611e33a4fe0f9b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ca78032a388a0795201792b36e6fc9b6e6e8eed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8a3a2887794b2c8e78b3e5d6e3de724527c9f41b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3071bb463ea1e6c686d0dc9638fc940f2f5cf17"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee20216f12d9482cd70e44dae5e7fabb38367c71"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fab201d72fde38d081e2c5d4ad25595c535b7b22"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff0e037241173b574b385bff53d67567b9816db5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38215,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:29.980,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fbdev: Fix do_register_framebuffer to prevent null-ptr-deref in fb_videomode_to_var If fb_add_videomode() in do_register_framebuffer() fails to allocate memory for fb_videomode, it will later lead to a null-ptr dereference in fb_videomode_to_var(), as the fb_info is registered while not having the mode in modelist that is expected to be there, i.e. the one that is described in fb_info->var. ================================================================ general protection fault, probably for non-canonical address 0xdffffc0000000001: 0000 [#1] PREEMPT SMP KASAN NOPTI KASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f] CPU: 1 PID: 30371 Comm: syz-executor.1 Not tainted 5.10.226-syzkaller #0 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014 RIP: 0010:fb_videomode_to_var+0x24/0x610 drivers/video/fbdev/core/modedb.c:901 Call Trace: display_to_var+0x3a/0x7c0 drivers/video/fbdev/core/fbcon.c:929 fbcon_resize+0x3e2/0x8f0 drivers/video/fbdev/core/fbcon.c:2071 resize_screen drivers/tty/vt/vt.c:1176 [inline] vc_do_resize+0x53a/0x1170 drivers/tty/vt/vt.c:1263 fbcon_modechanged+0x3ac/0x6e0 drivers/video/fbdev/core/fbcon.c:2720 fbcon_update_vcs+0x43/0x60 drivers/video/fbdev/core/fbcon.c:2776 do_fb_ioctl+0x6d2/0x740 drivers/video/fbdev/core/fbmem.c:1128 fb_ioctl+0xe7/0x150 drivers/video/fbdev/core/fbmem.c:1203 vfs_ioctl fs/ioctl.c:48 [inline] __do_sys_ioctl fs/ioctl.c:753 [inline] __se_sys_ioctl fs/ioctl.c:739 [inline] __x64_sys_ioctl+0x19a/0x210 fs/ioctl.c:739 do_syscall_64+0x33/0x40 arch/x86/entry/common.c:46 entry_SYSCALL_64_after_hwframe+0x67/0xd1 ================================================================ Even though fbcon_init() checks beforehand if fb_match_mode() in var_to_display() fails, it can not prevent the panic because fbcon_init() does not return error code. Considering this and the comment in the code about fb_match_mode() returning NULL - ""This should not happen"" - it is better to prevent registering the fb_info if its mode was not set successfully. Also move fb_add_videomode() closer to the beginning of do_register_framebuffer() to avoid having to do the cleanup on fail. Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",,"[{""url"":""https://git.kernel.org/stable/c/0909b2b49c4546a7a08c80f53d93736b63270827"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/17186f1f90d34fa701e4f14e6818305151637b9e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f2098f4fba7718eb2501207ca6e99d22427f25a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/908c5bb64f9c4319902b8ca1aa3fef8f83302520"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d803c4c2a4ac8ce2be6d899d5c7ab0bf7ec355e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38216,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:30.103,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iommu/vt-d: Restore context entry setup order for aliased devices Commit 2031c469f816 (""iommu/vt-d: Add support for static identity domain"") changed the context entry setup during domain attachment from a set-and-check policy to a clear-and-reset approach. This inadvertently introduced a regression affecting PCI aliased devices behind PCIe-to-PCI bridges. Specifically, keyboard and touchpad stopped working on several Apple Macbooks with below messages: kernel: platform pxa2xx-spi.3: Adding to iommu group 20 kernel: input: Apple SPI Keyboard as /devices/pci0000:00/0000:00:1e.3/pxa2xx-spi.3/spi_master/spi2/spi-APP000D:00/input/input0 kernel: DMAR: DRHD: handling fault status reg 3 kernel: DMAR: [DMA Read NO_PASID] Request device [00:1e.3] fault addr 0xffffa000 [fault reason 0x06] PTE Read access is not set kernel: DMAR: DRHD: handling fault status reg 3 kernel: DMAR: [DMA Read NO_PASID] Request device [00:1e.3] fault addr 0xffffa000 [fault reason 0x06] PTE Read access is not set kernel: applespi spi-APP000D:00: Error writing to device: 01 0e 00 00 kernel: DMAR: DRHD: handling fault status reg 3 kernel: DMAR: [DMA Read NO_PASID] Request device [00:1e.3] fault addr 0xffffa000 [fault reason 0x06] PTE Read access is not set kernel: DMAR: DRHD: handling fault status reg 3 kernel: applespi spi-APP000D:00: Error writing to device: 01 0e 00 00 Fix this by restoring the previous context setup order.",,"[{""url"":""https://git.kernel.org/stable/c/320302baed05c6456164652541f23d2a96522c06"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d43c81b691813e16a2d08208ce8947aebdab83cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fb5873b779dd5858123c19bbd6959566771e2e83"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38217,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:30.227,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: hwmon: (ftsteutates) Fix TOCTOU race in fts_read() In the fts_read() function, when handling hwmon_pwm_auto_channels_temp, the code accesses the shared variable data->fan_source[channel] twice without holding any locks. It is first checked against FTS_FAN_SOURCE_INVALID, and if the check passes, it is read again when used as an argument to the BIT() macro. This creates a Time-of-Check to Time-of-Use (TOCTOU) race condition. Another thread executing fts_update_device() can modify the value of data->fan_source[channel] between the check and its use. If the value is changed to FTS_FAN_SOURCE_INVALID (0xff) during this window, the BIT() macro will be called with a large shift value (BIT(255)). A bit shift by a value greater than or equal to the type width is undefined behavior and can lead to a crash or incorrect values being returned to userspace. Fix this by reading data->fan_source[channel] into a local variable once, eliminating the race condition. Additionally, add a bounds check to ensure the value is less than BITS_PER_LONG before passing it to the BIT() macro, making the code more robust against undefined behavior. This possible bug was found by an experimental static analysis tool developed by our team.",,"[{""url"":""https://git.kernel.org/stable/c/14c9ede9ca4cd078ad76a6ab9617b81074eb58bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4d646f627d3b7ed1cacca66e598af8bcd632d465"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/83e2ba8971ccd8fc08319fc7593288f070d80a76"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d95d87841d2a575bed3691884e8fedef57d7710d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38218,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:30.353,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to do sanity check on sit_bitmap_size w/ below testcase, resize will generate a corrupted image which contains inconsistent metadata, so when mounting such image, it will trigger kernel panic: touch img truncate -s $((512*1024*1024*1024)) img mkfs.f2fs -f img $((256*1024*1024)) resize.f2fs -s -i img -t $((1024*1024*1024)) mount img /mnt/f2fs ------------[ cut here ]------------ kernel BUG at fs/f2fs/segment.h:863! Oops: invalid opcode: 0000 [#1] SMP PTI CPU: 11 UID: 0 PID: 3922 Comm: mount Not tainted 6.15.0-rc1+ #191 PREEMPT(voluntary) Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 RIP: 0010:f2fs_ra_meta_pages+0x47c/0x490 Call Trace: f2fs_build_segment_manager+0x11c3/0x2600 f2fs_fill_super+0xe97/0x2840 mount_bdev+0xf4/0x140 legacy_get_tree+0x2b/0x50 vfs_get_tree+0x29/0xd0 path_mount+0x487/0xaf0 __x64_sys_mount+0x116/0x150 do_syscall_64+0x82/0x190 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7fdbfde1bcfe The reaseon is: sit_i->bitmap_size is 192, so size of sit bitmap is 192*8=1536, at maximum there are 1536 sit blocks, however MAIN_SEGS is 261893, so that sit_blk_cnt is 4762, build_sit_entries() -> current_sit_addr() tries to access out-of-boundary in sit_bitmap at offset from [1536, 4762), once sit_bitmap and sit_bitmap_mirror is not the same, it will trigger f2fs_bug_on(). Let's add sanity check in f2fs_sanity_check_ckpt() to avoid panic.",,"[{""url"":""https://git.kernel.org/stable/c/38ef48a8afef8df646b6f6ae7abb872f18b533c1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3e5ac62a56a24f4d88ce8ffd7bc452428b235868"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5db0d252c64e91ba1929c70112352e85dc5751e7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/79ef8a6c4ec53d327580fd7d2b522cf4f1d05b0c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/82f51bff393e4c12cf4de553120ca831cfa4ef19"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad862f71016ba38039df1c96ed55c0a4314cc183"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee1b421c469876544e297ec1090574bd76100247"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38219,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:30.473,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: f2fs: prevent kernel warning due to negative i_nlink from corrupted image WARNING: CPU: 1 PID: 9426 at fs/inode.c:417 drop_nlink+0xac/0xd0 home/cc/linux/fs/inode.c:417 Modules linked in: CPU: 1 UID: 0 PID: 9426 Comm: syz-executor568 Not tainted 6.14.0-12627-g94d471a4f428 #2 PREEMPT(full) Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014 RIP: 0010:drop_nlink+0xac/0xd0 home/cc/linux/fs/inode.c:417 Code: 48 8b 5d 28 be 08 00 00 00 48 8d bb 70 07 00 00 e8 f9 67 e6 ff f0 48 ff 83 70 07 00 00 5b 5d e9 9a 12 82 ff e8 95 12 82 ff 90 &lt;0f&gt; 0b 90 c7 45 48 ff ff ff ff 5b 5d e9 83 12 82 ff e8 fe 5f e6 ff RSP: 0018:ffffc900026b7c28 EFLAGS: 00010293 RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff8239710f RDX: ffff888041345a00 RSI: ffffffff8239717b RDI: 0000000000000005 RBP: ffff888054509ad0 R08: 0000000000000005 R09: 0000000000000000 R10: 0000000000000000 R11: ffffffff9ab36f08 R12: ffff88804bb40000 R13: ffff8880545091e0 R14: 0000000000008000 R15: ffff8880545091e0 FS: 000055555d0c5880(0000) GS:ffff8880eb3e3000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f915c55b178 CR3: 0000000050d20000 CR4: 0000000000352ef0 Call Trace: <task> f2fs_i_links_write home/cc/linux/fs/f2fs/f2fs.h:3194 [inline] f2fs_drop_nlink+0xd1/0x3c0 home/cc/linux/fs/f2fs/dir.c:845 f2fs_delete_entry+0x542/0x1450 home/cc/linux/fs/f2fs/dir.c:909 f2fs_unlink+0x45c/0x890 home/cc/linux/fs/f2fs/namei.c:581 vfs_unlink+0x2fb/0x9b0 home/cc/linux/fs/namei.c:4544 do_unlinkat+0x4c5/0x6a0 home/cc/linux/fs/namei.c:4608 __do_sys_unlink home/cc/linux/fs/namei.c:4654 [inline] __se_sys_unlink home/cc/linux/fs/namei.c:4652 [inline] __x64_sys_unlink+0xc5/0x110 home/cc/linux/fs/namei.c:4652 do_syscall_x64 home/cc/linux/arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xc7/0x250 home/cc/linux/arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7fb3d092324b Code: 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa b8 57 00 00 00 0f 05 &lt;48&gt; 3d 01 f0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007ffdc232d938 EFLAGS: 00000206 ORIG_RAX: 0000000000000057 RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fb3d092324b RDX: 00007ffdc232d960 RSI: 00007ffdc232d960 RDI: 00007ffdc232d9f0 RBP: 00007ffdc232d9f0 R08: 0000000000000001 R09: 00007ffdc232d7c0 R10: 00000000fffffffd R11: 0000000000000206 R12: 00007ffdc232eaf0 R13: 000055555d0cebb0 R14: 00007ffdc232d958 R15: 0000000000000001 </task>",,"[{""url"":""https://git.kernel.org/stable/c/1f6332872374b7f482fc4ad865f9422fedb587fc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/42cb74a92adaf88061039601ddf7c874f58b554e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5018d035530b6fbfad33eeb1dd1bc87da419a276"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a87cbcc909ccfd394d4936a94663f586453d0961"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aaa644e7ffff02e12c89cbce4753bc0b6f23ff87"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d14cbed4baccd712447fb3f9c011f008b56b2097"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d9a55869d8237e677ddaa18b0f58586364cfbc1c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fbfe8446cd3274b9e367f5708d94574230a44409"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38220,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:30.597,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: only dirty folios when data journaling regular files fstest generic/388 occasionally reproduces a crash that looks as follows: BUG: kernel NULL pointer dereference, address: 0000000000000000 ... Call Trace: <TASK> ext4_block_zero_page_range+0x30c/0x380 [ext4] ext4_truncate+0x436/0x440 [ext4] ext4_process_orphan+0x5d/0x110 [ext4] ext4_orphan_cleanup+0x124/0x4f0 [ext4] ext4_fill_super+0x262d/0x3110 [ext4] get_tree_bdev_flags+0x132/0x1d0 vfs_get_tree+0x26/0xd0 vfs_cmd_create+0x59/0xe0 __do_sys_fsconfig+0x4ed/0x6b0 do_syscall_64+0x82/0x170 ... This occurs when processing a symlink inode from the orphan list. The partial block zeroing code in the truncate path calls ext4_dirty_journalled_data() -> folio_mark_dirty(). The latter calls mapping->a_ops->dirty_folio(), but symlink inodes are not assigned an a_ops vector in ext4, hence the crash. To avoid this problem, update the ext4_dirty_journalled_data() helper to only mark the folio dirty on regular files (for which a_ops is assigned). This also matches the journaling logic in the ext4_symlink() creation path, where ext4_handle_dirty_metadata() is called directly.",,"[{""url"":""https://git.kernel.org/stable/c/be5f3061a6f904e3674257879e71881ceee5b673"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cf6a4c4ac7b6e3214f25df594c9689a62f1bb456"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d7af6eee8cd60f55aa8c5fe2b91f11ec0c9a0f27"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e26268ff1dcae5662c1b96c35f18cfa6ab73d9de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38221,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:30.723,2025-08-01T09:15:32.603,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: fix out of bounds punch offset Punching a hole with a start offset that exceeds max_end is not permitted and will result in a negative length in the truncate_inode_partial_folio() function while truncating the page cache, potentially leading to undesirable consequences. A simple reproducer: truncate -s 9895604649994 /mnt/foo xfs_io -c ""pwrite 8796093022208 4096"" /mnt/foo xfs_io -c ""fpunch 8796093022213 25769803777"" /mnt/foo kernel BUG at include/linux/highmem.h:275! Oops: invalid opcode: 0000 [#1] SMP PTI CPU: 3 UID: 0 PID: 710 Comm: xfs_io Not tainted 6.15.0-rc3 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-2.fc40 04/01/2014 RIP: 0010:zero_user_segments.constprop.0+0xd7/0x110 RSP: 0018:ffffc90001cf3b38 EFLAGS: 00010287 RAX: 0000000000000005 RBX: ffffea0001485e40 RCX: 0000000000001000 RDX: 000000000040b000 RSI: 0000000000000005 RDI: 000000000040b000 RBP: 000000000040affb R08: ffff888000000000 R09: ffffea0000000000 R10: 0000000000000003 R11: 00000000fffc7fc5 R12: 0000000000000005 R13: 000000000040affb R14: ffffea0001485e40 R15: ffff888031cd3000 FS: 00007f4f63d0b780(0000) GS:ffff8880d337d000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000000001ae0b038 CR3: 00000000536aa000 CR4: 00000000000006f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> truncate_inode_partial_folio+0x3dd/0x620 truncate_inode_pages_range+0x226/0x720 ? bdev_getblk+0x52/0x3e0 ? ext4_get_group_desc+0x78/0x150 ? crc32c_arch+0xfd/0x180 ? __ext4_get_inode_loc+0x18c/0x840 ? ext4_inode_csum+0x117/0x160 ? jbd2_journal_dirty_metadata+0x61/0x390 ? __ext4_handle_dirty_metadata+0xa0/0x2b0 ? kmem_cache_free+0x90/0x5a0 ? jbd2_journal_stop+0x1d5/0x550 ? __ext4_journal_stop+0x49/0x100 truncate_pagecache_range+0x50/0x80 ext4_truncate_page_cache_block_range+0x57/0x3a0 ext4_punch_hole+0x1fe/0x670 ext4_fallocate+0x792/0x17d0 ? __count_memcg_events+0x175/0x2a0 vfs_fallocate+0x121/0x560 ksys_fallocate+0x51/0xc0 __x64_sys_fallocate+0x24/0x40 x64_sys_call+0x18d2/0x4170 do_syscall_64+0xa7/0x220 entry_SYSCALL_64_after_hwframe+0x76/0x7e Fix this by filtering out cases where the punching start offset exceeds max_end.",,"[{""url"":""https://git.kernel.org/stable/c/28b62cb58fd014338f5004170f2e3a35bf0af238"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a4d60ba277ecd8a98c5a593cbc0ef2237c20a541"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b5e58bcd79625423487fa3ecba8e8411b5396327"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38222,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:30.850,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: inline: fix len overflow in ext4_prepare_inline_data When running the following code on an ext4 filesystem with inline_data feature enabled, it will lead to the bug below. fd = open(""file1"", O_RDWR | O_CREAT | O_TRUNC, 0666); ftruncate(fd, 30); pwrite(fd, ""a"", 1, (1UL << 40) + 5UL); That happens because write_begin will succeed as when ext4_generic_write_inline_data calls ext4_prepare_inline_data, pos + len will be truncated, leading to ext4_prepare_inline_data parameter to be 6 instead of 0x10000000006. Then, later when write_end is called, we hit: BUG_ON(pos + len > EXT4_I(inode)->i_inline_size); at ext4_write_inline_data. Fix it by using a loff_t type for the len parameter in ext4_prepare_inline_data instead of an unsigned int. [ 44.545164] ------------[ cut here ]------------ [ 44.545530] kernel BUG at fs/ext4/inline.c:240! [ 44.545834] Oops: invalid opcode: 0000 [#1] SMP NOPTI [ 44.546172] CPU: 3 UID: 0 PID: 343 Comm: test Not tainted 6.15.0-rc2-00003-g9080916f4863 #45 PREEMPT(full) 112853fcebfdb93254270a7959841d2c6aa2c8bb [ 44.546523] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 [ 44.546523] RIP: 0010:ext4_write_inline_data+0xfe/0x100 [ 44.546523] Code: 3c 0e 48 83 c7 48 48 89 de 5b 41 5c 41 5d 41 5e 41 5f 5d e9 e4 fa 43 01 5b 41 5c 41 5d 41 5e 41 5f 5d c3 cc cc cc cc cc 0f 0b <0f> 0b 0f 1f 44 00 00 55 41 57 41 56 41 55 41 54 53 48 83 ec 20 49 [ 44.546523] RSP: 0018:ffffb342008b79a8 EFLAGS: 00010216 [ 44.546523] RAX: 0000000000000001 RBX: ffff9329c579c000 RCX: 0000010000000006 [ 44.546523] RDX: 000000000000003c RSI: ffffb342008b79f0 RDI: ffff9329c158e738 [ 44.546523] RBP: 0000000000000001 R08: 0000000000000001 R09: 0000000000000000 [ 44.546523] R10: 00007ffffffff000 R11: ffffffff9bd0d910 R12: 0000006210000000 [ 44.546523] R13: fffffc7e4015e700 R14: 0000010000000005 R15: ffff9329c158e738 [ 44.546523] FS: 00007f4299934740(0000) GS:ffff932a60179000(0000) knlGS:0000000000000000 [ 44.546523] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 44.546523] CR2: 00007f4299a1ec90 CR3: 0000000002886002 CR4: 0000000000770eb0 [ 44.546523] PKRU: 55555554 [ 44.546523] Call Trace: [ 44.546523] <TASK> [ 44.546523] ext4_write_inline_data_end+0x126/0x2d0 [ 44.546523] generic_perform_write+0x17e/0x270 [ 44.546523] ext4_buffered_write_iter+0xc8/0x170 [ 44.546523] vfs_write+0x2be/0x3e0 [ 44.546523] __x64_sys_pwrite64+0x6d/0xc0 [ 44.546523] do_syscall_64+0x6a/0xf0 [ 44.546523] ? __wake_up+0x89/0xb0 [ 44.546523] ? xas_find+0x72/0x1c0 [ 44.546523] ? next_uptodate_folio+0x317/0x330 [ 44.546523] ? set_pte_range+0x1a6/0x270 [ 44.546523] ? filemap_map_pages+0x6ee/0x840 [ 44.546523] ? ext4_setattr+0x2fa/0x750 [ 44.546523] ? do_pte_missing+0x128/0xf70 [ 44.546523] ? security_inode_post_setattr+0x3e/0xd0 [ 44.546523] ? ___pte_offset_map+0x19/0x100 [ 44.546523] ? handle_mm_fault+0x721/0xa10 [ 44.546523] ? do_user_addr_fault+0x197/0x730 [ 44.546523] ? do_syscall_64+0x76/0xf0 [ 44.546523] ? arch_exit_to_user_mode_prepare+0x1e/0x60 [ 44.546523] ? irqentry_exit_to_user_mode+0x79/0x90 [ 44.546523] entry_SYSCALL_64_after_hwframe+0x55/0x5d [ 44.546523] RIP: 0033:0x7f42999c6687 [ 44.546523] Code: 48 89 fa 4c 89 df e8 58 b3 00 00 8b 93 08 03 00 00 59 5e 48 83 f8 fc 74 1a 5b c3 0f 1f 84 00 00 00 00 00 48 8b 44 24 10 0f 05 <5b> c3 0f 1f 80 00 00 00 00 83 e2 39 83 fa 08 75 de e8 23 ff ff ff [ 44.546523] RSP: 002b:00007ffeae4a7930 EFLAGS: 00000202 ORIG_RAX: 0000000000000012 [ 44.546523] RAX: ffffffffffffffda RBX: 00007f4299934740 RCX: 00007f42999c6687 [ 44.546523] RDX: 0000000000000001 RSI: 000055ea6149200f RDI: 0000000000000003 [ 44.546523] RBP: 00007ffeae4a79a0 R08: 0000000000000000 R09: 0000000000000000 [ 44.546523] R10: 0000010000000005 R11: 0000000000000202 R12: 0000 ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/227cb4ca5a6502164f850d22aec3104d7888b270"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/26e09d18599da0adc543eabd300080daaeda6869"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5766da2237e539f259aa0e5f3639ae37b44ca458"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/717414a8c083c376d4a8940a1230fe0c6ed4ee00"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d1d1c5bf4fc1af76be154d3afb2acdbd89ec7d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cf5f319a2d8ab8238f8cf3a19463b9bff6420934"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3dfc60efd145df5324b99a244b0b05505cde29b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e80ee0263d88d77f2fd1927f915003a7066cbb50"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38223,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:30.987,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ceph: avoid kernel BUG for encrypted inode with unaligned file size The generic/397 test hits a BUG_ON for the case of encrypted inode with unaligned file size (for example, 33K or 1K): [ 877.737811] run fstests generic/397 at 2025-01-03 12:34:40 [ 877.875761] libceph: mon0 (2)127.0.0.1:40674 session established [ 877.876130] libceph: client4614 fsid 19b90bca-f1ae-47a6-93dd-0b03ee637949 [ 877.991965] libceph: mon0 (2)127.0.0.1:40674 session established [ 877.992334] libceph: client4617 fsid 19b90bca-f1ae-47a6-93dd-0b03ee637949 [ 878.017234] libceph: mon0 (2)127.0.0.1:40674 session established [ 878.017594] libceph: client4620 fsid 19b90bca-f1ae-47a6-93dd-0b03ee637949 [ 878.031394] xfs_io (pid 18988) is setting deprecated v1 encryption policy; recommend upgrading to v2. [ 878.054528] libceph: mon0 (2)127.0.0.1:40674 session established [ 878.054892] libceph: client4623 fsid 19b90bca-f1ae-47a6-93dd-0b03ee637949 [ 878.070287] libceph: mon0 (2)127.0.0.1:40674 session established [ 878.070704] libceph: client4626 fsid 19b90bca-f1ae-47a6-93dd-0b03ee637949 [ 878.264586] libceph: mon0 (2)127.0.0.1:40674 session established [ 878.265258] libceph: client4629 fsid 19b90bca-f1ae-47a6-93dd-0b03ee637949 [ 878.374578] -----------[ cut here ]------------ [ 878.374586] kernel BUG at net/ceph/messenger.c:1070! [ 878.375150] Oops: invalid opcode: 0000 [#1] PREEMPT SMP NOPTI [ 878.378145] CPU: 2 UID: 0 PID: 4759 Comm: kworker/2:9 Not tainted 6.13.0-rc5+ #1 [ 878.378969] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014 [ 878.380167] Workqueue: ceph-msgr ceph_con_workfn [ 878.381639] RIP: 0010:ceph_msg_data_cursor_init+0x42/0x50 [ 878.382152] Code: 89 17 48 8b 46 70 55 48 89 47 08 c7 47 18 00 00 00 00 48 89 e5 e8 de cc ff ff 5d 31 c0 31 d2 31 f6 31 ff c3 cc cc cc cc 0f 0b <0f> 0b 0f 0b 66 2e 0f 1f 84 00 00 00 00 00 90 90 90 90 90 90 90 90 [ 878.383928] RSP: 0018:ffffb4ffc7cbbd28 EFLAGS: 00010287 [ 878.384447] RAX: ffffffff82bb9ac0 RBX: ffff981390c2f1f8 RCX: 0000000000000000 [ 878.385129] RDX: 0000000000009000 RSI: ffff981288232b58 RDI: ffff981390c2f378 [ 878.385839] RBP: ffffb4ffc7cbbe18 R08: 0000000000000000 R09: 0000000000000000 [ 878.386539] R10: 0000000000000000 R11: 0000000000000000 R12: ffff981390c2f030 [ 878.387203] R13: ffff981288232b58 R14: 0000000000000029 R15: 0000000000000001 [ 878.387877] FS: 0000000000000000(0000) GS:ffff9814b7900000(0000) knlGS:0000000000000000 [ 878.388663] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 878.389212] CR2: 00005e106a0554e0 CR3: 0000000112bf0001 CR4: 0000000000772ef0 [ 878.389921] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 878.390620] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [ 878.391307] PKRU: 55555554 [ 878.391567] Call Trace: [ 878.391807] <TASK> [ 878.392021] ? show_regs+0x71/0x90 [ 878.392391] ? die+0x38/0xa0 [ 878.392667] ? do_trap+0xdb/0x100 [ 878.392981] ? do_error_trap+0x75/0xb0 [ 878.393372] ? ceph_msg_data_cursor_init+0x42/0x50 [ 878.393842] ? exc_invalid_op+0x53/0x80 [ 878.394232] ? ceph_msg_data_cursor_init+0x42/0x50 [ 878.394694] ? asm_exc_invalid_op+0x1b/0x20 [ 878.395099] ? ceph_msg_data_cursor_init+0x42/0x50 [ 878.395583] ? ceph_con_v2_try_read+0xd16/0x2220 [ 878.396027] ? _raw_spin_unlock+0xe/0x40 [ 878.396428] ? raw_spin_rq_unlock+0x10/0x40 [ 878.396842] ? finish_task_switch.isra.0+0x97/0x310 [ 878.397338] ? __schedule+0x44b/0x16b0 [ 878.397738] ceph_con_workfn+0x326/0x750 [ 878.398121] process_one_work+0x188/0x3d0 [ 878.398522] ? __pfx_worker_thread+0x10/0x10 [ 878.398929] worker_thread+0x2b5/0x3c0 [ 878.399310] ? __pfx_worker_thread+0x10/0x10 [ 878.399727] kthread+0xe1/0x120 [ 878.400031] ? __pfx_kthread+0x10/0x10 [ 878.400431] ret_from_fork+0x43/0x70 [ 878.400771] ? __pfx_kthread+0x10/0x10 [ 878.401127] ret_from_fork_asm+0x1a/0x30 [ 878.401543] </TASK> [ 878.401760] Modules l ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/060909278cc0a91373a20726bd3d8ce085f480a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/26725a76264b97d1ff104031b78da57f47741625"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/75583606aeef357a524cf6afd07f4b653ae48964"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38224,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:31.110,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: can: kvaser_pciefd: refine error prone echo_skb_max handling logic echo_skb_max should define the supported upper limit of echo_skb[] allocated inside the netdevice's priv. The corresponding size value provided by this driver to alloc_candev() is KVASER_PCIEFD_CAN_TX_MAX_COUNT which is 17. But later echo_skb_max is rounded up to the nearest power of two (for the max case, that would be 32) and the tx/ack indices calculated further during tx/rx may exceed the upper array boundary. Kasan reported this for the ack case inside kvaser_pciefd_handle_ack_packet(), though the xmit function has actually caught the same thing earlier. BUG: KASAN: slab-out-of-bounds in kvaser_pciefd_handle_ack_packet+0x2d7/0x92a drivers/net/can/kvaser_pciefd.c:1528 Read of size 8 at addr ffff888105e4f078 by task swapper/4/0 CPU: 4 UID: 0 PID: 0 Comm: swapper/4 Not tainted 6.15.0 #12 PREEMPT(voluntary) Call Trace: <IRQ> dump_stack_lvl lib/dump_stack.c:122 print_report mm/kasan/report.c:521 kasan_report mm/kasan/report.c:634 kvaser_pciefd_handle_ack_packet drivers/net/can/kvaser_pciefd.c:1528 kvaser_pciefd_read_packet drivers/net/can/kvaser_pciefd.c:1605 kvaser_pciefd_read_buffer drivers/net/can/kvaser_pciefd.c:1656 kvaser_pciefd_receive_irq drivers/net/can/kvaser_pciefd.c:1684 kvaser_pciefd_irq_handler drivers/net/can/kvaser_pciefd.c:1733 __handle_irq_event_percpu kernel/irq/handle.c:158 handle_irq_event kernel/irq/handle.c:210 handle_edge_irq kernel/irq/chip.c:833 __common_interrupt arch/x86/kernel/irq.c:296 common_interrupt arch/x86/kernel/irq.c:286 </IRQ> Tx max count definitely matters for kvaser_pciefd_tx_avail(), but for seq numbers' generation that's not the case - we're free to calculate them as would be more convenient, not taking tx max count into account. The only downside is that the size of echo_skb[] should correspond to the max seq number (not tx max count), so in some situations a bit more memory would be consumed than could be. Thus make the size of the underlying echo_skb[] sufficient for the rounded max tx value. Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",,"[{""url"":""https://git.kernel.org/stable/c/54ec8b08216f3be2cc98b33633d3c8ea79749895"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6550c9aa11e2f57f9cdaa6249cdd44d446be874"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d8a054b6e6824a8b52c3977ebd38c9583a63efac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38225,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:31.237,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: imx-jpeg: Cleanup after an allocation error When allocation failures are not cleaned up by the driver, further allocation errors will be false-positives, which will cause buffers to remain uninitialized and cause NULL pointer dereferences. Ensure proper cleanup of failed allocations to prevent these issues.",,"[{""url"":""https://git.kernel.org/stable/c/0ee9469f818a0b4de3c0e7aecd733c103820d181"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6d0efe7d35c75394f32ff9d0650a007642d23857"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7500bb9cf164edbb2c8117d57620227b1a4a8369"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b89ff9cf37ff59399f850d5f7781ef78fc37679f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec26be7d6355a05552a0d0c1e73031f83aa4dc7f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38226,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:31.367,2025-07-17T17:15:37.453,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: vivid: Change the siize of the composing syzkaller found a bug: BUG: KASAN: vmalloc-out-of-bounds in tpg_fill_plane_pattern drivers/media/common/v4l2-tpg/v4l2-tpg-core.c:2608 [inline] BUG: KASAN: vmalloc-out-of-bounds in tpg_fill_plane_buffer+0x1a9c/0x5af0 drivers/media/common/v4l2-tpg/v4l2-tpg-core.c:2705 Write of size 1440 at addr ffffc9000d0ffda0 by task vivid-000-vid-c/5304 CPU: 0 UID: 0 PID: 5304 Comm: vivid-000-vid-c Not tainted 6.14.0-rc2-syzkaller-00039-g09fbf3d50205 #0 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0x169/0x550 mm/kasan/report.c:489 kasan_report+0x143/0x180 mm/kasan/report.c:602 kasan_check_range+0x282/0x290 mm/kasan/generic.c:189 __asan_memcpy+0x40/0x70 mm/kasan/shadow.c:106 tpg_fill_plane_pattern drivers/media/common/v4l2-tpg/v4l2-tpg-core.c:2608 [inline] tpg_fill_plane_buffer+0x1a9c/0x5af0 drivers/media/common/v4l2-tpg/v4l2-tpg-core.c:2705 vivid_fillbuff drivers/media/test-drivers/vivid/vivid-kthread-cap.c:470 [inline] vivid_thread_vid_cap_tick+0xf8e/0x60d0 drivers/media/test-drivers/vivid/vivid-kthread-cap.c:629 vivid_thread_vid_cap+0x8aa/0xf30 drivers/media/test-drivers/vivid/vivid-kthread-cap.c:767 kthread+0x7a9/0x920 kernel/kthread.c:464 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:148 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 </TASK> The composition size cannot be larger than the size of fmt_cap_rect. So execute v4l2_rect_map_inside() even if has_compose_cap == 0.",,"[{""url"":""https://git.kernel.org/stable/c/00da1c767a6567e56f23dda586847586868ac064"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/57597d8db5bbda618ba2145b7e8a7e6f01b6a27e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5d89aa42534723400fefd46e26e053b9c382b4ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/635cea4f44c1ddae208666772c164eab5a6bce39"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/89b5ab822bf69867c3951dd0eb34b0314c38966b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c56398885716d97ee9bcadb2bc9663a8c1757a34"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f6b1b0f8ba0b61d8b511df5649d57235f230c135"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f83ac8d30c43fd902af7c84c480f216157b60ef0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38227,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:32.153,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: vidtv: Terminating the subsequent process of initialization failure syzbot reported a slab-use-after-free Read in vidtv_mux_init. [1] After PSI initialization fails, the si member is accessed again, resulting in this uaf. After si initialization fails, the subsequent process needs to be exited. [1] BUG: KASAN: slab-use-after-free in vidtv_mux_pid_ctx_init drivers/media/test-drivers/vidtv/vidtv_mux.c:78 [inline] BUG: KASAN: slab-use-after-free in vidtv_mux_init+0xac2/0xbe0 drivers/media/test-drivers/vidtv/vidtv_mux.c:524 Read of size 8 at addr ffff88802fa42acc by task syz.2.37/6059 CPU: 0 UID: 0 PID: 6059 Comm: syz.2.37 Not tainted 6.14.0-rc5-syzkaller #0 Hardware name: Google Compute Engine, BIOS Google 02/12/2025 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:408 [inline] print_report+0xc3/0x670 mm/kasan/report.c:521 kasan_report+0xd9/0x110 mm/kasan/report.c:634 vidtv_mux_pid_ctx_init drivers/media/test-drivers/vidtv/vidtv_mux.c:78 vidtv_mux_init+0xac2/0xbe0 drivers/media/test-drivers/vidtv/vidtv_mux.c:524 vidtv_start_streaming drivers/media/test-drivers/vidtv/vidtv_bridge.c:194 vidtv_start_feed drivers/media/test-drivers/vidtv/vidtv_bridge.c:239 dmx_section_feed_start_filtering drivers/media/dvb-core/dvb_demux.c:973 dvb_dmxdev_feed_start drivers/media/dvb-core/dmxdev.c:508 [inline] dvb_dmxdev_feed_restart.isra.0 drivers/media/dvb-core/dmxdev.c:537 dvb_dmxdev_filter_stop+0x2b4/0x3a0 drivers/media/dvb-core/dmxdev.c:564 dvb_dmxdev_filter_free drivers/media/dvb-core/dmxdev.c:840 [inline] dvb_demux_release+0x92/0x550 drivers/media/dvb-core/dmxdev.c:1246 __fput+0x3ff/0xb70 fs/file_table.c:464 task_work_run+0x14e/0x250 kernel/task_work.c:227 exit_task_work include/linux/task_work.h:40 [inline] do_exit+0xad8/0x2d70 kernel/exit.c:938 do_group_exit+0xd3/0x2a0 kernel/exit.c:1087 __do_sys_exit_group kernel/exit.c:1098 [inline] __se_sys_exit_group kernel/exit.c:1096 [inline] __x64_sys_exit_group+0x3e/0x50 kernel/exit.c:1096 x64_sys_call+0x151f/0x1720 arch/x86/include/generated/asm/syscalls_64.h:232 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7f871d58d169 Code: Unable to access opcode bytes at 0x7f871d58d13f. RSP: 002b:00007fff4b19a788 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7 RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f871d58d169 RDX: 0000000000000064 RSI: 0000000000000000 RDI: 0000000000000000 RBP: 00007fff4b19a7ec R08: 0000000b4b19a87f R09: 00000000000927c0 R10: 0000000000000001 R11: 0000000000000246 R12: 0000000000000003 R13: 00000000000927c0 R14: 000000000001d553 R15: 00007fff4b19a840 </TASK> Allocated by task 6059: kasan_save_stack+0x33/0x60 mm/kasan/common.c:47 kasan_save_track+0x14/0x30 mm/kasan/common.c:68 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0xaa/0xb0 mm/kasan/common.c:394 kmalloc_noprof include/linux/slab.h:901 [inline] kzalloc_noprof include/linux/slab.h:1037 [inline] vidtv_psi_pat_table_init drivers/media/test-drivers/vidtv/vidtv_psi.c:970 vidtv_channel_si_init drivers/media/test-drivers/vidtv/vidtv_channel.c:423 vidtv_mux_init drivers/media/test-drivers/vidtv/vidtv_mux.c:519 vidtv_start_streaming drivers/media/test-drivers/vidtv/vidtv_bridge.c:194 vidtv_start_feed drivers/media/test-drivers/vidtv/vidtv_bridge.c:239 dmx_section_feed_start_filtering drivers/media/dvb-core/dvb_demux.c:973 dvb_dmxdev_feed_start drivers/media/dvb-core/dmxdev.c:508 [inline] dvb_dmxdev_feed_restart.isra.0 drivers/media/dvb-core/dmxdev.c:537 dvb_dmxdev_filter_stop+0x2b4/0x3a0 drivers/media/dvb-core/dmxdev.c:564 dvb_dmxdev_filter_free drivers/media/dvb-core/dmxdev.c:840 [inline] dvb_demux_release+0x92/0x550 drivers/media/dvb-core/dmxdev.c:1246 __fput+0x3ff/0xb70 fs/file_tabl ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/1d5f88f053480326873115092bc116b7d14916ba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/685c18bc5a36f823ee725e85aac1303ef5f535ba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/72541cae73d0809a6416bfcd2ee6473046a0013a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7e62be1f3b241bc9faee547864bb39332955509b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9824e1732a163e005aa84e12ec439493ebd4f097"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e1d72ff111eceea6b28dccb7ca4e8f4900b11729"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8c2483be6e8bb6c2148315b4a924c65bb442b5e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38228,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:32.290,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: imagination: fix a potential memory leak in e5010_probe() Add video_device_release() to release the memory allocated by video_device_alloc() if something goes wrong.",,"[{""url"":""https://git.kernel.org/stable/c/2a2bd7df402decbdefd0acb64ba4e17a0a2a4117"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/609ba05b9484856b08869f827a6edee51d51b5f3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fac3b9a91fa099d9bad29648127c0328d6c478c3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38229,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:32.410,2025-07-17T17:15:37.653,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: cxusb: no longer judge rbuf when the write fails syzbot reported a uninit-value in cxusb_i2c_xfer. [1] Only when the write operation of usb_bulk_msg() in dvb_usb_generic_rw() succeeds and rlen is greater than 0, the read operation of usb_bulk_msg() will be executed to read rlen bytes of data from the dvb device into the rbuf. In this case, although rlen is 1, the write operation failed which resulted in the dvb read operation not being executed, and ultimately variable i was not initialized. [1] BUG: KMSAN: uninit-value in cxusb_gpio_tuner drivers/media/usb/dvb-usb/cxusb.c:124 [inline] BUG: KMSAN: uninit-value in cxusb_i2c_xfer+0x153a/0x1a60 drivers/media/usb/dvb-usb/cxusb.c:196 cxusb_gpio_tuner drivers/media/usb/dvb-usb/cxusb.c:124 [inline] cxusb_i2c_xfer+0x153a/0x1a60 drivers/media/usb/dvb-usb/cxusb.c:196 __i2c_transfer+0xe25/0x3150 drivers/i2c/i2c-core-base.c:-1 i2c_transfer+0x317/0x4a0 drivers/i2c/i2c-core-base.c:2315 i2c_transfer_buffer_flags+0x125/0x1e0 drivers/i2c/i2c-core-base.c:2343 i2c_master_send include/linux/i2c.h:109 [inline] i2cdev_write+0x210/0x280 drivers/i2c/i2c-dev.c:183 do_loop_readv_writev fs/read_write.c:848 [inline] vfs_writev+0x963/0x14e0 fs/read_write.c:1057 do_writev+0x247/0x5c0 fs/read_write.c:1101 __do_sys_writev fs/read_write.c:1169 [inline] __se_sys_writev fs/read_write.c:1166 [inline] __x64_sys_writev+0x98/0xe0 fs/read_write.c:1166 x64_sys_call+0x2229/0x3c80 arch/x86/include/generated/asm/syscalls_64.h:21 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xcd/0x1e0 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f",,"[{""url"":""https://git.kernel.org/stable/c/04354c529c8246a38ae28f713fd6bfdc028113bc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/390b864e3281802109dfe56e508396683e125653"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/41807a5f67420464ac8ee7741504f6b5decb3b7c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73fb3b92da84637e3817580fa205d48065924e15"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/77829a5f5a74026b888b0529628475b29750cef4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/84eca597baa346f09b30accdaeca10ced3eeba2d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8b35b50b7e98d8e9a0a27257c8424448afae10de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9bff888c92f5c25effbb876d22a793c2388c1ccc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38230,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:32.550,2025-07-17T17:15:37.910,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: jfs: validate AG parameters in dbMount() to prevent crashes Validate db_agheight, db_agwidth, and db_agstart in dbMount to catch corrupted metadata early and avoid undefined behavior in dbAllocAG. Limits are derived from L2LPERCTL, LPERCTL/MAXAG, and CTLTREESIZE: - agheight: 0 to L2LPERCTL/2 (0 to 5) ensures shift (L2LPERCTL - 2*agheight) >= 0. - agwidth: 1 to min(LPERCTL/MAXAG, 2^(L2LPERCTL - 2*agheight)) ensures agperlev >= 1. - Ranges: 1-8 (agheight 0-3), 1-4 (agheight 4), 1 (agheight 5). - LPERCTL/MAXAG = 1024/128 = 8 limits leaves per AG; 2^(10 - 2*agheight) prevents division to 0. - agstart: 0 to CTLTREESIZE-1 - agwidth*(MAXAG-1) keeps ti within stree (size 1365). - Ranges: 0-1237 (agwidth 1), 0-348 (agwidth 8). UBSAN: shift-out-of-bounds in fs/jfs/jfs_dmap.c:1400:9 shift exponent -335544310 is negative CPU: 0 UID: 0 PID: 5822 Comm: syz-executor130 Not tainted 6.14.0-rc5-syzkaller #0 Hardware name: Google Compute Engine/Google Compute Engine, BIOS Google 02/12/2025 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 ubsan_epilogue lib/ubsan.c:231 [inline] __ubsan_handle_shift_out_of_bounds+0x3c8/0x420 lib/ubsan.c:468 dbAllocAG+0x1087/0x10b0 fs/jfs/jfs_dmap.c:1400 dbDiscardAG+0x352/0xa20 fs/jfs/jfs_dmap.c:1613 jfs_ioc_trim+0x45a/0x6b0 fs/jfs/jfs_discard.c:105 jfs_ioctl+0x2cd/0x3e0 fs/jfs/ioctl.c:131 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:906 [inline] __se_sys_ioctl+0xf5/0x170 fs/ioctl.c:892 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",,"[{""url"":""https://git.kernel.org/stable/c/0c40fa81f850556e9aa0185fede9ef1112db7b39"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/37bfb464ddca87f203071b5bd562cd91ddc0b40a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8b69608c6b6779a7ab07ce4467a56df90152cfb9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9242ff6245527a3ebb693ddd175493b38ddca72f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/95ae5ee6069d9a5945772625f289422ef659221a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a4259e72363e1ea204a97292001a9fc36c7e52fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b62a1e59d8716bbd2e73660743fe06acc97ed7d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c3705c82b7406a15ef38a610d03bf6baa43d6e0c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38231,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:32.683,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nfsd: Initialize ssc before laundromat_work to prevent NULL dereference In nfs4_state_start_net(), laundromat_work may access nfsd_ssc through nfs4_laundromat -> nfsd4_ssc_expire_umount. If nfsd_ssc isn't initialized, this can cause NULL pointer dereference. Normally the delayed start of laundromat_work allows sufficient time for nfsd_ssc initialization to complete. However, when the kernel waits too long for userspace responses (e.g. in nfs4_state_start_net -> nfsd4_end_grace -> nfsd4_record_grace_done -> nfsd4_cld_grace_done -> cld_pipe_upcall -> __cld_pipe_upcall -> wait_for_completion path), the delayed work may start before nfsd_ssc initialization finishes. Fix this by moving nfsd_ssc initialization before starting laundromat_work.",,"[{""url"":""https://git.kernel.org/stable/c/0fccf5f01ed28725cc313a66ca1247eef911d55e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5060e1a5fef184bd11d298e3f0ee920d96a23236"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/83ac1ba8ca102ab5c0ed4351f8ac6e74ac4d5d64"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a97668ec6d73dab237cd1c15efe012a10090a4ed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b31da62889e6d610114d81dc7a6edbcaa503fcf8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d622c2ee6c08147ab8c9b9e37d93b6e95d3258e0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/deaeb74ae9318252829c59a84a7d2316fc335660"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38232,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:32.810,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: NFSD: fix race between nfsd registration and exports_proc As of now nfsd calls create_proc_exports_entry() at start of init_nfsd and cleanup by remove_proc_entry() at last of exit_nfsd. Which causes kernel OOPs if there is race between below 2 operations: (i) exportfs -r (ii) mount -t nfsd none /proc/fs/nfsd for 5.4 kernel ARM64: CPU 1: el1_irq+0xbc/0x180 arch_counter_get_cntvct+0x14/0x18 running_clock+0xc/0x18 preempt_count_add+0x88/0x110 prep_new_page+0xb0/0x220 get_page_from_freelist+0x2d8/0x1778 __alloc_pages_nodemask+0x15c/0xef0 __vmalloc_node_range+0x28c/0x478 __vmalloc_node_flags_caller+0x8c/0xb0 kvmalloc_node+0x88/0xe0 nfsd_init_net+0x6c/0x108 [nfsd] ops_init+0x44/0x170 register_pernet_operations+0x114/0x270 register_pernet_subsys+0x34/0x50 init_nfsd+0xa8/0x718 [nfsd] do_one_initcall+0x54/0x2e0 CPU 2 : Unable to handle kernel NULL pointer dereference at virtual address 0000000000000010 PC is at : exports_net_open+0x50/0x68 [nfsd] Call trace: exports_net_open+0x50/0x68 [nfsd] exports_proc_open+0x2c/0x38 [nfsd] proc_reg_open+0xb8/0x198 do_dentry_open+0x1c4/0x418 vfs_open+0x38/0x48 path_openat+0x28c/0xf18 do_filp_open+0x70/0xe8 do_sys_open+0x154/0x248 Sometimes it crashes at exports_net_open() and sometimes cache_seq_next_rcu(). and same is happening on latest 6.14 kernel as well: [ 0.000000] Linux version 6.14.0-rc5-next-20250304-dirty ... [ 285.455918] Unable to handle kernel paging request at virtual address 00001f4800001f48 ... [ 285.464902] pc : cache_seq_next_rcu+0x78/0xa4 ... [ 285.469695] Call trace: [ 285.470083] cache_seq_next_rcu+0x78/0xa4 (P) [ 285.470488] seq_read+0xe0/0x11c [ 285.470675] proc_reg_read+0x9c/0xf0 [ 285.470874] vfs_read+0xc4/0x2fc [ 285.471057] ksys_read+0x6c/0xf4 [ 285.471231] __arm64_sys_read+0x1c/0x28 [ 285.471428] invoke_syscall+0x44/0x100 [ 285.471633] el0_svc_common.constprop.0+0x40/0xe0 [ 285.471870] do_el0_svc_compat+0x1c/0x34 [ 285.472073] el0_svc_compat+0x2c/0x80 [ 285.472265] el0t_32_sync_handler+0x90/0x140 [ 285.472473] el0t_32_sync+0x19c/0x1a0 [ 285.472887] Code: f9400885 93407c23 937d7c27 11000421 (f86378a3) [ 285.473422] ---[ end trace 0000000000000000 ]--- It reproduced simply with below script: while [ 1 ] do /exportfs -r done & while [ 1 ] do insmod /nfsd.ko mount -t nfsd none /proc/fs/nfsd umount /proc/fs/nfsd rmmod nfsd done & So exporting interfaces to user space shall be done at last and cleanup at first place. With change there is no Kernel OOPs.",,"[{""url"":""https://git.kernel.org/stable/c/2029ca75cdfa6a25716a5a76b751486cce7e3822"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/327011a2bb4f7de9c72b891a96ce8d902828bddf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f7fb730cac9aafda8b9813b55d04e28a9664d17c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38233,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:32.953,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: powerpc64/ftrace: fix clobbered r15 during livepatching While r15 is clobbered always with PPC_FTRACE_OUT_OF_LINE, it is not restored in livepatch sequence leading to not so obvious fails like below: BUG: Unable to handle kernel data access on write at 0xc0000000000f9078 Faulting instruction address: 0xc0000000018ff958 Oops: Kernel access of bad area, sig: 11 [#1] ... NIP: c0000000018ff958 LR: c0000000018ff930 CTR: c0000000009c0790 REGS: c00000005f2e7790 TRAP: 0300 Tainted: G K (6.14.0+) MSR: 8000000000009033 <SF,EE,ME,IR,DR,RI,LE> CR: 2822880b XER: 20040000 CFAR: c0000000008addc0 DAR: c0000000000f9078 DSISR: 0a000000 IRQMASK: 1 GPR00: c0000000018f2584 c00000005f2e7a30 c00000000280a900 c000000017ffa488 GPR04: 0000000000000008 0000000000000000 c0000000018f24fc 000000000000000d GPR08: fffffffffffe0000 000000000000000d 0000000000000000 0000000000008000 GPR12: c0000000009c0790 c000000017ffa480 c00000005f2e7c78 c0000000000f9070 GPR16: c00000005f2e7c90 0000000000000000 0000000000000000 0000000000000000 GPR20: 0000000000000000 c00000005f3efa80 c00000005f2e7c60 c00000005f2e7c88 GPR24: c00000005f2e7c60 0000000000000001 c0000000000f9078 0000000000000000 GPR28: 00007fff97960000 c000000017ffa480 0000000000000000 c0000000000f9078 ... Call Trace: check_heap_object+0x34/0x390 (unreliable) __mutex_unlock_slowpath.isra.0+0xe4/0x230 seq_read_iter+0x430/0xa90 proc_reg_read_iter+0xa4/0x200 vfs_read+0x41c/0x510 ksys_read+0xa4/0x190 system_call_exception+0x1d0/0x440 system_call_vectored_common+0x15c/0x2ec Fix it by restoring r15 always.",,"[{""url"":""https://git.kernel.org/stable/c/a9212bf5ca640232254b31330e86272fe4073bc9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cb5b691f8273432297611863ac142e17119279e0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38234,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-04T14:15:33.087,2025-07-08T16:18:53.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: sched/rt: Fix race in push_rt_task Overview ======== When a CPU chooses to call push_rt_task and picks a task to push to another CPU's runqueue then it will call find_lock_lowest_rq method which would take a double lock on both CPUs' runqueues. If one of the locks aren't readily available, it may lead to dropping the current runqueue lock and reacquiring both the locks at once. During this window it is possible that the task is already migrated and is running on some other CPU. These cases are already handled. However, if the task is migrated and has already been executed and another CPU is now trying to wake it up (ttwu) such that it is queued again on the runqeue (on_rq is 1) and also if the task was run by the same CPU, then the current checks will pass even though the task was migrated out and is no longer in the pushable tasks list. Crashes ======= This bug resulted in quite a few flavors of crashes triggering kernel panics with various crash signatures such as assert failures, page faults, null pointer dereferences, and queue corruption errors all coming from scheduler itself. Some of the crashes: -> kernel BUG at kernel/sched/rt.c:1616! BUG_ON(idx >= MAX_RT_PRIO) Call Trace: ? __die_body+0x1a/0x60 ? die+0x2a/0x50 ? do_trap+0x85/0x100 ? pick_next_task_rt+0x6e/0x1d0 ? do_error_trap+0x64/0xa0 ? pick_next_task_rt+0x6e/0x1d0 ? exc_invalid_op+0x4c/0x60 ? pick_next_task_rt+0x6e/0x1d0 ? asm_exc_invalid_op+0x12/0x20 ? pick_next_task_rt+0x6e/0x1d0 __schedule+0x5cb/0x790 ? update_ts_time_stats+0x55/0x70 schedule_idle+0x1e/0x40 do_idle+0x15e/0x200 cpu_startup_entry+0x19/0x20 start_secondary+0x117/0x160 secondary_startup_64_no_verify+0xb0/0xbb -> BUG: kernel NULL pointer dereference, address: 00000000000000c0 Call Trace: ? __die_body+0x1a/0x60 ? no_context+0x183/0x350 ? __warn+0x8a/0xe0 ? exc_page_fault+0x3d6/0x520 ? asm_exc_page_fault+0x1e/0x30 ? pick_next_task_rt+0xb5/0x1d0 ? pick_next_task_rt+0x8c/0x1d0 __schedule+0x583/0x7e0 ? update_ts_time_stats+0x55/0x70 schedule_idle+0x1e/0x40 do_idle+0x15e/0x200 cpu_startup_entry+0x19/0x20 start_secondary+0x117/0x160 secondary_startup_64_no_verify+0xb0/0xbb -> BUG: unable to handle page fault for address: ffff9464daea5900 kernel BUG at kernel/sched/rt.c:1861! BUG_ON(rq->cpu != task_cpu(p)) -> kernel BUG at kernel/sched/rt.c:1055! BUG_ON(!rq->nr_running) Call Trace: ? __die_body+0x1a/0x60 ? die+0x2a/0x50 ? do_trap+0x85/0x100 ? dequeue_top_rt_rq+0xa2/0xb0 ? do_error_trap+0x64/0xa0 ? dequeue_top_rt_rq+0xa2/0xb0 ? exc_invalid_op+0x4c/0x60 ? dequeue_top_rt_rq+0xa2/0xb0 ? asm_exc_invalid_op+0x12/0x20 ? dequeue_top_rt_rq+0xa2/0xb0 dequeue_rt_entity+0x1f/0x70 dequeue_task_rt+0x2d/0x70 __schedule+0x1a8/0x7e0 ? blk_finish_plug+0x25/0x40 schedule+0x3c/0xb0 futex_wait_queue_me+0xb6/0x120 futex_wait+0xd9/0x240 do_futex+0x344/0xa90 ? get_mm_exe_file+0x30/0x60 ? audit_exe_compare+0x58/0x70 ? audit_filter_rules.constprop.26+0x65e/0x1220 __x64_sys_futex+0x148/0x1f0 do_syscall_64+0x30/0x80 entry_SYSCALL_64_after_hwframe+0x62/0xc7 -> BUG: unable to handle page fault for address: ffff8cf3608bc2c0 Call Trace: ? __die_body+0x1a/0x60 ? no_context+0x183/0x350 ? spurious_kernel_fault+0x171/0x1c0 ? exc_page_fault+0x3b6/0x520 ? plist_check_list+0x15/0x40 ? plist_check_list+0x2e/0x40 ? asm_exc_page_fault+0x1e/0x30 ? _cond_resched+0x15/0x30 ? futex_wait_queue_me+0xc8/0x120 ? futex_wait+0xd9/0x240 ? try_to_wake_up+0x1b8/0x490 ? futex_wake+0x78/0x160 ? do_futex+0xcd/0xa90 ? plist_check_list+0x15/0x40 ? plist_check_list+0x2e/0x40 ? plist_del+0x6a/0xd0 ? plist_check_list+0x15/0x40 ? plist_check_list+0x2e/0x40 ? dequeue_pushable_task+0x20/0x70 ? __schedule+0x382/0x7e0 ? asm_sysvec_reschedule_i ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/07ecabfbca64f4f0b6071cf96e49d162fa9d138d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/690e47d1403e90b7f2366f03b52ed3304194c793"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38235,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-06T10:15:24.223,2025-07-08T16:18:34.923,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: HID: appletb-kbd: fix ""appletb_backlight"" backlight device reference counting During appletb_kbd_probe, probe attempts to get the backlight device by name. When this happens backlight_device_get_by_name looks for a device in the backlight class which has name ""appletb_backlight"" and upon finding a match it increments the reference count for the device and returns it to the caller. However this reference is never released leading to a reference leak. Fix this by decrementing the backlight device reference count on removal via put_device and on probe failure.",,"[{""url"":""https://git.kernel.org/stable/c/4540e41e753a7d69ecd3f5bad51fe620205c3a18"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/751d5437112a3f387de4ef6d2d1c131068ff7627"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38236,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-08T08:15:20.960,2025-08-09T15:15:28.627,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: af_unix: Don't leave consecutive consumed OOB skbs. Jann Horn reported a use-after-free in unix_stream_read_generic(). The following sequences reproduce the issue: $ python3 from socket import * s1, s2 = socketpair(AF_UNIX, SOCK_STREAM) s1.send(b'x', MSG_OOB) s2.recv(1, MSG_OOB) # leave a consumed OOB skb s1.send(b'y', MSG_OOB) s2.recv(1, MSG_OOB) # leave a consumed OOB skb s1.send(b'z', MSG_OOB) s2.recv(1) # recv 'z' illegally s2.recv(1, MSG_OOB) # access 'z' skb (use-after-free) Even though a user reads OOB data, the skb holding the data stays on the recv queue to mark the OOB boundary and break the next recv(). After the last send() in the scenario above, the sk2's recv queue has 2 leading consumed OOB skbs and 1 real OOB skb. Then, the following happens during the next recv() without MSG_OOB 1. unix_stream_read_generic() peeks the first consumed OOB skb 2. manage_oob() returns the next consumed OOB skb 3. unix_stream_read_generic() fetches the next not-yet-consumed OOB skb 4. unix_stream_read_generic() reads and frees the OOB skb , and the last recv(MSG_OOB) triggers KASAN splat. The 3. above occurs because of the SO_PEEK_OFF code, which does not expect unix_skb_len(skb) to be 0, but this is true for such consumed OOB skbs. while (skip >= unix_skb_len(skb)) { skip -= unix_skb_len(skb); skb = skb_peek_next(skb, &sk->sk_receive_queue); ... } In addition to this use-after-free, there is another issue that ioctl(SIOCATMARK) does not function properly with consecutive consumed OOB skbs. So, nothing good comes out of such a situation. Instead of complicating manage_oob(), ioctl() handling, and the next ECONNRESET fix by introducing a loop for consecutive consumed OOB skbs, let's not leave such consecutive OOB unnecessarily. Now, while receiving an OOB skb in unix_stream_recv_urg(), if its previous skb is a consumed OOB skb, it is freed. [0]: BUG: KASAN: slab-use-after-free in unix_stream_read_actor (net/unix/af_unix.c:3027) Read of size 4 at addr ffff888106ef2904 by task python3/315 CPU: 2 UID: 0 PID: 315 Comm: python3 Not tainted 6.16.0-rc1-00407-gec315832f6f9 #8 PREEMPT(voluntary) Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-4.fc42 04/01/2014 Call Trace: <TASK> dump_stack_lvl (lib/dump_stack.c:122) print_report (mm/kasan/report.c:409 mm/kasan/report.c:521) kasan_report (mm/kasan/report.c:636) unix_stream_read_actor (net/unix/af_unix.c:3027) unix_stream_read_generic (net/unix/af_unix.c:2708 net/unix/af_unix.c:2847) unix_stream_recvmsg (net/unix/af_unix.c:3048) sock_recvmsg (net/socket.c:1063 (discriminator 20) net/socket.c:1085 (discriminator 20)) __sys_recvfrom (net/socket.c:2278) __x64_sys_recvfrom (net/socket.c:2291 (discriminator 1) net/socket.c:2287 (discriminator 1) net/socket.c:2287 (discriminator 1)) do_syscall_64 (arch/x86/entry/syscall_64.c:63 (discriminator 1) arch/x86/entry/syscall_64.c:94 (discriminator 1)) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130) RIP: 0033:0x7f8911fcea06 Code: 5d e8 41 8b 93 08 03 00 00 59 5e 48 83 f8 fc 75 19 83 e2 39 83 fa 08 75 11 e8 26 ff ff ff 66 0f 1f 44 00 00 48 8b 45 10 0f 05 <48> 8b 5d f8 c9 c3 0f 1f 40 00 f3 0f 1e fa 55 48 89 e5 48 83 ec 08 RSP: 002b:00007fffdb0dccb0 EFLAGS: 00000202 ORIG_RAX: 000000000000002d RAX: ffffffffffffffda RBX: 00007fffdb0dcdc8 RCX: 00007f8911fcea06 RDX: 0000000000000001 RSI: 00007f8911a5e060 RDI: 0000000000000006 RBP: 00007fffdb0dccd0 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000001 R11: 0000000000000202 R12: 00007f89119a7d20 R13: ffffffffc4653600 R14: 0000000000000000 R15: 0000000000000000 </TASK> Allocated by task 315: kasan_save_stack (mm/kasan/common.c:48) kasan_save_track (mm/kasan/common.c:60 (discriminator 1) mm/kasan/common.c:69 (discriminator 1)) __kasan_slab_alloc (mm/kasan/common.c:348) kmem_cache_alloc_ ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/32ca245464e1479bfea8592b9db227fdc1641705"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/61a9ad7b69ce688697e5f63332f03e17725353bc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8db4d2d026e6e3649832bfe23b96c4acff0756db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a12237865b48a73183df252029ff5065d73d305e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fad0a2c16062ac7c606b93166a7ce9d265bab976"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://project-zero.issues.chromium.org/issues/423023990"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38237,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-08T08:15:21.870,2025-07-08T16:18:14.207,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: platform: exynos4-is: Add hardware sync wait to fimc_is_hw_change_mode() In fimc_is_hw_change_mode(), the function changes camera modes without waiting for hardware completion, risking corrupted data or system hangs if subsequent operations proceed before the hardware is ready. Add fimc_is_hw_wait_intmsr0_intmsd0() after mode configuration, ensuring hardware state synchronization and stable interrupt handling.",,"[{""url"":""https://git.kernel.org/stable/c/14acbb5af101b7bb58c0952949bba4c5fdf0ee7e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b0d92b94278561f43057003a73a17ce13b7c1a1a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bb97dfab7615fea97322b8a6131546e80f878a69"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd9f6ce7d512fa21249415c16af801a4ed5d97b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e4077a10a25560ec0bd0b42322e4ea027d6f76e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38238,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:25.080,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: fnic: Fix crash in fnic_wq_cmpl_handler when FDMI times out When both the RHBA and RPA FDMI requests time out, fnic reuses a frame to send ABTS for each of them. On send completion, this causes an attempt to free the same frame twice that leads to a crash. Fix crash by allocating separate frames for RHBA and RPA, and modify ABTS logic accordingly. Tested by checking MDS for FDMI information. Tested by using instrumented driver to: - Drop PLOGI response - Drop RHBA response - Drop RPA response - Drop RHBA and RPA response - Drop PLOGI response + ABTS response - Drop RHBA response + ABTS response - Drop RPA response + ABTS response - Drop RHBA and RPA response + ABTS response for both of them",,"[{""url"":""https://git.kernel.org/stable/c/09679e9abedfbc5a2590759a1a7893c1c26e6044"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a35b29bdedb4d2ae3160d4d6684a6f1ecd9ca7c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38239,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:25.983,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: megaraid_sas: Fix invalid node index On a system with DRAM interleave enabled, out-of-bound access is detected: megaraid_sas 0000:3f:00.0: requested/available msix 128/128 poll_queue 0 ------------[ cut here ]------------ UBSAN: array-index-out-of-bounds in ./arch/x86/include/asm/topology.h:72:28 index -1 is out of range for type 'cpumask *[1024]' dump_stack_lvl+0x5d/0x80 ubsan_epilogue+0x5/0x2b __ubsan_handle_out_of_bounds.cold+0x46/0x4b megasas_alloc_irq_vectors+0x149/0x190 [megaraid_sas] megasas_probe_one.cold+0xa4d/0x189c [megaraid_sas] local_pci_probe+0x42/0x90 pci_device_probe+0xdc/0x290 really_probe+0xdb/0x340 __driver_probe_device+0x78/0x110 driver_probe_device+0x1f/0xa0 __driver_attach+0xba/0x1c0 bus_for_each_dev+0x8b/0xe0 bus_add_driver+0x142/0x220 driver_register+0x72/0xd0 megasas_init+0xdf/0xff0 [megaraid_sas] do_one_initcall+0x57/0x310 do_init_module+0x90/0x250 init_module_from_file+0x85/0xc0 idempotent_init_module+0x114/0x310 __x64_sys_finit_module+0x65/0xc0 do_syscall_64+0x82/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e Fix it accordingly.",,"[{""url"":""https://git.kernel.org/stable/c/074efb35552556a4b3b25eedab076d5dc24a8199"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/19a47c966deb36624843b7301f0373a3dc541a05"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/752eb816b55adb0673727ba0ed96609a17895654"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf2c1643abc3b2507d56bb6c22bf9897272f8a35"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1064b3532192e987ab17be7281d5fee36fd25e1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38240,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-04-18T07:15:43.510,2025-04-21T14:23:45.950,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/mediatek: dp: drm_err => dev_err in HPD path to avoid NULL ptr The function mtk_dp_wait_hpd_asserted() may be called before the `mtk_dp->drm_dev` pointer is assigned in mtk_dp_bridge_attach(). Specifically it can be called via this callpath: - mtk_edp_wait_hpd_asserted - [panel probe] - dp_aux_ep_probe Using ""drm"" level prints anywhere in this callpath causes a NULL pointer dereference. Change the error message directly in mtk_dp_wait_hpd_asserted() to dev_err() to avoid this. Also change the error messages in mtk_dp_parse_capabilities(), which is called by mtk_dp_wait_hpd_asserted(). While touching these prints, also add the error code to them to make future debugging easier.",,"[{""url"":""https://git.kernel.org/stable/c/106a6de46cf4887d535018185ec528ce822d6d84"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/13ec849fd2eab808ee8eba2625df7ebea3b85edf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/149a5c38436c229950cf1020992ce65c9549bc19"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2fda391ef7a701748abd7fa32232981b522c1e07"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/57a9fb47551b33cde7b76d17c0072c3b394f4620"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38241,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:26.107,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm/shmem, swap: fix softlockup with mTHP swapin Following softlockup can be easily reproduced on my test machine with: echo always > /sys/kernel/mm/transparent_hugepage/hugepages-64kB/enabled swapon /dev/zram0 # zram0 is a 48G swap device mkdir -p /sys/fs/cgroup/memory/test echo 1G > /sys/fs/cgroup/test/memory.max echo $BASHPID > /sys/fs/cgroup/test/cgroup.procs while true; do dd if=/dev/zero of=/tmp/test.img bs=1M count=5120 cat /tmp/test.img > /dev/null rm /tmp/test.img done Then after a while: watchdog: BUG: soft lockup - CPU#0 stuck for 763s! [cat:5787] Modules linked in: zram virtiofs CPU: 0 UID: 0 PID: 5787 Comm: cat Kdump: loaded Tainted: G L 6.15.0.orig-gf3021d9246bc-dirty #118 PREEMPT(voluntary) Tainted: [L]=SOFTLOCKUP Hardware name: Red Hat KVM/RHEL-AV, BIOS 0.0.0 02/06/2015 RIP: 0010:mpol_shared_policy_lookup+0xd/0x70 Code: e9 b8 b4 ff ff 31 c0 c3 cc cc cc cc 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 66 0f 1f 00 0f 1f 44 00 00 41 54 55 53 <48> 8b 1f 48 85 db 74 41 4c 8d 67 08 48 89 fb 48 89 f5 4c 89 e7 e8 RSP: 0018:ffffc90002b1fc28 EFLAGS: 00000202 RAX: 00000000001c20ca RBX: 0000000000724e1e RCX: 0000000000000001 RDX: ffff888118e214c8 RSI: 0000000000057d42 RDI: ffff888118e21518 RBP: 000000000002bec8 R08: 0000000000000001 R09: 0000000000000000 R10: 0000000000000bf4 R11: 0000000000000000 R12: 0000000000000001 R13: 00000000001c20ca R14: 00000000001c20ca R15: 0000000000000000 FS: 00007f03f995c740(0000) GS:ffff88a07ad9a000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f03f98f1000 CR3: 0000000144626004 CR4: 0000000000770eb0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 PKRU: 55555554 Call Trace: <TASK> shmem_alloc_folio+0x31/0xc0 shmem_swapin_folio+0x309/0xcf0 ? filemap_get_entry+0x117/0x1e0 ? xas_load+0xd/0xb0 ? filemap_get_entry+0x101/0x1e0 shmem_get_folio_gfp+0x2ed/0x5b0 shmem_file_read_iter+0x7f/0x2e0 vfs_read+0x252/0x330 ksys_read+0x68/0xf0 do_syscall_64+0x4c/0x1c0 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7f03f9a46991 Code: 00 48 8b 15 81 14 10 00 f7 d8 64 89 02 b8 ff ff ff ff eb bd e8 20 ad 01 00 f3 0f 1e fa 80 3d 35 97 10 00 00 74 13 31 c0 0f 05 <48> 3d 00 f0 ff ff 77 4f c3 66 0f 1f 44 00 00 55 48 89 e5 48 83 ec RSP: 002b:00007fff3c52bd28 EFLAGS: 00000246 ORIG_RAX: 0000000000000000 RAX: ffffffffffffffda RBX: 0000000000040000 RCX: 00007f03f9a46991 RDX: 0000000000040000 RSI: 00007f03f98ba000 RDI: 0000000000000003 RBP: 00007fff3c52bd50 R08: 0000000000000000 R09: 00007f03f9b9a380 R10: 0000000000000022 R11: 0000000000000246 R12: 0000000000040000 R13: 00007f03f98ba000 R14: 0000000000000003 R15: 0000000000000000 </TASK> The reason is simple, readahead brought some order 0 folio in swap cache, and the swapin mTHP folio being allocated is in conflict with it, so swapcache_prepare fails and causes shmem_swap_alloc_folio to return -EEXIST, and shmem simply retries again and again causing this loop. Fix it by applying a similar fix for anon mTHP swapin. The performance change is very slight, time of swapin 10g zero folios with shmem (test for 12 times): Before: 2.47s After: 2.48s [kasong@tencent.com: add comment]",,"[{""url"":""https://git.kernel.org/stable/c/1283dfc1e0cd52cf525c2cb1b59a6f9183aab7ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a05dd8ae5cbb1cb45f349922cfea4f548a5e5d6f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38242,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:26.233,2025-07-10T15:15:26.957,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm: userfaultfd: fix race of userfaultfd_move and swap cache This commit fixes two kinds of races, they may have different results: Barry reported a BUG_ON in commit c50f8e6053b0, we may see the same BUG_ON if the filemap lookup returned NULL and folio is added to swap cache after that. If another kind of race is triggered (folio changed after lookup) we may see RSS counter is corrupted: [ 406.893936] BUG: Bad rss-counter state mm:ffff0000c5a9ddc0 type:MM_ANONPAGES val:-1 [ 406.894071] BUG: Bad rss-counter state mm:ffff0000c5a9ddc0 type:MM_SHMEMPAGES val:1 Because the folio is being accounted to the wrong VMA. I'm not sure if there will be any data corruption though, seems no. The issues above are critical already. On seeing a swap entry PTE, userfaultfd_move does a lockless swap cache lookup, and tries to move the found folio to the faulting vma. Currently, it relies on checking the PTE value to ensure that the moved folio still belongs to the src swap entry and that no new folio has been added to the swap cache, which turns out to be unreliable. While working and reviewing the swap table series with Barry, following existing races are observed and reproduced [1]: In the example below, move_pages_pte is moving src_pte to dst_pte, where src_pte is a swap entry PTE holding swap entry S1, and S1 is not in the swap cache: CPU1 CPU2 userfaultfd_move move_pages_pte() entry = pte_to_swp_entry(orig_src_pte); // Here it got entry = S1 ... < interrupted> ... <swapin src_pte, alloc and use folio A> // folio A is a new allocated folio // and get installed into src_pte <frees swap entry S1> // src_pte now points to folio A, S1 // has swap count == 0, it can be freed // by folio_swap_swap or swap // allocator's reclaim. <try to swap out another folio B> // folio B is a folio in another VMA. <put folio B to swap cache using S1 > // S1 is freed, folio B can use it // for swap out with no problem. ... folio = filemap_get_folio(S1) // Got folio B here !!! ... < interrupted again> ... <swapin folio B and free S1> // Now S1 is free to be used again. <swapout src_pte & folio A using S1> // Now src_pte is a swap entry PTE // holding S1 again. folio_trylock(folio) move_swap_pte double_pt_lock is_pte_pages_stable // Check passed because src_pte == S1 folio_move_anon_rmap(...) // Moved invalid folio B here !!! The race window is very short and requires multiple collisions of multiple rare events, so it's very unlikely to happen, but with a deliberately constructed reproducer and increased time window, it can be reproduced easily. This can be fixed by checking if the folio returned by filemap is the valid swap cache folio after acquiring the folio lock. Another similar race is possible: filemap_get_folio may return NULL, but folio (A) could be swapped in and then swapped out again using the same swap entry after the lookup. In such a case, folio (A) may remain in the swap cache, so it must be moved too: CPU1 CPU2 userfaultfd_move move_pages_pte() entry = pte_to_swp_entry(orig_src_pte); // Here it got entry = S1, and S1 is not in swap cache folio = filemap_get ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/0ea148a799198518d8ebab63ddd0bb6114a103bc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c443046d8c9ed8724a4f4c3c2457d3ac8814b2f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/db2ca8074955ca64187a4fb596dd290b9c446cd3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38243,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:26.350,2025-07-10T15:15:27.077,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: fix invalid inode pointer dereferences during log replay In a few places where we call read_one_inode(), if we get a NULL pointer we end up jumping into an error path, or fallthrough in case of __add_inode_ref(), where we then do something like this: iput(&inode->vfs_inode); which results in an invalid inode pointer that triggers an invalid memory access, resulting in a crash. Fix this by making sure we don't do such dereferences.",,"[{""url"":""https://git.kernel.org/stable/c/2dcf838cf5c2f0f4501edaa1680fcad03618d760"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/401d098f92ea69d8a75f8b845daf343e511681ba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba8386d662cc51cc5382688bbf7a152b0b0b27cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38244,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:26.480,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential deadlock when reconnecting channels Fix cifs_signal_cifsd_for_reconnect() to take the correct lock order and prevent the following deadlock from happening ====================================================== WARNING: possible circular locking dependency detected 6.16.0-rc3-build2+ #1301 Tainted: G S W ------------------------------------------------------ cifsd/6055 is trying to acquire lock: ffff88810ad56038 (&tcp_ses->srv_lock){+.+.}-{3:3}, at: cifs_signal_cifsd_for_reconnect+0x134/0x200 but task is already holding lock: ffff888119c64330 (&ret_buf->chan_lock){+.+.}-{3:3}, at: cifs_signal_cifsd_for_reconnect+0xcf/0x200 which lock already depends on the new lock. the existing dependency chain (in reverse order) is: -> #2 (&ret_buf->chan_lock){+.+.}-{3:3}: validate_chain+0x1cf/0x270 __lock_acquire+0x60e/0x780 lock_acquire.part.0+0xb4/0x1f0 _raw_spin_lock+0x2f/0x40 cifs_setup_session+0x81/0x4b0 cifs_get_smb_ses+0x771/0x900 cifs_mount_get_session+0x7e/0x170 cifs_mount+0x92/0x2d0 cifs_smb3_do_mount+0x161/0x460 smb3_get_tree+0x55/0x90 vfs_get_tree+0x46/0x180 do_new_mount+0x1b0/0x2e0 path_mount+0x6ee/0x740 do_mount+0x98/0xe0 __do_sys_mount+0x148/0x180 do_syscall_64+0xa4/0x260 entry_SYSCALL_64_after_hwframe+0x76/0x7e -> #1 (&ret_buf->ses_lock){+.+.}-{3:3}: validate_chain+0x1cf/0x270 __lock_acquire+0x60e/0x780 lock_acquire.part.0+0xb4/0x1f0 _raw_spin_lock+0x2f/0x40 cifs_match_super+0x101/0x320 sget+0xab/0x270 cifs_smb3_do_mount+0x1e0/0x460 smb3_get_tree+0x55/0x90 vfs_get_tree+0x46/0x180 do_new_mount+0x1b0/0x2e0 path_mount+0x6ee/0x740 do_mount+0x98/0xe0 __do_sys_mount+0x148/0x180 do_syscall_64+0xa4/0x260 entry_SYSCALL_64_after_hwframe+0x76/0x7e -> #0 (&tcp_ses->srv_lock){+.+.}-{3:3}: check_noncircular+0x95/0xc0 check_prev_add+0x115/0x2f0 validate_chain+0x1cf/0x270 __lock_acquire+0x60e/0x780 lock_acquire.part.0+0xb4/0x1f0 _raw_spin_lock+0x2f/0x40 cifs_signal_cifsd_for_reconnect+0x134/0x200 __cifs_reconnect+0x8f/0x500 cifs_handle_standard+0x112/0x280 cifs_demultiplex_thread+0x64d/0xbc0 kthread+0x2f7/0x310 ret_from_fork+0x2a/0x230 ret_from_fork_asm+0x1a/0x30 other info that might help us debug this: Chain exists of: &tcp_ses->srv_lock --> &ret_buf->ses_lock --> &ret_buf->chan_lock Possible unsafe locking scenario: CPU0 CPU1 ---- ---- lock(&ret_buf->chan_lock); lock(&ret_buf->ses_lock); lock(&ret_buf->chan_lock); lock(&tcp_ses->srv_lock); *** DEADLOCK *** 3 locks held by cifsd/6055: #0: ffffffff857de398 (&cifs_tcp_ses_lock){+.+.}-{3:3}, at: cifs_signal_cifsd_for_reconnect+0x7b/0x200 #1: ffff888119c64060 (&ret_buf->ses_lock){+.+.}-{3:3}, at: cifs_signal_cifsd_for_reconnect+0x9c/0x200 #2: ffff888119c64330 (&ret_buf->chan_lock){+.+.}-{3:3}, at: cifs_signal_cifsd_for_reconnect+0xcf/0x200",,"[{""url"":""https://git.kernel.org/stable/c/711741f94ac3cf9f4e3aa73aa171e76d188c0819"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f3ead8ebc0ef65b6c89a13912b4e80218425629"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c82c7041258d96e3286f6790ab700e4edd3cc9e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe035dc78aa6ca8f862857d45beaf7a0e03206ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38245,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:26.597,2025-07-17T17:15:38.150,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: atm: Release atm_dev_mutex after removing procfs in atm_dev_deregister(). syzbot reported a warning below during atm_dev_register(). [0] Before creating a new device and procfs/sysfs for it, atm_dev_register() looks up a duplicated device by __atm_dev_lookup(). These operations are done under atm_dev_mutex. However, when removing a device in atm_dev_deregister(), it releases the mutex just after removing the device from the list that __atm_dev_lookup() iterates over. So, there will be a small race window where the device does not exist on the device list but procfs/sysfs are still not removed, triggering the splat. Let's hold the mutex until procfs/sysfs are removed in atm_dev_deregister(). [0]: proc_dir_entry 'atm/atmtcp:0' already registered WARNING: CPU: 0 PID: 5919 at fs/proc/generic.c:377 proc_register+0x455/0x5f0 fs/proc/generic.c:377 Modules linked in: CPU: 0 UID: 0 PID: 5919 Comm: syz-executor284 Not tainted 6.16.0-rc2-syzkaller-00047-g52da431bf03b #0 PREEMPT(full) Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025 RIP: 0010:proc_register+0x455/0x5f0 fs/proc/generic.c:377 Code: 48 89 f9 48 c1 e9 03 80 3c 01 00 0f 85 a2 01 00 00 48 8b 44 24 10 48 c7 c7 20 c0 c2 8b 48 8b b0 d8 00 00 00 e8 0c 02 1c ff 90 <0f> 0b 90 90 48 c7 c7 80 f2 82 8e e8 0b de 23 09 48 8b 4c 24 28 48 RSP: 0018:ffffc9000466fa30 EFLAGS: 00010282 RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff817ae248 RDX: ffff888026280000 RSI: ffffffff817ae255 RDI: 0000000000000001 RBP: ffff8880232bed48 R08: 0000000000000001 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000001 R12: ffff888076ed2140 R13: dffffc0000000000 R14: ffff888078a61340 R15: ffffed100edda444 FS: 00007f38b3b0c6c0(0000) GS:ffff888124753000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f38b3bdf953 CR3: 0000000076d58000 CR4: 00000000003526f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> proc_create_data+0xbe/0x110 fs/proc/generic.c:585 atm_proc_dev_register+0x112/0x1e0 net/atm/proc.c:361 atm_dev_register+0x46d/0x890 net/atm/resources.c:113 atmtcp_create+0x77/0x210 drivers/atm/atmtcp.c:369 atmtcp_attach drivers/atm/atmtcp.c:403 [inline] atmtcp_ioctl+0x2f9/0xd60 drivers/atm/atmtcp.c:464 do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159 sock_do_ioctl+0x115/0x280 net/socket.c:1190 sock_ioctl+0x227/0x6b0 net/socket.c:1311 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:907 [inline] __se_sys_ioctl fs/ioctl.c:893 [inline] __x64_sys_ioctl+0x18b/0x210 fs/ioctl.c:893 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xcd/0x4c0 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7f38b3b74459 Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 51 18 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007f38b3b0c198 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 00007f38b3bfe318 RCX: 00007f38b3b74459 RDX: 0000000000000000 RSI: 0000000000006180 RDI: 0000000000000005 RBP: 00007f38b3bfe310 R08: 65732f636f72702f R09: 65732f636f72702f R10: 65732f636f72702f R11: 0000000000000246 R12: 00007f38b3bcb0ac R13: 00007f38b3b0c1a0 R14: 0000200000000200 R15: 00007f38b3bcb03b </TASK>",,"[{""url"":""https://git.kernel.org/stable/c/26248d5d68c865b888d632162abbf8130645622c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2a8dcee649d12f69713f2589171a1caf6d4fa439"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4bb1bb438134d9ee6b97cc07289dd7c569092eec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6922f1a048c090f10704bbef4a3a1e81932d2e0a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a433791aeaea6e84df709e0b9584b9bbe040cd1c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ae539d963a17443ec54cba8a767e4ffa318264f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b2e40fcfe1575faaa548f87614006d3fe44c779e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cabed6ba92a9a8c09da02a3f20e32ecd80989896"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38246,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:26.720,2025-07-10T15:15:27.300,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bnxt: properly flush XDP redirect lists We encountered following crash when testing a XDP_REDIRECT feature in production: [56251.579676] list_add corruption. next->prev should be prev (ffff93120dd40f30), but was ffffb301ef3a6740. (next=ffff93120dd 40f30). [56251.601413] ------------[ cut here ]------------ [56251.611357] kernel BUG at lib/list_debug.c:29! [56251.621082] Oops: invalid opcode: 0000 [#1] PREEMPT SMP NOPTI [56251.632073] CPU: 111 UID: 0 PID: 0 Comm: swapper/111 Kdump: loaded Tainted: P O 6.12.33-cloudflare-2025.6. 3 #1 [56251.653155] Tainted: [P]=PROPRIETARY_MODULE, [O]=OOT_MODULE [56251.663877] Hardware name: MiTAC GC68B-B8032-G11P6-GPU/S8032GM-HE-CFR, BIOS V7.020.B10-sig 01/22/2025 [56251.682626] RIP: 0010:__list_add_valid_or_report+0x4b/0xa0 [56251.693203] Code: 0e 48 c7 c7 68 e7 d9 97 e8 42 16 fe ff 0f 0b 48 8b 52 08 48 39 c2 74 14 48 89 f1 48 c7 c7 90 e7 d9 97 48 89 c6 e8 25 16 fe ff <0f> 0b 4c 8b 02 49 39 f0 74 14 48 89 d1 48 c7 c7 e8 e7 d9 97 4c 89 [56251.725811] RSP: 0018:ffff93120dd40b80 EFLAGS: 00010246 [56251.736094] RAX: 0000000000000075 RBX: ffffb301e6bba9d8 RCX: 0000000000000000 [56251.748260] RDX: 0000000000000000 RSI: ffff9149afda0b80 RDI: ffff9149afda0b80 [56251.760349] RBP: ffff9131e49c8000 R08: 0000000000000000 R09: ffff93120dd40a18 [56251.772382] R10: ffff9159cf2ce1a8 R11: 0000000000000003 R12: ffff911a80850000 [56251.784364] R13: ffff93120fbc7000 R14: 0000000000000010 R15: ffff9139e7510e40 [56251.796278] FS: 0000000000000000(0000) GS:ffff9149afd80000(0000) knlGS:0000000000000000 [56251.809133] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [56251.819561] CR2: 00007f5e85e6f300 CR3: 00000038b85e2006 CR4: 0000000000770ef0 [56251.831365] PKRU: 55555554 [56251.838653] Call Trace: [56251.845560] <IRQ> [56251.851943] cpu_map_enqueue.cold+0x5/0xa [56251.860243] xdp_do_redirect+0x2d9/0x480 [56251.868388] bnxt_rx_xdp+0x1d8/0x4c0 [bnxt_en] [56251.877028] bnxt_rx_pkt+0x5f7/0x19b0 [bnxt_en] [56251.885665] ? cpu_max_write+0x1e/0x100 [56251.893510] ? srso_alias_return_thunk+0x5/0xfbef5 [56251.902276] __bnxt_poll_work+0x190/0x340 [bnxt_en] [56251.911058] bnxt_poll+0xab/0x1b0 [bnxt_en] [56251.919041] ? srso_alias_return_thunk+0x5/0xfbef5 [56251.927568] ? srso_alias_return_thunk+0x5/0xfbef5 [56251.935958] ? srso_alias_return_thunk+0x5/0xfbef5 [56251.944250] __napi_poll+0x2b/0x160 [56251.951155] bpf_trampoline_6442548651+0x79/0x123 [56251.959262] __napi_poll+0x5/0x160 [56251.966037] net_rx_action+0x3d2/0x880 [56251.973133] ? srso_alias_return_thunk+0x5/0xfbef5 [56251.981265] ? srso_alias_return_thunk+0x5/0xfbef5 [56251.989262] ? __hrtimer_run_queues+0x162/0x2a0 [56251.996967] ? srso_alias_return_thunk+0x5/0xfbef5 [56252.004875] ? srso_alias_return_thunk+0x5/0xfbef5 [56252.012673] ? bnxt_msix+0x62/0x70 [bnxt_en] [56252.019903] handle_softirqs+0xcf/0x270 [56252.026650] irq_exit_rcu+0x67/0x90 [56252.032933] common_interrupt+0x85/0xa0 [56252.039498] </IRQ> [56252.044246] <TASK> [56252.048935] asm_common_interrupt+0x26/0x40 [56252.055727] RIP: 0010:cpuidle_enter_state+0xb8/0x420 [56252.063305] Code: dc 01 00 00 e8 f9 79 3b ff e8 64 f7 ff ff 49 89 c5 0f 1f 44 00 00 31 ff e8 a5 32 3a ff 45 84 ff 0f 85 ae 01 00 00 fb 45 85 f6 <0f> 88 88 01 00 00 48 8b 04 24 49 63 ce 4c 89 ea 48 6b f1 68 48 29 [56252.088911] RSP: 0018:ffff93120c97fe98 EFLAGS: 00000202 [56252.096912] RAX: ffff9149afd80000 RBX: ffff9141d3a72800 RCX: 0000000000000000 [56252.106844] RDX: 00003329176c6b98 RSI: ffffffe36db3fdc7 RDI: 0000000000000000 [56252.116733] RBP: 0000000000000002 R08: 0000000000000002 R09: 000000000000004e [56252.126652] R10: ffff9149afdb30c4 R11: 071c71c71c71c71c R12: ffffffff985ff860 [56252.136637] R13: 00003329176c6b98 R14: 0000000000000002 R15: 0000000000000000 [56252.146667] ? cpuidle_enter_state+0xab/0x420 [56252.153909] cpuidle_enter+0x2d/0x40 [56252.160360] do_idle+0x176/0x1c0 [56252.166456 ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/02bf488d56df9db4f5147280b65d9011e1ab88d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/16254aa985d14dee050564c4a3936f3dc096e1f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9caca6ac0e26cd20efd490d8b3b2ffb1c7c00f6f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c6665b8f0f58082c480ed8627029f44d046ef2c8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38247,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:26.847,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: userns and mnt_idmap leak in open_tree_attr(2) Once want_mount_setattr() has returned a positive, it does require finish_mount_kattr() to release ->mnt_userns. Failing do_mount_setattr() does not change that. As the result, we can end up leaking userns and possibly mnt_idmap as well.",,"[{""url"":""https://git.kernel.org/stable/c/0748e553df0225754c316a92af3a77fdc057b358"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/142db4e76110dd80239f4e79810f85ea1735ad60"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38248,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:26.963,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bridge: mcast: Fix use-after-free during router port configuration The bridge maintains a global list of ports behind which a multicast router resides. The list is consulted during forwarding to ensure multicast packets are forwarded to these ports even if the ports are not member in the matching MDB entry. When per-VLAN multicast snooping is enabled, the per-port multicast context is disabled on each port and the port is removed from the global router port list: # ip link add name br1 up type bridge vlan_filtering 1 mcast_snooping 1 # ip link add name dummy1 up master br1 type dummy # ip link set dev dummy1 type bridge_slave mcast_router 2 $ bridge -d mdb show | grep router router ports on br1: dummy1 # ip link set dev br1 type bridge mcast_vlan_snooping 1 $ bridge -d mdb show | grep router However, the port can be re-added to the global list even when per-VLAN multicast snooping is enabled: # ip link set dev dummy1 type bridge_slave mcast_router 0 # ip link set dev dummy1 type bridge_slave mcast_router 2 $ bridge -d mdb show | grep router router ports on br1: dummy1 Since commit 4b30ae9adb04 (""net: bridge: mcast: re-implement br_multicast_{enable, disable}_port functions""), when per-VLAN multicast snooping is enabled, multicast disablement on a port will disable the per-{port, VLAN} multicast contexts and not the per-port one. As a result, a port will remain in the global router port list even after it is deleted. This will lead to a use-after-free [1] when the list is traversed (when adding a new port to the list, for example): # ip link del dev dummy1 # ip link add name dummy2 up master br1 type dummy # ip link set dev dummy2 type bridge_slave mcast_router 2 Similarly, stale entries can also be found in the per-VLAN router port list. When per-VLAN multicast snooping is disabled, the per-{port, VLAN} contexts are disabled on each port and the port is removed from the per-VLAN router port list: # ip link add name br1 up type bridge vlan_filtering 1 mcast_snooping 1 mcast_vlan_snooping 1 # ip link add name dummy1 up master br1 type dummy # bridge vlan add vid 2 dev dummy1 # bridge vlan global set vid 2 dev br1 mcast_snooping 1 # bridge vlan set vid 2 dev dummy1 mcast_router 2 $ bridge vlan global show dev br1 vid 2 | grep router router ports: dummy1 # ip link set dev br1 type bridge mcast_vlan_snooping 0 $ bridge vlan global show dev br1 vid 2 | grep router However, the port can be re-added to the per-VLAN list even when per-VLAN multicast snooping is disabled: # bridge vlan set vid 2 dev dummy1 mcast_router 0 # bridge vlan set vid 2 dev dummy1 mcast_router 2 $ bridge vlan global show dev br1 vid 2 | grep router router ports: dummy1 When the VLAN is deleted from the port, the per-{port, VLAN} multicast context will not be disabled since multicast snooping is not enabled on the VLAN. As a result, the port will remain in the per-VLAN router port list even after it is no longer member in the VLAN. This will lead to a use-after-free [2] when the list is traversed (when adding a new port to the list, for example): # ip link add name dummy2 up master br1 type dummy # bridge vlan add vid 2 dev dummy2 # bridge vlan del vid 2 dev dummy1 # bridge vlan set vid 2 dev dummy2 mcast_router 2 Fix these issues by removing the port from the relevant (global or per-VLAN) router port list in br_multicast_port_ctx_deinit(). The function is invoked during port deletion with the per-port multicast context and during VLAN deletion with the per-{port, VLAN} multicast context. Note that deleting the multicast router timer is not enough as it only takes care of the temporary multicast router states (1 or 3) and not the permanent one (2). [1] BUG: KASAN: slab-out-of-bounds in br_multicast_add_router.part.0+0x3f1/0x560 Write of size 8 at addr ffff888004a67328 by task ip/384 [...] Call Trace: <TASK> dump_stack ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/7544f3f5b0b58c396f374d060898b5939da31709"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f05a4f9e959e0fc098046044c650acf897ea52d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38249,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:27.077,2025-07-17T17:15:38.870,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ALSA: usb-audio: Fix out-of-bounds read in snd_usb_get_audioformat_uac3() In snd_usb_get_audioformat_uac3(), the length value returned from snd_usb_ctl_msg() is used directly for memory allocation without validation. This length is controlled by the USB device. The allocated buffer is cast to a uac3_cluster_header_descriptor and its fields are accessed without verifying that the buffer is large enough. If the device returns a smaller than expected length, this leads to an out-of-bounds read. Add a length check to ensure the buffer is large enough for uac3_cluster_header_descriptor.",,"[{""url"":""https://git.kernel.org/stable/c/0ee87c2814deb5e42921281116ac3abcb326880b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/11e740dc1a2c8590eb7074b5c4ab921bb6224c36"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/24ff7d465c4284529bbfa207757bffb6f44b6403"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2dc1c3edf67abd30c757f8054a5da61927cdda21"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6eb211788e1370af52a245d4d7da35c374c7b401"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74fcb3852a2f579151ce80b9ed96cd916ba0d5d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c3fb926abe90d86f5e3055e0035f04d9892a118b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fb4e2a6e8f28a3c0ad382e363aeb9cd822007b8a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38250,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:27.193,2025-07-10T15:15:27.517,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: hci_core: Fix use-after-free in vhci_flush() syzbot reported use-after-free in vhci_flush() without repro. [0] From the splat, a thread close()d a vhci file descriptor while its device was being used by iotcl() on another thread. Once the last fd refcnt is released, vhci_release() calls hci_unregister_dev(), hci_free_dev(), and kfree() for struct vhci_data, which is set to hci_dev->dev->driver_data. The problem is that there is no synchronisation after unlinking hdev from hci_dev_list in hci_unregister_dev(). There might be another thread still accessing the hdev which was fetched before the unlink operation. We can use SRCU for such synchronisation. Let's run hci_dev_reset() under SRCU and wait for its completion in hci_unregister_dev(). Another option would be to restore hci_dev->destruct(), which was removed in commit 587ae086f6e4 (""Bluetooth: Remove unused hci-destruct cb""). However, this would not be a good solution, as we should not run hci_unregister_dev() while there are in-flight ioctl() requests, which could lead to another data-race KCSAN splat. Note that other drivers seem to have the same problem, for exmaple, virtbt_remove(). [0]: BUG: KASAN: slab-use-after-free in skb_queue_empty_lockless include/linux/skbuff.h:1891 [inline] BUG: KASAN: slab-use-after-free in skb_queue_purge_reason+0x99/0x360 net/core/skbuff.c:3937 Read of size 8 at addr ffff88807cb8d858 by task syz.1.219/6718 CPU: 1 UID: 0 PID: 6718 Comm: syz.1.219 Not tainted 6.16.0-rc1-syzkaller-00196-g08207f42d3ff #0 PREEMPT(full) Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025 Call Trace: <TASK> dump_stack_lvl+0x189/0x250 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:408 [inline] print_report+0xd2/0x2b0 mm/kasan/report.c:521 kasan_report+0x118/0x150 mm/kasan/report.c:634 skb_queue_empty_lockless include/linux/skbuff.h:1891 [inline] skb_queue_purge_reason+0x99/0x360 net/core/skbuff.c:3937 skb_queue_purge include/linux/skbuff.h:3368 [inline] vhci_flush+0x44/0x50 drivers/bluetooth/hci_vhci.c:69 hci_dev_do_reset net/bluetooth/hci_core.c:552 [inline] hci_dev_reset+0x420/0x5c0 net/bluetooth/hci_core.c:592 sock_do_ioctl+0xd9/0x300 net/socket.c:1190 sock_ioctl+0x576/0x790 net/socket.c:1311 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:907 [inline] __se_sys_ioctl+0xf9/0x170 fs/ioctl.c:893 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xfa/0x3b0 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7fcf5b98e929 Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007fcf5c7b9038 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 00007fcf5bbb6160 RCX: 00007fcf5b98e929 RDX: 0000000000000000 RSI: 00000000400448cb RDI: 0000000000000009 RBP: 00007fcf5ba10b39 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 0000000000000000 R14: 00007fcf5bbb6160 R15: 00007ffd6353d528 </TASK> Allocated by task 6535: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3e/0x80 mm/kasan/common.c:68 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0x93/0xb0 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __kmalloc_cache_noprof+0x230/0x3d0 mm/slub.c:4359 kmalloc_noprof include/linux/slab.h:905 [inline] kzalloc_noprof include/linux/slab.h:1039 [inline] vhci_open+0x57/0x360 drivers/bluetooth/hci_vhci.c:635 misc_open+0x2bc/0x330 drivers/char/misc.c:161 chrdev_open+0x4c9/0x5e0 fs/char_dev.c:414 do_dentry_open+0xdf0/0x1970 fs/open.c:964 vfs_open+0x3b/0x340 fs/open.c:1094 do_open fs/namei.c:3887 [inline] path_openat+0x2ee5/0x3830 fs/name ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/0e5c144c557df910ab64d9c25d06399a9a735e65"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1d6123102e9fbedc8d25bf4731da6d513173e49e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bc0819a25e04cd68ef3568cfa51b63118fea39a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce23b73f0f27e2dbeb81734a79db710f05aa33c6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38251,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:27.310,2025-07-17T17:15:39.000,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: atm: clip: prevent NULL deref in clip_push() Blamed commit missed that vcc_destroy_socket() calls clip_push() with a NULL skb. If clip_devs is NULL, clip_push() then crashes when reading skb->truesize.",,"[{""url"":""https://git.kernel.org/stable/c/3c709dce16999bf6a1d2ce377deb5dd6fdd8cb08"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/41f6420ee845006354c004839fed07da71e34aee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/88c88f91f4b3563956bb52e7a71a3640f7ece157"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9199e8cb75f13a1650adcb3c6cad42789c43884e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a07005a77b18ae59b8471e7e4d991fa9f642b3c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b993ea46b3b601915ceaaf3c802adf11e7d6bac6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ede31ad949ae0d03cb4c5edd79991586ad7c8bb8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38252,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:27.430,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: cxl/ras: Fix CPER handler device confusion By inspection, cxl_cper_handle_prot_err() is making a series of fragile assumptions that can lead to crashes: 1/ It assumes that endpoints identified in the record are a CXL-type-3 device, nothing guarantees that. 2/ It assumes that the device is bound to the cxl_pci driver, nothing guarantees that. 3/ Minor, it holds the device lock over the switch-port tracing for no reason as the trace is 100% generated from data in the record. Correct those by checking that the PCIe endpoint parents a cxl_memdev before assuming the format of the driver data, and move the lock to where it is required. Consequently this also makes the implementation ready for CXL accelerators that are not bound to cxl_pci.",,"[{""url"":""https://git.kernel.org/stable/c/3c70ec71abdaf4e4fa48cd8fdfbbd864d78235a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4bcb8dd36e9e3fad6c22862ac5b6993df838309b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38253,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:27.540,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: HID: wacom: fix crash in wacom_aes_battery_handler() Commit fd2a9b29dc9c (""HID: wacom: Remove AES power_supply after extended inactivity"") introduced wacom_aes_battery_handler() which is scheduled as a delayed work (aes_battery_work). In wacom_remove(), aes_battery_work is not canceled. Consequently, if the device is removed while aes_battery_work is still pending, then hard crashes or ""Oops: general protection fault..."" are experienced when wacom_aes_battery_handler() is finally called. E.g., this happens with built-in USB devices after resume from hibernate when aes_battery_work was still pending at the time of hibernation. So, take care to cancel aes_battery_work in wacom_remove().",,"[{""url"":""https://git.kernel.org/stable/c/57a3d82200dbeccd002244b96acad570eeeb731f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a4f182ffa30c52ad1c8e12edfb8049ee748c0f1b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f3054152c12e2eed1e72704aff47b0ea58229584"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38254,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:27.653,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add sanity checks for drm_edid_raw() When EDID is retrieved via drm_edid_raw(), it doesn't guarantee to return proper EDID bytes the caller wants: it may be either NULL (that leads to an Oops) or with too long bytes over the fixed size raw_edid array (that may lead to memory corruption). The latter was reported actually when connected with a bad adapter. Add sanity checks for drm_edid_raw() to address the above corner cases, and return EDID_BAD_INPUT accordingly. (cherry picked from commit 648d3f4d209725d51900d6a3ed46b7b600140cdf)",,"[{""url"":""https://git.kernel.org/stable/c/4b63507d7cd243574753c6b91f68516d9103f1de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6847b3b6e84ef37451c074e6a8db3fbd250c8dbf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38255,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:27.767,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: lib/group_cpus: fix NULL pointer dereference from group_cpus_evenly() While testing null_blk with configfs, echo 0 > poll_queues will trigger following panic: BUG: kernel NULL pointer dereference, address: 0000000000000010 Oops: Oops: 0000 [#1] SMP NOPTI CPU: 27 UID: 0 PID: 920 Comm: bash Not tainted 6.15.0-02023-gadbdb95c8696-dirty #1238 PREEMPT(undef) Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.1-2.fc37 04/01/2014 RIP: 0010:__bitmap_or+0x48/0x70 Call Trace: <TASK> __group_cpus_evenly+0x822/0x8c0 group_cpus_evenly+0x2d9/0x490 blk_mq_map_queues+0x1e/0x110 null_map_queues+0xc9/0x170 [null_blk] blk_mq_update_queue_map+0xdb/0x160 blk_mq_update_nr_hw_queues+0x22b/0x560 nullb_update_nr_hw_queues+0x71/0xf0 [null_blk] nullb_device_poll_queues_store+0xa4/0x130 [null_blk] configfs_write_iter+0x109/0x1d0 vfs_write+0x26e/0x6f0 ksys_write+0x79/0x180 __x64_sys_write+0x1d/0x30 x64_sys_call+0x45c4/0x45f0 do_syscall_64+0xa5/0x240 entry_SYSCALL_64_after_hwframe+0x76/0x7e Root cause is that numgrps is set to 0, and ZERO_SIZE_PTR is returned from kcalloc(), and later ZERO_SIZE_PTR will be deferenced. Fix the problem by checking numgrps first in group_cpus_evenly(), and return NULL directly if numgrps is zero. [yukuai3@huawei.com: also fix the non-SMP version]",,"[{""url"":""https://git.kernel.org/stable/c/29d39e0d5f16c060e32542b2cf351c09fd22b250"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/64a99eff8dcf1f951a544e6058341b2b19a8fdbd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/911ef2e8a7de5b2bae8ff11fb0bd01f699e6db65"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/df831e97739405ecbaddb85516bc7d4d1c933d6b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38256,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:27.880,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: io_uring/rsrc: fix folio unpinning syzbot complains about an unmapping failure: [ 108.070381][ T14] kernel BUG at mm/gup.c:71! [ 108.070502][ T14] Internal error: Oops - BUG: 00000000f2000800 [#1] SMP [ 108.123672][ T14] Hardware name: QEMU KVM Virtual Machine, BIOS edk2-20250221-8.fc42 02/21/2025 [ 108.127458][ T14] Workqueue: iou_exit io_ring_exit_work [ 108.174205][ T14] Call trace: [ 108.175649][ T14] sanity_check_pinned_pages+0x7cc/0x7d0 (P) [ 108.178138][ T14] unpin_user_page+0x80/0x10c [ 108.180189][ T14] io_release_ubuf+0x84/0xf8 [ 108.182196][ T14] io_free_rsrc_node+0x250/0x57c [ 108.184345][ T14] io_rsrc_data_free+0x148/0x298 [ 108.186493][ T14] io_sqe_buffers_unregister+0x84/0xa0 [ 108.188991][ T14] io_ring_ctx_free+0x48/0x480 [ 108.191057][ T14] io_ring_exit_work+0x764/0x7d8 [ 108.193207][ T14] process_one_work+0x7e8/0x155c [ 108.195431][ T14] worker_thread+0x958/0xed8 [ 108.197561][ T14] kthread+0x5fc/0x75c [ 108.199362][ T14] ret_from_fork+0x10/0x20 We can pin a tail page of a folio, but then io_uring will try to unpin the head page of the folio. While it should be fine in terms of keeping the page actually alive, mm folks say it's wrong and triggers a debug warning. Use unpin_user_folio() instead of unpin_user_page*. [axboe: adapt to current tree, massage commit message]",,"[{""url"":""https://git.kernel.org/stable/c/11e7b7369e655e6131387b174218d7fa9557b3da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/53fd75f25b223878b5fff14932e3a22f42b54f77"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5afb4bf9fc62d828647647ec31745083637132e4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38257,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:27.993,2025-07-10T15:15:27.730,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: s390/pkey: Prevent overflow in size calculation for memdup_user() Number of apqn target list entries contained in 'nr_apqns' variable is determined by userspace via an ioctl call so the result of the product in calculation of size passed to memdup_user() may overflow. In this case the actual size of the allocated area and the value describing it won't be in sync leading to various types of unpredictable behaviour later. Use a proper memdup_array_user() helper which returns an error if an overflow is detected. Note that it is different from when nr_apqns is initially zero - that case is considered valid and should be handled in subsequent pkey_handler implementations. Found by Linux Verification Center (linuxtesting.org).",,"[{""url"":""https://git.kernel.org/stable/c/73483ca7e07a5e39bdf612eec9d3d293e8bef649"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7360ee47599af91a1d5f4e74d635d9408a54e489"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/88f3869649edbc4a13f6c2877091f81cd5a50f05"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad1bdd24a02d5a8d119af8e4cd50933780a6d29f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f855b119e62b004a5044ed565f2a2b368c4d3f16"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/faa1ab4a23c42e34dc000ef4977b751d94d5148c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38258,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:28.110,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm/damon/sysfs-schemes: free old damon_sysfs_scheme_filter->memcg_path on write memcg_path_store() assigns a newly allocated memory buffer to filter->memcg_path, without deallocating the previously allocated and assigned memory buffer. As a result, users can leak kernel memory by continuously writing a data to memcg_path DAMOS sysfs file. Fix the leak by deallocating the previously set memory buffer.",,"[{""url"":""https://git.kernel.org/stable/c/490a43d07f1663d827e802720d30cbc0494e4f81"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4a158ac0538dd5695eeaa00aa0720d711f3e4ef1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4f489fe6afb395dbc79840efa3c05440b760d883"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c5d5b0047b0c0f304608f3824139f7bd34c48413"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38259,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:28.227,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: codecs: wcd9335: Fix missing free of regulator supplies Driver gets and enables all regulator supplies in probe path (wcd9335_parse_dt() and wcd9335_power_on_reset()), but does not cleanup in final error paths and in unbind (missing remove() callback). This leads to leaked memory and unbalanced regulator enable count during probe errors or unbind. Fix this by converting entire code into devm_regulator_bulk_get_enable() which also greatly simplifies the code.",,"[{""url"":""https://git.kernel.org/stable/c/9079db287fc3e38e040b0edeb0a25770bb679c8e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9830ef1803a5bc50b4a984a06cf23142cd46229d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a8795f3cd289cd958f6396a1b43ba46fa8e22a2e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b86280aaa23c1c0f31bcaa600d35ddc45bc38b7a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/edadaf4239c14dc8a19ea7f60b97d5524d93c29b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38260,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:28.340,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: handle csum tree error with rescue=ibadroots correctly [BUG] There is syzbot based reproducer that can crash the kernel, with the following call trace: (With some debug output added) DEBUG: rescue=ibadroots parsed BTRFS: device fsid 14d642db-7b15-43e4-81e6-4b8fac6a25f8 devid 1 transid 8 /dev/loop0 (7:0) scanned by repro (1010) BTRFS info (device loop0): first mount of filesystem 14d642db-7b15-43e4-81e6-4b8fac6a25f8 BTRFS info (device loop0): using blake2b (blake2b-256-generic) checksum algorithm BTRFS info (device loop0): using free-space-tree BTRFS warning (device loop0): checksum verify failed on logical 5312512 mirror 1 wanted 0xb043382657aede36608fd3386d6b001692ff406164733d94e2d9a180412c6003 found 0x810ceb2bacb7f0f9eb2bf3b2b15c02af867cb35ad450898169f3b1f0bd818651 level 0 DEBUG: read tree root path failed for tree csum, ret=-5 BTRFS warning (device loop0): checksum verify failed on logical 5328896 mirror 1 wanted 0x51be4e8b303da58e6340226815b70e3a93592dac3f30dd510c7517454de8567a found 0x51be4e8b303da58e634022a315b70e3a93592dac3f30dd510c7517454de8567a level 0 BTRFS warning (device loop0): checksum verify failed on logical 5292032 mirror 1 wanted 0x1924ccd683be9efc2fa98582ef58760e3848e9043db8649ee382681e220cdee4 found 0x0cb6184f6e8799d9f8cb335dccd1d1832da1071d12290dab3b85b587ecacca6e level 0 process 'repro' launched './file2' with NULL argv: empty string added DEBUG: no csum root, idatacsums=0 ibadroots=134217728 Oops: general protection fault, probably for non-canonical address 0xdffffc0000000041: 0000 [#1] SMP KASAN NOPTI KASAN: null-ptr-deref in range [0x0000000000000208-0x000000000000020f] CPU: 5 UID: 0 PID: 1010 Comm: repro Tainted: G OE 6.15.0-custom+ #249 PREEMPT(full) Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS unknown 02/02/2022 RIP: 0010:btrfs_lookup_csum+0x93/0x3d0 [btrfs] Call Trace: <TASK> btrfs_lookup_bio_sums+0x47a/0xdf0 [btrfs] btrfs_submit_bbio+0x43e/0x1a80 [btrfs] submit_one_bio+0xde/0x160 [btrfs] btrfs_readahead+0x498/0x6a0 [btrfs] read_pages+0x1c3/0xb20 page_cache_ra_order+0x4b5/0xc20 filemap_get_pages+0x2d3/0x19e0 filemap_read+0x314/0xde0 __kernel_read+0x35b/0x900 bprm_execve+0x62e/0x1140 do_execveat_common.isra.0+0x3fc/0x520 __x64_sys_execveat+0xdc/0x130 do_syscall_64+0x54/0x1d0 entry_SYSCALL_64_after_hwframe+0x76/0x7e ---[ end trace 0000000000000000 ]--- [CAUSE] Firstly the fs has a corrupted csum tree root, thus to mount the fs we have to go ""ro,rescue=ibadroots"" mount option. Normally with that mount option, a bad csum tree root should set BTRFS_FS_STATE_NO_DATA_CSUMS flag, so that any future data read will ignore csum search. But in this particular case, we have the following call trace that caused NULL csum root, but not setting BTRFS_FS_STATE_NO_DATA_CSUMS: load_global_roots_objectid(): ret = btrfs_search_slot(); /* Succeeded */ btrfs_item_key_to_cpu() found = true; /* We found the root item for csum tree. */ root = read_tree_root_path(); if (IS_ERR(root)) { if (!btrfs_test_opt(fs_info, IGNOREBADROOTS)) /* * Since we have rescue=ibadroots mount option, * @ret is still 0. */ break; if (!found || ret) { /* @found is true, @ret is 0, error handling for csum * tree is skipped. */ } This means we completely skipped to set BTRFS_FS_STATE_NO_DATA_CSUMS if the csum tree is corrupted, which results unexpected later csum lookup. [FIX] If read_tree_root_path() failed, always populate @ret to the error number. As at the end of the function, we need @ret to determine if we need to do the extra error handling for csum tree.",,"[{""url"":""https://git.kernel.org/stable/c/3f5c4a996f8f4fecd24a3eb344a307c50af895c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/547e836661554dcfa15c212a3821664e85b4191a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bbe9231fe611a54a447962494472f604419bad59"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8ce11903211542a61f05c02caedd2edfb4256b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc97a116dc4929905538bc0bd3af7faa51192957"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38261,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:28.460,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: riscv: save the SR_SUM status over switches When threads/tasks are switched we need to ensure the old execution's SR_SUM state is saved and the new thread has the old SR_SUM state restored. The issue was seen under heavy load especially with the syz-stress tool running, with crashes as follows in schedule_tail: Unable to handle kernel access to user memory without uaccess routines at virtual address 000000002749f0d0 Oops [#1] Modules linked in: CPU: 1 PID: 4875 Comm: syz-executor.0 Not tainted 5.12.0-rc2-syzkaller-00467-g0d7588ab9ef9 #0 Hardware name: riscv-virtio,qemu (DT) epc : schedule_tail+0x72/0xb2 kernel/sched/core.c:4264 ra : task_pid_vnr include/linux/sched.h:1421 [inline] ra : schedule_tail+0x70/0xb2 kernel/sched/core.c:4264 epc : ffffffe00008c8b0 ra : ffffffe00008c8ae sp : ffffffe025d17ec0 gp : ffffffe005d25378 tp : ffffffe00f0d0000 t0 : 0000000000000000 t1 : 0000000000000001 t2 : 00000000000f4240 s0 : ffffffe025d17ee0 s1 : 000000002749f0d0 a0 : 000000000000002a a1 : 0000000000000003 a2 : 1ffffffc0cfac500 a3 : ffffffe0000c80cc a4 : 5ae9db91c19bbe00 a5 : 0000000000000000 a6 : 0000000000f00000 a7 : ffffffe000082eba s2 : 0000000000040000 s3 : ffffffe00eef96c0 s4 : ffffffe022c77fe0 s5 : 0000000000004000 s6 : ffffffe067d74e00 s7 : ffffffe067d74850 s8 : ffffffe067d73e18 s9 : ffffffe067d74e00 s10: ffffffe00eef96e8 s11: 000000ae6cdf8368 t3 : 5ae9db91c19bbe00 t4 : ffffffc4043cafb2 t5 : ffffffc4043cafba t6 : 0000000000040000 status: 0000000000000120 badaddr: 000000002749f0d0 cause: 000000000000000f Call Trace: [<ffffffe00008c8b0>] schedule_tail+0x72/0xb2 kernel/sched/core.c:4264 [<ffffffe000005570>] ret_from_exception+0x0/0x14 Dumping ftrace buffer: (ftrace buffer empty) ---[ end trace b5f8f9231dc87dda ]--- The issue comes from the put_user() in schedule_tail (kernel/sched/core.c) doing the following: asmlinkage __visible void schedule_tail(struct task_struct *prev) { ... if (current->set_child_tid) put_user(task_pid_vnr(current), current->set_child_tid); ... } the put_user() macro causes the code sequence to come out as follows: 1: __enable_user_access() 2: reg = task_pid_vnr(current); 3: *current->set_child_tid = reg; 4: __disable_user_access() The problem is that we may have a sleeping function as argument which could clear SR_SUM causing the panic above. This was fixed by evaluating the argument of the put_user() macro outside the user-enabled section in commit 285a76bb2cf5 (""riscv: evaluate put_user() arg before enabling user access"")"" In order for riscv to take advantage of unsafe_get/put_XXX() macros and to avoid the same issue we had with put_user() and sleeping functions we must ensure code flow can go through switch_to() from within a region of code with SR_SUM enabled and come back with SR_SUM still enabled. This patch addresses the problem allowing future work to enable full use of unsafe_get/put_XXX() macros without needing to take a CSR bit flip cost on every access. Make switch_to() save and restore SR_SUM.",,"[{""url"":""https://git.kernel.org/stable/c/69ea599a8dab93a620c92c255be4239a06290a77"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/788aa64c01f1262310b4c1fb827a36df170d86ea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38262,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:28.570,2025-07-17T17:15:39.130,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tty: serial: uartlite: register uart driver in init When two instances of uart devices are probing, a concurrency race can occur. If one thread calls uart_register_driver function, which first allocates and assigns memory to 'uart_state' member of uart_driver structure, the other instance can bypass uart driver registration and call ulite_assign. This calls uart_add_one_port, which expects the uart driver to be fully initialized. This leads to a kernel panic due to a null pointer dereference: [ 8.143581] BUG: kernel NULL pointer dereference, address: 00000000000002b8 [ 8.156982] #PF: supervisor write access in kernel mode [ 8.156984] #PF: error_code(0x0002) - not-present page [ 8.156986] PGD 0 P4D 0 ... [ 8.180668] RIP: 0010:mutex_lock+0x19/0x30 [ 8.188624] Call Trace: [ 8.188629] ? __die_body.cold+0x1a/0x1f [ 8.195260] ? page_fault_oops+0x15c/0x290 [ 8.209183] ? __irq_resolve_mapping+0x47/0x80 [ 8.209187] ? exc_page_fault+0x64/0x140 [ 8.209190] ? asm_exc_page_fault+0x22/0x30 [ 8.209196] ? mutex_lock+0x19/0x30 [ 8.223116] uart_add_one_port+0x60/0x440 [ 8.223122] ? proc_tty_register_driver+0x43/0x50 [ 8.223126] ? tty_register_driver+0x1ca/0x1e0 [ 8.246250] ulite_probe+0x357/0x4b0 [uartlite] To prevent it, move uart driver registration in to init function. This will ensure that uart_driver is always registered when probe function is called.",,"[{""url"":""https://git.kernel.org/stable/c/5015eed450005bab6e5cb6810f7a62eab0434fc4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/685d29f2c5057b32c7b1b46f2a7d303b926c8f72"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6bd697b5fc39fd24e2aa418c7b7d14469f550a93"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6db06aaea07bb7c8e33a425cf7b98bf29ee6056e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e958d10dd0ce5ae674cce460db5c9ca3f25243b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9c905fdbba68a6d73d39a6b7de9b9f0d6c46df87"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f5e4229d94792b40e750f30c92bcf7a3107c72ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38263,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:28.690,2025-07-17T17:15:39.260,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bcache: fix NULL pointer in cache_set_flush() 1. LINE#1794 - LINE#1887 is some codes about function of bch_cache_set_alloc(). 2. LINE#2078 - LINE#2142 is some codes about function of register_cache_set(). 3. register_cache_set() will call bch_cache_set_alloc() in LINE#2098. 1794 struct cache_set *bch_cache_set_alloc(struct cache_sb *sb) 1795 { ... 1860 if (!(c->devices = kcalloc(c->nr_uuids, sizeof(void *), GFP_KERNEL)) || 1861 mempool_init_slab_pool(&c->search, 32, bch_search_cache) || 1862 mempool_init_kmalloc_pool(&c->bio_meta, 2, 1863 sizeof(struct bbio) + sizeof(struct bio_vec) * 1864 bucket_pages(c)) || 1865 mempool_init_kmalloc_pool(&c->fill_iter, 1, iter_size) || 1866 bioset_init(&c->bio_split, 4, offsetof(struct bbio, bio), 1867 BIOSET_NEED_BVECS|BIOSET_NEED_RESCUER) || 1868 !(c->uuids = alloc_bucket_pages(GFP_KERNEL, c)) || 1869 !(c->moving_gc_wq = alloc_workqueue(""bcache_gc"", 1870 WQ_MEM_RECLAIM, 0)) || 1871 bch_journal_alloc(c) || 1872 bch_btree_cache_alloc(c) || 1873 bch_open_buckets_alloc(c) || 1874 bch_bset_sort_state_init(&c->sort, ilog2(c->btree_pages))) 1875 goto err; ^^^^^^^^ 1876 ... 1883 return c; 1884 err: 1885 bch_cache_set_unregister(c); ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 1886 return NULL; 1887 } ... 2078 static const char *register_cache_set(struct cache *ca) 2079 { ... 2098 c = bch_cache_set_alloc(&ca->sb); 2099 if (!c) 2100 return err; ^^^^^^^^^^ ... 2128 ca->set = c; 2129 ca->set->cache[ca->sb.nr_this_dev] = ca; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ... 2138 return NULL; 2139 err: 2140 bch_cache_set_unregister(c); 2141 return err; 2142 } (1) If LINE#1860 - LINE#1874 is true, then do 'goto err'(LINE#1875) and call bch_cache_set_unregister()(LINE#1885). (2) As (1) return NULL(LINE#1886), LINE#2098 - LINE#2100 would return. (3) As (2) has returned, LINE#2128 - LINE#2129 would do *not* give the value to c->cache[], it means that c->cache[] is NULL. LINE#1624 - LINE#1665 is some codes about function of cache_set_flush(). As (1), in LINE#1885 call bch_cache_set_unregister() ---> bch_cache_set_stop() ---> closure_queue() -.-> cache_set_flush() (as below LINE#1624) 1624 static void cache_set_flush(struct closure *cl) 1625 { ... 1654 for_each_cache(ca, c, i) 1655 if (ca->alloc_thread) ^^ 1656 kthread_stop(ca->alloc_thread); ... 1665 } (4) In LINE#1655 ca is NULL(see (3)) in cache_set_flush() then the kernel crash occurred as below: [ 846.712887] bcache: register_cache() error drbd6: cannot allocate memory [ 846.713242] bcache: register_bcache() error : failed to register device [ 846.713336] bcache: cache_set_free() Cache set 2f84bdc1-498a-4f2f-98a7-01946bf54287 unregistered [ 846.713768] BUG: unable to handle kernel NULL pointer dereference at 00000000000009f8 [ 846.714790] PGD 0 P4D 0 [ 846.715129] Oops: 0000 [#1] SMP PTI [ 846.715472] CPU: 19 PID: 5057 Comm: kworker/19:16 Kdump: loaded Tainted: G OE --------- - - 4.18.0-147.5.1.el8_1.5es.3.x86_64 #1 [ 846.716082] Hardware name: ESPAN GI-25212/X11DPL-i, BIOS 2.1 06/15/2018 [ 846.716451] Workqueue: events cache_set_flush [bcache] [ 846.716808] RIP: 0010:cache_set_flush+0xc9/0x1b0 [bcache] [ 846.717155] Code: 00 4c 89 a5 b0 03 00 00 48 8b 85 68 f6 ff ff a8 08 0f 84 88 00 00 00 31 db 66 83 bd 3c f7 ff ff 00 48 8b 85 48 ff ff ff 74 28 <48> 8b b8 f8 09 00 0 ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/1e46ed947ec658f89f1a910d880cd05e42d3763e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1f25f2d3fa29325320c19a30abf787e0bd5fc91b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f9e128186c99a117e304f1dce6d0b9e50c63cd8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/553f560e0a74a7008ad9dba05c3fd05da296befb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/667c3f52373ff5354cb3543e27237eb7df7b2333"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c4f5e7e417034b05f5d2f5fa9a872db897da69bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d54681938b777488e5dfb781b566d16adad991de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38264,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-09T11:15:28.810,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nvme-tcp: sanitize request list handling Validate the request in nvme_tcp_handle_r2t() to ensure it's not part of any list, otherwise a malicious R2T PDU might inject a loop in request list processing.",,"[{""url"":""https://git.kernel.org/stable/c/0bf04c874fcb1ae46a863034296e4b33d8fbd66c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/78a4adcd3fedb0728436e8094848ebf4c6bae006"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f054ea62598197714a6ca7b3b387a027308f8b13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38265,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:24.600,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: serial: jsm: fix NPE during jsm_uart_port_init No device was set which caused serial_base_ctrl_add to crash. BUG: kernel NULL pointer dereference, address: 0000000000000050 Oops: Oops: 0000 [#1] PREEMPT SMP NOPTI CPU: 16 UID: 0 PID: 368 Comm: (udev-worker) Not tainted 6.12.25-amd64 #1 Debian 6.12.25-1 RIP: 0010:serial_base_ctrl_add+0x96/0x120 Call Trace: <TASK> serial_core_register_port+0x1a0/0x580 ? __setup_irq+0x39c/0x660 ? __kmalloc_cache_noprof+0x111/0x310 jsm_uart_port_init+0xe8/0x180 [jsm] jsm_probe_one+0x1f4/0x410 [jsm] local_pci_probe+0x42/0x90 pci_device_probe+0x22f/0x270 really_probe+0xdb/0x340 ? pm_runtime_barrier+0x54/0x90 ? __pfx___driver_attach+0x10/0x10 __driver_probe_device+0x78/0x110 driver_probe_device+0x1f/0xa0 __driver_attach+0xba/0x1c0 bus_for_each_dev+0x8c/0xe0 bus_add_driver+0x112/0x1f0 driver_register+0x72/0xd0 jsm_init_module+0x36/0xff0 [jsm] ? __pfx_jsm_init_module+0x10/0x10 [jsm] do_one_initcall+0x58/0x310 do_init_module+0x60/0x230 Tested with Digi Neo PCIe 8 port card.",,"[{""url"":""https://git.kernel.org/stable/c/3258d7ff8ebfa451426662b23e8f2b51b129afe1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/985961dd2688a527a4847300d41beaad475ab7af"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a14c0d2eb3f0b1836fdec22908b87ecffd2ac844"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/abaecb2a4ad021c2f2426e9b2a9c020aef57aca9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3975aa899c0a3bbc10d035e699b142cd1373a71"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38266,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:24.727,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: pinctrl: mediatek: eint: Fix invalid pointer dereference for v1 platforms Commit 3ef9f710efcb (""pinctrl: mediatek: Add EINT support for multiple addresses"") introduced an access to the 'soc' field of struct mtk_pinctrl in mtk_eint_do_init() and for that an include of pinctrl-mtk-common-v2.h. However, pinctrl drivers relying on the v1 common driver include pinctrl-mtk-common.h instead, which provides another definition of struct mtk_pinctrl that does not contain an 'soc' field. Since mtk_eint_do_init() can be called both by v1 and v2 drivers, it will now try to dereference an invalid pointer when called on v1 platforms. This has been observed on Genio 350 EVK (MT8365), which crashes very early in boot (the kernel trace can only be seen with earlycon). In order to fix this, since 'struct mtk_pinctrl' was only needed to get a 'struct mtk_eint_pin', make 'struct mtk_eint_pin' a parameter of mtk_eint_do_init() so that callers need to supply it, removing mtk_eint_do_init()'s dependency on any particular 'struct mtk_pinctrl'.",,"[{""url"":""https://git.kernel.org/stable/c/1c9977b263475373b31bbf86af94a5c9ae2be42c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ebe21ede792cef851847648962c363cac67d17f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38267,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:24.833,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ring-buffer: Do not trigger WARN_ON() due to a commit_overrun When reading a memory mapped buffer the reader page is just swapped out with the last page written in the write buffer. If the reader page is the same as the commit buffer (the buffer that is currently being written to) it was assumed that it should never have missed events. If it does, it triggers a WARN_ON_ONCE(). But there just happens to be one scenario where this can legitimately happen. That is on a commit_overrun. A commit overrun is when an interrupt preempts an event being written to the buffer and then the interrupt adds so many new events that it fills and wraps the buffer back to the commit. Any new events would then be dropped and be reported as ""missed_events"". In this case, the next page to read is the commit buffer and after the swap of the reader page, the reader page will be the commit buffer, but this time there will be missed events and this triggers the following warning: ------------[ cut here ]------------ WARNING: CPU: 2 PID: 1127 at kernel/trace/ring_buffer.c:7357 ring_buffer_map_get_reader+0x49a/0x780 Modules linked in: kvm_intel kvm irqbypass CPU: 2 UID: 0 PID: 1127 Comm: trace-cmd Not tainted 6.15.0-rc7-test-00004-g478bc2824b45-dirty #564 PREEMPT Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 RIP: 0010:ring_buffer_map_get_reader+0x49a/0x780 Code: 00 00 00 48 89 fe 48 c1 ee 03 80 3c 2e 00 0f 85 ec 01 00 00 4d 3b a6 a8 00 00 00 0f 85 8a fd ff ff 48 85 c0 0f 84 55 fe ff ff <0f> 0b e9 4e fe ff ff be 08 00 00 00 4c 89 54 24 58 48 89 54 24 50 RSP: 0018:ffff888121787dc0 EFLAGS: 00010002 RAX: 00000000000006a2 RBX: ffff888100062800 RCX: ffffffff8190cb49 RDX: ffff888126934c00 RSI: 1ffff11020200a15 RDI: ffff8881010050a8 RBP: dffffc0000000000 R08: 0000000000000000 R09: ffffed1024d26982 R10: ffff888126934c17 R11: ffff8881010050a8 R12: ffff888126934c00 R13: ffff8881010050b8 R14: ffff888101005000 R15: ffff888126930008 FS: 00007f95c8cd7540(0000) GS:ffff8882b576e000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f95c8de4dc0 CR3: 0000000128452002 CR4: 0000000000172ef0 Call Trace: <TASK> ? __pfx_ring_buffer_map_get_reader+0x10/0x10 tracing_buffers_ioctl+0x283/0x370 __x64_sys_ioctl+0x134/0x190 do_syscall_64+0x79/0x1c0 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7f95c8de48db Code: 00 48 89 44 24 18 31 c0 48 8d 44 24 60 c7 04 24 10 00 00 00 48 89 44 24 08 48 8d 44 24 20 48 89 44 24 10 b8 10 00 00 00 0f 05 <89> c2 3d 00 f0 ff ff 77 1c 48 8b 44 24 18 64 48 2b 04 25 28 00 00 RSP: 002b:00007ffe037ba110 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 00007ffe037bb2b0 RCX: 00007f95c8de48db RDX: 0000000000000000 RSI: 0000000000005220 RDI: 0000000000000006 RBP: 00007ffe037ba180 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 00007ffe037bb6f8 R14: 00007f95c9065000 R15: 00005575c7492c90 </TASK> irq event stamp: 5080 hardirqs last enabled at (5079): [<ffffffff83e0adb0>] _raw_spin_unlock_irqrestore+0x50/0x70 hardirqs last disabled at (5080): [<ffffffff83e0aa83>] _raw_spin_lock_irqsave+0x63/0x70 softirqs last enabled at (4182): [<ffffffff81516122>] handle_softirqs+0x552/0x710 softirqs last disabled at (4159): [<ffffffff815163f7>] __irq_exit_rcu+0x107/0x210 ---[ end trace 0000000000000000 ]--- The above was triggered by running on a kernel with both lockdep and KASAN as well as kmemleak enabled and executing the following command: # perf record -o perf-test.dat -a -- trace-cmd record --nosplice -e all -p function hackbench 50 With perf interjecting a lot of interrupts and trace-cmd enabling all events as well as function tracing, with lockdep, KASAN and kmemleak enabled, it could cause an interrupt preempting an event being written to add enough event ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/4fc78a7c9ca994e1da5d3940704d4e8f0ea8c5e4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b8df8cb8f7eef52baa9ac5bf36a405ca67945a91"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e018053632bad8ee0752242c7d2cffb0bbf45404"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38268,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:24.963,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: typec: tcpm: move tcpm_queue_vdm_unlocked to asynchronous work A state check was previously added to tcpm_queue_vdm_unlocked to prevent a deadlock where the DisplayPort Alt Mode driver would be executing work and attempting to grab the tcpm_lock while the TCPM was holding the lock and attempting to unregister the altmode, blocking on the altmode driver's cancel_work_sync call. Because the state check isn't protected, there is a small window where the Alt Mode driver could determine that the TCPM is in a ready state and attempt to grab the lock while the TCPM grabs the lock and changes the TCPM state to one that causes the deadlock. The callstack is provided below: [110121.667392][ C7] Call trace: [110121.667396][ C7] __switch_to+0x174/0x338 [110121.667406][ C7] __schedule+0x608/0x9f0 [110121.667414][ C7] schedule+0x7c/0xe8 [110121.667423][ C7] kernfs_drain+0xb0/0x114 [110121.667431][ C7] __kernfs_remove+0x16c/0x20c [110121.667436][ C7] kernfs_remove_by_name_ns+0x74/0xe8 [110121.667442][ C7] sysfs_remove_group+0x84/0xe8 [110121.667450][ C7] sysfs_remove_groups+0x34/0x58 [110121.667458][ C7] device_remove_groups+0x10/0x20 [110121.667464][ C7] device_release_driver_internal+0x164/0x2e4 [110121.667475][ C7] device_release_driver+0x18/0x28 [110121.667484][ C7] bus_remove_device+0xec/0x118 [110121.667491][ C7] device_del+0x1e8/0x4ac [110121.667498][ C7] device_unregister+0x18/0x38 [110121.667504][ C7] typec_unregister_altmode+0x30/0x44 [110121.667515][ C7] tcpm_reset_port+0xac/0x370 [110121.667523][ C7] tcpm_snk_detach+0x84/0xb8 [110121.667529][ C7] run_state_machine+0x4c0/0x1b68 [110121.667536][ C7] tcpm_state_machine_work+0x94/0xe4 [110121.667544][ C7] kthread_worker_fn+0x10c/0x244 [110121.667552][ C7] kthread+0x104/0x1d4 [110121.667557][ C7] ret_from_fork+0x10/0x20 [110121.667689][ C7] Workqueue: events dp_altmode_work [110121.667697][ C7] Call trace: [110121.667701][ C7] __switch_to+0x174/0x338 [110121.667710][ C7] __schedule+0x608/0x9f0 [110121.667717][ C7] schedule+0x7c/0xe8 [110121.667725][ C7] schedule_preempt_disabled+0x24/0x40 [110121.667733][ C7] __mutex_lock+0x408/0xdac [110121.667741][ C7] __mutex_lock_slowpath+0x14/0x24 [110121.667748][ C7] mutex_lock+0x40/0xec [110121.667757][ C7] tcpm_altmode_enter+0x78/0xb4 [110121.667764][ C7] typec_altmode_enter+0xdc/0x10c [110121.667769][ C7] dp_altmode_work+0x68/0x164 [110121.667775][ C7] process_one_work+0x1e4/0x43c [110121.667783][ C7] worker_thread+0x25c/0x430 [110121.667789][ C7] kthread+0x104/0x1d4 [110121.667794][ C7] ret_from_fork+0x10/0x20 Change tcpm_queue_vdm_unlocked to queue for tcpm_queue_vdm_work, which can perform the state check while holding the TCPM lock while the Alt Mode lock is no longer held. This requires a new struct to hold the vdm data, altmode_vdm_event.",,"[{""url"":""https://git.kernel.org/stable/c/1970d34b48cbeceb0c765984c9a6bb204c77f16a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/324d45e53f1a36c88bc649dc39e0c8300a41be0a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7bdd712abefbec79176ab412d8c623e755c5d0ba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38269,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:25.083,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: exit after state insertion failure at btrfs_convert_extent_bit() If insert_state() state failed it returns an error pointer and we call extent_io_tree_panic() which will trigger a BUG() call. However if CONFIG_BUG is disabled, which is an uncommon and exotic scenario, then we fallthrough and call cache_state() which will dereference the error pointer, resulting in an invalid memory access. So jump to the 'out' label after calling extent_io_tree_panic(), it also makes the code more clear besides dealing with the exotic scenario where CONFIG_BUG is disabled.",,"[{""url"":""https://git.kernel.org/stable/c/3bf179e36da917c5d9bec71c714573ed1649b7c1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/58c50f45e1821a04d61b62514f9bd34afe67c622"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8d9d32088e304e2bc444a3087cab0bbbd9951866"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38270,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:25.197,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: drv: netdevsim: don't napi_complete() from netpoll netdevsim supports netpoll. Make sure we don't call napi_complete() from it, since it may not be scheduled. Breno reports hitting a warning in napi_complete_done(): WARNING: CPU: 14 PID: 104 at net/core/dev.c:6592 napi_complete_done+0x2cc/0x560 __napi_poll+0x2d8/0x3a0 handle_softirqs+0x1fe/0x710 This is presumably after netpoll stole the SCHED bit prematurely.",,"[{""url"":""https://git.kernel.org/stable/c/1264971017b4d7141352a7fe29021bdfce5d885d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6837dd877270c57689bd866de9f3de14172c2439"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a8ff2e362d901200a1075c3ca9c56d9c7bbef389"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38271,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:25.307,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: prevent a NULL deref in rtnl_create_link() At the time rtnl_create_link() is running, dev->netdev_ops is NULL, we must not use netdev_lock_ops() or risk a NULL deref if CONFIG_NET_SHAPER is defined. Use netif_set_group() instead of dev_set_group(). RIP: 0010:netdev_need_ops_lock include/net/netdev_lock.h:33 [inline] RIP: 0010:netdev_lock_ops include/net/netdev_lock.h:41 [inline] RIP: 0010:dev_set_group+0xc0/0x230 net/core/dev_api.c:82 Call Trace: <TASK> rtnl_create_link+0x748/0xd10 net/core/rtnetlink.c:3674 rtnl_newlink_create+0x25c/0xb00 net/core/rtnetlink.c:3813 __rtnl_newlink net/core/rtnetlink.c:3940 [inline] rtnl_newlink+0x16d6/0x1c70 net/core/rtnetlink.c:4055 rtnetlink_rcv_msg+0x7cf/0xb70 net/core/rtnetlink.c:6944 netlink_rcv_skb+0x208/0x470 net/netlink/af_netlink.c:2534 netlink_unicast_kernel net/netlink/af_netlink.c:1313 [inline] netlink_unicast+0x75b/0x8d0 net/netlink/af_netlink.c:1339 netlink_sendmsg+0x805/0xb30 net/netlink/af_netlink.c:1883 sock_sendmsg_nosec net/socket.c:712 [inline]",,"[{""url"":""https://git.kernel.org/stable/c/8a29ae8428a5c26f0b4471c2057d9e9415c53109"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/feafc73f3e6ae73371777a037d41d2e31c929636"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38272,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:25.423,2025-09-09T17:15:44.533,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: dsa: b53: do not enable EEE on bcm63xx BCM63xx internal switches do not support EEE, but provide multiple RGMII ports where external PHYs may be connected. If one of these PHYs are EEE capable, we may try to enable EEE for the MACs, which then hangs the system on access of the (non-existent) EEE registers. Fix this by checking if the switch actually supports EEE before attempting to configure it.",,"[{""url"":""https://git.kernel.org/stable/c/1237c2d4a8db79dfd4369bff6930b0e385ed7d5c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2dbccf1eb8c04b84ee3afdb1d6b787db02e7befc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3fbe3f4c57fda09f32e13fa05f53a0cc6f500619"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38273,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:25.530,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: tipc: fix refcount warning in tipc_aead_encrypt syzbot reported a refcount warning [1] caused by calling get_net() on a network namespace that is being destroyed (refcount=0). This happens when a TIPC discovery timer fires during network namespace cleanup. The recently added get_net() call in commit e279024617134 (""net/tipc: fix slab-use-after-free Read in tipc_aead_encrypt_done"") attempts to hold a reference to the network namespace. However, if the namespace is already being destroyed, its refcount might be zero, leading to the use-after-free warning. Replace get_net() with maybe_get_net(), which safely checks if the refcount is non-zero before incrementing it. If the namespace is being destroyed, return -ENODEV early, after releasing the bearer reference. [1]: https://lore.kernel.org/all/68342b55.a70a0220.253bc2.0091.GAE@google.com/T/#m12019cf9ae77e1954f666914640efa36d52704a2",,"[{""url"":""https://git.kernel.org/stable/c/307391e8fe70401a6d39ecc9978e13c2c0cdf81f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/445d59025d76d0638b03110f8791d5b89ed5162d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ff60e0d9974dccf24e89bcd3ee7933e538d929f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/acab7ca5ff19889b80a8ee7dec220ee1a96dede9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c762fc79d710d676b793f9d98b1414efe6eb51e6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0b11227c4e8eb4bdf1b86aa8f0f3abb24e0f029"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f29ccaa07cf3d35990f4d25028cc55470d29372b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38274,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:25.650,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fpga: fix potential null pointer deref in fpga_mgr_test_img_load_sgt() fpga_mgr_test_img_load_sgt() allocates memory for sgt using kunit_kzalloc() however it does not check if the allocation failed. It then passes sgt to sg_alloc_table(), which passes it to __sg_alloc_table(). This function calls memset() on sgt in an attempt to zero it out. If the allocation fails then sgt will be NULL and the memset will trigger a NULL pointer dereference. Fix this by checking the allocation with KUNIT_ASSERT_NOT_ERR_OR_NULL().",,"[{""url"":""https://git.kernel.org/stable/c/6ebf1982038af12f3588417e4fd0417d2551da28"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8b2230ac7ff0aeb2441132df638a82ab124f8624"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e69e2cfd8b38d9463a250e153ef4963a604d61e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb4c74eaa6e2d15f3bbd32941c9d2a25b29a718d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38275,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:25.770,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: phy: qcom-qmp-usb: Fix an NULL vs IS_ERR() bug The qmp_usb_iomap() helper function currently returns the raw result of devm_ioremap() for non-exclusive mappings. Since devm_ioremap() may return a NULL pointer and the caller only checks error pointers with IS_ERR(), NULL could bypass the check and lead to an invalid dereference. Fix the issue by checking if devm_ioremap() returns NULL. When it does, qmp_usb_iomap() now returns an error pointer via IOMEM_ERR_PTR(-ENOMEM), ensuring safe and consistent error handling.",,"[{""url"":""https://git.kernel.org/stable/c/0b979a409e40457ca1b5cb48755d1f34eee58805"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0c33117f00c8c5363c22676931b22ae5041f7603"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/127dfb4f1c5a2b622039c5d203f321380ea36665"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5072c1749197fc28b27d7efc0d80320d7cac9572"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d14402a38c2d868cacb1facaf9be908ca6558e59"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38276,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:25.887,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fs/dax: Fix ""don't skip locked entries when scanning entries"" Commit 6be3e21d25ca (""fs/dax: don't skip locked entries when scanning entries"") introduced a new function, wait_entry_unlocked_exclusive(), which waits for the current entry to become unlocked without advancing the XArray iterator state. Waiting for the entry to become unlocked requires dropping the XArray lock. This requires calling xas_pause() prior to dropping the lock which leaves the xas in a suitable state for the next iteration. However this has the side-effect of advancing the xas state to the next index. Normally this isn't an issue because xas_for_each() contains code to detect this state and thus avoid advancing the index a second time on the next loop iteration. However both callers of and wait_entry_unlocked_exclusive() itself subsequently use the xas state to reload the entry. As xas_pause() updated the state to the next index this will cause the current entry which is being waited on to be skipped. This caused the following warning to fire intermittently when running xftest generic/068 on an XFS filesystem with FS DAX enabled: [ 35.067397] ------------[ cut here ]------------ [ 35.068229] WARNING: CPU: 21 PID: 1640 at mm/truncate.c:89 truncate_folio_batch_exceptionals+0xd8/0x1e0 [ 35.069717] Modules linked in: nd_pmem dax_pmem nd_btt nd_e820 libnvdimm [ 35.071006] CPU: 21 UID: 0 PID: 1640 Comm: fstest Not tainted 6.15.0-rc7+ #77 PREEMPT(voluntary) [ 35.072613] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/204 [ 35.074845] RIP: 0010:truncate_folio_batch_exceptionals+0xd8/0x1e0 [ 35.075962] Code: a1 00 00 00 f6 47 0d 20 0f 84 97 00 00 00 4c 63 e8 41 39 c4 7f 0b eb 61 49 83 c5 01 45 39 ec 7e 58 42 f68 [ 35.079522] RSP: 0018:ffffb04e426c7850 EFLAGS: 00010202 [ 35.080359] RAX: 0000000000000000 RBX: ffff9d21e3481908 RCX: ffffb04e426c77f4 [ 35.081477] RDX: ffffb04e426c79e8 RSI: ffffb04e426c79e0 RDI: ffff9d21e34816e8 [ 35.082590] RBP: ffffb04e426c79e0 R08: 0000000000000001 R09: 0000000000000003 [ 35.083733] R10: 0000000000000000 R11: 822b53c0f7a49868 R12: 000000000000001f [ 35.084850] R13: 0000000000000000 R14: ffffb04e426c78e8 R15: fffffffffffffffe [ 35.085953] FS: 00007f9134c87740(0000) GS:ffff9d22abba0000(0000) knlGS:0000000000000000 [ 35.087346] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 35.088244] CR2: 00007f9134c86000 CR3: 000000040afff000 CR4: 00000000000006f0 [ 35.089354] Call Trace: [ 35.089749] <TASK> [ 35.090168] truncate_inode_pages_range+0xfc/0x4d0 [ 35.091078] truncate_pagecache+0x47/0x60 [ 35.091735] xfs_setattr_size+0xc7/0x3e0 [ 35.092648] xfs_vn_setattr+0x1ea/0x270 [ 35.093437] notify_change+0x1f4/0x510 [ 35.094219] ? do_truncate+0x97/0xe0 [ 35.094879] do_truncate+0x97/0xe0 [ 35.095640] path_openat+0xabd/0xca0 [ 35.096278] do_filp_open+0xd7/0x190 [ 35.096860] do_sys_openat2+0x8a/0xe0 [ 35.097459] __x64_sys_openat+0x6d/0xa0 [ 35.098076] do_syscall_64+0xbb/0x1d0 [ 35.098647] entry_SYSCALL_64_after_hwframe+0x77/0x7f [ 35.099444] RIP: 0033:0x7f9134d81fc1 [ 35.100033] Code: 75 57 89 f0 25 00 00 41 00 3d 00 00 41 00 74 49 80 3d 2a 26 0e 00 00 74 6d 89 da 48 89 ee bf 9c ff ff ff5 [ 35.102993] RSP: 002b:00007ffcd41e0d10 EFLAGS: 00000202 ORIG_RAX: 0000000000000101 [ 35.104263] RAX: ffffffffffffffda RBX: 0000000000000242 RCX: 00007f9134d81fc1 [ 35.105452] RDX: 0000000000000242 RSI: 00007ffcd41e1200 RDI: 00000000ffffff9c [ 35.106663] RBP: 00007ffcd41e1200 R08: 0000000000000000 R09: 0000000000000064 [ 35.107923] R10: 00000000000001a4 R11: 0000000000000202 R12: 0000000000000066 [ 35.109112] R13: 0000000000100000 R14: 0000000000100000 R15: 0000000000000400 [ 35.110357] </TASK> [ 35.110769] irq event stamp: 8415587 [ 35.111486] hardirqs last enabled at (8415599): [<ffffffff8d74b562>] __up_console_se ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/61009dd2252ab4391d44a240e891f1e04c00b9ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dd59137bfe70cf3646021b4721e430213b9c71bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38277,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:26.003,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mtd: nand: ecc-mxic: Fix use of uninitialized variable ret If ctx->steps is zero, the loop processing ECC steps is skipped, and the variable ret remains uninitialized. It is later checked and returned, which leads to undefined behavior and may cause unpredictable results in user space or kernel crashes. This scenario can be triggered in edge cases such as misconfigured geometry, ECC engine misuse, or if ctx->steps is not validated after initialization. Initialize ret to zero before the loop to ensure correct and safe behavior regardless of the ctx->steps value. Found by Linux Verification Center (linuxtesting.org) with SVACE.",,"[{""url"":""https://git.kernel.org/stable/c/49482f4a39620f6afedcd3f6aa9e0d558b6a460b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4d9d6e4be09472aa72953caca3dbefdc27846170"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7a23cc510ecaabab4f6df7e9d910d16e279b72ad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a0d9d9b5a4634e146ae41cb25667322e5c7d74d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d95846350aac72303036a70c4cdc69ae314aa26d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38278,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:26.123,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: octeontx2-pf: QOS: Refactor TC_HTB_LEAF_DEL_LAST callback This patch addresses below issues, 1. Active traffic on the leaf node must be stopped before its send queue is reassigned to the parent. This patch resolves the issue by marking the node as 'Inner'. 2. During a system reboot, the interface receives TC_HTB_LEAF_DEL and TC_HTB_LEAF_DEL_LAST callbacks to delete its HTB queues. In the case of TC_HTB_LEAF_DEL_LAST, although the same send queue is reassigned to the parent, the current logic still attempts to update the real number of queues, leadning to below warnings New queues can't be registered after device unregistration. WARNING: CPU: 0 PID: 6475 at net/core/net-sysfs.c:1714 netdev_queue_update_kobjects+0x1e4/0x200",,"[{""url"":""https://git.kernel.org/stable/c/5df8db01d6a4e9c35a5ba5d7e130d5cecd3ffcb4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/67af4ec948e8ce3ea53a9cf614d01fddf172e56d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec62c99914a79d84c8de5ba1b94d62f2ed721f2a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1fca0eae5a0573f226f46c6871260278e7dda12"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38279,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:26.240,2025-07-10T15:15:28.063,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf: Do not include stack ptr register in precision backtracking bookkeeping Yi Lai reported an issue ([1]) where the following warning appears in kernel dmesg: [ 60.643604] verifier backtracking bug [ 60.643635] WARNING: CPU: 10 PID: 2315 at kernel/bpf/verifier.c:4302 __mark_chain_precision+0x3a6c/0x3e10 [ 60.648428] Modules linked in: bpf_testmod(OE) [ 60.650471] CPU: 10 UID: 0 PID: 2315 Comm: test_progs Tainted: G OE 6.15.0-rc4-gef11287f8289-dirty #327 PREEMPT(full) [ 60.654385] Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE [ 60.656682] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014 [ 60.660475] RIP: 0010:__mark_chain_precision+0x3a6c/0x3e10 [ 60.662814] Code: 5a 30 84 89 ea e8 c4 d9 01 00 80 3d 3e 7d d8 04 00 0f 85 60 fa ff ff c6 05 31 7d d8 04 01 48 c7 c7 00 58 30 84 e8 c4 06 a5 ff <0f> 0b e9 46 fa ff ff 48 ... [ 60.668720] RSP: 0018:ffff888116cc7298 EFLAGS: 00010246 [ 60.671075] RAX: 54d70e82dfd31900 RBX: ffff888115b65e20 RCX: 0000000000000000 [ 60.673659] RDX: 0000000000000001 RSI: 0000000000000004 RDI: 00000000ffffffff [ 60.676241] RBP: 0000000000000400 R08: ffff8881f6f23bd3 R09: 1ffff1103ede477a [ 60.678787] R10: dffffc0000000000 R11: ffffed103ede477b R12: ffff888115b60ae8 [ 60.681420] R13: 1ffff11022b6cbc4 R14: 00000000fffffff2 R15: 0000000000000001 [ 60.684030] FS: 00007fc2aedd80c0(0000) GS:ffff88826fa8a000(0000) knlGS:0000000000000000 [ 60.686837] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 60.689027] CR2: 000056325369e000 CR3: 000000011088b002 CR4: 0000000000370ef0 [ 60.691623] Call Trace: [ 60.692821] <TASK> [ 60.693960] ? __pfx_verbose+0x10/0x10 [ 60.695656] ? __pfx_disasm_kfunc_name+0x10/0x10 [ 60.697495] check_cond_jmp_op+0x16f7/0x39b0 [ 60.699237] do_check+0x58fa/0xab10 ... Further analysis shows the warning is at line 4302 as below: 4294 /* static subprog call instruction, which 4295 * means that we are exiting current subprog, 4296 * so only r1-r5 could be still requested as 4297 * precise, r0 and r6-r10 or any stack slot in 4298 * the current frame should be zero by now 4299 */ 4300 if (bt_reg_mask(bt) & ~BPF_REGMASK_ARGS) { 4301 verbose(env, ""BUG regs %x\n"", bt_reg_mask(bt)); 4302 WARN_ONCE(1, ""verifier backtracking bug""); 4303 return -EFAULT; 4304 } With the below test (also in the next patch): __used __naked static void __bpf_jmp_r10(void) { asm volatile ( ""r2 = 2314885393468386424 ll;"" ""goto +0;"" ""if r2 <= r10 goto +3;"" ""if r1 >= -1835016 goto +0;"" ""if r2 <= 8 goto +0;"" ""if r3 <= 0 goto +0;"" ""exit;"" ::: __clobber_all); } SEC(""?raw_tp"") __naked void bpf_jmp_r10(void) { asm volatile ( ""r3 = 0 ll;"" ""call __bpf_jmp_r10;"" ""r0 = 0;"" ""exit;"" ::: __clobber_all); } The following is the verifier failure log: 0: (18) r3 = 0x0 ; R3_w=0 2: (85) call pc+2 caller: R10=fp0 callee: frame1: R1=ctx() R3_w=0 R10=fp0 5: frame1: R1=ctx() R3_w=0 R10=fp0 ; asm volatile ("" \ @ verifier_precision.c:184 5: (18) r2 = 0x20202000256c6c78 ; frame1: R2_w=0x20202000256c6c78 7: (05) goto pc+0 8: (bd) if r2 <= r10 goto pc+3 ; frame1: R2_w=0x20202000256c6c78 R10=fp0 9: (35) if r1 >= 0xffe3fff8 goto pc+0 ; frame1: R1=ctx() 10: (b5) if r2 <= 0x8 goto pc+0 mark_precise: frame1: last_idx 10 first_idx 0 subseq_idx -1 mark_precise: frame1: regs=r2 stack= before 9: (35) if r1 >= 0xffe3fff8 goto pc+0 mark_precise: frame1: regs=r2 stack= before 8: (bd) if r2 <= r10 goto pc+3 mark_preci ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/4265682c29c92f52c0da6fad5a79b5801462c8de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac49b7560b4b08b1e4043a29214cc7ad77644c00"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e2d2115e56c4a02377189bfc3a9a7933552a7b0f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38280,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:26.353,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf: Avoid __bpf_prog_ret0_warn when jit fails syzkaller reported an issue: WARNING: CPU: 3 PID: 217 at kernel/bpf/core.c:2357 __bpf_prog_ret0_warn+0xa/0x20 kernel/bpf/core.c:2357 Modules linked in: CPU: 3 UID: 0 PID: 217 Comm: kworker/u32:6 Not tainted 6.15.0-rc4-syzkaller-00040-g8bac8898fe39 RIP: 0010:__bpf_prog_ret0_warn+0xa/0x20 kernel/bpf/core.c:2357 Call Trace: <TASK> bpf_dispatcher_nop_func include/linux/bpf.h:1316 [inline] __bpf_prog_run include/linux/filter.h:718 [inline] bpf_prog_run include/linux/filter.h:725 [inline] cls_bpf_classify+0x74a/0x1110 net/sched/cls_bpf.c:105 ... When creating bpf program, 'fp->jit_requested' depends on bpf_jit_enable. This issue is triggered because of CONFIG_BPF_JIT_ALWAYS_ON is not set and bpf_jit_enable is set to 1, causing the arch to attempt JIT the prog, but jit failed due to FAULT_INJECTION. As a result, incorrectly treats the program as valid, when the program runs it calls `__bpf_prog_ret0_warn` and triggers the WARN_ON_ONCE(1).",,"[{""url"":""https://git.kernel.org/stable/c/0b9bb52796b239de6792d0d68cdc6eb505ebff96"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2bc6dffb4b72d53d6a6ada510269bf548c3f7ae0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6f639c25bfad17d9fd7379ab91ff9678ea9aac85"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/86bc9c742426a16b52a10ef61f5b721aecca2344"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e7fb4ebee6e900899d2b2e5852c3e2eafcbcad66"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ef92b96530d1731d9ac167bc7c193c683cd78fff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38281,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:26.480,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: mt7996: Add NULL check in mt7996_thermal_init devm_kasprintf() can return a NULL pointer on failure,but this returned value in mt7996_thermal_init() is not checked. Add NULL check in mt7996_thermal_init(), to handle kernel NULL pointer dereference error.",,"[{""url"":""https://git.kernel.org/stable/c/8340cb173750c1ea99cd643006b72f8b0e6c21f2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/caf4b347c5dc40fdd125793b5e82ba9fc4de5275"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38282,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:26.610,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: kernfs: Relax constraint in draining guard The active reference lifecycle provides the break/unbreak mechanism but the active reference is not truly active after unbreak -- callers don't use it afterwards but it's important for proper pairing of kn->active counting. Assuming this mechanism is in place, the WARN check in kernfs_should_drain_open_files() is too sensitive -- it may transiently catch those (rightful) callers between kernfs_unbreak_active_protection() and kernfs_put_active() as found out by Chen Ridong: kernfs_remove_by_name_ns kernfs_get_active // active=1 __kernfs_remove // active=0x80000002 kernfs_drain ... wait_event //waiting (active == 0x80000001) kernfs_break_active_protection // active = 0x80000001 // continue kernfs_unbreak_active_protection // active = 0x80000002 ... kernfs_should_drain_open_files // warning occurs kernfs_put_active To avoid the false positives (mind panic_on_warn) remove the check altogether. (This is meant as quick fix, I think active reference break/unbreak may be simplified with larger rework.)",,"[{""url"":""https://git.kernel.org/stable/c/071d8e4c2a3b0999a9b822e2eb8854784a350f8a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2d6a67c2b3b87808a347dc1047b520a9dd177a4f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6bfb154f95d5f0ab7ed056f23aba8c1a94cb3927"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c81f1c7812c61f187bed1b938f1d2e391d503ab"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/72275c888f8962b406ee9c6885c79bf68cca5a63"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38283,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:26.740,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: hisi_acc_vfio_pci: bugfix live migration function without VF device driver If the VF device driver is not loaded in the Guest OS and we attempt to perform device data migration, the address of the migrated data will be NULL. The live migration recovery operation on the destination side will access a null address value, which will cause access errors. Therefore, live migration of VMs without added VF device drivers does not require device data migration. In addition, when the queue address data obtained by the destination is empty, device queue recovery processing will not be performed.",,"[{""url"":""https://git.kernel.org/stable/c/2777a40998deb36f96b6afc48bd397cf58a4edf0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/53e8e8e909f7c3a77857d09d2b733a42547f57ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/59a834592dd200969fdf3c61be1cb0615c647e45"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b5ef128926cd34dffa2a66607b9c82b902581ef8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38284,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:26.857,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: rtw89: pci: configure manual DAC mode via PCI config API only To support 36-bit DMA, configure chip proprietary bit via PCI config API or chip DBI interface. However, the PCI device mmap isn't set yet and the DBI is also inaccessible via mmap, so only if the bit can be accessible via PCI config API, chip can support 36-bit DMA. Otherwise, fallback to 32-bit DMA. With NULL mmap address, kernel throws trace: BUG: unable to handle page fault for address: 0000000000001090 #PF: supervisor write access in kernel mode #PF: error_code(0x0002) - not-present page PGD 0 P4D 0 Oops: Oops: 0002 [#1] PREEMPT SMP PTI CPU: 1 UID: 0 PID: 71 Comm: irq/26-pciehp Tainted: G OE 6.14.2-061402-generic #202504101348 Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE RIP: 0010:rtw89_pci_ops_write16+0x12/0x30 [rtw89_pci] RSP: 0018:ffffb0ffc0acf9d8 EFLAGS: 00010206 RAX: ffffffffc158f9c0 RBX: ffff94865e702020 RCX: 0000000000000000 RDX: 0000000000000718 RSI: 0000000000001090 RDI: ffff94865e702020 RBP: ffffb0ffc0acf9d8 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000015 R13: 0000000000000719 R14: ffffb0ffc0acfa1f R15: ffffffffc1813060 FS: 0000000000000000(0000) GS:ffff9486f3480000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000001090 CR3: 0000000090440001 CR4: 00000000000626f0 Call Trace: <TASK> rtw89_pci_read_config_byte+0x6d/0x120 [rtw89_pci] rtw89_pci_cfg_dac+0x5b/0xb0 [rtw89_pci] rtw89_pci_probe+0xa96/0xbd0 [rtw89_pci] ? __pfx___device_attach_driver+0x10/0x10 ? __pfx___device_attach_driver+0x10/0x10 local_pci_probe+0x47/0xa0 pci_call_probe+0x5d/0x190 pci_device_probe+0xa7/0x160 really_probe+0xf9/0x370 ? pm_runtime_barrier+0x55/0xa0 __driver_probe_device+0x8c/0x140 driver_probe_device+0x24/0xd0 __device_attach_driver+0xcd/0x170 bus_for_each_drv+0x99/0x100 __device_attach+0xb4/0x1d0 device_attach+0x10/0x20 pci_bus_add_device+0x59/0x90 pci_bus_add_devices+0x31/0x80 pciehp_configure_device+0xaa/0x170 pciehp_enable_slot+0xd6/0x240 pciehp_handle_presence_or_link_change+0xf1/0x180 pciehp_ist+0x162/0x1c0 irq_thread_fn+0x24/0x70 irq_thread+0xef/0x1c0 ? __pfx_irq_thread_fn+0x10/0x10 ? __pfx_irq_thread_dtor+0x10/0x10 ? __pfx_irq_thread+0x10/0x10 kthread+0xfc/0x230 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x47/0x70 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK>",,"[{""url"":""https://git.kernel.org/stable/c/a70cf04b08f44f41bce14659aa7012674b15d9de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e1e0f046041474004dc6ebce5ce1d3e86556291d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38285,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:26.977,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf: Fix WARN() in get_bpf_raw_tp_regs syzkaller reported an issue: WARNING: CPU: 3 PID: 5971 at kernel/trace/bpf_trace.c:1861 get_bpf_raw_tp_regs+0xa4/0x100 kernel/trace/bpf_trace.c:1861 Modules linked in: CPU: 3 UID: 0 PID: 5971 Comm: syz-executor205 Not tainted 6.15.0-rc5-syzkaller-00038-g707df3375124 #0 PREEMPT(full) Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 RIP: 0010:get_bpf_raw_tp_regs+0xa4/0x100 kernel/trace/bpf_trace.c:1861 RSP: 0018:ffffc90003636fa8 EFLAGS: 00010293 RAX: 0000000000000000 RBX: 0000000000000003 RCX: ffffffff81c6bc4c RDX: ffff888032efc880 RSI: ffffffff81c6bc83 RDI: 0000000000000005 RBP: ffff88806a730860 R08: 0000000000000005 R09: 0000000000000003 R10: 0000000000000004 R11: 0000000000000000 R12: 0000000000000004 R13: 0000000000000001 R14: ffffc90003637008 R15: 0000000000000900 FS: 0000000000000000(0000) GS:ffff8880d6cdf000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f7baee09130 CR3: 0000000029f5a000 CR4: 0000000000352ef0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ____bpf_get_stack_raw_tp kernel/trace/bpf_trace.c:1934 [inline] bpf_get_stack_raw_tp+0x24/0x160 kernel/trace/bpf_trace.c:1931 bpf_prog_ec3b2eefa702d8d3+0x43/0x47 bpf_dispatcher_nop_func include/linux/bpf.h:1316 [inline] __bpf_prog_run include/linux/filter.h:718 [inline] bpf_prog_run include/linux/filter.h:725 [inline] __bpf_trace_run kernel/trace/bpf_trace.c:2363 [inline] bpf_trace_run3+0x23f/0x5a0 kernel/trace/bpf_trace.c:2405 __bpf_trace_mmap_lock_acquire_returned+0xfc/0x140 include/trace/events/mmap_lock.h:47 __traceiter_mmap_lock_acquire_returned+0x79/0xc0 include/trace/events/mmap_lock.h:47 __do_trace_mmap_lock_acquire_returned include/trace/events/mmap_lock.h:47 [inline] trace_mmap_lock_acquire_returned include/trace/events/mmap_lock.h:47 [inline] __mmap_lock_do_trace_acquire_returned+0x138/0x1f0 mm/mmap_lock.c:35 __mmap_lock_trace_acquire_returned include/linux/mmap_lock.h:36 [inline] mmap_read_trylock include/linux/mmap_lock.h:204 [inline] stack_map_get_build_id_offset+0x535/0x6f0 kernel/bpf/stackmap.c:157 __bpf_get_stack+0x307/0xa10 kernel/bpf/stackmap.c:483 ____bpf_get_stack kernel/bpf/stackmap.c:499 [inline] bpf_get_stack+0x32/0x40 kernel/bpf/stackmap.c:496 ____bpf_get_stack_raw_tp kernel/trace/bpf_trace.c:1941 [inline] bpf_get_stack_raw_tp+0x124/0x160 kernel/trace/bpf_trace.c:1931 bpf_prog_ec3b2eefa702d8d3+0x43/0x47 Tracepoint like trace_mmap_lock_acquire_returned may cause nested call as the corner case show above, which will be resolved with more general method in the future. As a result, WARN_ON_ONCE will be triggered. As Alexei suggested, remove the WARN_ON_ONCE first.",,"[{""url"":""https://git.kernel.org/stable/c/147ea936fc6fa8fe0c93f0df918803a5375ca535"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/18e8cbbae79cb35bdce8a01c889827b9799c762e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3880cdbed1c4607e378f58fa924c5d6df900d1d3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/44ebe361abb322d2afd77930fa767a99f271c4d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6d8f39875a10a194051c3eaefebc7ac06a34aaf3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c98cdf6795a36bca163ebb40411fef1687b9eb13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e167414beabb1e941fe563a96becc98627d5bdf6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee90be48edb3dac612e0b7f5332482a9e8be2696"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38286,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:27.107,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: pinctrl: at91: Fix possible out-of-boundary access at91_gpio_probe() doesn't check that given OF alias is not available or something went wrong when trying to get it. This might have consequences when accessing gpio_chips array with that value as an index. Note, that BUG() can be compiled out and hence won't actually perform the required checks.",,"[{""url"":""https://git.kernel.org/stable/c/264a5cf0c422e65c94447a1ebebfac7c92690670"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/288c39286f759314ee8fb3a80a858179b4f306da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2ecafe59668d2506a68459a9d169ebe41a147a41"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/762ef7d1e6eefad9896560bfcb9bcf7f1b6df9c1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/db5665cbfd766db7d8cd0e5fd6e3c0b412916774"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e02e12d6a7ab76c83849a4122785650dc7edef65"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb435bc4c74acbb286cec773deac13d117d3ef39"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1c1fdc41fbf7e308ced9c86f3f66345a3f6f478"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38287,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:27.230,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: IB/cm: Drop lockdep assert and WARN when freeing old msg The send completion handler can run after cm_id has advanced to another message. The cm_id lock is not needed in this case, but a recent change re-used cm_free_priv_msg(), which asserts that the lock is held and WARNs if the cm_id's currently outstanding msg is different than the one being freed.",,"[{""url"":""https://git.kernel.org/stable/c/7590649ee7af381a9d1153143026dec124c5798e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc096a0cd2017cb0aa1e7fb83131410af9283910"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38288,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:27.340,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: smartpqi: Fix smp_processor_id() call trace for preemptible kernels Correct kernel call trace when calling smp_processor_id() when called in preemptible kernels by using raw_smp_processor_id(). smp_processor_id() checks to see if preemption is disabled and if not, issue an error message followed by a call to dump_stack(). Brief example of call trace: kernel: check_preemption_disabled: 436 callbacks suppressed kernel: BUG: using smp_processor_id() in preemptible [00000000] code: kworker/u1025:0/2354 kernel: caller is pqi_scsi_queue_command+0x183/0x310 [smartpqi] kernel: CPU: 129 PID: 2354 Comm: kworker/u1025:0 kernel: ... kernel: Workqueue: writeback wb_workfn (flush-253:0) kernel: Call Trace: kernel: <TASK> kernel: dump_stack_lvl+0x34/0x48 kernel: check_preemption_disabled+0xdd/0xe0 kernel: pqi_scsi_queue_command+0x183/0x310 [smartpqi] kernel: ...",,"[{""url"":""https://git.kernel.org/stable/c/31224199316f488c8385c5dcdccf7bd80f675b81"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/42d033cf4b517e91c187ad2fbd7b30fdc6d2d62c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6589bc3699bcb45b35b3095c44a5af7a4d75ef7e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38289,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:27.470,2025-07-10T15:15:28.170,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: lpfc: Avoid potential ndlp use-after-free in dev_loss_tmo_callbk Smatch detected a potential use-after-free of an ndlp oject in dev_loss_tmo_callbk during driver unload or fatal error handling. Fix by reordering code to avoid potential use-after-free if initial nodelist reference has been previously removed.",,"[{""url"":""https://git.kernel.org/stable/c/4f09940b5581e44069eb31a66cf7f05c3c35ed04"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b5162bb6aa1ec04dff4509b025883524b6d7e7ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ea405fb4144985d5c60f49c2abd9ba47ea44fdb4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38290,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:27.583,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: fix node corruption in ar->arvifs list In current WLAN recovery code flow, ath12k_core_halt() only reinitializes the ""arvifs"" list head. This will cause the list node immediately following the list head to become an invalid list node. Because the prev of that node still points to the list head ""arvifs"", but the next of the list head ""arvifs"" no longer points to that list node. When a WLAN recovery occurs during the execution of a vif removal, and it happens before the spin_lock_bh(&ar->data_lock) in ath12k_mac_vdev_delete(), list_del() will detect the previously mentioned situation, thereby triggering a kernel panic. The fix is to remove and reinitialize all vif list nodes from the list head ""arvifs"" during WLAN halt. The reinitialization is to make the list nodes valid, ensuring that the list_del() in ath12k_mac_vdev_delete() can execute normally. Call trace: __list_del_entry_valid_or_report+0xd4/0x100 (P) ath12k_mac_remove_link_interface.isra.0+0xf8/0x2e4 [ath12k] ath12k_scan_vdev_clean_work+0x40/0x164 [ath12k] cfg80211_wiphy_work+0xfc/0x100 process_one_work+0x164/0x2d0 worker_thread+0x254/0x380 kthread+0xfc/0x100 ret_from_fork+0x10/0x20 The change is mostly copied from the ath11k patch: https://lore.kernel.org/all/20250320053145.3445187-1-quic_stonez@quicinc.com/ Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.4.1-00199-QCAHKSWPL_SILICONZ-1",,"[{""url"":""https://git.kernel.org/stable/c/6285516170f9e2f04b9dbf1e5100e0d7cbac22b4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6bfe7ae9bbd9734751b853e2d2e1c13e8b46fd2d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/823435bd23108d6f8be89ea2d025c0e2e3769c51"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be049199dec9189602bc06e2c70eda3aa0f2ea6e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38291,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:27.700,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: Prevent sending WMI commands to firmware during firmware crash Currently, we encounter the following kernel call trace when a firmware crash occurs. This happens because the host sends WMI commands to the firmware while it is in recovery, causing the commands to fail and resulting in the kernel call trace. Set the ATH12K_FLAG_CRASH_FLUSH and ATH12K_FLAG_RECOVERY flags when the host driver receives the firmware crash notification from MHI. This prevents sending WMI commands to the firmware during recovery. Call Trace: <TASK> dump_stack_lvl+0x75/0xc0 register_lock_class+0x6be/0x7a0 ? __lock_acquire+0x644/0x19a0 __lock_acquire+0x95/0x19a0 lock_acquire+0x265/0x310 ? ath12k_ce_send+0xa2/0x210 [ath12k] ? find_held_lock+0x34/0xa0 ? ath12k_ce_send+0x56/0x210 [ath12k] _raw_spin_lock_bh+0x33/0x70 ? ath12k_ce_send+0xa2/0x210 [ath12k] ath12k_ce_send+0xa2/0x210 [ath12k] ath12k_htc_send+0x178/0x390 [ath12k] ath12k_wmi_cmd_send_nowait+0x76/0xa0 [ath12k] ath12k_wmi_cmd_send+0x62/0x190 [ath12k] ath12k_wmi_pdev_bss_chan_info_request+0x62/0xc0 [ath1 ath12k_mac_op_get_survey+0x2be/0x310 [ath12k] ieee80211_dump_survey+0x99/0x240 [mac80211] nl80211_dump_survey+0xe7/0x470 [cfg80211] ? kmalloc_reserve+0x59/0xf0 genl_dumpit+0x24/0x70 netlink_dump+0x177/0x360 __netlink_dump_start+0x206/0x280 genl_family_rcv_msg_dumpit.isra.22+0x8a/0xe0 ? genl_family_rcv_msg_attrs_parse.isra.23+0xe0/0xe0 ? genl_op_lock.part.12+0x10/0x10 ? genl_dumpit+0x70/0x70 genl_rcv_msg+0x1d0/0x290 ? nl80211_del_station+0x330/0x330 [cfg80211] ? genl_get_cmd_both+0x50/0x50 netlink_rcv_skb+0x4f/0x100 genl_rcv+0x1f/0x30 netlink_unicast+0x1b6/0x260 netlink_sendmsg+0x31a/0x450 __sock_sendmsg+0xa8/0xb0 ____sys_sendmsg+0x1e4/0x260 ___sys_sendmsg+0x89/0xe0 ? local_clock_noinstr+0xb/0xc0 ? rcu_is_watching+0xd/0x40 ? kfree+0x1de/0x370 ? __sys_sendmsg+0x7a/0xc0 Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.4.1-00199-QCAHKSWPL_SILICONZ-1",,"[{""url"":""https://git.kernel.org/stable/c/2563069baf243cadc76dc64d9085606742c4b282"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e9e094a9734ea3bd4d4d117c915ccf129ac61ba1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38292,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:27.813,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: fix invalid access to memory In ath12k_dp_rx_msdu_coalesce(), rxcb is fetched from skb and boolean is_continuation is part of rxcb. Currently, after freeing the skb, the rxcb->is_continuation accessed again which is wrong since the memory is already freed. This might lead use-after-free error. Hence, fix by locally defining bool is_continuation from rxcb, so that after freeing skb, is_continuation can be used. Compile tested only.",,"[{""url"":""https://git.kernel.org/stable/c/371b340affa52f280f6eadfd25fbd43f09f0d5c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5f09d16cd57764c95c8548fe5b70672c9ac01127"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9f17747fbda6fca934854463873c4abf8061491d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38293,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:27.927,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath11k: fix node corruption in ar->arvifs list In current WLAN recovery code flow, ath11k_core_halt() only reinitializes the ""arvifs"" list head. This will cause the list node immediately following the list head to become an invalid list node. Because the prev of that node still points to the list head ""arvifs"", but the next of the list head ""arvifs"" no longer points to that list node. When a WLAN recovery occurs during the execution of a vif removal, and it happens before the spin_lock_bh(&ar->data_lock) in ath11k_mac_op_remove_interface(), list_del() will detect the previously mentioned situation, thereby triggering a kernel panic. The fix is to remove and reinitialize all vif list nodes from the list head ""arvifs"" during WLAN halt. The reinitialization is to make the list nodes valid, ensuring that the list_del() in ath11k_mac_op_remove_interface() can execute normally. Call trace: __list_del_entry_valid_or_report+0xb8/0xd0 ath11k_mac_op_remove_interface+0xb0/0x27c [ath11k] drv_remove_interface+0x48/0x194 [mac80211] ieee80211_do_stop+0x6e0/0x844 [mac80211] ieee80211_stop+0x44/0x17c [mac80211] __dev_close_many+0xac/0x150 __dev_change_flags+0x194/0x234 dev_change_flags+0x24/0x6c devinet_ioctl+0x3a0/0x670 inet_ioctl+0x200/0x248 sock_do_ioctl+0x60/0x118 sock_ioctl+0x274/0x35c __arm64_sys_ioctl+0xac/0xf0 invoke_syscall+0x48/0x114 ... Tested-on: QCA6698AQ hw2.1 PCI WLAN.HSP.1.1-04591-QCAHSPSWPL_V1_V2_SILICONZ_IOE-1",,"[{""url"":""https://git.kernel.org/stable/c/31e98e277ae47f56632e4d663b1d4fd12ba33ea8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c139015b597e570dd5962934e9f9a2f4cc8ef48"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6d6cb27fe146061f2512e904618f5e005bb7bb6a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b0974ed82e6ad5ff246fd90a5b14f3e7be4f2924"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f50ba7e7b607f2d00618799312e7fdb76a1ff48e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f5d77d0d41ea7a204d47288d0cf0404a52b5890e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f9507cf2dd0e1ed5028c0e8240da6fe5fd3110d3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38294,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:28.050,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: fix NULL access in assign channel context handler Currently, when ath12k_mac_assign_vif_to_vdev() fails, the radio handle (ar) gets accessed from the link VIF handle (arvif) for debug logging, This is incorrect. In the fail scenario, radio handle is NULL. Fix the NULL access, avoid radio handle access by moving to the hardware debug logging helper function (ath12k_hw_warn). Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1 Tested-on: WCN7850 hw2.0 PCI WLAN.HMT.1.0.c5-00481-QCAHMTSWPL_V1.0_V2.0_SILICONZ-3",,"[{""url"":""https://git.kernel.org/stable/c/3f919f76893069ec3c7475acaeb611eb31fca22d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ea24531d00f782f4e659e8c74578b7ac144720ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38295,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:28.160,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: perf/amlogic: Replace smp_processor_id() with raw_smp_processor_id() in meson_ddr_pmu_create() The Amlogic DDR PMU driver meson_ddr_pmu_create() function incorrectly uses smp_processor_id(), which assumes disabled preemption. This leads to kernel warnings during module loading because meson_ddr_pmu_create() can be called in a preemptible context. Following kernel warning and stack trace: [ 31.745138] [ T2289] BUG: using smp_processor_id() in preemptible [00000000] code: (udev-worker)/2289 [ 31.745154] [ T2289] caller is debug_smp_processor_id+0x28/0x38 [ 31.745172] [ T2289] CPU: 4 UID: 0 PID: 2289 Comm: (udev-worker) Tainted: GW 6.14.0-0-MANJARO-ARM #1 59519addcbca6ba8de735e151fd7b9e97aac7ff0 [ 31.745181] [ T2289] Tainted: [W]=WARN [ 31.745183] [ T2289] Hardware name: Hardkernel ODROID-N2Plus (DT) [ 31.745188] [ T2289] Call trace: [ 31.745191] [ T2289] show_stack+0x28/0x40 (C) [ 31.745199] [ T2289] dump_stack_lvl+0x4c/0x198 [ 31.745205] [ T2289] dump_stack+0x20/0x50 [ 31.745209] [ T2289] check_preemption_disabled+0xec/0xf0 [ 31.745213] [ T2289] debug_smp_processor_id+0x28/0x38 [ 31.745216] [ T2289] meson_ddr_pmu_create+0x200/0x560 [meson_ddr_pmu_g12 8095101c49676ad138d9961e3eddaee10acca7bd] [ 31.745237] [ T2289] g12_ddr_pmu_probe+0x20/0x38 [meson_ddr_pmu_g12 8095101c49676ad138d9961e3eddaee10acca7bd] [ 31.745246] [ T2289] platform_probe+0x98/0xe0 [ 31.745254] [ T2289] really_probe+0x144/0x3f8 [ 31.745258] [ T2289] __driver_probe_device+0xb8/0x180 [ 31.745261] [ T2289] driver_probe_device+0x54/0x268 [ 31.745264] [ T2289] __driver_attach+0x11c/0x288 [ 31.745267] [ T2289] bus_for_each_dev+0xfc/0x160 [ 31.745274] [ T2289] driver_attach+0x34/0x50 [ 31.745277] [ T2289] bus_add_driver+0x160/0x2b0 [ 31.745281] [ T2289] driver_register+0x78/0x120 [ 31.745285] [ T2289] __platform_driver_register+0x30/0x48 [ 31.745288] [ T2289] init_module+0x30/0xfe0 [meson_ddr_pmu_g12 8095101c49676ad138d9961e3eddaee10acca7bd] [ 31.745298] [ T2289] do_one_initcall+0x11c/0x438 [ 31.745303] [ T2289] do_init_module+0x68/0x228 [ 31.745311] [ T2289] load_module+0x118c/0x13a8 [ 31.745315] [ T2289] __arm64_sys_finit_module+0x274/0x390 [ 31.745320] [ T2289] invoke_syscall+0x74/0x108 [ 31.745326] [ T2289] el0_svc_common+0x90/0xf8 [ 31.745330] [ T2289] do_el0_svc+0x2c/0x48 [ 31.745333] [ T2289] el0_svc+0x60/0x150 [ 31.745337] [ T2289] el0t_64_sync_handler+0x80/0x118 [ 31.745341] [ T2289] el0t_64_sync+0x1b8/0x1c0 Changes replaces smp_processor_id() with raw_smp_processor_id() to ensure safe CPU ID retrieval in preemptible contexts.",,"[{""url"":""https://git.kernel.org/stable/c/097469a2b0f12b91b4f27b9e9e4f2c46484cde30"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6f5f53048d3b761d694430632d3a03977273e987"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/77511c2d2d1cbce8d9b4f50849843dd469d14173"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b038ffbd49e41f99228dbb0c66d6dd7b20292884"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38296,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:28.277,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ACPI: platform_profile: Avoid initializing on non-ACPI platforms The platform profile driver is loaded even on platforms that do not have ACPI enabled. The initialization of the sysfs entries was recently moved from platform_profile_register() to the module init call, and those entries need acpi_kobj to be initialized which is not the case when ACPI is disabled. This results in the following warning: WARNING: CPU: 5 PID: 1 at fs/sysfs/group.c:131 internal_create_group+0xa22/0xdd8 Modules linked in: CPU: 5 UID: 0 PID: 1 Comm: swapper/0 Tainted: G W 6.15.0-rc7-dirty #6 PREEMPT Tainted: [W]=WARN Hardware name: riscv-virtio,qemu (DT) epc : internal_create_group+0xa22/0xdd8 ra : internal_create_group+0xa22/0xdd8 Call Trace: internal_create_group+0xa22/0xdd8 sysfs_create_group+0x22/0x2e platform_profile_init+0x74/0xb2 do_one_initcall+0x198/0xa9e kernel_init_freeable+0x6d8/0x780 kernel_init+0x28/0x24c ret_from_fork+0xe/0x18 Fix this by checking if ACPI is enabled before trying to create sysfs entries. [ rjw: Subject and changelog edits ]",,"[{""url"":""https://git.kernel.org/stable/c/ccc3d68b92be89c30ba42ac62d2a141bd0c2b457"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dd133162c9cff5951a692fab9811fadf46a46457"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38297,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:28.390,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: PM: EM: Fix potential division-by-zero error in em_compute_costs() When the device is of a non-CPU type, table[i].performance won't be initialized in the previous em_init_performance(), resulting in division by zero when calculating costs in em_compute_costs(). Since the 'cost' algorithm is only used for EAS energy efficiency calculations and is currently not utilized by other device drivers, we should add the _is_cpu_device(dev) check to prevent this division-by-zero issue.",,"[{""url"":""https://git.kernel.org/stable/c/14cbdd64f3870cf0a2d94b87919b9056448c59a0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/179c0c7044a378198adb36f2a12410ab68cc730a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/81d72f9241d884ec29524431f74f8009310cfa0c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38298,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:28.500,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: EDAC/skx_common: Fix general protection fault After loading i10nm_edac (which automatically loads skx_edac_common), if unload only i10nm_edac, then reload it and perform error injection testing, a general protection fault may occur: mce: [Hardware Error]: Machine check events logged Oops: general protection fault ... ... Workqueue: events mce_gen_pool_process RIP: 0010:string+0x53/0xe0 ... Call Trace: <TASK> ? die_addr+0x37/0x90 ? exc_general_protection+0x1e7/0x3f0 ? asm_exc_general_protection+0x26/0x30 ? string+0x53/0xe0 vsnprintf+0x23e/0x4c0 snprintf+0x4d/0x70 skx_adxl_decode+0x16a/0x330 [skx_edac_common] skx_mce_check_error.part.0+0xf8/0x220 [skx_edac_common] skx_mce_check_error+0x17/0x20 [skx_edac_common] ... The issue arose was because the variable 'adxl_component_count' (inside skx_edac_common), which counts the ADXL components, was not reset. During the reloading of i10nm_edac, the count was incremented by the actual number of ADXL components again, resulting in a count that was double the real number of ADXL components. This led to an out-of-bounds reference to the ADXL component array, causing the general protection fault above. Fix this issue by resetting the 'adxl_component_count' in adxl_put(), which is called during the unloading of {skx,i10nm}_edac.",,"[{""url"":""https://git.kernel.org/stable/c/20d2d476b3ae18041be423671a8637ed5ffd6958"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/31ef6f7c9aee3be78d63789653e92350f2537f93"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f5d0659000923735350da60ad710f8c804544fe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/80bf28fd623d97dd4f4825fbbe9d736cec2afba3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a13e8343ffcff27af1ff79597ff7ba241e6d9471"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6ed3a6edff09c1187cc6ade7f5967bca2376a13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf6a8502a5f4ff6e4d135d795945cdade49ec8b0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e8530ed3c0769a4d8f79c212715ec1cf277787f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38299,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:28.623,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: mediatek: mt8195: Set ETDM1/2 IN/OUT to COMP_DUMMY() ETDM2_IN_BE and ETDM1_OUT_BE are defined as COMP_EMPTY(), in the case the codec dai_name will be null. Avoid a crash if the device tree is not assigning a codec to these links. [ 1.179936] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000 [ 1.181065] Mem abort info: [ 1.181420] ESR = 0x0000000096000004 [ 1.181892] EC = 0x25: DABT (current EL), IL = 32 bits [ 1.182576] SET = 0, FnV = 0 [ 1.182964] EA = 0, S1PTW = 0 [ 1.183367] FSC = 0x04: level 0 translation fault [ 1.183983] Data abort info: [ 1.184406] ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000 [ 1.185097] CM = 0, WnR = 0, TnD = 0, TagAccess = 0 [ 1.185766] GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 [ 1.186439] [0000000000000000] user address but active_mm is swapper [ 1.187239] Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP [ 1.188029] Modules linked in: [ 1.188420] CPU: 7 UID: 0 PID: 70 Comm: kworker/u32:1 Not tainted 6.14.0-rc4-next-20250226+ #85 [ 1.189515] Hardware name: Radxa NIO 12L (DT) [ 1.190065] Workqueue: events_unbound deferred_probe_work_func [ 1.190808] pstate: 40400009 (nZcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 1.191683] pc : __pi_strcmp+0x24/0x140 [ 1.192170] lr : mt8195_mt6359_soc_card_probe+0x224/0x7b0 [ 1.192854] sp : ffff800083473970 [ 1.193271] x29: ffff800083473a10 x28: 0000000000001008 x27: 0000000000000002 [ 1.194168] x26: ffff800082408960 x25: ffff800082417db0 x24: ffff800082417d88 [ 1.195065] x23: 000000000000001e x22: ffff800082dbf480 x21: ffff800082dc07b8 [ 1.195961] x20: 0000000000000000 x19: 0000000000000013 x18: 00000000ffffffff [ 1.196858] x17: 000000040044ffff x16: 005000f2b5503510 x15: 0000000000000006 [ 1.197755] x14: ffff800082407af0 x13: 6e6f69737265766e x12: 692d6b636f6c6374 [ 1.198651] x11: 0000000000000002 x10: ffff80008240b920 x9 : 0000000000000018 [ 1.199547] x8 : 0101010101010101 x7 : 0000000000000000 x6 : 0000000000000000 [ 1.200443] x5 : 0000000000000000 x4 : 8080808080000000 x3 : 303933383978616d [ 1.201339] x2 : 0000000000000000 x1 : ffff80008240b920 x0 : 0000000000000000 [ 1.202236] Call trace: [ 1.202545] __pi_strcmp+0x24/0x140 (P) [ 1.203029] mtk_soundcard_common_probe+0x3bc/0x5b8 [ 1.203644] platform_probe+0x70/0xe8 [ 1.204106] really_probe+0xc8/0x3a0 [ 1.204556] __driver_probe_device+0x84/0x160 [ 1.205104] driver_probe_device+0x44/0x130 [ 1.205630] __device_attach_driver+0xc4/0x170 [ 1.206189] bus_for_each_drv+0x8c/0xf8 [ 1.206672] __device_attach+0xa8/0x1c8 [ 1.207155] device_initial_probe+0x1c/0x30 [ 1.207681] bus_probe_device+0xb0/0xc0 [ 1.208165] deferred_probe_work_func+0xa4/0x100 [ 1.208747] process_one_work+0x158/0x3e0 [ 1.209254] worker_thread+0x2c4/0x3e8 [ 1.209727] kthread+0x134/0x1f0 [ 1.210136] ret_from_fork+0x10/0x20 [ 1.210589] Code: 54000401 b50002c6 d503201f f86a6803 (f8408402) [ 1.211355] ---[ end trace 0000000000000000 ]---",,"[{""url"":""https://git.kernel.org/stable/c/183e7329d41d7a8e298f48b6b0eb81102a8654de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7af317f7faaab09d5a78f24605057d11f5955115"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/87dbfe2b392df9621f6e522e5fa6fb8849ca92ab"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38300,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:28.740,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: crypto: sun8i-ce-cipher - fix error handling in sun8i_ce_cipher_prepare() Fix two DMA cleanup issues on the error path in sun8i_ce_cipher_prepare(): 1] If dma_map_sg() fails for areq->dst, the device driver would try to free DMA memory it has not allocated in the first place. To fix this, on the ""theend_sgs"" error path, call dma unmap only if the corresponding dma map was successful. 2] If the dma_map_single() call for the IV fails, the device driver would try to free an invalid DMA memory address on the ""theend_iv"" path: ------------[ cut here ]------------ DMA-API: sun8i-ce 1904000.crypto: device driver tries to free an invalid DMA memory address WARNING: CPU: 2 PID: 69 at kernel/dma/debug.c:968 check_unmap+0x123c/0x1b90 Modules linked in: skcipher_example(O+) CPU: 2 UID: 0 PID: 69 Comm: 1904000.crypto- Tainted: G O 6.15.0-rc3+ #24 PREEMPT Tainted: [O]=OOT_MODULE Hardware name: OrangePi Zero2 (DT) pc : check_unmap+0x123c/0x1b90 lr : check_unmap+0x123c/0x1b90 ... Call trace: check_unmap+0x123c/0x1b90 (P) debug_dma_unmap_page+0xac/0xc0 dma_unmap_page_attrs+0x1f4/0x5fc sun8i_ce_cipher_do_one+0x1bd4/0x1f40 crypto_pump_work+0x334/0x6e0 kthread_worker_fn+0x21c/0x438 kthread+0x374/0x664 ret_from_fork+0x10/0x20 ---[ end trace 0000000000000000 ]--- To fix this, check for !dma_mapping_error() before calling dma_unmap_single() on the ""theend_iv"" path.",,"[{""url"":""https://git.kernel.org/stable/c/19d267d9fad00d94ad8477899e38ed7c11f33fb6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4051250e5db489f8ad65fc337e2677b9b568ac72"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a0ac3f85b2e3ef529e852f252a70311f9029d5e6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c62b79c1c51303dbcb6edfa4de0ee176f4934c52"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f31adc3e356f7350d4a4d68c98d3f60f2f6e26b3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38301,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:28.860,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nvmem: zynqmp_nvmem: unbreak driver after cleanup Commit 29be47fcd6a0 (""nvmem: zynqmp_nvmem: zynqmp_nvmem_probe cleanup"") changed the driver to expect the device pointer to be passed as the ""context"", but in nvmem the context parameter comes from nvmem_config.priv which is never set - Leading to null pointer exceptions when the device is accessed.",,"[{""url"":""https://git.kernel.org/stable/c/3728101f56ef54425a11027a3ddc2c3941d60b71"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c8bb1bcea877446f86922a8fd1661b8c07d90e5c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe8abdd175d7b547ae1a612757e7902bcd62e9cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38302,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:28.970,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: block: don't use submit_bio_noacct_nocheck in blk_zone_wplug_bio_work Bios queued up in the zone write plug have already gone through all all preparation in the submit_bio path, including the freeze protection. Submitting them through submit_bio_noacct_nocheck duplicates the work and can can cause deadlocks when freezing a queue with pending bio write plugs. Go straight to ->submit_bio or blk_mq_submit_bio to bypass the superfluous extra freeze protection and checks.",,"[{""url"":""https://git.kernel.org/stable/c/0fccb6773b1f4f992e435582cf8e050de421b678"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6ffae5d53f704d300cc73b06b4ea99e4507f7cf1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cf625013d8741c01407bbb4a60c111b61b9fa69d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38303,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:29.090,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: eir: Fix possible crashes on eir_create_adv_data eir_create_adv_data may attempt to add EIR_FLAGS and EIR_TX_POWER without checking if that would fit.",,"[{""url"":""https://git.kernel.org/stable/c/2af40d795d3fb0ee5c074b7ac56ab22402aa6e4f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/47c03902269aff377f959dc3fd94a9733aa31d6e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b9db0c27e73b7c8a19384a44af527edfda74ff3d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38304,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:29.200,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: Fix NULL pointer deference on eir_get_service_data The len parameter is considered optional so it can be NULL so it cannot be used for skipping to next entry of EIR_SERVICE_DATA.",,"[{""url"":""https://git.kernel.org/stable/c/20a2aa01f5aeb6daad9aeaa7c33dd512c58d81eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/497c9d2d7d3983826bb02c10fb4a5818be6550fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4bf29910570666e668a60d953f8da78e95bb7fa2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d99cc0f8e6fa0f35570887899f178122a61d44e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/842f7c3154d5b25ca11753c02ee8cf6ee64c0142"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38305,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:29.320,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ptp: remove ptp->n_vclocks check logic in ptp_vclock_in_use() There is no disagreement that we should check both ptp->is_virtual_clock and ptp->n_vclocks to check if the ptp virtual clock is in use. However, when we acquire ptp->n_vclocks_mux to read ptp->n_vclocks in ptp_vclock_in_use(), we observe a recursive lock in the call trace starting from n_vclocks_store(). ============================================ WARNING: possible recursive locking detected 6.15.0-rc6 #1 Not tainted -------------------------------------------- syz.0.1540/13807 is trying to acquire lock: ffff888035a24868 (&ptp->n_vclocks_mux){+.+.}-{4:4}, at: ptp_vclock_in_use drivers/ptp/ptp_private.h:103 [inline] ffff888035a24868 (&ptp->n_vclocks_mux){+.+.}-{4:4}, at: ptp_clock_unregister+0x21/0x250 drivers/ptp/ptp_clock.c:415 but task is already holding lock: ffff888030704868 (&ptp->n_vclocks_mux){+.+.}-{4:4}, at: n_vclocks_store+0xf1/0x6d0 drivers/ptp/ptp_sysfs.c:215 other info that might help us debug this: Possible unsafe locking scenario: CPU0 ---- lock(&ptp->n_vclocks_mux); lock(&ptp->n_vclocks_mux); *** DEADLOCK *** .... ============================================ The best way to solve this is to remove the logic that checks ptp->n_vclocks in ptp_vclock_in_use(). The reason why this is appropriate is that any path that uses ptp->n_vclocks must unconditionally check if ptp->n_vclocks is greater than 0 before unregistering vclocks, and all functions are already written this way. And in the function that uses ptp->n_vclocks, we already get ptp->n_vclocks_mux before unregistering vclocks. Therefore, we need to remove the redundant check for ptp->n_vclocks in ptp_vclock_in_use() to prevent recursive locking.",,"[{""url"":""https://git.kernel.org/stable/c/259119595227fd20f6aa29d85abe086b6fdd9eb1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5d217e7031a5c06d366580fc6ddbf43527b780d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/87f7ce260a3c838b49e1dc1ceedf1006795157a2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b1b73c452331451020be3bf4b014901015ae6663"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b93e6fef4eda48e17d9c642b9abad98a066fd4a3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ef8fc007c28a30a4c0d90bf755e0f343d99bb392"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38306,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:29.440,2025-09-09T17:15:44.660,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fs/fhandle.c: fix a race in call of has_locked_children() may_decode_fh() is calling has_locked_children() while holding no locks. That's an oopsable race... The rest of the callers are safe since they are holding namespace_sem and are guaranteed a positive refcount on the mount in question. Rename the current has_locked_children() to __has_locked_children(), make it static and switch the fs/namespace.c users to it. Make has_locked_children() a wrapper for __has_locked_children(), calling the latter under read_seqlock_excl(&mount_lock).",,"[{""url"":""https://git.kernel.org/stable/c/1f282cdc1d219c4a557f7009e81bc792820d9d9a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/287c7d34eedd37af1272dfb3b6e8656f4f026424"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6482c3dccbfb8d20e2856ce67c75856859930b3f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38307,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:29.550,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: Intel: avs: Verify content returned by parse_int_array() The first element of the returned array stores its length. If it is 0, any manipulation beyond the element at index 0 ends with null-ptr-deref.",,"[{""url"":""https://git.kernel.org/stable/c/18ff538aac63de1866e5a49d57e22788b5c21d12"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2916794ffbce604cc2cda105f6b8a4a7c748dd7f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/93e246b6769bdacb09cfff4ea0f00fe5ab4f0d7a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc03c899e6d9812b25c3754c9a95c3830c4aec26"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38308,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:29.667,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: Intel: avs: Fix possible null-ptr-deref when initing hw Search result of avs_dai_find_path_template() shall be verified before being used. As 'template' is already known when avs_hw_constraints_init() is fired, drop the search entirely.",,"[{""url"":""https://git.kernel.org/stable/c/2f78724d4f0c665c83e202e3989d5333a2cb1036"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ea218ae05e60616531fe652650b98dcd3c328279"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38309,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:29.777,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/xe/vm: move xe_svm_init() earlier In xe_vm_close_and_put() we need to be able to call xe_svm_fini(), however during vm creation we can call this on the error path, before having actually initialised the svm state, leading to various splats followed by a fatal NPD. (cherry picked from commit 4f296d77cf49fcb5f90b4674123ad7f3a0676165)",,"[{""url"":""https://git.kernel.org/stable/c/8cf8cde41ad01150afbd1327ad1942387787f7fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f5e6a6a8aa46d44ec7a240766cf3b7dd077718b9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38310,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:29.890,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: seg6: Fix validation of nexthop addresses The kernel currently validates that the length of the provided nexthop address does not exceed the specified length. This can lead to the kernel reading uninitialized memory if user space provided a shorter length than the specified one. Fix by validating that the provided length exactly matches the specified one.",,"[{""url"":""https://git.kernel.org/stable/c/668923c474608dd9ebce0fbcc41bd8a27aa73dd6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7632fedb266d93ed0ed9f487133e6c6314a9b2d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd4cd09810211fa23609c5c1018352e9e1cd8e5a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cef33a86bcb04ecf4dc10c56f6c42ee9d1c54bac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d2507aeea45b3c5aa24d5daae0cf3db76895c0b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d5d9fd13bc19a3f9f2a951c5b6e934d84205789e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38311,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:30.010,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iavf: get rid of the crit lock Get rid of the crit lock. That frees us from the error prone logic of try_locks. Thanks to netdev_lock() by Jakub it is now easy, and in most cases we were protected by it already - replace crit lock by netdev lock when it was not the case. Lockdep reports that we should cancel the work under crit_lock [splat1], and that was the scheme we have mostly followed since [1] by Slawomir. But when that is done we still got into deadlocks [splat2]. So instead we should look at the bigger problem, namely ""weird locking/scheduling"" of the iavf. The first step to fix that is to remove the crit lock. I will followup with a -next series that simplifies scheduling/tasks. Cancel the work without netdev lock (weird unlock+lock scheme), to fix the [splat2] (which would be totally ugly if we would kept the crit lock). Extend protected part of iavf_watchdog_task() to include scheduling more work. Note that the removed comment in iavf_reset_task() was misplaced, it belonged to inside of the removed if condition, so it's gone now. [splat1] - w/o this patch - The deadlock during VF removal: WARNING: possible circular locking dependency detected sh/3825 is trying to acquire lock: ((work_completion)(&(&adapter->watchdog_task)->work)){+.+.}-{0:0}, at: start_flush_work+0x1a1/0x470 but task is already holding lock: (&adapter->crit_lock){+.+.}-{4:4}, at: iavf_remove+0xd1/0x690 [iavf] which lock already depends on the new lock. [splat2] - when cancelling work under crit lock, w/o this series, see [2] for the band aid attempt WARNING: possible circular locking dependency detected sh/3550 is trying to acquire lock: ((wq_completion)iavf){+.+.}-{0:0}, at: touch_wq_lockdep_map+0x26/0x90 but task is already holding lock: (&dev->lock){+.+.}-{4:4}, at: iavf_remove+0xa6/0x6e0 [iavf] which lock already depends on the new lock. [1] fc2e6b3b132a (""iavf: Rework mutexes for better synchronisation"") [2] https://github.com/pkitszel/linux/commit/52dddbfc2bb60294083f5711a158a",,"[{""url"":""https://git.kernel.org/stable/c/120f28a6f314fef7f282c99f196923fe44081cad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/620ab4d6215de0b25227f9fff1a8c7fb66837cb8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38312,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:30.120,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fbdev: core: fbcvt: avoid division by 0 in fb_cvt_hperiod() In fb_find_mode_cvt(), iff mode->refresh somehow happens to be 0x80000000, cvt.f_refresh will become 0 when multiplying it by 2 due to overflow. It's then passed to fb_cvt_hperiod(), where it's used as a divider -- division by 0 will result in kernel oops. Add a sanity check for cvt.f_refresh to avoid such overflow... Found by Linux Verification Center (linuxtesting.org) with the Svace static analysis tool.",,"[{""url"":""https://git.kernel.org/stable/c/2d63433e8eaa3c91b2948190e395bc67009db0d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f6dae09fc8c306eb70fdfef70726e1f154e173a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/53784073cbad18f75583fd3da9ffdfc4d1f05405"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/54947530663edcbaaee1314c01fdd8c72861b124"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/610f247f2772e4f92b63442125a1b7ade79898d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9027ce4c037b566b658b8939a76326b7125e3627"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ab91647acdf43b984824776559a452212eaeb21a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b235393b9f43ff86a38ca2bde6372312ea215dc5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38313,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:30.240,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bus: fsl-mc: fix double-free on mc_dev The blamed commit tried to simplify how the deallocations are done but, in the process, introduced a double-free on the mc_dev variable. In case the MC device is a DPRC, a new mc_bus is allocated and the mc_dev variable is just a reference to one of its fields. In this circumstance, on the error path only the mc_bus should be freed. This commit introduces back the following checkpatch warning which is a false-positive. WARNING: kfree(NULL) is safe and this check is probably not required + if (mc_bus) + kfree(mc_bus);",,"[{""url"":""https://git.kernel.org/stable/c/12e4431e5078847791936820bd39df9e1ee26d2e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1d5baab39e5b09a76870b345cdee7933871b881f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3135e03a92f6b5259d0a7f25f728e9e7866ede3f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4b23c46eb2d88924b93aca647bde9a4b9cf62cf9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7002b954c4a8b9965ba0f139812ee4a6f71beac8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/873d47114fd5e5a1cad2018843671537cc71ac84"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b2057374f326303c86d8423415ab58656eebc695"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d694bf8a9acdbd061596f3e7549bc8cb70750a60"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38314,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:30.363,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: virtio-pci: Fix result size returned for the admin command completion The result size returned by virtio_pci_admin_dev_parts_get() is 8 bytes larger than the actual result data size. This occurs because the result_sg_size field of the command is filled with the result length from virtqueue_get_buf(), which includes both the data size and an additional 8 bytes of status. This oversized result size causes two issues: 1. The state transferred to the destination includes 8 bytes of extra data at the end. 2. The allocated buffer in the kernel may be smaller than the returned size, leading to failures when reading beyond the allocated size. The commit fixes this by subtracting the status size from the result of virtqueue_get_buf(). This fix has been tested through live migrations with virtio-net, virtio-net-transitional, and virtio-blk devices.",,"[{""url"":""https://git.kernel.org/stable/c/920b6720bb63893b81516c0c45884a8350f9e4bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ef41ebf787fcbde99ac404ae473f8467641f983"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38315,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:30.477,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: btintel: Check dsbr size from EFI variable Since the size of struct btintel_dsbr is already known, we can just start there instead of querying the EFI variable size. If the final result doesn't match what we expect also fail. This fixes a stack buffer overflow when the EFI variable is larger than struct btintel_dsbr.",,"[{""url"":""https://git.kernel.org/stable/c/3aa1dc3c9060e335e82e9c182bf3d1db29220b1b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7b8526bb489780ccc0caffc446ecabec83cfe568"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9427f6081f37c795a8bd29d0ee72a4da3bd64af8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38316,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:30.590,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: mt7996: avoid NULL pointer dereference in mt7996_set_monitor() The function mt7996_set_monitor() dereferences phy before the NULL sanity check. Fix this to avoid NULL pointer dereference by moving the dereference after the check.",,"[{""url"":""https://git.kernel.org/stable/c/83a422c8169eef95aef57f7ddc467bb126d9ae81"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cb423ddad0f6e6f55b1700422ab777b25597cc83"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38317,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:30.703,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: Fix buffer overflow in debugfs If the user tries to write more than 32 bytes then it results in memory corruption. Fortunately, this is debugfs so it's limited to root users.",,"[{""url"":""https://git.kernel.org/stable/c/0c57aa8ef94cffc5c2d68230e19329a03e71a94f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c4a200d03574bfcbf54fdb7ba5968b58ad2e0b3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c7a5031a6b0d42e640fbd2d5d05f61f74e32dce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38318,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:30.823,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: perf: arm-ni: Fix missing platform_set_drvdata() Add missing platform_set_drvdata in arm_ni_probe(), otherwise calling platform_get_drvdata() in remove returns NULL.",,"[{""url"":""https://git.kernel.org/stable/c/498129a868ce966af277841f7e32e9f76b3779ad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e43fa9c713a6d084a5732aa6dd41c734845f25e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc5106088d6db75df61308ef6de314d1f7959646"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38319,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T08:15:30.940,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/pp: Fix potential NULL pointer dereference in atomctrl_initialize_mc_reg_table The function atomctrl_initialize_mc_reg_table() and atomctrl_initialize_mc_reg_table_v2_2() does not check the return value of smu_atom_get_data_table(). If smu_atom_get_data_table() fails to retrieve vram_info, it returns NULL which is later dereferenced.",,"[{""url"":""https://git.kernel.org/stable/c/64f3acc8c7e6809631457b75638601b36dea3129"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7080c20a9139842033ed4af604dc1fa4028593ad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/820116a39f96bdc7d426c33a804b52f53700a919"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/85cdcb834fb490731ff2d123f87ca799c57dacf2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a4ff7391c8b75b1541900bd9d0c238e558c11fb3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cdf7e1ff99ab06ef15d0b5d1aca5258a4fb62b85"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38320,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:25.947,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: arm64/ptrace: Fix stack-out-of-bounds read in regs_get_kernel_stack_nth() KASAN reports a stack-out-of-bounds read in regs_get_kernel_stack_nth(). Call Trace: [ 97.283505] BUG: KASAN: stack-out-of-bounds in regs_get_kernel_stack_nth+0xa8/0xc8 [ 97.284677] Read of size 8 at addr ffff800089277c10 by task 1.sh/2550 [ 97.285732] [ 97.286067] CPU: 7 PID: 2550 Comm: 1.sh Not tainted 6.6.0+ #11 [ 97.287032] Hardware name: linux,dummy-virt (DT) [ 97.287815] Call trace: [ 97.288279] dump_backtrace+0xa0/0x128 [ 97.288946] show_stack+0x20/0x38 [ 97.289551] dump_stack_lvl+0x78/0xc8 [ 97.290203] print_address_description.constprop.0+0x84/0x3c8 [ 97.291159] print_report+0xb0/0x280 [ 97.291792] kasan_report+0x84/0xd0 [ 97.292421] __asan_load8+0x9c/0xc0 [ 97.293042] regs_get_kernel_stack_nth+0xa8/0xc8 [ 97.293835] process_fetch_insn+0x770/0xa30 [ 97.294562] kprobe_trace_func+0x254/0x3b0 [ 97.295271] kprobe_dispatcher+0x98/0xe0 [ 97.295955] kprobe_breakpoint_handler+0x1b0/0x210 [ 97.296774] call_break_hook+0xc4/0x100 [ 97.297451] brk_handler+0x24/0x78 [ 97.298073] do_debug_exception+0xac/0x178 [ 97.298785] el1_dbg+0x70/0x90 [ 97.299344] el1h_64_sync_handler+0xcc/0xe8 [ 97.300066] el1h_64_sync+0x78/0x80 [ 97.300699] kernel_clone+0x0/0x500 [ 97.301331] __arm64_sys_clone+0x70/0x90 [ 97.302084] invoke_syscall+0x68/0x198 [ 97.302746] el0_svc_common.constprop.0+0x11c/0x150 [ 97.303569] do_el0_svc+0x38/0x50 [ 97.304164] el0_svc+0x44/0x1d8 [ 97.304749] el0t_64_sync_handler+0x100/0x130 [ 97.305500] el0t_64_sync+0x188/0x190 [ 97.306151] [ 97.306475] The buggy address belongs to stack of task 1.sh/2550 [ 97.307461] and is located at offset 0 in frame: [ 97.308257] __se_sys_clone+0x0/0x138 [ 97.308910] [ 97.309241] This frame has 1 object: [ 97.309873] [48, 184) 'args' [ 97.309876] [ 97.310749] The buggy address belongs to the virtual mapping at [ 97.310749] [ffff800089270000, ffff800089279000) created by: [ 97.310749] dup_task_struct+0xc0/0x2e8 [ 97.313347] [ 97.313674] The buggy address belongs to the physical page: [ 97.314604] page: refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x14f69a [ 97.315885] flags: 0x15ffffe00000000(node=1|zone=2|lastcpupid=0xfffff) [ 97.316957] raw: 015ffffe00000000 0000000000000000 dead000000000122 0000000000000000 [ 97.318207] raw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000 [ 97.319445] page dumped because: kasan: bad access detected [ 97.320371] [ 97.320694] Memory state around the buggy address: [ 97.321511] ffff800089277b00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 97.322681] ffff800089277b80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 97.323846] >ffff800089277c00: 00 00 f1 f1 f1 f1 f1 f1 00 00 00 00 00 00 00 00 [ 97.325023] ^ [ 97.325683] ffff800089277c80: 00 00 00 00 00 00 00 00 00 f3 f3 f3 f3 f3 f3 f3 [ 97.326856] ffff800089277d00: f3 f3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 This issue seems to be related to the behavior of some gcc compilers and was also fixed on the s390 architecture before: commit d93a855c31b7 (""s390/ptrace: Avoid KASAN false positives in regs_get_kernel_stack_nth()"") As described in that commit, regs_get_kernel_stack_nth() has confirmed that `addr` is on the stack, so reading the value at `*addr` should be allowed. Use READ_ONCE_NOCHECK() helper to silence the KASAN check for this case. [will: Use '*addr' as the argument to READ_ONCE_NOCHECK()]",,"[{""url"":""https://git.kernel.org/stable/c/01f91d415a8375d85e0c7d3615cd4a168308bb7c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/21da6d3561f373898349ca7167c9811c020da695"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/22f935bc86bdfbde04009f05eee191d220cd8c89"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/39dfc971e42d886e7df01371cd1bef505076d84c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/422e565b7889ebfd9c8705a3fc786642afe61fca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/64773b3ea09235168a549a195cba43bb867c4a17"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/67abac27d806e8f9d4226ec1528540cf73af673a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/92750bfe7b0d8dbcaf578c091a65eda1c5f9ad38"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38321,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:26.103,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: smb: Log an error when close_all_cached_dirs fails Under low-memory conditions, close_all_cached_dirs() can't move the dentries to a separate list to dput() them once the locks are dropped. This will result in a ""Dentry still in use"" error, so add an error message that makes it clear this is what happened: [ 495.281119] CIFS: VFS: \\otters.example.com\share Out of memory while dropping dentries [ 495.281595] ------------[ cut here ]------------ [ 495.281887] BUG: Dentry ffff888115531138{i=78,n=/} still in use (2) [unmount of cifs cifs] [ 495.282391] WARNING: CPU: 1 PID: 2329 at fs/dcache.c:1536 umount_check+0xc8/0xf0 Also, bail out of looping through all tcons as soon as a single allocation fails, since we're already in trouble, and kmalloc() attempts for subseqeuent tcons are likely to fail just like the first one did.",,"[{""url"":""https://git.kernel.org/stable/c/43f26094d6702e494e800532c3f1606e7a68eb30"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4479db143390bdcadc1561292aab579cdfa9f6c6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a2182743a8b4969481f64aec4908ff162e8a206c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b8ced2b9a23a1a2c1e0ed8d0d02512e51bdf38da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38322,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:26.240,2025-08-28T15:15:48.370,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: perf/x86/intel: Fix crash in icl_update_topdown_event() The perf_fuzzer found a hard-lockup crash on a RaptorLake machine: Oops: general protection fault, maybe for address 0xffff89aeceab400: 0000 CPU: 23 UID: 0 PID: 0 Comm: swapper/23 Tainted: [W]=WARN Hardware name: Dell Inc. Precision 9660/0VJ762 RIP: 0010:native_read_pmc+0x7/0x40 Code: cc e8 8d a9 01 00 48 89 03 5b cd cc cc cc cc 0f 1f ... RSP: 000:fffb03100273de8 EFLAGS: 00010046 .... Call Trace: <TASK> icl_update_topdown_event+0x165/0x190 ? ktime_get+0x38/0xd0 intel_pmu_read_event+0xf9/0x210 __perf_event_read+0xf9/0x210 CPUs 16-23 are E-core CPUs that don't support the perf metrics feature. The icl_update_topdown_event() should not be invoked on these CPUs. It's a regression of commit: f9bdf1f95339 (""perf/x86/intel: Avoid disable PMU if !cpuc->enabled in sample read"") The bug introduced by that commit is that the is_topdown_event() function is mistakenly used to replace the is_topdown_count() call to check if the topdown functions for the perf metrics feature should be invoked. Fix it.",,"[{""url"":""https://git.kernel.org/stable/c/702ea6028032d6c1fe96c2d4762a3575e3654819"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/79e2dd573116d3338507c311460da9669095c94d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a85cc69acdcb05f8cd226b8ea0778b8e2e887e6f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b0823d5fbacb1c551d793cbfe7af24e0d1fa45ed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38323,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:26.377,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: atm: add lec_mutex syzbot found its way in net/atm/lec.c, and found an error path in lecd_attach() could leave a dangling pointer in dev_lec[]. Add a mutex to protect dev_lecp[] uses from lecd_attach(), lec_vcc_attach() and lec_mcast_attach(). Following patch will use this mutex for /proc/net/atm/lec. BUG: KASAN: slab-use-after-free in lecd_attach net/atm/lec.c:751 [inline] BUG: KASAN: slab-use-after-free in lane_ioctl+0x2224/0x23e0 net/atm/lec.c:1008 Read of size 8 at addr ffff88807c7b8e68 by task syz.1.17/6142 CPU: 1 UID: 0 PID: 6142 Comm: syz.1.17 Not tainted 6.16.0-rc1-syzkaller-00239-g08215f5486ec #0 PREEMPT(full) Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:408 [inline] print_report+0xcd/0x680 mm/kasan/report.c:521 kasan_report+0xe0/0x110 mm/kasan/report.c:634 lecd_attach net/atm/lec.c:751 [inline] lane_ioctl+0x2224/0x23e0 net/atm/lec.c:1008 do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159 sock_do_ioctl+0x118/0x280 net/socket.c:1190 sock_ioctl+0x227/0x6b0 net/socket.c:1311 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:907 [inline] __se_sys_ioctl fs/ioctl.c:893 [inline] __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:893 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xcd/0x4c0 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f </TASK> Allocated by task 6132: kasan_save_stack+0x33/0x60 mm/kasan/common.c:47 kasan_save_track+0x14/0x30 mm/kasan/common.c:68 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0xaa/0xb0 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __do_kmalloc_node mm/slub.c:4328 [inline] __kvmalloc_node_noprof+0x27b/0x620 mm/slub.c:5015 alloc_netdev_mqs+0xd2/0x1570 net/core/dev.c:11711 lecd_attach net/atm/lec.c:737 [inline] lane_ioctl+0x17db/0x23e0 net/atm/lec.c:1008 do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159 sock_do_ioctl+0x118/0x280 net/socket.c:1190 sock_ioctl+0x227/0x6b0 net/socket.c:1311 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:907 [inline] __se_sys_ioctl fs/ioctl.c:893 [inline] __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:893 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xcd/0x4c0 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f Freed by task 6132: kasan_save_stack+0x33/0x60 mm/kasan/common.c:47 kasan_save_track+0x14/0x30 mm/kasan/common.c:68 kasan_save_free_info+0x3b/0x60 mm/kasan/generic.c:576 poison_slab_object mm/kasan/common.c:247 [inline] __kasan_slab_free+0x51/0x70 mm/kasan/common.c:264 kasan_slab_free include/linux/kasan.h:233 [inline] slab_free_hook mm/slub.c:2381 [inline] slab_free mm/slub.c:4643 [inline] kfree+0x2b4/0x4d0 mm/slub.c:4842 free_netdev+0x6c5/0x910 net/core/dev.c:11892 lecd_attach net/atm/lec.c:744 [inline] lane_ioctl+0x1ce8/0x23e0 net/atm/lec.c:1008 do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159 sock_do_ioctl+0x118/0x280 net/socket.c:1190 sock_ioctl+0x227/0x6b0 net/socket.c:1311 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:907 [inline] __se_sys_ioctl fs/ioctl.c:893 [inline] __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:893",,"[{""url"":""https://git.kernel.org/stable/c/17e156a94e94a906a570dbf9b48877956c60bef8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/18e8f0c4f826fb08c2d3825cdd6c57e24b207e0a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/64b378db28a967f7b271b055380c2360279aa424"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a7a713dfb5f9477345450f27c7c0741864511192"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d13a3824bfd2b4774b671a75cf766a16637a0e67"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dffd03422ae6a459039c8602f410e6c0f4cbc6c8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e91274cc7ed88ab5bdc62d426067c82b0b118a0b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f4d80b16ecc4229f7e6345158ef34c36be323f0e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38324,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:26.520,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mpls: Use rcu_dereference_rtnl() in mpls_route_input_rcu(). As syzbot reported [0], mpls_route_input_rcu() can be called from mpls_getroute(), where is under RTNL. net->mpls.platform_label is only updated under RTNL. Let's use rcu_dereference_rtnl() in mpls_route_input_rcu() to silence the splat. [0]: WARNING: suspicious RCU usage 6.15.0-rc7-syzkaller-00082-g5cdb2c77c4c3 #0 Not tainted ---------------------------- net/mpls/af_mpls.c:84 suspicious rcu_dereference_check() usage! other info that might help us debug this: rcu_scheduler_active = 2, debug_locks = 1 1 lock held by syz.2.4451/17730: #0: ffffffff9012a3e8 (rtnl_mutex){+.+.}-{4:4}, at: rtnl_lock net/core/rtnetlink.c:80 [inline] #0: ffffffff9012a3e8 (rtnl_mutex){+.+.}-{4:4}, at: rtnetlink_rcv_msg+0x371/0xe90 net/core/rtnetlink.c:6961 stack backtrace: CPU: 1 UID: 0 PID: 17730 Comm: syz.2.4451 Not tainted 6.15.0-rc7-syzkaller-00082-g5cdb2c77c4c3 #0 PREEMPT(full) Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x16c/0x1f0 lib/dump_stack.c:120 lockdep_rcu_suspicious+0x166/0x260 kernel/locking/lockdep.c:6865 mpls_route_input_rcu+0x1d4/0x200 net/mpls/af_mpls.c:84 mpls_getroute+0x621/0x1ea0 net/mpls/af_mpls.c:2381 rtnetlink_rcv_msg+0x3c9/0xe90 net/core/rtnetlink.c:6964 netlink_rcv_skb+0x16d/0x440 net/netlink/af_netlink.c:2534 netlink_unicast_kernel net/netlink/af_netlink.c:1313 [inline] netlink_unicast+0x53a/0x7f0 net/netlink/af_netlink.c:1339 netlink_sendmsg+0x8d1/0xdd0 net/netlink/af_netlink.c:1883 sock_sendmsg_nosec net/socket.c:712 [inline] __sock_sendmsg net/socket.c:727 [inline] ____sys_sendmsg+0xa98/0xc70 net/socket.c:2566 ___sys_sendmsg+0x134/0x1d0 net/socket.c:2620 __sys_sendmmsg+0x200/0x420 net/socket.c:2709 __do_sys_sendmmsg net/socket.c:2736 [inline] __se_sys_sendmmsg net/socket.c:2733 [inline] __x64_sys_sendmmsg+0x9c/0x100 net/socket.c:2733 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xcd/0x230 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7f0a2818e969 Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007f0a28f52038 EFLAGS: 00000246 ORIG_RAX: 0000000000000133 RAX: ffffffffffffffda RBX: 00007f0a283b5fa0 RCX: 00007f0a2818e969 RDX: 0000000000000003 RSI: 0000200000000080 RDI: 0000000000000003 RBP: 00007f0a28210ab1 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 0000000000000000 R14: 00007f0a283b5fa0 R15: 00007ffce5e9f268 </TASK>",,"[{""url"":""https://git.kernel.org/stable/c/2919297b18e5a5fb7e643f9e32c12c0b17cce1be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/36af82f25fbdcd719eb947c15ea874bf80bcf229"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/49b8a9d7d44401a186e20b1aaf591d2e62727aeb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/517bc6836ee9fcffe2539f6f6aa3fdd9c7a7ae73"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6dbb0d97c5096072c78a6abffe393584e57ae945"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a060781640012d5d5105072f4c44ed6ad6830ef9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d8cd847fb8626872631cc22d44be5127b4ebfb74"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f19cbd84e645e39bc3228e1191bb151ef0ffac8c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38325,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:26.673,2025-08-01T09:15:32.903,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: add free_transport ops in ksmbd connection free_transport function for tcp connection can be called from smbdirect. It will cause kernel oops. This patch add free_transport ops in ksmbd connection, and add each free_transports for tcp and smbdirect.",,"[{""url"":""https://git.kernel.org/stable/c/3890da762a66191c440b0bd6e3ee45501edbb0c1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f3aae77280aad9f5acc6709c596148966f765c7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/52f5a52dc17a4a7b4363ac03fe2c4ef26f020dc6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a89f5fae998bdc4d0505306f93844c9ae059d50c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38326,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:26.797,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: aoe: clean device rq_list in aoedev_downdev() An aoe device's rq_list contains accepted block requests that are waiting to be transmitted to the aoe target. This queue was added as part of the conversion to blk_mq. However, the queue was not cleaned out when an aoe device is downed which caused blk_mq_freeze_queue() to sleep indefinitely waiting for those requests to complete, causing a hang. This fix cleans out the queue before calling blk_mq_freeze_queue().",,"[{""url"":""https://git.kernel.org/stable/c/00be74e1470af292c37a438b8e69dee47dcbf481"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/531aef4a1accb13b21a3b82ec29955f4733367d5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/64fc0bad62ed38874131dd0337d844a43bd1017e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f90d45e57cb2ef1f0adcaf925ddffdfc5e680ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8662ac79a63488e279b91c12a72b02bc0dc49f7b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ed52e9652ba41d362e9ec923077f6da23336f269"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ef0b5bbbed7f220db2e9c73428f9a36e8dfc69ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa2a79f0da92614c5dc45c8b3d2638681c7734ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38327,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:26.933,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fgraph: Do not enable function_graph tracer when setting funcgraph-args When setting the funcgraph-args option when function graph tracer is net enabled, it incorrectly enables it. Worse, it unregisters itself when it was never registered. Then when it gets enabled again, it will register itself a second time causing a WARNing. ~# echo 1 > /sys/kernel/tracing/options/funcgraph-args ~# head -20 /sys/kernel/tracing/trace # tracer: nop # # entries-in-buffer/entries-written: 813/26317372 #P:8 # # _-----=> irqs-off/BH-disabled # / _----=> need-resched # | / _---=> hardirq/softirq # || / _--=> preempt-depth # ||| / _-=> migrate-disable # |||| / delay # TASK-PID CPU# ||||| TIMESTAMP FUNCTION # | | | ||||| | | <idle>-0 [007] d..4. 358.966010: 7) 1.692 us | fetch_next_timer_interrupt(basej=4294981640, basem=357956000000, base_local=0xffff88823c3ae040, base_global=0xffff88823c3af300, tevt=0xffff888100e47cb8); <idle>-0 [007] d..4. 358.966012: 7) | tmigr_cpu_deactivate(nextexp=357988000000) { <idle>-0 [007] d..4. 358.966013: 7) | _raw_spin_lock(lock=0xffff88823c3b2320) { <idle>-0 [007] d..4. 358.966014: 7) 0.981 us | preempt_count_add(val=1); <idle>-0 [007] d..5. 358.966017: 7) 1.058 us | do_raw_spin_lock(lock=0xffff88823c3b2320); <idle>-0 [007] d..4. 358.966019: 7) 5.824 us | } <idle>-0 [007] d..5. 358.966021: 7) | tmigr_inactive_up(group=0xffff888100cb9000, child=0x0, data=0xffff888100e47bc0) { <idle>-0 [007] d..5. 358.966022: 7) | tmigr_update_events(group=0xffff888100cb9000, child=0x0, data=0xffff888100e47bc0) { Notice the ""tracer: nop"" at the top there. The current tracer is the ""nop"" tracer, but the content is obviously the function graph tracer. Enabling function graph tracing will cause it to register again and trigger a warning in the accounting: ~# echo function_graph > /sys/kernel/tracing/current_tracer -bash: echo: write error: Device or resource busy With the dmesg of: ------------[ cut here ]------------ WARNING: CPU: 7 PID: 1095 at kernel/trace/ftrace.c:3509 ftrace_startup_subops+0xc1e/0x1000 Modules linked in: kvm_intel kvm irqbypass CPU: 7 UID: 0 PID: 1095 Comm: bash Not tainted 6.16.0-rc2-test-00006-gea03de4105d3 #24 PREEMPT Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 RIP: 0010:ftrace_startup_subops+0xc1e/0x1000 Code: 48 b8 22 01 00 00 00 00 ad de 49 89 84 24 88 01 00 00 8b 44 24 08 89 04 24 e9 c3 f7 ff ff c7 04 24 ed ff ff ff e9 b7 f7 ff ff <0f> 0b c7 04 24 f0 ff ff ff e9 a9 f7 ff ff c7 04 24 f4 ff ff ff e9 RSP: 0018:ffff888133cff948 EFLAGS: 00010202 RAX: 0000000000000001 RBX: 1ffff1102679ff31 RCX: 0000000000000000 RDX: 1ffffffff0b27a60 RSI: ffffffff8593d2f0 RDI: ffffffff85941140 RBP: 00000000000c2041 R08: ffffffffffffffff R09: ffffed1020240221 R10: ffff88810120110f R11: ffffed1020240214 R12: ffffffff8593d2f0 R13: ffffffff8593d300 R14: ffffffff85941140 R15: ffffffff85631100 FS: 00007f7ec6f28740(0000) GS:ffff8882b5251000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f7ec6f181c0 CR3: 000000012f1d0005 CR4: 0000000000172ef0 Call Trace: <TASK> ? __pfx_ftrace_startup_subops+0x10/0x10 ? find_held_lock+0x2b/0x80 ? ftrace_stub_direct_tramp+0x10/0x10 ? ftrace_stub_direct_tramp+0x10/0x10 ? trace_preempt_on+0xd0/0x110 ? __pfx_trace_graph_entry_args+0x10/ ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/300dedd9fe182d4c7424550d81cee595994486d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/327e28664307d49ce3fa71ba30dcc0007c270974"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38328,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:27.067,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: jffs2: check jffs2_prealloc_raw_node_refs() result in few other places Fuzzing hit another invalid pointer dereference due to the lack of checking whether jffs2_prealloc_raw_node_refs() completed successfully. Subsequent logic implies that the node refs have been allocated. Handle that. The code is ready for propagating the error upwards. KASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f] CPU: 1 PID: 5835 Comm: syz-executor145 Not tainted 5.10.234-syzkaller #0 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014 RIP: 0010:jffs2_link_node_ref+0xac/0x690 fs/jffs2/nodelist.c:600 Call Trace: jffs2_mark_erased_block fs/jffs2/erase.c:460 [inline] jffs2_erase_pending_blocks+0x688/0x1860 fs/jffs2/erase.c:118 jffs2_garbage_collect_pass+0x638/0x1a00 fs/jffs2/gc.c:253 jffs2_reserve_space+0x3f4/0xad0 fs/jffs2/nodemgmt.c:167 jffs2_write_inode_range+0x246/0xb50 fs/jffs2/write.c:362 jffs2_write_end+0x712/0x1110 fs/jffs2/file.c:302 generic_perform_write+0x2c2/0x500 mm/filemap.c:3347 __generic_file_write_iter+0x252/0x610 mm/filemap.c:3465 generic_file_write_iter+0xdb/0x230 mm/filemap.c:3497 call_write_iter include/linux/fs.h:2039 [inline] do_iter_readv_writev+0x46d/0x750 fs/read_write.c:740 do_iter_write+0x18c/0x710 fs/read_write.c:866 vfs_writev+0x1db/0x6a0 fs/read_write.c:939 do_pwritev fs/read_write.c:1036 [inline] __do_sys_pwritev fs/read_write.c:1083 [inline] __se_sys_pwritev fs/read_write.c:1078 [inline] __x64_sys_pwritev+0x235/0x310 fs/read_write.c:1078 do_syscall_64+0x30/0x40 arch/x86/entry/common.c:46 entry_SYSCALL_64_after_hwframe+0x67/0xd1 Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",,"[{""url"":""https://git.kernel.org/stable/c/042fa922c84b5080401bcd8897d4ac4919d15075"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2b6d96503255a3ed676cd70f8368870c6d6a25c6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/38d767fb4a7766ec2058f97787e4c6e8d10343d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7e860296d7808de1db175c1eda29f94a2955dcc4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd42ddddd70abc7127c12b96c8c85dbd080ea56f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d1b81776f337a9b997f797c70ac0a26d838a2168"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d96e6451a8d0fe62492d4cc942d695772293c05a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f41c625328777f9ad572901ba0b0065bb9c9c1da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38329,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:27.220,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: firmware: cs_dsp: Fix OOB memory read access in KUnit test (wmfw info) KASAN reported out of bounds access - cs_dsp_mock_wmfw_add_info(), because the source string length was rounded up to the allocation size.",,"[{""url"":""https://git.kernel.org/stable/c/0000a2303ba78b6424ff15b5085b5f5098750a2e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d979b783d61f7f1f95664031b71a33afc74627b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38330,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:27.363,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: firmware: cs_dsp: Fix OOB memory read access in KUnit test (ctl cache) KASAN reported out of bounds access - cs_dsp_ctl_cache_init_multiple_offsets(). The code uses mock_coeff_template.length_bytes (4 bytes) for register value allocations. But later, this length is set to 8 bytes which causes test code failures. As fix, just remove the lenght override, keeping the original value 4 for all operations.",,"[{""url"":""https://git.kernel.org/stable/c/e3dafc64b90546eb769f33333afabd9e3e915757"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f4ba2ea57da51d616b689c4b8826c517ff5a8523"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38331,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:27.533,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: ethernet: cortina: Use TOE/TSO on all TCP It is desireable to push the hardware accelerator to also process non-segmented TCP frames: we pass the skb->len to the ""TOE/TSO"" offloader and it will handle them. Without this quirk the driver becomes unstable and lock up and and crash. I do not know exactly why, but it is probably due to the TOE (TCP offload engine) feature that is coupled with the segmentation feature - it is not possible to turn one part off and not the other, either both TOE and TSO are active, or neither of them. Not having the TOE part active seems detrimental, as if that hardware feature is not really supposed to be turned off. The datasheet says: ""Based on packet parsing and TCP connection/NAT table lookup results, the NetEngine puts the packets belonging to the same TCP connection to the same queue for the software to process. The NetEngine puts incoming packets to the buffer or series of buffers for a jumbo packet. With this hardware acceleration, IP/TCP header parsing, checksum validation and connection lookup are offloaded from the software processing."" After numerous tests with the hardware locking up after something between minutes and hours depending on load using iperf3 I have concluded this is necessary to stabilize the hardware.",,"[{""url"":""https://git.kernel.org/stable/c/1b503b790109d19710ec83c589c3ee59e95347ec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2bd434bb0eeb680c2b3dd6c68ca319b30cb8d47f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6a07e3af4973402fa199a80036c10060b922c92c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a37888a435b0737128d2d9c6f67b8d608f83df7a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ebe12e232f1d58ebb4b53b6d9149962b707bed91"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38332,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:27.680,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: lpfc: Use memcpy() for BIOS version The strlcat() with FORTIFY support is triggering a panic because it thinks the target buffer will overflow although the correct target buffer size is passed in. Anyway, instead of memset() with 0 followed by a strlcat(), just use memcpy() and ensure that the resulting buffer is NULL terminated. BIOSVersion is only used for the lpfc_printf_log() which expects a properly terminated string.",,"[{""url"":""https://git.kernel.org/stable/c/003baa7a1a152576d744bd655820449bbdb0248e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2f63bf0d2b146956a2f2ff3b25cee71019e64561"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/34c0a670556b24d36c9f8934227edb819ca5609e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/75ea8375c5a83f46c47bfb3de6217c7589a8df93"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac7bfaa099ec3e4d7dfd0ab9726fc3bc7911365d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ae82eaf4aeea060bb736c3e20c0568b67c701d7d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b699bda5db818b684ff62d140defd6394f38f3d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d34f2384d6df11a6c67039b612c2437f46e587e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38333,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:27.827,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to bail out in get_new_segment() ------------[ cut here ]------------ WARNING: CPU: 3 PID: 579 at fs/f2fs/segment.c:2832 new_curseg+0x5e8/0x6dc pc : new_curseg+0x5e8/0x6dc Call trace: new_curseg+0x5e8/0x6dc f2fs_allocate_data_block+0xa54/0xe28 do_write_page+0x6c/0x194 f2fs_do_write_node_page+0x38/0x78 __write_node_page+0x248/0x6d4 f2fs_sync_node_pages+0x524/0x72c f2fs_write_checkpoint+0x4bc/0x9b0 __checkpoint_and_complete_reqs+0x80/0x244 issue_checkpoint_thread+0x8c/0xec kthread+0x114/0x1bc ret_from_fork+0x10/0x20 get_new_segment() detects inconsistent status in between free_segmap and free_secmap, let's record such error into super block, and bail out get_new_segment() instead of continue using the segment.",,"[{""url"":""https://git.kernel.org/stable/c/bb5eb8a5b222fa5092f60d5555867a05ebc3bdf2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca860f507a61c7c3d4dde47b830a5c0d555cf83c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f0023d7a2a86999c8e1300e911d92f995a5310a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38334,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:27.960,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: x86/sgx: Prevent attempts to reclaim poisoned pages TL;DR: SGX page reclaim touches the page to copy its contents to secondary storage. SGX instructions do not gracefully handle machine checks. Despite this, the existing SGX code will try to reclaim pages that it _knows_ are poisoned. Avoid even trying to reclaim poisoned pages. The longer story: Pages used by an enclave only get epc_page->poison set in arch_memory_failure() but they currently stay on sgx_active_page_list until sgx_encl_release(), with the SGX_EPC_PAGE_RECLAIMER_TRACKED flag untouched. epc_page->poison is not checked in the reclaimer logic meaning that, if other conditions are met, an attempt will be made to reclaim an EPC page that was poisoned. This is bad because 1. we don't want that page to end up added to another enclave and 2. it is likely to cause one core to shut down and the kernel to panic. Specifically, reclaiming uses microcode operations including ""EWB"" which accesses the EPC page contents to encrypt and write them out to non-SGX memory. Those operations cannot handle MCEs in their accesses other than by putting the executing core into a special shutdown state (affecting both threads with HT.) The kernel will subsequently panic on the remaining cores seeing the core didn't enter MCE handler(s) in time. Call sgx_unmark_page_reclaimable() to remove the affected EPC page from sgx_active_page_list on memory error to stop it being considered for reclaiming. Testing epc_page->poison in sgx_reclaim_pages() would also work but I assume it's better to add code in the less likely paths. The affected EPC page is not added to &node->sgx_poison_page_list until later in sgx_encl_release()->sgx_free_epc_page() when it is EREMOVEd. Membership on other lists doesn't change to avoid changing any of the lists' semantics except for sgx_active_page_list. There's a ""TBD"" comment in arch_memory_failure() about pre-emptive actions, the goal here is not to address everything that it may imply. This also doesn't completely close the time window when a memory error notification will be fatal (for a not previously poisoned EPC page) -- the MCE can happen after sgx_reclaim_pages() has selected its candidates or even *inside* a microcode operation (actually easy to trigger due to the amount of time spent in them.) The spinlock in sgx_unmark_page_reclaimable() is safe because memory_failure() runs in process context and no spinlocks are held, explicitly noted in a mm/memory-failure.c comment.",,"[{""url"":""https://git.kernel.org/stable/c/00a88e9ea1b170d579c56327c38f7e8cf689df87"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/31dcbac94bfeabb86bf85b0c36803fdd6536437b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/62b62a2a6dc51ed6e8e334861f04220c9cf8106a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc5de5bd6deabd327ced2b2b1d0b4f14cd146afe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ed16618c380c32c68c06186d0ccbb0d5e0586e59"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38335,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:28.100,2025-08-28T15:15:48.497,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Input: gpio-keys - fix a sleep while atomic with PREEMPT_RT When enabling PREEMPT_RT, the gpio_keys_irq_timer() callback runs in hard irq context, but the input_event() takes a spin_lock, which isn't allowed there as it is converted to a rt_spin_lock(). [ 4054.289999] BUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:48 [ 4054.290028] in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 0, name: swapper/0 ... [ 4054.290195] __might_resched+0x13c/0x1f4 [ 4054.290209] rt_spin_lock+0x54/0x11c [ 4054.290219] input_event+0x48/0x80 [ 4054.290230] gpio_keys_irq_timer+0x4c/0x78 [ 4054.290243] __hrtimer_run_queues+0x1a4/0x438 [ 4054.290257] hrtimer_interrupt+0xe4/0x240 [ 4054.290269] arch_timer_handler_phys+0x2c/0x44 [ 4054.290283] handle_percpu_devid_irq+0x8c/0x14c [ 4054.290297] handle_irq_desc+0x40/0x58 [ 4054.290307] generic_handle_domain_irq+0x1c/0x28 [ 4054.290316] gic_handle_irq+0x44/0xcc Considering the gpio_keys_irq_isr() can run in any context, e.g. it can be threaded, it seems there's no point in requesting the timer isr to run in hard irq context. Relax the hrtimer not to use the hard context.",,"[{""url"":""https://git.kernel.org/stable/c/664e5a6f541ff226621487d1280d2ec28e86be28"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a7b79db25846459de63ca8974268f0c41c734c4b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a8f01e51109f77229e426b57c5d19251b462c6aa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec8f5da79b425deef5aebacdd4fe645620cd4f0b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f4a8f561d08e39f7833d4a278ebfb12a41eef15f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa53beab4740c4e5fe969f218a379f9558be33dc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38336,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:28.230,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ata: pata_via: Force PIO for ATAPI devices on VT6415/VT6330 The controller has a hardware bug that can hard hang the system when doing ATAPI DMAs without any trace of what happened. Depending on the device attached, it can also prevent the system from booting. In this case, the system hangs when reading the ATIP from optical media with cdrecord -vvv -atip on an _NEC DVD_RW ND-4571A 1-01 and an Optiarc DVD RW AD-7200A 1.06 attached to an ASRock 990FX Extreme 4, running at UDMA/33. The issue can be reproduced by running the same command with a cygwin build of cdrecord on WinXP, although it requires more attempts to cause it. The hang in that case is also resolved by forcing PIO. It doesn't appear that VIA has produced any drivers for that OS, thus no known workaround exists. HDDs attached to the controller do not suffer from any DMA issues.",,"[{""url"":""https://git.kernel.org/stable/c/0d9a48dfa934f43ac839211ae4aeba34f666a9a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/67d66a5e4583fd3bcf13d6f747e571df13cbad51"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7fc89c218fc96a296a2840b1e37f4e0975f7a108"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8212cd92fe40aae6fe5a073bc70e758c42bb4bfc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8edfed4439b107d62151ff6c075958d169da3e71"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/947f9304d3c876c6672b947b80c0ef51161c6d2f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bb7212ee4ff086628a2c1c22336d082a87cb893d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d29fc02caad7f94b62d56ee1b01c954f9c961ba7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38337,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:28.373,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: jbd2: fix data-race and null-ptr-deref in jbd2_journal_dirty_metadata() Since handle->h_transaction may be a NULL pointer, so we should change it to call is_handle_aborted(handle) first before dereferencing it. And the following data-race was reported in my fuzzer: ================================================================== BUG: KCSAN: data-race in jbd2_journal_dirty_metadata / jbd2_journal_dirty_metadata write to 0xffff888011024104 of 4 bytes by task 10881 on cpu 1: jbd2_journal_dirty_metadata+0x2a5/0x770 fs/jbd2/transaction.c:1556 __ext4_handle_dirty_metadata+0xe7/0x4b0 fs/ext4/ext4_jbd2.c:358 ext4_do_update_inode fs/ext4/inode.c:5220 [inline] ext4_mark_iloc_dirty+0x32c/0xd50 fs/ext4/inode.c:5869 __ext4_mark_inode_dirty+0xe1/0x450 fs/ext4/inode.c:6074 ext4_dirty_inode+0x98/0xc0 fs/ext4/inode.c:6103 .... read to 0xffff888011024104 of 4 bytes by task 10880 on cpu 0: jbd2_journal_dirty_metadata+0xf2/0x770 fs/jbd2/transaction.c:1512 __ext4_handle_dirty_metadata+0xe7/0x4b0 fs/ext4/ext4_jbd2.c:358 ext4_do_update_inode fs/ext4/inode.c:5220 [inline] ext4_mark_iloc_dirty+0x32c/0xd50 fs/ext4/inode.c:5869 __ext4_mark_inode_dirty+0xe1/0x450 fs/ext4/inode.c:6074 ext4_dirty_inode+0x98/0xc0 fs/ext4/inode.c:6103 .... value changed: 0x00000000 -> 0x00000001 ================================================================== This issue is caused by missing data-race annotation for jh->b_modified. Therefore, the missing annotation needs to be added.",,"[{""url"":""https://git.kernel.org/stable/c/23361b479f2700c00960d3ae9cdc8ededa762d47"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2e7c64d7a92c031d016f11c8e8cb05131ab7b75a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/43d5e3bb5f1dcd91e30238ea0b59a5f77063f84e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5c1a34ff5b0bfdfd2f9343aa9b08d25df618bac5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a377996d714afb8d4d5f4906336f78510039da29"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/af98b0157adf6504fade79b3e6cb260c4ff68e37"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec669e5bf409f16e464bfad75f0ba039a45de29a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f78b38af3540b4875147b7b884ee11a27b3dbf4c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38338,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:28.510,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fs/nfs/read: fix double-unlock bug in nfs_return_empty_folio() Sometimes, when a file was read while it was being truncated by another NFS client, the kernel could deadlock because folio_unlock() was called twice, and the second call would XOR back the `PG_locked` flag. Most of the time (depending on the timing of the truncation), nobody notices the problem because folio_unlock() gets called three times, which flips `PG_locked` back off: 1. vfs_read, nfs_read_folio, ... nfs_read_add_folio, nfs_return_empty_folio 2. vfs_read, nfs_read_folio, ... netfs_read_collection, netfs_unlock_abandoned_read_pages 3. vfs_read, ... nfs_do_read_folio, nfs_read_add_folio, nfs_return_empty_folio The problem is that nfs_read_add_folio() is not supposed to unlock the folio if fscache is enabled, and a nfs_netfs_folio_unlock() check is missing in nfs_return_empty_folio(). Rarely this leads to a warning in netfs_read_collection(): ------------[ cut here ]------------ R=0000031c: folio 10 is not locked WARNING: CPU: 0 PID: 29 at fs/netfs/read_collect.c:133 netfs_read_collection+0x7c0/0xf00 [...] Workqueue: events_unbound netfs_read_collection_worker RIP: 0010:netfs_read_collection+0x7c0/0xf00 [...] Call Trace: <TASK> netfs_read_collection_worker+0x67/0x80 process_one_work+0x12e/0x2c0 worker_thread+0x295/0x3a0 Most of the time, however, processes just get stuck forever in folio_wait_bit_common(), waiting for `PG_locked` to disappear, which never happens because nobody is really holding the folio lock.",,"[{""url"":""https://git.kernel.org/stable/c/14f5549ad163be2c018abc1bb38370fff617a243"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1e93b61d3eaa14bfebcc2716ac09d43f3845d420"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c10fa44bc5f700e2ea21de2fbae520ba21f19d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5bf0b9eeb0174686f22c2e5b8fb9f47ad25da6f5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38339,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:28.633,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: powerpc/bpf: fix JIT code size calculation of bpf trampoline arch_bpf_trampoline_size() provides JIT size of the BPF trampoline before the buffer for JIT'ing it is allocated. The total number of instructions emitted for BPF trampoline JIT code depends on where the final image is located. So, the size arrived at with the dummy pass in arch_bpf_trampoline_size() can vary from the actual size needed in arch_prepare_bpf_trampoline(). When the instructions accounted in arch_bpf_trampoline_size() is less than the number of instructions emitted during the actual JIT compile of the trampoline, the below warning is produced: WARNING: CPU: 8 PID: 204190 at arch/powerpc/net/bpf_jit_comp.c:981 __arch_prepare_bpf_trampoline.isra.0+0xd2c/0xdcc which is: /* Make sure the trampoline generation logic doesn't overflow */ if (image && WARN_ON_ONCE(&image[ctx->idx] > (u32 *)rw_image_end - BPF_INSN_SAFETY)) { So, during the dummy pass, instead of providing some arbitrary image location, account for maximum possible instructions if and when there is a dependency with image location for JIT'ing.",,"[{""url"":""https://git.kernel.org/stable/c/59ba025948be2a92e8bc9ae1cbdaf197660bd508"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7833deb95e05bec146414b3a2feb24f025ca27c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38340,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:28.760,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: firmware: cs_dsp: Fix OOB memory read access in KUnit test KASAN reported out of bounds access - cs_dsp_mock_bin_add_name_or_info(), because the source string length was rounded up to the allocation size.",,"[{""url"":""https://git.kernel.org/stable/c/8f4cc454a0bb45b800bc7817c09c8f72e31901f3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe6446215bfad11cf3b446f38b28dc7708973c25"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38341,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:28.890,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: eth: fbnic: avoid double free when failing to DMA-map FW msg The semantics are that caller of fbnic_mbx_map_msg() retains the ownership of the message on error. All existing callers dutifully free the page.",,"[{""url"":""https://git.kernel.org/stable/c/0a211e23852019ef55c70094524e87a944accbb5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5bd1bafd4474ee26f504b41aba11f3e2a1175b88"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/670179265ad787b9dd8e701601914618b8927755"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38342,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:29.017,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: software node: Correct a OOB check in software_node_get_reference_args() software_node_get_reference_args() wants to get @index-th element, so the property value requires at least '(index + 1) * sizeof(*ref)' bytes but that can not be guaranteed by current OOB check, and may cause OOB for malformed property. Fix by using as OOB check '((index + 1) * sizeof(*ref) > prop->length)'.",,"[{""url"":""https://git.kernel.org/stable/c/142acd739eb6f08c148a96ae8309256f1422ff4b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/31e4e12e0e9609850cefd4b2e1adf782f56337d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4b3383110b6df48e0ba5936af2cb68d5eb6bd43b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/56ce76e8d406cc72b89aee7931df5cf3f18db49d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7af18e42bdefe1dba5bcb32555a4d524fd504939"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9324127b07dde8529222dc19233aa57ec810856c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f9397cf7bfb680799fb8c7f717c8f756384c3280"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38343,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:29.157,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: mt7996: drop fragments with multicast or broadcast RA IEEE 802.11 fragmentation can only be applied to unicast frames. Therefore, drop fragments with multicast or broadcast RA. This patch addresses vulnerabilities such as CVE-2020-26145.",,"[{""url"":""https://git.kernel.org/stable/c/24900688ee47071aa6a61e78473999b5b80f0423"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5fd5b8132b5de08c99eea003f7715ff2e361b007"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/80fda1cd7b0a1edd0849dc71403a070d0922118d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d4b93f9c2f666011dcf810050ef60a6b8d06f186"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38344,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:29.283,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ACPICA: fix acpi parse and parseext cache leaks ACPICA commit 8829e70e1360c81e7a5a901b5d4f48330e021ea5 I'm Seunghun Han, and I work for National Security Research Institute of South Korea. I have been doing a research on ACPI and found an ACPI cache leak in ACPI early abort cases. Boot log of ACPI cache leak is as follows: [ 0.352414] ACPI: Added _OSI(Module Device) [ 0.353182] ACPI: Added _OSI(Processor Device) [ 0.353182] ACPI: Added _OSI(3.0 _SCP Extensions) [ 0.353182] ACPI: Added _OSI(Processor Aggregator Device) [ 0.356028] ACPI: Unable to start the ACPI Interpreter [ 0.356799] ACPI Error: Could not remove SCI handler (20170303/evmisc-281) [ 0.360215] kmem_cache_destroy Acpi-State: Slab cache still has objects [ 0.360648] CPU: 0 PID: 1 Comm: swapper/0 Tainted: G W 4.12.0-rc4-next-20170608+ #10 [ 0.361273] Hardware name: innotek gmb_h virtual_box/virtual_box, BIOS virtual_box 12/01/2006 [ 0.361873] Call Trace: [ 0.362243] ? dump_stack+0x5c/0x81 [ 0.362591] ? kmem_cache_destroy+0x1aa/0x1c0 [ 0.362944] ? acpi_sleep_proc_init+0x27/0x27 [ 0.363296] ? acpi_os_delete_cache+0xa/0x10 [ 0.363646] ? acpi_ut_delete_caches+0x6d/0x7b [ 0.364000] ? acpi_terminate+0xa/0x14 [ 0.364000] ? acpi_init+0x2af/0x34f [ 0.364000] ? __class_create+0x4c/0x80 [ 0.364000] ? video_setup+0x7f/0x7f [ 0.364000] ? acpi_sleep_proc_init+0x27/0x27 [ 0.364000] ? do_one_initcall+0x4e/0x1a0 [ 0.364000] ? kernel_init_freeable+0x189/0x20a [ 0.364000] ? rest_init+0xc0/0xc0 [ 0.364000] ? kernel_init+0xa/0x100 [ 0.364000] ? ret_from_fork+0x25/0x30 I analyzed this memory leak in detail. I found that Acpi-State cache and Acpi-Parse cache were merged because the size of cache objects was same slab cache size. I finally found Acpi-Parse cache and Acpi-parse_ext cache were leaked using SLAB_NEVER_MERGE flag in kmem_cache_create() function. Real ACPI cache leak point is as follows: [ 0.360101] ACPI: Added _OSI(Module Device) [ 0.360101] ACPI: Added _OSI(Processor Device) [ 0.360101] ACPI: Added _OSI(3.0 _SCP Extensions) [ 0.361043] ACPI: Added _OSI(Processor Aggregator Device) [ 0.364016] ACPI: Unable to start the ACPI Interpreter [ 0.365061] ACPI Error: Could not remove SCI handler (20170303/evmisc-281) [ 0.368174] kmem_cache_destroy Acpi-Parse: Slab cache still has objects [ 0.369332] CPU: 1 PID: 1 Comm: swapper/0 Tainted: G W 4.12.0-rc4-next-20170608+ #8 [ 0.371256] Hardware name: innotek gmb_h virtual_box/virtual_box, BIOS virtual_box 12/01/2006 [ 0.372000] Call Trace: [ 0.372000] ? dump_stack+0x5c/0x81 [ 0.372000] ? kmem_cache_destroy+0x1aa/0x1c0 [ 0.372000] ? acpi_sleep_proc_init+0x27/0x27 [ 0.372000] ? acpi_os_delete_cache+0xa/0x10 [ 0.372000] ? acpi_ut_delete_caches+0x56/0x7b [ 0.372000] ? acpi_terminate+0xa/0x14 [ 0.372000] ? acpi_init+0x2af/0x34f [ 0.372000] ? __class_create+0x4c/0x80 [ 0.372000] ? video_setup+0x7f/0x7f [ 0.372000] ? acpi_sleep_proc_init+0x27/0x27 [ 0.372000] ? do_one_initcall+0x4e/0x1a0 [ 0.372000] ? kernel_init_freeable+0x189/0x20a [ 0.372000] ? rest_init+0xc0/0xc0 [ 0.372000] ? kernel_init+0xa/0x100 [ 0.372000] ? ret_from_fork+0x25/0x30 [ 0.388039] kmem_cache_destroy Acpi-parse_ext: Slab cache still has objects [ 0.389063] CPU: 1 PID: 1 Comm: swapper/0 Tainted: G W 4.12.0-rc4-next-20170608+ #8 [ 0.390557] Hardware name: innotek gmb_h virtual_box/virtual_box, BIOS virtual_box 12/01/2006 [ 0.392000] Call Trace: [ 0.392000] ? dump_stack+0x5c/0x81 [ 0.392000] ? kmem_cache_destroy+0x1aa/0x1c0 [ 0.392000] ? acpi_sleep_proc_init+0x27/0x27 [ 0.392000] ? acpi_os_delete_cache+0xa/0x10 [ 0.392000] ? acpi_ut_delete_caches+0x6d/0x7b [ 0.392000] ? acpi_terminate+0xa/0x14 [ 0.392000] ? acpi_init+0x2af/0x3 ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/0a119fdaed67566aa3e0b5222dced4d08bbce463"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/198c2dab022e5e94a99fff267b669d693bc7bb49"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1e0e629e88b1f7751ce69bf70cda6d1598d45271"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1fee4324b5660de080cefc3fc91c371543bdb8f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3e0c59180ec83bdec43b3d3482cff23d86d380d0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/41afebc9a0762aafc35d2df88f4e1b798155a940"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/960236150cd3f08e13b397dd5ae4ccf7a2986c00"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bed18f0bdcd6737a938264a59d67923688696fc4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38345,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:29.433,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ACPICA: fix acpi operand cache leak in dswstate.c ACPICA commit 987a3b5cf7175916e2a4b6ea5b8e70f830dfe732 I found an ACPI cache leak in ACPI early termination and boot continuing case. When early termination occurs due to malicious ACPI table, Linux kernel terminates ACPI function and continues to boot process. While kernel terminates ACPI function, kmem_cache_destroy() reports Acpi-Operand cache leak. Boot log of ACPI operand cache leak is as follows: >[ 0.585957] ACPI: Added _OSI(Module Device) >[ 0.587218] ACPI: Added _OSI(Processor Device) >[ 0.588530] ACPI: Added _OSI(3.0 _SCP Extensions) >[ 0.589790] ACPI: Added _OSI(Processor Aggregator Device) >[ 0.591534] ACPI Error: Illegal I/O port address/length above 64K: C806E00000004002/0x2 (20170303/hwvalid-155) >[ 0.594351] ACPI Exception: AE_LIMIT, Unable to initialize fixed events (20170303/evevent-88) >[ 0.597858] ACPI: Unable to start the ACPI Interpreter >[ 0.599162] ACPI Error: Could not remove SCI handler (20170303/evmisc-281) >[ 0.601836] kmem_cache_destroy Acpi-Operand: Slab cache still has objects >[ 0.603556] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.12.0-rc5 #26 >[ 0.605159] Hardware name: innotek gmb_h virtual_box/virtual_box, BIOS virtual_box 12/01/2006 >[ 0.609177] Call Trace: >[ 0.610063] ? dump_stack+0x5c/0x81 >[ 0.611118] ? kmem_cache_destroy+0x1aa/0x1c0 >[ 0.612632] ? acpi_sleep_proc_init+0x27/0x27 >[ 0.613906] ? acpi_os_delete_cache+0xa/0x10 >[ 0.617986] ? acpi_ut_delete_caches+0x3f/0x7b >[ 0.619293] ? acpi_terminate+0xa/0x14 >[ 0.620394] ? acpi_init+0x2af/0x34f >[ 0.621616] ? __class_create+0x4c/0x80 >[ 0.623412] ? video_setup+0x7f/0x7f >[ 0.624585] ? acpi_sleep_proc_init+0x27/0x27 >[ 0.625861] ? do_one_initcall+0x4e/0x1a0 >[ 0.627513] ? kernel_init_freeable+0x19e/0x21f >[ 0.628972] ? rest_init+0x80/0x80 >[ 0.630043] ? kernel_init+0xa/0x100 >[ 0.631084] ? ret_from_fork+0x25/0x30 >[ 0.633343] vgaarb: loaded >[ 0.635036] EDAC MC: Ver: 3.0.0 >[ 0.638601] PCI: Probing PCI hardware >[ 0.639833] PCI host bridge to bus 0000:00 >[ 0.641031] pci_bus 0000:00: root bus resource [io 0x0000-0xffff] > ... Continue to boot and log is omitted ... I analyzed this memory leak in detail and found acpi_ds_obj_stack_pop_and_ delete() function miscalculated the top of the stack. acpi_ds_obj_stack_push() function uses walk_state->operand_index for start position of the top, but acpi_ds_obj_stack_pop_and_delete() function considers index 0 for it. Therefore, this causes acpi operand memory leak. This cache leak causes a security threat because an old kernel (<= 4.9) shows memory locations of kernel functions in stack dump. Some malicious users could use this information to neutralize kernel ASLR. I made a patch to fix ACPI operand cache leak.",,"[{""url"":""https://git.kernel.org/stable/c/156fd20a41e776bbf334bd5e45c4f78dfc90ce1c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1c0d9115a001979cb446ba5e8331dd1d29a10bbf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4fa430a8bca708c7776f6b9d001257f48b19a5b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a68893b594ee6ce0efce5f74c07e64e9dd0c2c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/64c4bcf0308dd1d752ef31d560040b8725e29984"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/755a8006b76792922ff7b1c9674d8897a476b5d7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/76d37168155880f2b04a0aad92ceb0f9d799950e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0783910ca4368b01466bc8dcdcc13c3e0b7db53"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38346,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:29.573,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ftrace: Fix UAF when lookup kallsym after ftrace disabled The following issue happens with a buggy module: BUG: unable to handle page fault for address: ffffffffc05d0218 PGD 1bd66f067 P4D 1bd66f067 PUD 1bd671067 PMD 101808067 PTE 0 Oops: Oops: 0000 [#1] SMP KASAN PTI Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS RIP: 0010:sized_strscpy+0x81/0x2f0 RSP: 0018:ffff88812d76fa08 EFLAGS: 00010246 RAX: 0000000000000000 RBX: ffffffffc0601010 RCX: dffffc0000000000 RDX: 0000000000000038 RSI: dffffc0000000000 RDI: ffff88812608da2d RBP: 8080808080808080 R08: ffff88812608da2d R09: ffff88812608da68 R10: ffff88812608d82d R11: ffff88812608d810 R12: 0000000000000038 R13: ffff88812608da2d R14: ffffffffc05d0218 R15: fefefefefefefeff FS: 00007fef552de740(0000) GS:ffff8884251c7000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: ffffffffc05d0218 CR3: 00000001146f0000 CR4: 00000000000006f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ftrace_mod_get_kallsym+0x1ac/0x590 update_iter_mod+0x239/0x5b0 s_next+0x5b/0xa0 seq_read_iter+0x8c9/0x1070 seq_read+0x249/0x3b0 proc_reg_read+0x1b0/0x280 vfs_read+0x17f/0x920 ksys_read+0xf3/0x1c0 do_syscall_64+0x5f/0x2e0 entry_SYSCALL_64_after_hwframe+0x76/0x7e The above issue may happen as follows: (1) Add kprobe tracepoint; (2) insmod test.ko; (3) Module triggers ftrace disabled; (4) rmmod test.ko; (5) cat /proc/kallsyms; --> Will trigger UAF as test.ko already removed; ftrace_mod_get_kallsym() ... strscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN); ... The problem is when a module triggers an issue with ftrace and sets ftrace_disable. The ftrace_disable is set when an anomaly is discovered and to prevent any more damage, ftrace stops all text modification. The issue that happened was that the ftrace_disable stops more than just the text modification. When a module is loaded, its init functions can also be traced. Because kallsyms deletes the init functions after a module has loaded, ftrace saves them when the module is loaded and function tracing is enabled. This allows the output of the function trace to show the init function names instead of just their raw memory addresses. When a module is removed, ftrace_release_mod() is called, and if ftrace_disable is set, it just returns without doing anything more. The problem here is that it leaves the mod_list still around and if kallsyms is called, it will call into this code and access the module memory that has already been freed as it will return: strscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN); Where the ""mod"" no longer exists and triggers a UAF bug.",,"[{""url"":""https://git.kernel.org/stable/c/03a162933c4a03b9f1a84f7d8482903c7e1e11bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6805582abb720681dd1c87ff677f155dcf4e86c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/83a692a9792aa86249d68a8ac0b9d55ecdd255fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8690cd3258455bbae64f809e1d3ee0f043661c71"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e89c17dc8970c5f71a3a991f5724d4c8de42d8c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d064c68781c19f378af1ae741d9132d35d24b2bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f78a786ad9a5443a29eef4dae60cde85b7375129"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f914b52c379c12288b7623bb814d0508dbe7481d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38347,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:29.717,2025-08-28T15:15:48.623,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to do sanity check on ino and xnid syzbot reported a f2fs bug as below: INFO: task syz-executor140:5308 blocked for more than 143 seconds. Not tainted 6.14.0-rc7-syzkaller-00069-g81e4f8d68c66 #0 ""echo 0 > /proc/sys/kernel/hung_task_timeout_secs"" disables this message. task:syz-executor140 state:D stack:24016 pid:5308 tgid:5308 ppid:5306 task_flags:0x400140 flags:0x00000006 Call Trace: <TASK> context_switch kernel/sched/core.c:5378 [inline] __schedule+0x190e/0x4c90 kernel/sched/core.c:6765 __schedule_loop kernel/sched/core.c:6842 [inline] schedule+0x14b/0x320 kernel/sched/core.c:6857 io_schedule+0x8d/0x110 kernel/sched/core.c:7690 folio_wait_bit_common+0x839/0xee0 mm/filemap.c:1317 __folio_lock mm/filemap.c:1664 [inline] folio_lock include/linux/pagemap.h:1163 [inline] __filemap_get_folio+0x147/0xb40 mm/filemap.c:1917 pagecache_get_page+0x2c/0x130 mm/folio-compat.c:87 find_get_page_flags include/linux/pagemap.h:842 [inline] f2fs_grab_cache_page+0x2b/0x320 fs/f2fs/f2fs.h:2776 __get_node_page+0x131/0x11b0 fs/f2fs/node.c:1463 read_xattr_block+0xfb/0x190 fs/f2fs/xattr.c:306 lookup_all_xattrs fs/f2fs/xattr.c:355 [inline] f2fs_getxattr+0x676/0xf70 fs/f2fs/xattr.c:533 __f2fs_get_acl+0x52/0x870 fs/f2fs/acl.c:179 f2fs_acl_create fs/f2fs/acl.c:375 [inline] f2fs_init_acl+0xd7/0x9b0 fs/f2fs/acl.c:418 f2fs_init_inode_metadata+0xa0f/0x1050 fs/f2fs/dir.c:539 f2fs_add_inline_entry+0x448/0x860 fs/f2fs/inline.c:666 f2fs_add_dentry+0xba/0x1e0 fs/f2fs/dir.c:765 f2fs_do_add_link+0x28c/0x3a0 fs/f2fs/dir.c:808 f2fs_add_link fs/f2fs/f2fs.h:3616 [inline] f2fs_mknod+0x2e8/0x5b0 fs/f2fs/namei.c:766 vfs_mknod+0x36d/0x3b0 fs/namei.c:4191 unix_bind_bsd net/unix/af_unix.c:1286 [inline] unix_bind+0x563/0xe30 net/unix/af_unix.c:1379 __sys_bind_socket net/socket.c:1817 [inline] __sys_bind+0x1e4/0x290 net/socket.c:1848 __do_sys_bind net/socket.c:1853 [inline] __se_sys_bind net/socket.c:1851 [inline] __x64_sys_bind+0x7a/0x90 net/socket.c:1851 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f Let's dump and check metadata of corrupted inode, it shows its xattr_nid is the same to its i_ino. dump.f2fs -i 3 chaseyu.img.raw i_xattr_nid [0x 3 : 3] So that, during mknod in the corrupted directory, it tries to get and lock inode page twice, result in deadlock. - f2fs_mknod - f2fs_add_inline_entry - f2fs_get_inode_page --- lock dir's inode page - f2fs_init_acl - f2fs_acl_create(dir,..) - __f2fs_get_acl - f2fs_getxattr - lookup_all_xattrs - __get_node_page --- try to lock dir's inode page In order to fix this, let's add sanity check on ino and xnid.",,"[{""url"":""https://git.kernel.org/stable/c/061cf3a84bde038708eb0f1d065b31b7c2456533"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/44e904a1ad09e84039058dcbbb1b9ea5b8d7d75d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a06d97d5340c00510f24e80e8de821bd3bd9285"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aaddc6c696bd1bff20eaacfa88579d6eae64d541"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c4029044cc408b149e63db7dc8617a0783a3f10d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e98dc1909f3d5bc078ec7a605524f1e3f4c0eb14"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ecff54aa20b5b21db82e63e46066b55e43d72e78"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fed611bd8c7b76b070aa407d0c7558e20d9e1f68"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38348,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-10T09:15:29.840,2025-07-10T13:17:30.017,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: p54: prevent buffer-overflow in p54_rx_eeprom_readback() Robert Morris reported: |If a malicious USB device pretends to be an Intersil p54 wifi |interface and generates an eeprom_readback message with a large |eeprom->v1.len, p54_rx_eeprom_readback() will copy data from the |message beyond the end of priv->eeprom. | |static void p54_rx_eeprom_readback(struct p54_common *priv, | struct sk_buff *skb) |{ | struct p54_hdr *hdr = (struct p54_hdr *) skb->data; | struct p54_eeprom_lm86 *eeprom = (struct p54_eeprom_lm86 *) hdr->data; | | if (priv->fw_var >= 0x509) { | memcpy(priv->eeprom, eeprom->v2.data, | le16_to_cpu(eeprom->v2.len)); | } else { | memcpy(priv->eeprom, eeprom->v1.data, | le16_to_cpu(eeprom->v1.len)); | } | [...] The eeprom->v{1,2}.len is set by the driver in p54_download_eeprom(). The device is supposed to provide the same length back to the driver. But yes, it's possible (like shown in the report) to alter the value to something that causes a crash/panic due to overrun. This patch addresses the issue by adding the size to the common device context, so p54_rx_eeprom_readback no longer relies on possibly tampered values... That said, it also checks if the ""firmware"" altered the value and no longer copies them. The one, small saving grace is: Before the driver tries to read the eeprom, it needs to upload >a< firmware. the vendor firmware has a proprietary license and as a reason, it is not present on most distributions by default.",,"[{""url"":""https://git.kernel.org/stable/c/0e4dc150423b829c35cbcf399481ca11594fc036"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/12134f79e53eb56b0b0b7447fa0c512acf6a8422"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1f7f8168abe8cbe845ab8bb557228d44784a6b57"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6d05390d20f110de37d051a3e063ef0a542d01fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/714afb4c38edd19a057d519c1f9c5d164b43de94"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9701f842031b825e2fd5f22d064166f8f13f6e4d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da1b9a55ff116cb040528ef664c70a4eec03ae99"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f39b2f8c1549a539846e083790fad396ef6cd802"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38349,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-18T08:15:27.543,2025-08-19T06:15:32.513,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: eventpoll: don't decrement ep refcount while still holding the ep mutex Jann Horn points out that epoll is decrementing the ep refcount and then doing a mutex_unlock(&ep->mtx); afterwards. That's very wrong, because it can lead to a use-after-free. That pattern is actually fine for the very last reference, because the code in question will delay the actual call to ""ep_free(ep)"" until after it has unlocked the mutex. But it's wrong for the much subtler ""next to last"" case when somebody *else* may also be dropping their reference and free the ep while we're still using the mutex. Note that this is true even if that other user is also using the same ep mutex: mutexes, unlike spinlocks, can not be used for object ownership, even if they guarantee mutual exclusion. A mutex ""unlock"" operation is not atomic, and as one user is still accessing the mutex as part of unlocking it, another user can come in and get the now released mutex and free the data structure while the first user is still cleaning up. See our mutex documentation in Documentation/locking/mutex-design.rst, in particular the section [1] about semantics: ""mutex_unlock() may access the mutex structure even after it has internally released the lock already - so it's not safe for another context to acquire the mutex and assume that the mutex_unlock() context is not using the structure anymore"" So if we drop our ep ref before the mutex unlock, but we weren't the last one, we may then unlock the mutex, another user comes in, drops _their_ reference and releases the 'ep' as it now has no users - all while the mutex_unlock() is still accessing it. Fix this by simply moving the ep refcount dropping to outside the mutex: the refcount itself is atomic, and doesn't need mutex protection (that's the whole _point_ of refcounts: unlike mutexes, they are inherently about object lifetimes).",,"[{""url"":""https://git.kernel.org/stable/c/521e9ff0b67c66a17d6f9593dfccafaa984aae4c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/605c18698ecfa99165f36b7f59d3ed503e169814"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6dee745bd0aec9d399df674256e7b1ecdb615444"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c2e52ebbe885c7eeaabd3b7ddcdc1246fc400d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://project-zero.issues.chromium.org/issues/430541637"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38350,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-19T07:15:22.043,2025-07-22T13:06:07.260,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/sched: Always pass notifications when child class becomes empty Certain classful qdiscs may invoke their classes' dequeue handler on an enqueue operation. This may unexpectedly empty the child qdisc and thus make an in-flight class passive via qlen_notify(). Most qdiscs do not expect such behaviour at this point in time and may re-activate the class eventually anyways which will lead to a use-after-free. The referenced fix commit attempted to fix this behavior for the HFSC case by moving the backlog accounting around, though this turned out to be incomplete since the parent's parent may run into the issue too. The following reproducer demonstrates this use-after-free: tc qdisc add dev lo root handle 1: drr tc filter add dev lo parent 1: basic classid 1:1 tc class add dev lo parent 1: classid 1:1 drr tc qdisc add dev lo parent 1:1 handle 2: hfsc def 1 tc class add dev lo parent 2: classid 2:1 hfsc rt m1 8 d 1 m2 0 tc qdisc add dev lo parent 2:1 handle 3: netem tc qdisc add dev lo parent 3:1 handle 4: blackhole echo 1 | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888 tc class delete dev lo classid 1:1 echo 1 | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888 Since backlog accounting issues leading to a use-after-frees on stale class pointers is a recurring pattern at this point, this patch takes a different approach. Instead of trying to fix the accounting, the patch ensures that qdisc_tree_reduce_backlog always calls qlen_notify when the child qdisc is empty. This solves the problem because deletion of qdiscs always involves a call to qdisc_reset() and / or qdisc_purge_queue() which ultimately resets its qlen to 0 thus causing the following qdisc_tree_reduce_backlog() to report to the parent. Note that this may call qlen_notify on passive classes multiple times. This is not a problem after the recent patch series that made all the classful qdiscs qlen_notify() handlers idempotent.",,"[{""url"":""https://git.kernel.org/stable/c/103406b38c600fec1fe375a77b27d87e314aea09"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3b290923ad2b23596208c1e29520badef4356a43"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7874c9c132e906a52a187d045995b115973c93fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a44acdd9e84a211989ff4b9b92bf3545d8456ad5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a553afd91f55ff39b1e8a1c4989a29394c9e0472"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e269f29e9395527bc00c213c6b15da04ebb35070"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e9921b57dca05ac5f4fa1fa8e993d4f0ee52e2b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f680a4643c6f71e758d8fe0431a958e9a6a4f59d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38351,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-19T12:15:35.383,2025-08-28T15:15:48.767,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: KVM: x86/hyper-v: Skip non-canonical addresses during PV TLB flush In KVM guests with Hyper-V hypercalls enabled, the hypercalls HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST and HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX allow a guest to request invalidation of portions of a virtual TLB. For this, the hypercall parameter includes a list of GVAs that are supposed to be invalidated. However, when non-canonical GVAs are passed, there is currently no filtering in place and they are eventually passed to checked invocations of INVVPID on Intel / INVLPGA on AMD. While AMD's INVLPGA silently ignores non-canonical addresses (effectively a no-op), Intel's INVVPID explicitly signals VM-Fail and ultimately triggers the WARN_ONCE in invvpid_error(): invvpid failed: ext=0x0 vpid=1 gva=0xaaaaaaaaaaaaa000 WARNING: CPU: 6 PID: 326 at arch/x86/kvm/vmx/vmx.c:482 invvpid_error+0x91/0xa0 [kvm_intel] Modules linked in: kvm_intel kvm 9pnet_virtio irqbypass fuse CPU: 6 UID: 0 PID: 326 Comm: kvm-vm Not tainted 6.15.0 #14 PREEMPT(voluntary) RIP: 0010:invvpid_error+0x91/0xa0 [kvm_intel] Call Trace: vmx_flush_tlb_gva+0x320/0x490 [kvm_intel] kvm_hv_vcpu_flush_tlb+0x24f/0x4f0 [kvm] kvm_arch_vcpu_ioctl_run+0x3013/0x5810 [kvm] Hyper-V documents that invalid GVAs (those that are beyond a partition's GVA space) are to be ignored. While not completely clear whether this ruling also applies to non-canonical GVAs, it is likely fine to make that assumption, and manual testing on Azure confirms ""real"" Hyper-V interprets the specification in the same way. Skip non-canonical GVAs when processing the list of address to avoid tripping the INVVPID failure. Alternatively, KVM could filter out ""bad"" GVAs before inserting into the FIFO, but practically speaking the only downside of pushing validation to the final processing is that doing so is suboptimal for the guest, and no well-behaved guest will request TLB flushes for non-canonical addresses.",,"[{""url"":""https://git.kernel.org/stable/c/2d4dea3f76510c0afe3f18c910f647b816f7d566"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d5784ea45663330eaa868c518ea40e7a9f06aa2d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1b3ad11ec11c88ba9f79a73d27d4cda3f80fb24"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa787ac07b3ceb56dd88a62d1866038498e96230"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38352,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-22T08:15:23.577,2025-09-05T14:18:52.123,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: posix-cpu-timers: fix race between handle_posix_cpu_timers() and posix_cpu_timer_del() If an exiting non-autoreaping task has already passed exit_notify() and calls handle_posix_cpu_timers() from IRQ, it can be reaped by its parent or debugger right after unlock_task_sighand(). If a concurrent posix_cpu_timer_del() runs at that moment, it won't be able to detect timer->it.cpu.firing != 0: cpu_timer_task_rcu() and/or lock_task_sighand() will fail. Add the tsk->exit_state check into run_posix_cpu_timers() to fix this. This fix is not needed if CONFIG_POSIX_CPU_TIMERS_TASK_WORK=y, because exit_task_work() is called before exit_notify(). But the check still makes sense, task_work_add(&tsk->posix_cputimers_work.work) will fail anyway in this case.","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-367""}]}]","[{""url"":""https://git.kernel.org/stable/c/2c72fe18cc5f9f1750f5bc148cf1c94c29e106ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/2f3daa04a9328220de46f0d5c919a6c0073a9f0b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/460188bc042a3f40f72d34b9f7fc6ee66b0b757b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/764a7a5dfda23f69919441f2eac2a83e7db6e5bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/78a4b8e3795b31dae58762bc091bb0f4f74a2200"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/c076635b3a42771ace7d276de8dc3bc76ee2ba1b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/c29d5318708e67ac13c1b6fc1007d179fb65b4d7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/f90fff1e152dedf52b932240ebbd670d83330eca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":7.4,""baseSeverity"":""HIGH"",""attackVector"":""LOCAL"",""attackComplexity"":""HIGH"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.4,""impactScore"":5.9}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""2.6.36"",""versionEndExcluding"":""5.4.295"",""matchCriteriaId"":""AA6F945B-F2BB-4787-B4AD-104604AAF325""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.5"",""versionEndExcluding"":""5.10.239"",""matchCriteriaId"":""C3D14F4C-A21E-465D-A928-5CCE684E2B98""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.11"",""versionEndExcluding"":""5.15.186"",""matchCriteriaId"":""D96F2C0D-0D4A-4658-AD34-D8A626EA422D""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.142"",""matchCriteriaId"":""459B4E94-FE0E-434D-B782-95E3A5FFC6B1""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.2"",""versionEndExcluding"":""6.6.94"",""matchCriteriaId"":""304E3F01-7D7A-4908-994E-7F95C5C00B06""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.7"",""versionEndExcluding"":""6.12.34"",""matchCriteriaId"":""4FFA54AA-CDFE-4591-BD07-72813D0948F4""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.13"",""versionEndExcluding"":""6.15.3"",""matchCriteriaId"":""0541C761-BD5E-4C1A-8432-83B375D7EB92""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.16:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""6D4894DB-CCFE-4602-B1BF-3960B2E19A01""}]}]}]",,2025-09-04,2025-09-25,"Apply mitigations per vendor instructions, follow applicable BOD 22-01 guidance for cloud services, or discontinue use of the product if mitigations are unavailable.",Linux Kernel Time-of-Check Time-of-Use (TOCTOU) Race Condition Vulnerability,,,
CVE-2025-38353,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:23.650,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/xe: Fix taking invalid lock on wedge If device wedges on e.g. GuC upload, the submission is not yet enabled and the state is not even initialized. Protect the wedge call so it does nothing in this case. It fixes the following splat: [] xe 0000:bf:00.0: [drm] device wedged, needs recovery [] ------------[ cut here ]------------ [] DEBUG_LOCKS_WARN_ON(lock->magic != lock) [] WARNING: CPU: 48 PID: 312 at kernel/locking/mutex.c:564 __mutex_lock+0x8a1/0xe60 ... [] RIP: 0010:__mutex_lock+0x8a1/0xe60 [] mutex_lock_nested+0x1b/0x30 [] xe_guc_submit_wedge+0x80/0x2b0 [xe]",,"[{""url"":""https://git.kernel.org/stable/c/1e1981b16bb1bbe2fafa57ed439b45cb5b34e32d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/20eec7018e132a023f84ccbdf56b6c5b73d3094f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6d81b2d7037ef36163ad16459ed3fd17cb1b596"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38354,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:24.123,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/msm/gpu: Fix crash when throttling GPU immediately during boot There is a small chance that the GPU is already hot during boot. In that case, the call to of_devfreq_cooling_register() will immediately try to apply devfreq cooling, as seen in the following crash: Unable to handle kernel paging request at virtual address 0000000000014110 pc : a6xx_gpu_busy+0x1c/0x58 [msm] lr : msm_devfreq_get_dev_status+0xbc/0x140 [msm] Call trace: a6xx_gpu_busy+0x1c/0x58 [msm] (P) devfreq_simple_ondemand_func+0x3c/0x150 devfreq_update_target+0x44/0xd8 qos_max_notifier_call+0x30/0x84 blocking_notifier_call_chain+0x6c/0xa0 pm_qos_update_target+0xd0/0x110 freq_qos_apply+0x3c/0x74 apply_constraint+0x88/0x148 __dev_pm_qos_update_request+0x7c/0xcc dev_pm_qos_update_request+0x38/0x5c devfreq_cooling_set_cur_state+0x98/0xf0 __thermal_cdev_update+0x64/0xb4 thermal_cdev_update+0x4c/0x58 step_wise_manage+0x1f0/0x318 __thermal_zone_device_update+0x278/0x424 __thermal_cooling_device_register+0x2bc/0x308 thermal_of_cooling_device_register+0x10/0x1c of_devfreq_cooling_register_power+0x240/0x2bc of_devfreq_cooling_register+0x14/0x20 msm_devfreq_init+0xc4/0x1a0 [msm] msm_gpu_init+0x304/0x574 [msm] adreno_gpu_init+0x1c4/0x2e0 [msm] a6xx_gpu_init+0x5c8/0x9c8 [msm] adreno_bind+0x2a8/0x33c [msm] ... At this point we haven't initialized the GMU at all yet, so we cannot read the GMU registers inside a6xx_gpu_busy(). A similar issue was fixed before in commit 6694482a70e9 (""drm/msm: Avoid unclocked GMU register access in 6xx gpu_busy""): msm_devfreq_init() does call devfreq_suspend_device(), but unlike msm_devfreq_suspend(), it doesn't set the df->suspended flag accordingly. This means the df->suspended flag does not match the actual devfreq state after initialization and msm_devfreq_get_dev_status() will end up accessing GMU registers, causing the crash. Fix this by setting df->suspended correctly during initialization. Patchwork: https://patchwork.freedesktop.org/patch/650772/",,"[{""url"":""https://git.kernel.org/stable/c/1847ea44e3bdf7da8ff4158bc01b43a2e46394bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7946a10f8da75abc494e4bb80243e153e93e459a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6f673cc9488fd722c601fe020601dba14db21b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ae2015b0dbc0eea7aaf022194371f451f784d994"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b71717735be48d7743a34897e9e44a0b53e30c0e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38355,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:24.240,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/xe: Process deferred GGTT node removals on device unwind While we are indirectly draining our dedicated workqueue ggtt->wq that we use to complete asynchronous removal of some GGTT nodes, this happends as part of the managed-drm unwinding (ggtt_fini_early), which could be later then manage-device unwinding, where we could already unmap our MMIO/GMS mapping (mmio_fini). This was recently observed during unsuccessful VF initialization: [ ] xe 0000:00:02.1: probe with driver xe failed with error -62 [ ] xe 0000:00:02.1: DEVRES REL ffff88811e747340 __xe_bo_unpin_map_no_vm (16 bytes) [ ] xe 0000:00:02.1: DEVRES REL ffff88811e747540 __xe_bo_unpin_map_no_vm (16 bytes) [ ] xe 0000:00:02.1: DEVRES REL ffff88811e747240 __xe_bo_unpin_map_no_vm (16 bytes) [ ] xe 0000:00:02.1: DEVRES REL ffff88811e747040 tiles_fini (16 bytes) [ ] xe 0000:00:02.1: DEVRES REL ffff88811e746840 mmio_fini (16 bytes) [ ] xe 0000:00:02.1: DEVRES REL ffff88811e747f40 xe_bo_pinned_fini (16 bytes) [ ] xe 0000:00:02.1: DEVRES REL ffff88811e746b40 devm_drm_dev_init_release (16 bytes) [ ] xe 0000:00:02.1: [drm:drm_managed_release] drmres release begin [ ] xe 0000:00:02.1: [drm:drm_managed_release] REL ffff88810ef81640 __fini_relay (8 bytes) [ ] xe 0000:00:02.1: [drm:drm_managed_release] REL ffff88810ef80d40 guc_ct_fini (8 bytes) [ ] xe 0000:00:02.1: [drm:drm_managed_release] REL ffff88810ef80040 __drmm_mutex_release (8 bytes) [ ] xe 0000:00:02.1: [drm:drm_managed_release] REL ffff88810ef80140 ggtt_fini_early (8 bytes) and this was leading to: [ ] BUG: unable to handle page fault for address: ffffc900058162a0 [ ] #PF: supervisor write access in kernel mode [ ] #PF: error_code(0x0002) - not-present page [ ] Oops: Oops: 0002 [#1] SMP NOPTI [ ] Tainted: [W]=WARN [ ] Workqueue: xe-ggtt-wq ggtt_node_remove_work_func [xe] [ ] RIP: 0010:xe_ggtt_set_pte+0x6d/0x350 [xe] [ ] Call Trace: [ ] <TASK> [ ] xe_ggtt_clear+0xb0/0x270 [xe] [ ] ggtt_node_remove+0xbb/0x120 [xe] [ ] ggtt_node_remove_work_func+0x30/0x50 [xe] [ ] process_one_work+0x22b/0x6f0 [ ] worker_thread+0x1e8/0x3d Add managed-device action that will explicitly drain the workqueue with all pending node removals prior to releasing MMIO/GSM mapping. (cherry picked from commit 89d2835c3680ab1938e22ad81b1c9f8c686bd391)",,"[{""url"":""https://git.kernel.org/stable/c/1b12f8dabbb8fd7d5a2611dd7bc5982ffbc2e5df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5ab4eba9b26a93605b4f2f2b688d6ba818d7331d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/af2b588abe006bd55ddd358c4c3b87523349c475"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38356,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:24.353,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/xe/guc: Explicitly exit CT safe mode on unwind During driver probe we might be briefly using CT safe mode, which is based on a delayed work, but usually we are able to stop this once we have IRQ fully operational. However, if we abort the probe quite early then during unwind we might try to destroy the workqueue while there is still a pending delayed work that attempts to restart itself which triggers a WARN. This was recently observed during unsuccessful VF initialization: [ ] xe 0000:00:02.1: probe with driver xe failed with error -62 [ ] ------------[ cut here ]------------ [ ] workqueue: cannot queue safe_mode_worker_func [xe] on wq xe-g2h-wq [ ] WARNING: CPU: 9 PID: 0 at kernel/workqueue.c:2257 __queue_work+0x287/0x710 [ ] RIP: 0010:__queue_work+0x287/0x710 [ ] Call Trace: [ ] delayed_work_timer_fn+0x19/0x30 [ ] call_timer_fn+0xa1/0x2a0 Exit the CT safe mode on unwind to avoid that warning. (cherry picked from commit 2ddbb73ec20b98e70a5200cb85deade22ccea2ec)",,"[{""url"":""https://git.kernel.org/stable/c/6d0b588614c43d6334b2d7a70a99f31f7b14ecc0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad40098da5c3b43114d860a5b5740e7204158534"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f161e905b08ae8a513c5a36a10e3163e9920cfe6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38357,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:24.463,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fuse: fix runtime warning on truncate_folio_batch_exceptionals() The WARN_ON_ONCE is introduced on truncate_folio_batch_exceptionals() to capture whether the filesystem has removed all DAX entries or not. And the fix has been applied on the filesystem xfs and ext4 by the commit 0e2f80afcfa6 (""fs/dax: ensure all pages are idle prior to filesystem unmount""). Apply the missed fix on filesystem fuse to fix the runtime warning: [ 2.011450] ------------[ cut here ]------------ [ 2.011873] WARNING: CPU: 0 PID: 145 at mm/truncate.c:89 truncate_folio_batch_exceptionals+0x272/0x2b0 [ 2.012468] Modules linked in: [ 2.012718] CPU: 0 UID: 1000 PID: 145 Comm: weston Not tainted 6.16.0-rc2-WSL2-STABLE #2 PREEMPT(undef) [ 2.013292] RIP: 0010:truncate_folio_batch_exceptionals+0x272/0x2b0 [ 2.013704] Code: 48 63 d0 41 29 c5 48 8d 1c d5 00 00 00 00 4e 8d 6c 2a 01 49 c1 e5 03 eb 09 48 83 c3 08 49 39 dd 74 83 41 f6 44 1c 08 01 74 ef <0f> 0b 49 8b 34 1e 48 89 ef e8 10 a2 17 00 eb df 48 8b 7d 00 e8 35 [ 2.014845] RSP: 0018:ffffa47ec33f3b10 EFLAGS: 00010202 [ 2.015279] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000 [ 2.015884] RDX: 0000000000000000 RSI: ffffa47ec33f3ca0 RDI: ffff98aa44f3fa80 [ 2.016377] RBP: ffff98aa44f3fbf0 R08: ffffa47ec33f3ba8 R09: 0000000000000000 [ 2.016942] R10: 0000000000000001 R11: 0000000000000000 R12: ffffa47ec33f3ca0 [ 2.017437] R13: 0000000000000008 R14: ffffa47ec33f3ba8 R15: 0000000000000000 [ 2.017972] FS: 000079ce006afa40(0000) GS:ffff98aade441000(0000) knlGS:0000000000000000 [ 2.018510] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 2.018987] CR2: 000079ce03e74000 CR3: 000000010784f006 CR4: 0000000000372eb0 [ 2.019518] Call Trace: [ 2.019729] <TASK> [ 2.019901] truncate_inode_pages_range+0xd8/0x400 [ 2.020280] ? timerqueue_add+0x66/0xb0 [ 2.020574] ? get_nohz_timer_target+0x2a/0x140 [ 2.020904] ? timerqueue_add+0x66/0xb0 [ 2.021231] ? timerqueue_del+0x2e/0x50 [ 2.021646] ? __remove_hrtimer+0x39/0x90 [ 2.022017] ? srso_alias_untrain_ret+0x1/0x10 [ 2.022497] ? psi_group_change+0x136/0x350 [ 2.023046] ? _raw_spin_unlock+0xe/0x30 [ 2.023514] ? finish_task_switch.isra.0+0x8d/0x280 [ 2.024068] ? __schedule+0x532/0xbd0 [ 2.024551] fuse_evict_inode+0x29/0x190 [ 2.025131] evict+0x100/0x270 [ 2.025641] ? _atomic_dec_and_lock+0x39/0x50 [ 2.026316] ? __pfx_generic_delete_inode+0x10/0x10 [ 2.026843] __dentry_kill+0x71/0x180 [ 2.027335] dput+0xeb/0x1b0 [ 2.027725] __fput+0x136/0x2b0 [ 2.028054] __x64_sys_close+0x3d/0x80 [ 2.028469] do_syscall_64+0x6d/0x1b0 [ 2.028832] ? clear_bhb_loop+0x30/0x80 [ 2.029182] ? clear_bhb_loop+0x30/0x80 [ 2.029533] ? clear_bhb_loop+0x30/0x80 [ 2.029902] entry_SYSCALL_64_after_hwframe+0x76/0x7e [ 2.030423] RIP: 0033:0x79ce03d0d067 [ 2.030820] Code: b8 ff ff ff ff e9 3e ff ff ff 66 0f 1f 84 00 00 00 00 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 03 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 41 c3 48 83 ec 18 89 7c 24 0c e8 c3 a7 f8 ff [ 2.032354] RSP: 002b:00007ffef0498948 EFLAGS: 00000246 ORIG_RAX: 0000000000000003 [ 2.032939] RAX: ffffffffffffffda RBX: 00007ffef0498960 RCX: 000079ce03d0d067 [ 2.033612] RDX: 0000000000000003 RSI: 0000000000001000 RDI: 000000000000000d [ 2.034289] RBP: 00007ffef0498a30 R08: 000000000000000d R09: 0000000000000000 [ 2.034944] R10: 00007ffef0498978 R11: 0000000000000246 R12: 0000000000000001 [ 2.035610] R13: 00007ffef0498960 R14: 000079ce03e09ce0 R15: 0000000000000003 [ 2.036301] </TASK> [ 2.036532] ---[ end trace 0000000000000000 ]---",,"[{""url"":""https://git.kernel.org/stable/c/b48878aee8e7311411148c7a67c8f0b02f571d75"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/befd9a71d859ea625eaa84dae1b243efb3df3eca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38358,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:24.573,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: fix race between async reclaim worker and close_ctree() Syzbot reported an assertion failure due to an attempt to add a delayed iput after we have set BTRFS_FS_STATE_NO_DELAYED_IPUT in the fs_info state: WARNING: CPU: 0 PID: 65 at fs/btrfs/inode.c:3420 btrfs_add_delayed_iput+0x2f8/0x370 fs/btrfs/inode.c:3420 Modules linked in: CPU: 0 UID: 0 PID: 65 Comm: kworker/u8:4 Not tainted 6.15.0-next-20250530-syzkaller #0 PREEMPT(full) Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025 Workqueue: btrfs-endio-write btrfs_work_helper RIP: 0010:btrfs_add_delayed_iput+0x2f8/0x370 fs/btrfs/inode.c:3420 Code: 4e ad 5d (...) RSP: 0018:ffffc9000213f780 EFLAGS: 00010293 RAX: ffffffff83c635b7 RBX: ffff888058920000 RCX: ffff88801c769e00 RDX: 0000000000000000 RSI: 0000000000000100 RDI: 0000000000000000 RBP: 0000000000000001 R08: ffff888058921b67 R09: 1ffff1100b12436c R10: dffffc0000000000 R11: ffffed100b12436d R12: 0000000000000001 R13: dffffc0000000000 R14: ffff88807d748000 R15: 0000000000000100 FS: 0000000000000000(0000) GS:ffff888125c53000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00002000000bd038 CR3: 000000006a142000 CR4: 00000000003526f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> btrfs_put_ordered_extent+0x19f/0x470 fs/btrfs/ordered-data.c:635 btrfs_finish_one_ordered+0x11d8/0x1b10 fs/btrfs/inode.c:3312 btrfs_work_helper+0x399/0xc20 fs/btrfs/async-thread.c:312 process_one_work kernel/workqueue.c:3238 [inline] process_scheduled_works+0xae1/0x17b0 kernel/workqueue.c:3321 worker_thread+0x8a0/0xda0 kernel/workqueue.c:3402 kthread+0x70e/0x8a0 kernel/kthread.c:464 ret_from_fork+0x3fc/0x770 arch/x86/kernel/process.c:148 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:245 </TASK> This can happen due to a race with the async reclaim worker like this: 1) The async metadata reclaim worker enters shrink_delalloc(), which calls btrfs_start_delalloc_roots() with an nr_pages argument that has a value less than LONG_MAX, and that in turn enters start_delalloc_inodes(), which sets the local variable 'full_flush' to false because wbc->nr_to_write is less than LONG_MAX; 2) There it finds inode X in a root's delalloc list, grabs a reference for inode X (with igrab()), and triggers writeback for it with filemap_fdatawrite_wbc(), which creates an ordered extent for inode X; 3) The unmount sequence starts from another task, we enter close_ctree() and we flush the workqueue fs_info->endio_write_workers, which waits for the ordered extent for inode X to complete and when dropping the last reference of the ordered extent, with btrfs_put_ordered_extent(), when we call btrfs_add_delayed_iput() we don't add the inode to the list of delayed iputs because it has a refcount of 2, so we decrement it to 1 and return; 4) Shortly after at close_ctree() we call btrfs_run_delayed_iputs() which runs all delayed iputs, and then we set BTRFS_FS_STATE_NO_DELAYED_IPUT in the fs_info state; 5) The async reclaim worker, after calling filemap_fdatawrite_wbc(), now calls btrfs_add_delayed_iput() for inode X and there we trigger an assertion failure since the fs_info state has the flag BTRFS_FS_STATE_NO_DELAYED_IPUT set. Fix this by setting BTRFS_FS_STATE_NO_DELAYED_IPUT only after we wait for the async reclaim workers to finish, after we call cancel_work_sync() for them at close_ctree(), and by running delayed iputs after wait for the reclaim workers to finish and before setting the bit. This race was recently introduced by commit 19e60b2a95f5 (""btrfs: add extra warning if delayed iput is added when it's not allowed""). Without the new validation at btrfs_add_delayed_iput(), ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/4693cda2c06039c875f2eef0123b22340c34bfa0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a26bf338cdad3643a6e7c3d78a172baadba15c1a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38359,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:24.687,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: s390/mm: Fix in_atomic() handling in do_secure_storage_access() Kernel user spaces accesses to not exported pages in atomic context incorrectly try to resolve the page fault. With debug options enabled call traces like this can be seen: BUG: sleeping function called from invalid context at kernel/locking/rwsem.c:1523 in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 419074, name: qemu-system-s39 preempt_count: 1, expected: 0 RCU nest depth: 0, expected: 0 INFO: lockdep is turned off. Preemption disabled at: [<00000383ea47cfa2>] copy_page_from_iter_atomic+0xa2/0x8a0 CPU: 12 UID: 0 PID: 419074 Comm: qemu-system-s39 Tainted: G W 6.16.0-20250531.rc0.git0.69b3a602feac.63.fc42.s390x+debug #1 PREEMPT Tainted: [W]=WARN Hardware name: IBM 3931 A01 703 (LPAR) Call Trace: [<00000383e990d282>] dump_stack_lvl+0xa2/0xe8 [<00000383e99bf152>] __might_resched+0x292/0x2d0 [<00000383eaa7c374>] down_read+0x34/0x2d0 [<00000383e99432f8>] do_secure_storage_access+0x108/0x360 [<00000383eaa724b0>] __do_pgm_check+0x130/0x220 [<00000383eaa842e4>] pgm_check_handler+0x114/0x160 [<00000383ea47d028>] copy_page_from_iter_atomic+0x128/0x8a0 ([<00000383ea47d016>] copy_page_from_iter_atomic+0x116/0x8a0) [<00000383e9c45eae>] generic_perform_write+0x16e/0x310 [<00000383e9eb87f4>] ext4_buffered_write_iter+0x84/0x160 [<00000383e9da0de4>] vfs_write+0x1c4/0x460 [<00000383e9da123c>] ksys_write+0x7c/0x100 [<00000383eaa7284e>] __do_syscall+0x15e/0x280 [<00000383eaa8417e>] system_call+0x6e/0x90 INFO: lockdep is turned off. It is not allowed to take the mmap_lock while in atomic context. Therefore handle such a secure storage access fault as if the accessed page is not mapped: the uaccess function will return -EFAULT, and the caller has to deal with this. Usually this means that the access is retried in process context, which allows to resolve the page fault (or in this case export the page).",,"[{""url"":""https://git.kernel.org/stable/c/11709abccf93b08adde95ef313c300b0d4bc28f1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d2e317dfd2d1fe416c77315d17c5d57dbe374915"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38360,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:24.797,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add more checks for DSC / HUBP ONO guarantees [WHY] For non-zero DSC instances it's possible that the HUBP domain required to drive it for sequential ONO ASICs isn't met, potentially causing the logic to the tile to enter an undefined state leading to a system hang. [HOW] Add more checks to ensure that the HUBP domain matching the DSC instance is appropriately powered. (cherry picked from commit da63df07112e5a9857a8d2aaa04255c4206754ec)",,"[{""url"":""https://git.kernel.org/stable/c/0d57dd1765d311111d9885346108c4deeae1deb4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f4e601bc6765e4ff5f42cc2d00993c86b367f7e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/646442758910d13f9afc57f38bc0a537c3575390"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38361,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:24.903,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check dce_hwseq before dereferencing it [WHAT] hws was checked for null earlier in dce110_blank_stream, indicating hws can be null, and should be checked whenever it is used. (cherry picked from commit 79db43611ff61280b6de58ce1305e0b2ecf675ad)",,"[{""url"":""https://git.kernel.org/stable/c/b669507b637eb6b1aaecf347f193efccc65d756e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/df11bf0ef795b6d415c4d8ee54fa3f2105e75bcb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e881b82f5d3d8d54d168cd276169f0fee01bf0e7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38362,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:25.017,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add null pointer check for get_first_active_display() The function mod_hdcp_hdcp1_enable_encryption() calls the function get_first_active_display(), but does not check its return value. The return value is a null pointer if the display list is empty. This will lead to a null pointer dereference in mod_hdcp_hdcp2_enable_encryption(). Add a null pointer check for get_first_active_display() and return MOD_HDCP_STATUS_DISPLAY_NOT_FOUND if the function return null.",,"[{""url"":""https://git.kernel.org/stable/c/1ebcdf38887949def1a553ff3e45c98ed95a3cd0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/34d3e10ab905f06445f8dbd8a3d9697095e71bae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4ce9f2dc9ff7cc410e8c5d936ec551e26b9599a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5148c7ea69e9c5bf2f05081190f45ba96d3d1e7a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3005145eab98d36777660b8893466e4f630ae1c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c3e9826a22027a21d998d3e64882fa377b613006"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38363,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:25.137,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/tegra: Fix a possible null pointer dereference In tegra_crtc_reset(), new memory is allocated with kzalloc(), but no check is performed. Before calling __drm_atomic_helper_crtc_reset, state should be checked to prevent possible null pointer dereference.",,"[{""url"":""https://git.kernel.org/stable/c/31ac2c680a8ac11dc54a5b339a07e138bcedd924"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5ff3636bcc32e1cb747f6f820bcf2bb6990a7d41"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/780351a5f61416ed2ba1199cc57e4a076fca644d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/99a25fc7933b88d5e16668bf6ba2d098e1754406"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ab390ab81241cf8bf37c0a0ac2e9c6606bf3e991"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac4ca634f0c9f227538711d725339293f7047b02"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c7fc459ae6f988e0d5045a270bd600ab08bc61f1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38364,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:25.260,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: maple_tree: fix MA_STATE_PREALLOC flag in mas_preallocate() Temporarily clear the preallocation flag when explicitly requesting allocations. Pre-existing allocations are already counted against the request through mas_node_count_gfp(), but the allocations will not happen if the MA_STATE_PREALLOC flag is set. This flag is meant to avoid re-allocating in bulk allocation mode, and to detect issues with preallocation calculations. The MA_STATE_PREALLOC flag should also always be set on zero allocations so that detection of underflow allocations will print a WARN_ON() during consumption. User visible effect of this flaw is a WARN_ON() followed by a null pointer dereference when subsequent requests for larger number of nodes is ignored, such as the vma merge retry in mmap_region() caused by drivers altering the vma flags (which happens in v6.6, at least)",,"[{""url"":""https://git.kernel.org/stable/c/9e32f4700867abbd5d19abfcf698dbd0d2ce36a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cf95f8426f889949b738f51ffcd72884411f3a6a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d69cd64bd5af41c6fd409313504089970edaf02f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e63032e66bca1d06e600033f3369ba3db3af0870"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fba46a5d83ca8decb338722fb4899026d8d9ead2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38365,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:25.380,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: fix a race between renames and directory logging We have a race between a rename and directory inode logging that if it happens and we crash/power fail before the rename completes, the next time the filesystem is mounted, the log replay code will end up deleting the file that was being renamed. This is best explained following a step by step analysis of an interleaving of steps that lead into this situation. Consider the initial conditions: 1) We are at transaction N; 2) We have directories A and B created in a past transaction (< N); 3) We have inode X corresponding to a file that has 2 hardlinks, one in directory A and the other in directory B, so we'll name them as ""A/foo_link1"" and ""B/foo_link2"". Both hard links were persisted in a past transaction (< N); 4) We have inode Y corresponding to a file that as a single hard link and is located in directory A, we'll name it as ""A/bar"". This file was also persisted in a past transaction (< N). The steps leading to a file loss are the following and for all of them we are under transaction N: 1) Link ""A/foo_link1"" is removed, so inode's X last_unlink_trans field is updated to N, through btrfs_unlink() -> btrfs_record_unlink_dir(); 2) Task A starts a rename for inode Y, with the goal of renaming from ""A/bar"" to ""A/baz"", so we enter btrfs_rename(); 3) Task A inserts the new BTRFS_INODE_REF_KEY for inode Y by calling btrfs_insert_inode_ref(); 4) Because the rename happens in the same directory, we don't set the last_unlink_trans field of directoty A's inode to the current transaction id, that is, we don't cal btrfs_record_unlink_dir(); 5) Task A then removes the entries from directory A (BTRFS_DIR_ITEM_KEY and BTRFS_DIR_INDEX_KEY items) when calling __btrfs_unlink_inode() (actually the dir index item is added as a delayed item, but the effect is the same); 6) Now before task A adds the new entry ""A/baz"" to directory A by calling btrfs_add_link(), another task, task B is logging inode X; 7) Task B starts a fsync of inode X and after logging inode X, at btrfs_log_inode_parent() it calls btrfs_log_all_parents(), since inode X has a last_unlink_trans value of N, set at in step 1; 8) At btrfs_log_all_parents() we search for all parent directories of inode X using the commit root, so we find directories A and B and log them. Bu when logging direct A, we don't have a dir index item for inode Y anymore, neither the old name ""A/bar"" nor for the new name ""A/baz"" since the rename has deleted the old name but has not yet inserted the new name - task A hasn't called yet btrfs_add_link() to do that. Note that logging directory A doesn't fallback to a transaction commit because its last_unlink_trans has a lower value than the current transaction's id (see step 4); 9) Task B finishes logging directories A and B and gets back to btrfs_sync_file() where it calls btrfs_sync_log() to persist the log tree; 10) Task B successfully persisted the log tree, btrfs_sync_log() completed with success, and a power failure happened. We have a log tree without any directory entry for inode Y, so the log replay code deletes the entry for inode Y, name ""A/bar"", from the subvolume tree since it doesn't exist in the log tree and the log tree is authorative for its index (we logged a BTRFS_DIR_LOG_INDEX_KEY item that covers the index range for the dentry that corresponds to ""A/bar""). Since there's no other hard link for inode Y and the log replay code deletes the name ""A/bar"", the file is lost. The issue wouldn't happen if task B synced the log only after task A called btrfs_log_new_name(), which would update the log with the new name for inode Y (""A/bar""). Fix this by pinning the log root during renames before removing the old directory entry, and unpinning af ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/2088895d5903082bb9021770b919e733c57edbc1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ca864de852bc91007b32d2a0d48993724f4abad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/51bd363c7010d033d3334daf457c824484bf9bf0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c6874646c21bd820cf475e2874e62c133954023"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aeeae8feeaae4445a86f9815273e81f902dc1f5b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38366,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:25.500,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: LoongArch: KVM: Check validity of ""num_cpu"" from user space The maximum supported cpu number is EIOINTC_ROUTE_MAX_VCPUS about irqchip EIOINTC, here add validation about cpu number to avoid array pointer overflow.",,"[{""url"":""https://git.kernel.org/stable/c/a3293b4078ee93174f70f36d3ab7618554ce6ab6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc8d5b209e09d3b52bca1ffe00045876842d96ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38367,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:25.603,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: LoongArch: KVM: Avoid overflow with array index The variable index is modified and reused as array index when modify register EIOINTC_ENABLE. There will be array index overflow problem.",,"[{""url"":""https://git.kernel.org/stable/c/080e8d2ecdfde588897aa8a87a8884061f4dbbbb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2cc84c4b0d70d42e291862ecc848890d18e1004a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38368,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:25.710,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: misc: tps6594-pfsm: Add NULL pointer check in tps6594_pfsm_probe() The returned value, pfsm->miscdev.name, from devm_kasprintf() could be NULL. A pointer check is added to prevent potential NULL pointer dereference. This is similar to the fix in commit 3027e7b15b02 (""ice: Fix some null pointer dereference issues in ice_ptp.c""). This issue is found by our static analysis tool.",,"[{""url"":""https://git.kernel.org/stable/c/a10c8bff454b11ef553d9df19ee722d2df34cd0e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a8d1b4f219e8833130927f19d1c8bfbf49215ce4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a99b598d836c9c6411110c70a2da134c78d96e67"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d27ee5c59881a64ea92e363502742cb4f38b7460"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38369,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:25.823,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dmaengine: idxd: Check availability of workqueue allocated by idxd wq driver before using Running IDXD workloads in a container with the /dev directory mounted can trigger a call trace or even a kernel panic when the parent process of the container is terminated. This issue occurs because, under certain configurations, Docker does not properly propagate the mount replica back to the original mount point. In this case, when the user driver detaches, the WQ is destroyed but it still calls destroy_workqueue() attempting to completes all pending work. It's necessary to check wq->wq and skip the drain if it no longer exists.",,"[{""url"":""https://git.kernel.org/stable/c/17502e7d7b7113346296f6758324798d536c31fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/98fd66c8ba77e3a7137575f610271014bc0e701f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aee7a7439f8c0884da87694a401930204a57128f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0051a3daa8b2cb318b03b2f9317c3e40855847a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38370,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:25.933,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: fix failure to rebuild free space tree using multiple transactions If we are rebuilding a free space tree, while modifying the free space tree we may need to allocate a new metadata block group. If we end up using multiple transactions for the rebuild, when we call btrfs_end_transaction() we enter btrfs_create_pending_block_groups() which calls add_block_group_free_space() to add items to the free space tree for the block group. Then later during the free space tree rebuild, at btrfs_rebuild_free_space_tree(), we may find such new block groups and call populate_free_space_tree() for them, which fails with -EEXIST because there are already items in the free space tree. Then we abort the transaction with -EEXIST at btrfs_rebuild_free_space_tree(). Notice that we say ""may find"" the new block groups because a new block group may be inserted in the block groups rbtree, which is being iterated by the rebuild process, before or after the current node where the rebuild process is currently at. Syzbot recently reported such case which produces a trace like the following: ------------[ cut here ]------------ BTRFS: Transaction aborted (error -17) WARNING: CPU: 1 PID: 7626 at fs/btrfs/free-space-tree.c:1341 btrfs_rebuild_free_space_tree+0x470/0x54c fs/btrfs/free-space-tree.c:1341 Modules linked in: CPU: 1 UID: 0 PID: 7626 Comm: syz.2.25 Not tainted 6.15.0-rc7-syzkaller-00085-gd7fa1af5b33e-dirty #0 PREEMPT Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025 pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : btrfs_rebuild_free_space_tree+0x470/0x54c fs/btrfs/free-space-tree.c:1341 lr : btrfs_rebuild_free_space_tree+0x470/0x54c fs/btrfs/free-space-tree.c:1341 sp : ffff80009c4f7740 x29: ffff80009c4f77b0 x28: ffff0000d4c3f400 x27: 0000000000000000 x26: dfff800000000000 x25: ffff70001389eee8 x24: 0000000000000003 x23: 1fffe000182b6e7b x22: 0000000000000000 x21: ffff0000c15b73d8 x20: 00000000ffffffef x19: ffff0000c15b7378 x18: 1fffe0003386f276 x17: ffff80008f31e000 x16: ffff80008adbe98c x15: 0000000000000001 x14: 1fffe0001b281550 x13: 0000000000000000 x12: 0000000000000000 x11: ffff60001b281551 x10: 0000000000000003 x9 : 1c8922000a902c00 x8 : 1c8922000a902c00 x7 : ffff800080485878 x6 : 0000000000000000 x5 : 0000000000000001 x4 : 0000000000000001 x3 : ffff80008047843c x2 : 0000000000000001 x1 : ffff80008b3ebc40 x0 : 0000000000000001 Call trace: btrfs_rebuild_free_space_tree+0x470/0x54c fs/btrfs/free-space-tree.c:1341 (P) btrfs_start_pre_rw_mount+0xa78/0xe10 fs/btrfs/disk-io.c:3074 btrfs_remount_rw fs/btrfs/super.c:1319 [inline] btrfs_reconfigure+0x828/0x2418 fs/btrfs/super.c:1543 reconfigure_super+0x1d4/0x6f0 fs/super.c:1083 do_remount fs/namespace.c:3365 [inline] path_mount+0xb34/0xde0 fs/namespace.c:4200 do_mount fs/namespace.c:4221 [inline] __do_sys_mount fs/namespace.c:4432 [inline] __se_sys_mount fs/namespace.c:4409 [inline] __arm64_sys_mount+0x3e8/0x468 fs/namespace.c:4409 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline] invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151 el0_svc+0x58/0x17c arch/arm64/kernel/entry-common.c:767 el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:786 el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600 irq event stamp: 330 hardirqs last enabled at (329): [<ffff80008048590c>] raw_spin_rq_unlock_irq kernel/sched/sched.h:1525 [inline] hardirqs last enabled at (329): [<ffff80008048590c>] finish_lock_switch+0xb0/0x1c0 kernel/sched/core.c:5130 hardirqs last disabled at (330): [<ffff80008adb9e60>] el1_dbg+0x24/0x80 arch/arm64/kernel/entry-common.c:511 softirqs last enabled at (10): [<ffff8000801fbf10>] local_bh_enable+0 ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/1e6ed33cabba8f06f532f2e5851a102602823734"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/88fdd4899ea9bfe6cf943f099fcf8ad5df153782"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38371,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:26.043,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/v3d: Disable interrupts before resetting the GPU Currently, an interrupt can be triggered during a GPU reset, which can lead to GPU hangs and NULL pointer dereference in an interrupt context as shown in the following trace: [ 314.035040] Unable to handle kernel NULL pointer dereference at virtual address 00000000000000c0 [ 314.043822] Mem abort info: [ 314.046606] ESR = 0x0000000096000005 [ 314.050347] EC = 0x25: DABT (current EL), IL = 32 bits [ 314.055651] SET = 0, FnV = 0 [ 314.058695] EA = 0, S1PTW = 0 [ 314.061826] FSC = 0x05: level 1 translation fault [ 314.066694] Data abort info: [ 314.069564] ISV = 0, ISS = 0x00000005, ISS2 = 0x00000000 [ 314.075039] CM = 0, WnR = 0, TnD = 0, TagAccess = 0 [ 314.080080] GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 [ 314.085382] user pgtable: 4k pages, 39-bit VAs, pgdp=0000000102728000 [ 314.091814] [00000000000000c0] pgd=0000000000000000, p4d=0000000000000000, pud=0000000000000000 [ 314.100511] Internal error: Oops: 0000000096000005 [#1] PREEMPT SMP [ 314.106770] Modules linked in: v3d i2c_brcmstb vc4 snd_soc_hdmi_codec gpu_sched drm_shmem_helper drm_display_helper cec drm_dma_helper drm_kms_helper drm drm_panel_orientation_quirks snd_soc_core snd_compress snd_pcm_dmaengine snd_pcm snd_timer snd backlight [ 314.129654] CPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.12.25+rpt-rpi-v8 #1 Debian 1:6.12.25-1+rpt1 [ 314.139388] Hardware name: Raspberry Pi 4 Model B Rev 1.4 (DT) [ 314.145211] pstate: 600000c5 (nZCv daIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 314.152165] pc : v3d_irq+0xec/0x2e0 [v3d] [ 314.156187] lr : v3d_irq+0xe0/0x2e0 [v3d] [ 314.160198] sp : ffffffc080003ea0 [ 314.163502] x29: ffffffc080003ea0 x28: ffffffec1f184980 x27: 021202b000000000 [ 314.170633] x26: ffffffec1f17f630 x25: ffffff8101372000 x24: ffffffec1f17d9f0 [ 314.177764] x23: 000000000000002a x22: 000000000000002a x21: ffffff8103252000 [ 314.184895] x20: 0000000000000001 x19: 00000000deadbeef x18: 0000000000000000 [ 314.192026] x17: ffffff94e51d2000 x16: ffffffec1dac3cb0 x15: c306000000000000 [ 314.199156] x14: 0000000000000000 x13: b2fc982e03cc5168 x12: 0000000000000001 [ 314.206286] x11: ffffff8103f8bcc0 x10: ffffffec1f196868 x9 : ffffffec1dac3874 [ 314.213416] x8 : 0000000000000000 x7 : 0000000000042a3a x6 : ffffff810017a180 [ 314.220547] x5 : ffffffec1ebad400 x4 : ffffffec1ebad320 x3 : 00000000000bebeb [ 314.227677] x2 : 0000000000000000 x1 : 0000000000000000 x0 : 0000000000000000 [ 314.234807] Call trace: [ 314.237243] v3d_irq+0xec/0x2e0 [v3d] [ 314.240906] __handle_irq_event_percpu+0x58/0x218 [ 314.245609] handle_irq_event+0x54/0xb8 [ 314.249439] handle_fasteoi_irq+0xac/0x240 [ 314.253527] handle_irq_desc+0x48/0x68 [ 314.257269] generic_handle_domain_irq+0x24/0x38 [ 314.261879] gic_handle_irq+0x48/0xd8 [ 314.265533] call_on_irq_stack+0x24/0x58 [ 314.269448] do_interrupt_handler+0x88/0x98 [ 314.273624] el1_interrupt+0x34/0x68 [ 314.277193] el1h_64_irq_handler+0x18/0x28 [ 314.281281] el1h_64_irq+0x64/0x68 [ 314.284673] default_idle_call+0x3c/0x168 [ 314.288675] do_idle+0x1fc/0x230 [ 314.291895] cpu_startup_entry+0x3c/0x50 [ 314.295810] rest_init+0xe4/0xf0 [ 314.299030] start_kernel+0x5e8/0x790 [ 314.302684] __primary_switched+0x80/0x90 [ 314.306691] Code: 940029eb 360ffc13 f9442ea0 52800001 (f9406017) [ 314.312775] ---[ end trace 0000000000000000 ]--- [ 314.317384] Kernel panic - not syncing: Oops: Fatal exception in interrupt [ 314.324249] SMP: stopping secondary CPUs [ 314.328167] Kernel Offset: 0x2b9da00000 from 0xffffffc080000000 [ 314.334076] PHYS_OFFSET: 0x0 [ 314.336946] CPU features: 0x08,00002013,c0200000,0200421b [ 314.342337] Memory Limit: none [ 314.345382] ---[ end Kernel panic - not syncing: Oops: Fatal exception in interrupt ]--- Before resetting the G ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/226862f50a7a88e4e4de9abbf36c64d19acd6fd0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2446e25e9246e0642a41d91cbf54c33b275da3c3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/387da3b6d1a90e3210bc9a7fb56703bdad2ac18a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/576a6739e08ac06c67f2916f71204557232388b0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ff95ed0371aec4d9617e478e9c69cde86cd7c38"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b9c403d1236cecb10dd0246a30d81e4b265f8e8d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c8851a6ab19d9f390677c42a3cc01ff9b2eb6241"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc805c927cd832bb8f790b756880ae6c769d5fbc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38372,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:26.173,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/mlx5: Fix unsafe xarray access in implicit ODP handling __xa_store() and __xa_erase() were used without holding the proper lock, which led to a lockdep warning due to unsafe RCU usage. This patch replaces them with xa_store() and xa_erase(), which perform the necessary locking internally. ============================= WARNING: suspicious RCPU usage 6.14.0-rc7_for_upstream_debug_2025_03_18_15_01 #1 Not tainted ----------------------------- ./include/linux/xarray.h:1211 suspicious rcu_dereference_protected() usage! other info that might help us debug this: rcu_scheduler_active = 2, debug_locks = 1 3 locks held by kworker/u136:0/219: at: process_one_work+0xbe4/0x15f0 process_one_work+0x75c/0x15f0 pagefault_mr+0x9a5/0x1390 [mlx5_ib] stack backtrace: CPU: 14 UID: 0 PID: 219 Comm: kworker/u136:0 Not tainted 6.14.0-rc7_for_upstream_debug_2025_03_18_15_01 #1 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014 Workqueue: mlx5_ib_page_fault mlx5_ib_eqe_pf_action [mlx5_ib] Call Trace: dump_stack_lvl+0xa8/0xc0 lockdep_rcu_suspicious+0x1e6/0x260 xas_create+0xb8a/0xee0 xas_store+0x73/0x14c0 __xa_store+0x13c/0x220 ? xa_store_range+0x390/0x390 ? spin_bug+0x1d0/0x1d0 pagefault_mr+0xcb5/0x1390 [mlx5_ib] ? _raw_spin_unlock+0x1f/0x30 mlx5_ib_eqe_pf_action+0x3be/0x2620 [mlx5_ib] ? lockdep_hardirqs_on_prepare+0x400/0x400 ? mlx5_ib_invalidate_range+0xcb0/0xcb0 [mlx5_ib] process_one_work+0x7db/0x15f0 ? pwq_dec_nr_in_flight+0xda0/0xda0 ? assign_work+0x168/0x240 worker_thread+0x57d/0xcd0 ? rescuer_thread+0xc40/0xc40 kthread+0x3b3/0x800 ? kthread_is_per_cpu+0xb0/0xb0 ? lock_downgrade+0x680/0x680 ? do_raw_spin_lock+0x12d/0x270 ? spin_bug+0x1d0/0x1d0 ? finish_task_switch.isra.0+0x284/0x9e0 ? lockdep_hardirqs_on_prepare+0x284/0x400 ? kthread_is_per_cpu+0xb0/0xb0 ret_from_fork+0x2d/0x70 ? kthread_is_per_cpu+0xb0/0xb0 ret_from_fork_asm+0x11/0x20",,"[{""url"":""https://git.kernel.org/stable/c/2c6b640ea08bff1a192bf87fa45246ff1e40767c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d2ef890e49963b768d4fe5a33029aacd9f6b93f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ebebffb47c78f63ba7e4fbde393e44af38b7625d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38373,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:26.283,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: IB/mlx5: Fix potential deadlock in MR deregistration The issue arises when kzalloc() is invoked while holding umem_mutex or any other lock acquired under umem_mutex. This is problematic because kzalloc() can trigger fs_reclaim_aqcuire(), which may, in turn, invoke mmu_notifier_invalidate_range_start(). This function can lead to mlx5_ib_invalidate_range(), which attempts to acquire umem_mutex again, resulting in a deadlock. The problematic flow: CPU0 | CPU1 ---------------------------------------|------------------------------------------------ mlx5_ib_dereg_mr() |  revoke_mr() |  mutex_lock(&umem_odp->umem_mutex) | | mlx5_mkey_cache_init() |  mutex_lock(&dev->cache.rb_lock) |  mlx5r_cache_create_ent_locked() |  kzalloc(GFP_KERNEL) |  fs_reclaim() |  mmu_notifier_invalidate_range_start() |  mlx5_ib_invalidate_range() |  mutex_lock(&umem_odp->umem_mutex)  cache_ent_find_and_store() |  mutex_lock(&dev->cache.rb_lock) | Additionally, when kzalloc() is called from within cache_ent_find_and_store(), we encounter the same deadlock due to re-acquisition of umem_mutex. Solve by releasing umem_mutex in dereg_mr() after umr_revoke_mr() and before acquiring rb_lock. This ensures that we don't hold umem_mutex while performing memory allocations that could trigger the reclaim path. This change prevents the deadlock by ensuring proper lock ordering and avoiding holding locks during memory allocation operations that could trigger the reclaim path. The following lockdep warning demonstrates the deadlock: python3/20557 is trying to acquire lock: ffff888387542128 (&umem_odp->umem_mutex){+.+.}-{4:4}, at: mlx5_ib_invalidate_range+0x5b/0x550 [mlx5_ib] but task is already holding lock: ffffffff82f6b840 (mmu_notifier_invalidate_range_start){+.+.}-{0:0}, at: unmap_vmas+0x7b/0x1a0 which lock already depends on the new lock. the existing dependency chain (in reverse order) is: -> #3 (mmu_notifier_invalidate_range_start){+.+.}-{0:0}: fs_reclaim_acquire+0x60/0xd0 mem_cgroup_css_alloc+0x6f/0x9b0 cgroup_init_subsys+0xa4/0x240 cgroup_init+0x1c8/0x510 start_kernel+0x747/0x760 x86_64_start_reservations+0x25/0x30 x86_64_start_kernel+0x73/0x80 common_startup_64+0x129/0x138 -> #2 (fs_reclaim){+.+.}-{0:0}: fs_reclaim_acquire+0x91/0xd0 __kmalloc_cache_noprof+0x4d/0x4c0 mlx5r_cache_create_ent_locked+0x75/0x620 [mlx5_ib] mlx5_mkey_cache_init+0x186/0x360 [mlx5_ib] mlx5_ib_stage_post_ib_reg_umr_init+0x3c/0x60 [mlx5_ib] __mlx5_ib_add+0x4b/0x190 [mlx5_ib] mlx5r_probe+0xd9/0x320 [mlx5_ib] auxiliary_bus_probe+0x42/0x70 really_probe+0xdb/0x360 __driver_probe_device+0x8f/0x130 driver_probe_device+0x1f/0xb0 __driver_attach+0xd4/0x1f0 bus_for_each_dev+0x79/0xd0 bus_add_driver+0xf0/0x200 driver_register+0x6e/0xc0 __auxiliary_driver_register+0x6a/0xc0 do_one_initcall+0x5e/0x390 do_init_module+0x88/0x240 init_module_from_file+0x85/0xc0 idempotent_init_module+0x104/0x300 __x64_sys_finit_module+0x68/0xc0 do_syscall_64+0x6d/0x140 entry_SYSCALL_64_after_hwframe+0x4b/0x53 -> #1 (&dev->cache.rb_lock){+.+.}-{4:4}: __mutex_lock+0x98/0xf10 __mlx5_ib_dereg_mr+0x6f2/0x890 [mlx5_ib] mlx5_ib_dereg_mr+0x21/0x110 [mlx5_ib] ib_dereg_mr_user+0x85/0x1f0 [ib_core] ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/2ed25aa7f7711f508b6120e336f05cd9d49943c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/727eb1be65a370572edf307558ec3396b8573156"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/beb89ada5715e7bd1518c58863eedce89ec051a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38374,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:26.400,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: optee: ffa: fix sleep in atomic context The OP-TEE driver registers the function notif_callback() for FF-A notifications. However, this function is called in an atomic context leading to errors like this when processing asynchronous notifications: | BUG: sleeping function called from invalid context at kernel/locking/mutex.c:258 | in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 9, name: kworker/0:0 | preempt_count: 1, expected: 0 | RCU nest depth: 0, expected: 0 | CPU: 0 UID: 0 PID: 9 Comm: kworker/0:0 Not tainted 6.14.0-00019-g657536ebe0aa #13 | Hardware name: linux,dummy-virt (DT) | Workqueue: ffa_pcpu_irq_notification notif_pcpu_irq_work_fn | Call trace: | show_stack+0x18/0x24 (C) | dump_stack_lvl+0x78/0x90 | dump_stack+0x18/0x24 | __might_resched+0x114/0x170 | __might_sleep+0x48/0x98 | mutex_lock+0x24/0x80 | optee_get_msg_arg+0x7c/0x21c | simple_call_with_arg+0x50/0xc0 | optee_do_bottom_half+0x14/0x20 | notif_callback+0x3c/0x48 | handle_notif_callbacks+0x9c/0xe0 | notif_get_and_handle+0x40/0x88 | generic_exec_single+0x80/0xc0 | smp_call_function_single+0xfc/0x1a0 | notif_pcpu_irq_work_fn+0x2c/0x38 | process_one_work+0x14c/0x2b4 | worker_thread+0x2e4/0x3e0 | kthread+0x13c/0x210 | ret_from_fork+0x10/0x20 Fix this by adding work queue to process the notification in a non-atomic context.",,"[{""url"":""https://git.kernel.org/stable/c/312d02adb959ea199372f375ada06e0186f651e4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5f28563f0c6862c99eb115c918421d9b73f137ad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f27cf15783bd60063c6c97434cbd67ebd91d8db5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38375,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:26.517,2025-08-28T15:15:48.893,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: virtio-net: ensure the received length does not exceed allocated size In xdp_linearize_page, when reading the following buffers from the ring, we forget to check the received length with the true allocate size. This can lead to an out-of-bound read. This commit adds that missing check.",,"[{""url"":""https://git.kernel.org/stable/c/11f2d0e8be2b5e784ac45fa3da226492c3e506d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/315dbdd7cdf6aa533829774caaf4d25f1fd20e73"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6aca3dad2145e864dfe4d1060f45eb1bac75dd58"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/773e95c268b5d859f51f7547559734fd2a57660c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/80b971be4c37a4d23a7f1abc5ff33dc7733d649b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/982beb7582c193544eb9c6083937ec5ac1c9d651"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bc68bc3563344ccdc57d1961457cdeecab8f81ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ddc8649d363141fb3371dd81a73e1cb4ef8ed1e1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38376,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:26.650,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: chipidea: udc: disconnect/reconnect from host when do suspend/resume Shawn and John reported a hang issue during system suspend as below: - USB gadget is enabled as Ethernet - There is data transfer over USB Ethernet (scp a big file between host and device) - Device is going in/out suspend (echo mem > /sys/power/state) The root cause is the USB device controller is suspended but the USB bus is still active which caused the USB host continues to transfer data with device and the device continues to queue USB requests (in this case, a delayed TCP ACK packet trigger the issue) after controller is suspended, however the USB controller clock is already gated off. Then if udc driver access registers after that point, the system will hang. The correct way to avoid such issue is to disconnect device from host when the USB bus is not at suspend state. Then the host will receive disconnect event and stop data transfer in time. To continue make USB gadget device work after system resume, this will reconnect device automatically. To make usb wakeup work if USB bus is already at suspend state, this will keep connection for it only when USB device controller has enabled wakeup capability.",,"[{""url"":""https://git.kernel.org/stable/c/31a6afbe86e8e9deba9ab53876ec49eafc7fd901"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5fd585fedb79bac2af9976b0fa3ffa354f0cc0bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/937f49be49d6ee696eb5457c21ff89c135c9b5ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c68a27bbebbdb4e0ccd45d4f0df7111a09ddac24"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38377,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:26.780,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: rose: fix dangling neighbour pointers in rose_rt_device_down() There are two bugs in rose_rt_device_down() that can cause use-after-free: 1. The loop bound `t->count` is modified within the loop, which can cause the loop to terminate early and miss some entries. 2. When removing an entry from the neighbour array, the subsequent entries are moved up to fill the gap, but the loop index `i` is still incremented, causing the next entry to be skipped. For example, if a node has three neighbours (A, A, B) with count=3 and A is being removed, the second A is not checked. i=0: (A, A, B) -> (A, B) with count=2 ^ checked i=1: (A, B) -> (A, B) with count=2 ^ checked (B, not A!) i=2: (doesn't occur because i < count is false) This leaves the second A in the array with count=2, but the rose_neigh structure has been freed. Code that accesses these entries assumes that the first `count` entries are valid pointers, causing a use-after-free when it accesses the dangling pointer. Fix both issues by iterating over the array in reverse order with a fixed loop bound. This ensures that all entries are examined and that the removal of an entry doesn't affect subsequent iterations.",,"[{""url"":""https://git.kernel.org/stable/c/2b952dbb32fef835756f07ff0cd77efbb836dfea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2c6c82ee074bfcfd1bc978ec45bfea37703d840a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/34a500caf48c47d5171f4aa1f237da39b07c6157"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/446ac00b86be1670838e513b643933d78837d8db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7a1841c9609377e989ec41c16551309ce79c39e4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/94e0918e39039c47ddceb609500817f7266be756"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b6b232e16e08c6dc120672b4753392df0d28c1b4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe62a35fb1f77f494ed534fc69a9043dc5a30ce1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38378,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:26.917,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: HID: appletb-kbd: fix slab use-after-free bug in appletb_kbd_probe In probe appletb_kbd_probe() a ""struct appletb_kbd *kbd"" is allocated via devm_kzalloc() to store touch bar keyboard related data. Later on if backlight_device_get_by_name() finds a backlight device with name ""appletb_backlight"" a timer (kbd->inactivity_timer) is setup with appletb_inactivity_timer() and the timer is armed to run after appletb_tb_dim_timeout (60) seconds. A use-after-free is triggered when failure occurs after the timer is armed. This ultimately means probe failure occurs and as a result the ""struct appletb_kbd *kbd"" which is device managed memory is freed. After 60 seconds the timer will have expired and __run_timers will attempt to access the timer (kbd->inactivity_timer) however the kdb structure has been freed causing a use-after free. [ 71.636938] ================================================================== [ 71.637915] BUG: KASAN: slab-use-after-free in __run_timers+0x7ad/0x890 [ 71.637915] Write of size 8 at addr ffff8881178c5958 by task swapper/1/0 [ 71.637915] [ 71.637915] CPU: 1 UID: 0 PID: 0 Comm: swapper/1 Not tainted 6.16.0-rc2-00318-g739a6c93cc75-dirty #12 PREEMPT(voluntary) [ 71.637915] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014 [ 71.637915] Call Trace: [ 71.637915] <IRQ> [ 71.637915] dump_stack_lvl+0x53/0x70 [ 71.637915] print_report+0xce/0x670 [ 71.637915] ? __run_timers+0x7ad/0x890 [ 71.637915] kasan_report+0xce/0x100 [ 71.637915] ? __run_timers+0x7ad/0x890 [ 71.637915] __run_timers+0x7ad/0x890 [ 71.637915] ? __pfx___run_timers+0x10/0x10 [ 71.637915] ? update_process_times+0xfc/0x190 [ 71.637915] ? __pfx_update_process_times+0x10/0x10 [ 71.637915] ? _raw_spin_lock_irq+0x80/0xe0 [ 71.637915] ? _raw_spin_lock_irq+0x80/0xe0 [ 71.637915] ? __pfx__raw_spin_lock_irq+0x10/0x10 [ 71.637915] run_timer_softirq+0x141/0x240 [ 71.637915] ? __pfx_run_timer_softirq+0x10/0x10 [ 71.637915] ? __pfx___hrtimer_run_queues+0x10/0x10 [ 71.637915] ? kvm_clock_get_cycles+0x18/0x30 [ 71.637915] ? ktime_get+0x60/0x140 [ 71.637915] handle_softirqs+0x1b8/0x5c0 [ 71.637915] ? __pfx_handle_softirqs+0x10/0x10 [ 71.637915] irq_exit_rcu+0xaf/0xe0 [ 71.637915] sysvec_apic_timer_interrupt+0x6c/0x80 [ 71.637915] </IRQ> [ 71.637915] [ 71.637915] Allocated by task 39: [ 71.637915] kasan_save_stack+0x33/0x60 [ 71.637915] kasan_save_track+0x14/0x30 [ 71.637915] __kasan_kmalloc+0x8f/0xa0 [ 71.637915] __kmalloc_node_track_caller_noprof+0x195/0x420 [ 71.637915] devm_kmalloc+0x74/0x1e0 [ 71.637915] appletb_kbd_probe+0x37/0x3c0 [ 71.637915] hid_device_probe+0x2d1/0x680 [ 71.637915] really_probe+0x1c3/0x690 [ 71.637915] __driver_probe_device+0x247/0x300 [ 71.637915] driver_probe_device+0x49/0x210 [...] [ 71.637915] [ 71.637915] Freed by task 39: [ 71.637915] kasan_save_stack+0x33/0x60 [ 71.637915] kasan_save_track+0x14/0x30 [ 71.637915] kasan_save_free_info+0x3b/0x60 [ 71.637915] __kasan_slab_free+0x37/0x50 [ 71.637915] kfree+0xcf/0x360 [ 71.637915] devres_release_group+0x1f8/0x3c0 [ 71.637915] hid_device_probe+0x315/0x680 [ 71.637915] really_probe+0x1c3/0x690 [ 71.637915] __driver_probe_device+0x247/0x300 [ 71.637915] driver_probe_device+0x49/0x210 [...] The root cause of the issue is that the timer is not disarmed on failure paths leading to it remaining active and accessing freed memory. To fix this call timer_delete_sync() to deactivate the timer. Another small issue is that timer_delete_sync is called unconditionally in appletb_kbd_remove(), fix this by checking for a valid kbd->backlight_dev before calling timer_delete_sync.",,"[{""url"":""https://git.kernel.org/stable/c/38224c472a038fa9ccd4085511dd9f3d6119dbf9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/51720dee3a61ebace36c3dcdd0b4a488e0970f29"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38379,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:27.033,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: smb: client: fix warning when reconnecting channel When reconnecting a channel in smb2_reconnect_server(), a dummy tcon is passed down to smb2_reconnect() with ->query_interface uninitialized, so we can't call queue_delayed_work() on it. Fix the following warning by ensuring that we're queueing the delayed worker from correct tcon. WARNING: CPU: 4 PID: 1126 at kernel/workqueue.c:2498 __queue_delayed_work+0x1d2/0x200 Modules linked in: cifs cifs_arc4 nls_ucs2_utils cifs_md4 [last unloaded: cifs] CPU: 4 UID: 0 PID: 1126 Comm: kworker/4:0 Not tainted 6.16.0-rc3 #5 PREEMPT(voluntary) Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-4.fc42 04/01/2014 Workqueue: cifsiod smb2_reconnect_server [cifs] RIP: 0010:__queue_delayed_work+0x1d2/0x200 Code: 41 5e 41 5f e9 7f ee ff ff 90 0f 0b 90 e9 5d ff ff ff bf 02 00 00 00 e8 6c f3 07 00 89 c3 eb bd 90 0f 0b 90 e9 57 f> 0b 90 e9 65 fe ff ff 90 0f 0b 90 e9 72 fe ff ff 90 0f 0b 90 e9 RSP: 0018:ffffc900014afad8 EFLAGS: 00010003 RAX: 0000000000000000 RBX: ffff888124d99988 RCX: ffffffff81399cc1 RDX: dffffc0000000000 RSI: ffff888114326e00 RDI: ffff888124d999f0 RBP: 000000000000ea60 R08: 0000000000000001 R09: ffffed10249b3331 R10: ffff888124d9998f R11: 0000000000000004 R12: 0000000000000040 R13: ffff888114326e00 R14: ffff888124d999d8 R15: ffff888114939020 FS: 0000000000000000(0000) GS:ffff88829f7fe000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007ffe7a2b4038 CR3: 0000000120a6f000 CR4: 0000000000750ef0 PKRU: 55555554 Call Trace: <TASK> queue_delayed_work_on+0xb4/0xc0 smb2_reconnect+0xb22/0xf50 [cifs] smb2_reconnect_server+0x413/0xd40 [cifs] ? __pfx_smb2_reconnect_server+0x10/0x10 [cifs] ? local_clock_noinstr+0xd/0xd0 ? local_clock+0x15/0x30 ? lock_release+0x29b/0x390 process_one_work+0x4c5/0xa10 ? __pfx_process_one_work+0x10/0x10 ? __list_add_valid_or_report+0x37/0x120 worker_thread+0x2f1/0x5a0 ? __kthread_parkme+0xde/0x100 ? __pfx_worker_thread+0x10/0x10 kthread+0x1fe/0x380 ? kthread+0x10f/0x380 ? __pfx_kthread+0x10/0x10 ? local_clock_noinstr+0xd/0xd0 ? ret_from_fork+0x1b/0x1f0 ? local_clock+0x15/0x30 ? lock_release+0x29b/0x390 ? rcu_is_watching+0x20/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x15b/0x1f0 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK> irq event stamp: 1116206 hardirqs last enabled at (1116205): [<ffffffff8143af42>] __up_console_sem+0x52/0x60 hardirqs last disabled at (1116206): [<ffffffff81399f0e>] queue_delayed_work_on+0x6e/0xc0 softirqs last enabled at (1116138): [<ffffffffc04562fd>] __smb_send_rqst+0x42d/0x950 [cifs] softirqs last disabled at (1116136): [<ffffffff823d35e1>] release_sock+0x21/0xf0",,"[{""url"":""https://git.kernel.org/stable/c/0cee638d92ac898d73eccc4e4bab70e9fc95946a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3bbe46716092d8ef6b0df4b956f585c5cd0fc78e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f6932ef25378794894c3c1024092ad14da2d330"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d2b629a9dc5c72537645533af1cb11a7d34c4b1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38380,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:27.157,2025-09-17T14:15:38.730,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,[],,,,,,,,,,
CVE-2025-38381,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:27.280,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Input: cs40l50-vibra - fix potential NULL dereference in cs40l50_upload_owt() The cs40l50_upload_owt() function allocates memory via kmalloc() without checking for allocation failure, which could lead to a NULL pointer dereference. Return -ENOMEM in case allocation fails.",,"[{""url"":""https://git.kernel.org/stable/c/4cf65845fdd09d711fc7546d60c9abe010956922"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e87fc697fa4be5164e47cfba4ddd4732499adc60"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ea20568895c1122f15b6fc9e8d02c6cbe22964f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38382,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:27.390,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: fix iteration of extrefs during log replay At __inode_add_ref() when processing extrefs, if we jump into the next label we have an undefined value of victim_name.len, since we haven't initialized it before we did the goto. This results in an invalid memory access in the next iteration of the loop since victim_name.len was not initialized to the length of the name of the current extref. Fix this by initializing victim_name.len with the current extref's name length.",,"[{""url"":""https://git.kernel.org/stable/c/2d11d274e2e1d7c79e2ca8461ce3ff3a95c11171"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/539969fc472886a1d63565459514d47e27fef461"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/54a7081ed168b72a8a2d6ef4ba3a1259705a2926"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ac790dc2ba00499a8d671d4a24de4d4ad27e234"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aee57a0293dca675637e5504709f9f8fd8e871be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38383,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:27.520,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm/vmalloc: fix data race in show_numa_info() The following data-race was found in show_numa_info(): ================================================================== BUG: KCSAN: data-race in vmalloc_info_show / vmalloc_info_show read to 0xffff88800971fe30 of 4 bytes by task 8289 on cpu 0: show_numa_info mm/vmalloc.c:4936 [inline] vmalloc_info_show+0x5a8/0x7e0 mm/vmalloc.c:5016 seq_read_iter+0x373/0xb40 fs/seq_file.c:230 proc_reg_read_iter+0x11e/0x170 fs/proc/inode.c:299 .... write to 0xffff88800971fe30 of 4 bytes by task 8287 on cpu 1: show_numa_info mm/vmalloc.c:4934 [inline] vmalloc_info_show+0x38f/0x7e0 mm/vmalloc.c:5016 seq_read_iter+0x373/0xb40 fs/seq_file.c:230 proc_reg_read_iter+0x11e/0x170 fs/proc/inode.c:299 .... value changed: 0x0000008f -> 0x00000000 ================================================================== According to this report,there is a read/write data-race because m->private is accessible to multiple CPUs. To fix this, instead of allocating the heap in proc_vmalloc_init() and passing the heap address to m->private, vmalloc_info_show() should allocate the heap.",,"[{""url"":""https://git.kernel.org/stable/c/5c5f0468d172ddec2e333d738d2a1f85402cf0bc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5c966f447a584ece3c70395898231aeb56256ee7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ead91de35d9cd5c4f80ec51e6020f342079170af"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38384,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:27.643,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mtd: spinand: fix memory leak of ECC engine conf Memory allocated for the ECC engine conf is not released during spinand cleanup. Below kmemleak trace is seen for this memory leak: unreferenced object 0xffffff80064f00e0 (size 8): comm ""swapper/0"", pid 1, jiffies 4294937458 hex dump (first 8 bytes): 00 00 00 00 00 00 00 00 ........ backtrace (crc 0): kmemleak_alloc+0x30/0x40 __kmalloc_cache_noprof+0x208/0x3c0 spinand_ondie_ecc_init_ctx+0x114/0x200 nand_ecc_init_ctx+0x70/0xa8 nanddev_ecc_engine_init+0xec/0x27c spinand_probe+0xa2c/0x1620 spi_mem_probe+0x130/0x21c spi_probe+0xf0/0x170 really_probe+0x17c/0x6e8 __driver_probe_device+0x17c/0x21c driver_probe_device+0x58/0x180 __device_attach_driver+0x15c/0x1f8 bus_for_each_drv+0xec/0x150 __device_attach+0x188/0x24c device_initial_probe+0x10/0x20 bus_probe_device+0x11c/0x160 Fix the leak by calling nanddev_ecc_engine_cleanup() inside spinand_cleanup().",,"[{""url"":""https://git.kernel.org/stable/c/6463cbe08b0cbf9bba8763306764f5fd643023e1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/68d3417305ee100dcad90fd6e5846b22497aa394"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/93147abf80a831dd3b5660b3309b4f09546073b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c40b207cafd006c610832ba52a81cedee77adcb9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d5c1e3f32902ab518519d05515ee6030fd6c59ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f99408670407abb6493780e38cb4ece3fbb52cfc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38385,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:27.760,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: usb: lan78xx: fix WARN in __netif_napi_del_locked on disconnect Remove redundant netif_napi_del() call from disconnect path. A WARN may be triggered in __netif_napi_del_locked() during USB device disconnect: WARNING: CPU: 0 PID: 11 at net/core/dev.c:7417 __netif_napi_del_locked+0x2b4/0x350 This happens because netif_napi_del() is called in the disconnect path while NAPI is still enabled. However, it is not necessary to call netif_napi_del() explicitly, since unregister_netdev() will handle NAPI teardown automatically and safely. Removing the redundant call avoids triggering the warning. Full trace: lan78xx 1-1:1.0 enu1: Failed to read register index 0x000000c4. ret = -ENODEV lan78xx 1-1:1.0 enu1: Failed to set MAC down with error -ENODEV lan78xx 1-1:1.0 enu1: Link is Down lan78xx 1-1:1.0 enu1: Failed to read register index 0x00000120. ret = -ENODEV ------------[ cut here ]------------ WARNING: CPU: 0 PID: 11 at net/core/dev.c:7417 __netif_napi_del_locked+0x2b4/0x350 Modules linked in: flexcan can_dev fuse CPU: 0 UID: 0 PID: 11 Comm: kworker/0:1 Not tainted 6.16.0-rc2-00624-ge926949dab03 #9 PREEMPT Hardware name: SKOV IMX8MP CPU revC - bd500 (DT) Workqueue: usb_hub_wq hub_event pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : __netif_napi_del_locked+0x2b4/0x350 lr : __netif_napi_del_locked+0x7c/0x350 sp : ffffffc085b673c0 x29: ffffffc085b673c0 x28: ffffff800b7f2000 x27: ffffff800b7f20d8 x26: ffffff80110bcf58 x25: ffffff80110bd978 x24: 1ffffff0022179eb x23: ffffff80110bc000 x22: ffffff800b7f5000 x21: ffffff80110bc000 x20: ffffff80110bcf38 x19: ffffff80110bcf28 x18: dfffffc000000000 x17: ffffffc081578940 x16: ffffffc08284cee0 x15: 0000000000000028 x14: 0000000000000006 x13: 0000000000040000 x12: ffffffb0022179e8 x11: 1ffffff0022179e7 x10: ffffffb0022179e7 x9 : dfffffc000000000 x8 : 0000004ffdde8619 x7 : ffffff80110bcf3f x6 : 0000000000000001 x5 : ffffff80110bcf38 x4 : ffffff80110bcf38 x3 : 0000000000000000 x2 : 0000000000000000 x1 : 1ffffff0022179e7 x0 : 0000000000000000 Call trace: __netif_napi_del_locked+0x2b4/0x350 (P) lan78xx_disconnect+0xf4/0x360 usb_unbind_interface+0x158/0x718 device_remove+0x100/0x150 device_release_driver_internal+0x308/0x478 device_release_driver+0x1c/0x30 bus_remove_device+0x1a8/0x368 device_del+0x2e0/0x7b0 usb_disable_device+0x244/0x540 usb_disconnect+0x220/0x758 hub_event+0x105c/0x35e0 process_one_work+0x760/0x17b0 worker_thread+0x768/0xce8 kthread+0x3bc/0x690 ret_from_fork+0x10/0x20 irq event stamp: 211604 hardirqs last enabled at (211603): [<ffffffc0828cc9ec>] _raw_spin_unlock_irqrestore+0x84/0x98 hardirqs last disabled at (211604): [<ffffffc0828a9a84>] el1_dbg+0x24/0x80 softirqs last enabled at (211296): [<ffffffc080095f10>] handle_softirqs+0x820/0xbc8 softirqs last disabled at (210993): [<ffffffc080010288>] __do_softirq+0x18/0x20 ---[ end trace 0000000000000000 ]--- lan78xx 1-1:1.0 enu1: failed to kill vid 0081/0",,"[{""url"":""https://git.kernel.org/stable/c/17a37b9a5dd945d86110838fb471e7139ba993a2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/510a6095d754df9d727f644ec5076b7929d6c9ea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c7ffc9af7186ed79403a3ffee9a1e5199fc7450"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7135056a49035597198280820c61b8c5dbe4a1d0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/968a419c95131e420f12bbdba19e96e2f6b071c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38386,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:27.877,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ACPICA: Refuse to evaluate a method if arguments are missing As reported in [1], a platform firmware update that increased the number of method parameters and forgot to update a least one of its callers, caused ACPICA to crash due to use-after-free. Since this a result of a clear AML issue that arguably cannot be fixed up by the interpreter (it cannot produce missing data out of thin air), address it by making ACPICA refuse to evaluate a method if the caller attempts to pass fewer arguments than expected to it.",,"[{""url"":""https://git.kernel.org/stable/c/18ff4ed6a33a7e3f2097710eacc96bea7696e803"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2219e49857ffd6aea1b1ca5214d3270f84623a16"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4305d936abde795c2ef6ba916de8f00a50f64d2d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6fcab2791543924d438e7fa49276d0998b0a069f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ab1e8491c19eb2ea0fda81ef28e841c7cb6399f5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b49d224d1830c46e20adce2a239c454cdab426f1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c9e4da550ae196132b990bd77ed3d8f2d9747f87"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d547779e72cea9865b732cd45393c4cd02b3598e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38387,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:28.000,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/mlx5: Initialize obj_event->obj_sub_list before xa_insert The obj_event may be loaded immediately after inserted, then if the list_head is not initialized then we may get a poisonous pointer. This fixes the crash below: mlx5_core 0000:03:00.0: MLX5E: StrdRq(1) RqSz(8) StrdSz(2048) RxCqeCmprss(0 enhanced) mlx5_core.sf mlx5_core.sf.4: firmware version: 32.38.3056 mlx5_core 0000:03:00.0 en3f0pf0sf2002: renamed from eth0 mlx5_core.sf mlx5_core.sf.4: Rate limit: 127 rates are supported, range: 0Mbps to 195312Mbps IPv6: ADDRCONF(NETDEV_CHANGE): en3f0pf0sf2002: link becomes ready Unable to handle kernel NULL pointer dereference at virtual address 0000000000000060 Mem abort info: ESR = 0x96000006 EC = 0x25: DABT (current EL), IL = 32 bits SET = 0, FnV = 0 EA = 0, S1PTW = 0 Data abort info: ISV = 0, ISS = 0x00000006 CM = 0, WnR = 0 user pgtable: 4k pages, 48-bit VAs, pgdp=00000007760fb000 [0000000000000060] pgd=000000076f6d7003, p4d=000000076f6d7003, pud=0000000777841003, pmd=0000000000000000 Internal error: Oops: 96000006 [#1] SMP Modules linked in: ipmb_host(OE) act_mirred(E) cls_flower(E) sch_ingress(E) mptcp_diag(E) udp_diag(E) raw_diag(E) unix_diag(E) tcp_diag(E) inet_diag(E) binfmt_misc(E) bonding(OE) rdma_ucm(OE) rdma_cm(OE) iw_cm(OE) ib_ipoib(OE) ib_cm(OE) isofs(E) cdrom(E) mst_pciconf(OE) ib_umad(OE) mlx5_ib(OE) ipmb_dev_int(OE) mlx5_core(OE) kpatch_15237886(OEK) mlxdevm(OE) auxiliary(OE) ib_uverbs(OE) ib_core(OE) psample(E) mlxfw(OE) tls(E) sunrpc(E) vfat(E) fat(E) crct10dif_ce(E) ghash_ce(E) sha1_ce(E) sbsa_gwdt(E) virtio_console(E) ext4(E) mbcache(E) jbd2(E) xfs(E) libcrc32c(E) mmc_block(E) virtio_net(E) net_failover(E) failover(E) sha2_ce(E) sha256_arm64(E) nvme(OE) nvme_core(OE) gpio_mlxbf3(OE) mlx_compat(OE) mlxbf_pmc(OE) i2c_mlxbf(OE) sdhci_of_dwcmshc(OE) pinctrl_mlxbf3(OE) mlxbf_pka(OE) gpio_generic(E) i2c_core(E) mmc_core(E) mlxbf_gige(OE) vitesse(E) pwr_mlxbf(OE) mlxbf_tmfifo(OE) micrel(E) mlxbf_bootctl(OE) virtio_ring(E) virtio(E) ipmi_devintf(E) ipmi_msghandler(E) [last unloaded: mst_pci] CPU: 11 PID: 20913 Comm: rte-worker-11 Kdump: loaded Tainted: G OE K 5.10.134-13.1.an8.aarch64 #1 Hardware name: https://www.mellanox.com BlueField-3 SmartNIC Main Card/BlueField-3 SmartNIC Main Card, BIOS 4.2.2.12968 Oct 26 2023 pstate: a0400089 (NzCv daIf +PAN -UAO -TCO BTYPE=--) pc : dispatch_event_fd+0x68/0x300 [mlx5_ib] lr : devx_event_notifier+0xcc/0x228 [mlx5_ib] sp : ffff80001005bcf0 x29: ffff80001005bcf0 x28: 0000000000000001 x27: ffff244e0740a1d8 x26: ffff244e0740a1d0 x25: ffffda56beff5ae0 x24: ffffda56bf911618 x23: ffff244e0596a480 x22: ffff244e0596a480 x21: ffff244d8312ad90 x20: ffff244e0596a480 x19: fffffffffffffff0 x18: 0000000000000000 x17: 0000000000000000 x16: ffffda56be66d620 x15: 0000000000000000 x14: 0000000000000000 x13: 0000000000000000 x12: 0000000000000000 x11: 0000000000000040 x10: ffffda56bfcafb50 x9 : ffffda5655c25f2c x8 : 0000000000000010 x7 : 0000000000000000 x6 : ffff24545a2e24b8 x5 : 0000000000000003 x4 : ffff80001005bd28 x3 : 0000000000000000 x2 : 0000000000000000 x1 : ffff244e0596a480 x0 : ffff244d8312ad90 Call trace: dispatch_event_fd+0x68/0x300 [mlx5_ib] devx_event_notifier+0xcc/0x228 [mlx5_ib] atomic_notifier_call_chain+0x58/0x80 mlx5_eq_async_int+0x148/0x2b0 [mlx5_core] atomic_notifier_call_chain+0x58/0x80 irq_int_handler+0x20/0x30 [mlx5_core] __handle_irq_event_percpu+0x60/0x220 handle_irq_event_percpu+0x3c/0x90 handle_irq_event+0x58/0x158 handle_fasteoi_irq+0xfc/0x188 generic_handle_irq+0x34/0x48 ...",,"[{""url"":""https://git.kernel.org/stable/c/00ed215f593876385451423924fe0358c556179c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/23a3b32a274a8d6f33480d0eff436eb100981651"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/716b555fc0580c2aa4c2c32ae4401c7e3ad9873e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8edab8a72d67742f87e9dc2e2b0cdfddda5dc29a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/93fccfa71c66a4003b3d2fef3a38de7307e14a4e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/972e968aac0dce8fe8faad54f6106de576695d8e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9a28377a96fb299c180dd9cf0be3b0a038a52d4e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e8069711139249994450c214cec152b917b959e0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38388,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:28.127,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: firmware: arm_ffa: Replace mutex with rwlock to avoid sleep in atomic context The current use of a mutex to protect the notifier hashtable accesses can lead to issues in the atomic context. It results in the below kernel warnings: | BUG: sleeping function called from invalid context at kernel/locking/mutex.c:258 | in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 9, name: kworker/0:0 | preempt_count: 1, expected: 0 | RCU nest depth: 0, expected: 0 | CPU: 0 UID: 0 PID: 9 Comm: kworker/0:0 Not tainted 6.14.0 #4 | Workqueue: ffa_pcpu_irq_notification notif_pcpu_irq_work_fn | Call trace: | show_stack+0x18/0x24 (C) | dump_stack_lvl+0x78/0x90 | dump_stack+0x18/0x24 | __might_resched+0x114/0x170 | __might_sleep+0x48/0x98 | mutex_lock+0x24/0x80 | handle_notif_callbacks+0x54/0xe0 | notif_get_and_handle+0x40/0x88 | generic_exec_single+0x80/0xc0 | smp_call_function_single+0xfc/0x1a0 | notif_pcpu_irq_work_fn+0x2c/0x38 | process_one_work+0x14c/0x2b4 | worker_thread+0x2e4/0x3e0 | kthread+0x13c/0x210 | ret_from_fork+0x10/0x20 To address this, replace the mutex with an rwlock to protect the notifier hashtable accesses. This ensures that read-side locking does not sleep and multiple readers can acquire the lock concurrently, avoiding unnecessary contention and potential deadlocks. Writer access remains exclusive, preserving correctness. This change resolves warnings from lockdep about potential sleep in atomic context.",,"[{""url"":""https://git.kernel.org/stable/c/31405510a48dcf054abfa5b7b8d70ce1b27d1f13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8986f8f61b482c0e6efd28f0b2423d9640c20eb1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ca7a421229bbdfbe2e1e628cff5cfa782720a10"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38389,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:28.240,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/i915/gt: Fix timeline left held on VMA alloc error The following error has been reported sporadically by CI when a test unbinds the i915 driver on a ring submission platform: <4> [239.330153] ------------[ cut here ]------------ <4> [239.330166] i915 0000:00:02.0: [drm] drm_WARN_ON(dev_priv->mm.shrink_count) <4> [239.330196] WARNING: CPU: 1 PID: 18570 at drivers/gpu/drm/i915/i915_gem.c:1309 i915_gem_cleanup_early+0x13e/0x150 [i915] ... <4> [239.330640] RIP: 0010:i915_gem_cleanup_early+0x13e/0x150 [i915] ... <4> [239.330942] Call Trace: <4> [239.330944] <TASK> <4> [239.330949] i915_driver_late_release+0x2b/0xa0 [i915] <4> [239.331202] i915_driver_release+0x86/0xa0 [i915] <4> [239.331482] devm_drm_dev_init_release+0x61/0x90 <4> [239.331494] devm_action_release+0x15/0x30 <4> [239.331504] release_nodes+0x3d/0x120 <4> [239.331517] devres_release_all+0x96/0xd0 <4> [239.331533] device_unbind_cleanup+0x12/0x80 <4> [239.331543] device_release_driver_internal+0x23a/0x280 <4> [239.331550] ? bus_find_device+0xa5/0xe0 <4> [239.331563] device_driver_detach+0x14/0x20 ... <4> [357.719679] ---[ end trace 0000000000000000 ]--- If the test also unloads the i915 module then that's followed with: <3> [357.787478] ============================================================================= <3> [357.788006] BUG i915_vma (Tainted: G U W N ): Objects remaining on __kmem_cache_shutdown() <3> [357.788031] ----------------------------------------------------------------------------- <3> [357.788204] Object 0xffff888109e7f480 @offset=29824 <3> [357.788670] Allocated in i915_vma_instance+0xee/0xc10 [i915] age=292729 cpu=4 pid=2244 <4> [357.788994] i915_vma_instance+0xee/0xc10 [i915] <4> [357.789290] init_status_page+0x7b/0x420 [i915] <4> [357.789532] intel_engines_init+0x1d8/0x980 [i915] <4> [357.789772] intel_gt_init+0x175/0x450 [i915] <4> [357.790014] i915_gem_init+0x113/0x340 [i915] <4> [357.790281] i915_driver_probe+0x847/0xed0 [i915] <4> [357.790504] i915_pci_probe+0xe6/0x220 [i915] ... Closer analysis of CI results history has revealed a dependency of the error on a few IGT tests, namely: - igt@api_intel_allocator@fork-simple-stress-signal, - igt@api_intel_allocator@two-level-inception-interruptible, - igt@gem_linear_blits@interruptible, - igt@prime_mmap_coherency@ioctl-errors, which invisibly trigger the issue, then exhibited with first driver unbind attempt. All of the above tests perform actions which are actively interrupted with signals. Further debugging has allowed to narrow that scope down to DRM_IOCTL_I915_GEM_EXECBUFFER2, and ring_context_alloc(), specific to ring submission, in particular. If successful then that function, or its execlists or GuC submission equivalent, is supposed to be called only once per GEM context engine, followed by raise of a flag that prevents the function from being called again. The function is expected to unwind its internal errors itself, so it may be safely called once more after it returns an error. In case of ring submission, the function first gets a reference to the engine's legacy timeline and then allocates a VMA. If the VMA allocation fails, e.g. when i915_vma_instance() called from inside is interrupted with a signal, then ring_context_alloc() fails, leaving the timeline held referenced. On next I915_GEM_EXECBUFFER2 IOCTL, another reference to the timeline is got, and only that last one is put on successful completion. As a consequence, the legacy timeline, with its underlying engine status page's VMA object, is still held and not released on driver unbind. Get the legacy timeline only after successful allocation of the context engine's VMA. v2: Add a note on other submission methods (Krzysztof Karas): Both execlists and GuC submission use lrc_alloc() which seems free from a similar issue. (cherry picked from commit cc43422b3cc79eacff4c5a8ba0d224688ca9dd4f)",,"[{""url"":""https://git.kernel.org/stable/c/40e09506aea1fde1f3e0e04eca531bbb23404baf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c778c96e469fb719b11683e0a3be8ea68052fa2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a7ae7bebdc4c2ecd48a2c061319956f65c09473"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/60b757730884e4a223152a68d9b5f625dac94119"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a5aa7bc1fca78c7fa127d9e33aa94a0c9066c1d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c542d62883f62ececafcb630a1c5010133826bea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e47d7d6edc40a6ace7cc04e5893759fee68569f5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f10af34261448610d4048ac6e6af87f80e3881a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38390,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:28.373,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: firmware: arm_ffa: Fix memory leak by freeing notifier callback node Commit e0573444edbf (""firmware: arm_ffa: Add interfaces to request notification callbacks"") adds support for notifier callbacks by allocating and inserting a callback node into a hashtable during registration of notifiers. However, during unregistration, the code only removes the node from the hashtable without freeing the associated memory, resulting in a memory leak. Resolve the memory leak issue by ensuring the allocated notifier callback node is properly freed after it is removed from the hashtable entry.",,"[{""url"":""https://git.kernel.org/stable/c/076fa20b4f5737c34921dbb152f9efceaee571b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/938827c440564b2cf2f9b804d1fe81ce8267eded"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a833d31ad867103ba72a0b73f3606f4ab8601719"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38391,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:28.487,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: typec: altmodes/displayport: do not index invalid pin_assignments A poorly implemented DisplayPort Alt Mode port partner can indicate that its pin assignment capabilities are greater than the maximum value, DP_PIN_ASSIGN_F. In this case, calls to pin_assignment_show will cause a BRK exception due to an out of bounds array access. Prevent for loop in pin_assignment_show from accessing invalid values in pin_assignments by adding DP_PIN_ASSIGN_MAX value in typec_dp.h and using i < DP_PIN_ASSIGN_MAX as a loop condition.",,"[{""url"":""https://git.kernel.org/stable/c/114a977e0f6bf278e05eade055e13fc271f69cf7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2f535517b5611b7221ed478527e4b58e29536ddf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/45e9444b3b97eaf51a5024f1fea92f44f39b50c6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/47cb5d26f61d80c805d7de4106451153779297a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5581e694d3a1c2f32c5a51d745c55b107644e1f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/621d5a3ef0231ab242f2d31eecec40c38ca609c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/af4db5a35a4ef7a68046883bfd12468007db38f1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c93bc959788ed9a1af7df57cb539837bdf790cee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38392,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:28.617,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: idpf: convert control queue mutex to a spinlock With VIRTCHNL2_CAP_MACFILTER enabled, the following warning is generated on module load: [ 324.701677] BUG: sleeping function called from invalid context at kernel/locking/mutex.c:578 [ 324.701684] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 1582, name: NetworkManager [ 324.701689] preempt_count: 201, expected: 0 [ 324.701693] RCU nest depth: 0, expected: 0 [ 324.701697] 2 locks held by NetworkManager/1582: [ 324.701702] #0: ffffffff9f7be770 (rtnl_mutex){....}-{3:3}, at: rtnl_newlink+0x791/0x21e0 [ 324.701730] #1: ff1100216c380368 (_xmit_ETHER){....}-{2:2}, at: __dev_open+0x3f0/0x870 [ 324.701749] Preemption disabled at: [ 324.701752] [<ffffffff9cd23b9d>] __dev_open+0x3dd/0x870 [ 324.701765] CPU: 30 UID: 0 PID: 1582 Comm: NetworkManager Not tainted 6.15.0-rc5+ #2 PREEMPT(voluntary) [ 324.701771] Hardware name: Intel Corporation M50FCP2SBSTD/M50FCP2SBSTD, BIOS SE5C741.86B.01.01.0001.2211140926 11/14/2022 [ 324.701774] Call Trace: [ 324.701777] <TASK> [ 324.701779] dump_stack_lvl+0x5d/0x80 [ 324.701788] ? __dev_open+0x3dd/0x870 [ 324.701793] __might_resched.cold+0x1ef/0x23d <..> [ 324.701818] __mutex_lock+0x113/0x1b80 <..> [ 324.701917] idpf_ctlq_clean_sq+0xad/0x4b0 [idpf] [ 324.701935] ? kasan_save_track+0x14/0x30 [ 324.701941] idpf_mb_clean+0x143/0x380 [idpf] <..> [ 324.701991] idpf_send_mb_msg+0x111/0x720 [idpf] [ 324.702009] idpf_vc_xn_exec+0x4cc/0x990 [idpf] [ 324.702021] ? rcu_is_watching+0x12/0xc0 [ 324.702035] idpf_add_del_mac_filters+0x3ed/0xb50 [idpf] <..> [ 324.702122] __hw_addr_sync_dev+0x1cf/0x300 [ 324.702126] ? find_held_lock+0x32/0x90 [ 324.702134] idpf_set_rx_mode+0x317/0x390 [idpf] [ 324.702152] __dev_open+0x3f8/0x870 [ 324.702159] ? __pfx___dev_open+0x10/0x10 [ 324.702174] __dev_change_flags+0x443/0x650 <..> [ 324.702208] netif_change_flags+0x80/0x160 [ 324.702218] do_setlink.isra.0+0x16a0/0x3960 <..> [ 324.702349] rtnl_newlink+0x12fd/0x21e0 The sequence is as follows: rtnl_newlink()-> __dev_change_flags()-> __dev_open()-> dev_set_rx_mode() - > # disables BH and grabs ""dev->addr_list_lock"" idpf_set_rx_mode() -> # proceed only if VIRTCHNL2_CAP_MACFILTER is ON __dev_uc_sync() -> idpf_add_mac_filter -> idpf_add_del_mac_filters -> idpf_send_mb_msg() -> idpf_mb_clean() -> idpf_ctlq_clean_sq() # mutex_lock(cq_lock) Fix by converting cq_lock to a spinlock. All operations under the new lock are safe except freeing the DMA memory, which may use vunmap(). Fix by requesting a contiguous physical memory for the DMA mapping.",,"[{""url"":""https://git.kernel.org/stable/c/9a36715cd6bc6a6f16230e19a7f947bab34b3fe5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b2beb5bb2cd90d7939e470ed4da468683f41baa3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc6c3c2c9dfdaa3a3357f59a80a2904677a71a9a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38393,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:28.723,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: NFSv4/pNFS: Fix a race to wake on NFS_LAYOUT_DRAIN We found a few different systems hung up in writeback waiting on the same page lock, and one task waiting on the NFS_LAYOUT_DRAIN bit in pnfs_update_layout(), however the pnfs_layout_hdr's plh_outstanding count was zero. It seems most likely that this is another race between the waiter and waker similar to commit ed0172af5d6f (""SUNRPC: Fix a race to wake a sync task""). Fix it up by applying the advised barrier.",,"[{""url"":""https://git.kernel.org/stable/c/08287df60bac5b008b6bcdb03053988335d3d282"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1f4da20080718f258e189a2c5f515385fa393da6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/864a54c1243ed3ca60baa4bc492dede1361f4c83"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8846fd02c98da8b79e6343a20e6071be6f372180"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ca65fa71024a1767a59ffbc6a6e2278af84735e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c01776287414ca43412d1319d2877cbad65444ac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e4b13885e7ef1e64e45268feef1e5f0707c47e72"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38394,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:28.843,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: HID: appletb-kbd: fix memory corruption of input_handler_list In appletb_kbd_probe an input handler is initialised and then registered with input core through input_register_handler(). When this happens input core will add the input handler (specifically its node) to the global input_handler_list. The input_handler_list is central to the functionality of input core and is traversed in various places in input core. An example of this is when a new input device is plugged in and gets registered with input core. The input_handler in probe is allocated as device managed memory. If a probe failure occurs after input_register_handler() the input_handler memory is freed, yet it will remain in the input_handler_list. This effectively means the input_handler_list contains a dangling pointer to data belonging to a freed input handler. This causes an issue when any other input device is plugged in - in my case I had an old PixArt HP USB optical mouse and I decided to plug it in after a failure occurred after input_register_handler(). This lead to the registration of this input device via input_register_device which involves traversing over every handler in the corrupted input_handler_list and calling input_attach_handler(), giving each handler a chance to bind to newly registered device. The core of this bug is a UAF which causes memory corruption of input_handler_list and to fix it we must ensure the input handler is unregistered from input core, this is done through input_unregister_handler(). [ 63.191597] ================================================================== [ 63.192094] BUG: KASAN: slab-use-after-free in input_attach_handler.isra.0+0x1a9/0x1e0 [ 63.192094] Read of size 8 at addr ffff888105ea7c80 by task kworker/0:2/54 [ 63.192094] [ 63.192094] CPU: 0 UID: 0 PID: 54 Comm: kworker/0:2 Not tainted 6.16.0-rc2-00321-g2aa6621d [ 63.192094] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.164 [ 63.192094] Workqueue: usb_hub_wq hub_event [ 63.192094] Call Trace: [ 63.192094] <TASK> [ 63.192094] dump_stack_lvl+0x53/0x70 [ 63.192094] print_report+0xce/0x670 [ 63.192094] kasan_report+0xce/0x100 [ 63.192094] input_attach_handler.isra.0+0x1a9/0x1e0 [ 63.192094] input_register_device+0x76c/0xd00 [ 63.192094] hidinput_connect+0x686d/0xad60 [ 63.192094] hid_connect+0xf20/0x1b10 [ 63.192094] hid_hw_start+0x83/0x100 [ 63.192094] hid_device_probe+0x2d1/0x680 [ 63.192094] really_probe+0x1c3/0x690 [ 63.192094] __driver_probe_device+0x247/0x300 [ 63.192094] driver_probe_device+0x49/0x210 [ 63.192094] __device_attach_driver+0x160/0x320 [ 63.192094] bus_for_each_drv+0x10f/0x190 [ 63.192094] __device_attach+0x18e/0x370 [ 63.192094] bus_probe_device+0x123/0x170 [ 63.192094] device_add+0xd4d/0x1460 [ 63.192094] hid_add_device+0x30b/0x910 [ 63.192094] usbhid_probe+0x920/0xe00 [ 63.192094] usb_probe_interface+0x363/0x9a0 [ 63.192094] really_probe+0x1c3/0x690 [ 63.192094] __driver_probe_device+0x247/0x300 [ 63.192094] driver_probe_device+0x49/0x210 [ 63.192094] __device_attach_driver+0x160/0x320 [ 63.192094] bus_for_each_drv+0x10f/0x190 [ 63.192094] __device_attach+0x18e/0x370 [ 63.192094] bus_probe_device+0x123/0x170 [ 63.192094] device_add+0xd4d/0x1460 [ 63.192094] usb_set_configuration+0xd14/0x1880 [ 63.192094] usb_generic_driver_probe+0x78/0xb0 [ 63.192094] usb_probe_device+0xaa/0x2e0 [ 63.192094] really_probe+0x1c3/0x690 [ 63.192094] __driver_probe_device+0x247/0x300 [ 63.192094] driver_probe_device+0x49/0x210 [ 63.192094] __device_attach_driver+0x160/0x320 [ 63.192094] bus_for_each_drv+0x10f/0x190 [ 63.192094] __device_attach+0x18e/0x370 [ 63.192094] bus_probe_device+0x123/0x170 [ 63.192094] device_add+0xd4d/0x1460 [ 63.192094] usb_new_device+0x7b4/0x1000 [ 63.192094] hub_event+0x234d/0x3 ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/6ad40b07e15c29712d9a4b8096914ccd82e3fc17"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c80f2b047d5cc42fbd2dff9d1942d4ba7545100f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38395,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:28.950,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: regulator: gpio: Fix the out-of-bounds access to drvdata::gpiods drvdata::gpiods is supposed to hold an array of 'gpio_desc' pointers. But the memory is allocated for only one pointer. This will lead to out-of-bounds access later in the code if 'config::ngpios' is > 1. So fix the code to allocate enough memory to hold 'config::ngpios' of GPIO descriptors. While at it, also move the check for memory allocation failure to be below the allocation to make it more readable.",,"[{""url"":""https://git.kernel.org/stable/c/24418bc77a66cb5be9f5a837431ba3674ed8b52f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3830ab97cda9599872625cc0dc7b00160193634f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/56738cbac3bbb1d39a71a07f57484dec1db8b239"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9fe71972869faed1f8f9b3beb9040f9c1b300c79"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a1e12fac214d4f49fcb186dbdf9c5592e7fa0a7a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a3cd5ae7befbac849e0e0529c94ca04e8093cfd2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c9764fd88bc744592b0604ccb6b6fc1a5f76b4e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e4d19e5d71b217940e33f2ef6c6962b7b68c5606"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38396,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:29.077,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fs: export anon_inode_make_secure_inode() and fix secretmem LSM bypass Export anon_inode_make_secure_inode() to allow KVM guest_memfd to create anonymous inodes with proper security context. This replaces the current pattern of calling alloc_anon_inode() followed by inode_init_security_anon() for creating security context manually. This change also fixes a security regression in secretmem where the S_PRIVATE flag was not cleared after alloc_anon_inode(), causing LSM/SELinux checks to be bypassed for secretmem file descriptors. As guest_memfd currently resides in the KVM module, we need to export this symbol for use outside the core kernel. In the future, guest_memfd might be moved to core-mm, at which point the symbols no longer would have to be exported. When/if that happens is still unclear.",,"[{""url"":""https://git.kernel.org/stable/c/66d29d757c968d2bee9124816da5d718eb352959"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6ca45ea48530332a4ba09595767bd26d3232743b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cbe4134ea4bc493239786220bd69cb8a13493190"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3eed01347721cd7a8819568161c91d538fbf229"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f94c422157f3e43dd31990567b3e5d54b3e5b32b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38397,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:29.193,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nvme-multipath: fix suspicious RCU usage warning When I run the NVME over TCP test in virtme-ng, I get the following ""suspicious RCU usage"" warning in nvme_mpath_add_sysfs_link(): ''' [ 5.024557][ T44] nvmet: Created nvm controller 1 for subsystem nqn.2025-06.org.nvmexpress.mptcp for NQN nqn.2014-08.org.nvmexpress:uuid:f7f6b5e0-ff97-4894-98ac-c85309e0bc77. [ 5.027401][ T183] nvme nvme0: creating 2 I/O queues. [ 5.029017][ T183] nvme nvme0: mapped 2/0/0 default/read/poll queues. [ 5.032587][ T183] nvme nvme0: new ctrl: NQN ""nqn.2025-06.org.nvmexpress.mptcp"", addr 127.0.0.1:4420, hostnqn: nqn.2014-08.org.nvmexpress:uuid:f7f6b5e0-ff97-4894-98ac-c85309e0bc77 [ 5.042214][ T25] [ 5.042440][ T25] ============================= [ 5.042579][ T25] WARNING: suspicious RCU usage [ 5.042705][ T25] 6.16.0-rc3+ #23 Not tainted [ 5.042812][ T25] ----------------------------- [ 5.042934][ T25] drivers/nvme/host/multipath.c:1203 RCU-list traversed in non-reader section!! [ 5.043111][ T25] [ 5.043111][ T25] other info that might help us debug this: [ 5.043111][ T25] [ 5.043341][ T25] [ 5.043341][ T25] rcu_scheduler_active = 2, debug_locks = 1 [ 5.043502][ T25] 3 locks held by kworker/u9:0/25: [ 5.043615][ T25] #0: ffff888008730948 ((wq_completion)async){+.+.}-{0:0}, at: process_one_work+0x7ed/0x1350 [ 5.043830][ T25] #1: ffffc900001afd40 ((work_completion)(&entry->work)){+.+.}-{0:0}, at: process_one_work+0xcf3/0x1350 [ 5.044084][ T25] #2: ffff888013ee0020 (&head->srcu){.+.+}-{0:0}, at: nvme_mpath_add_sysfs_link.part.0+0xb4/0x3a0 [ 5.044300][ T25] [ 5.044300][ T25] stack backtrace: [ 5.044439][ T25] CPU: 0 UID: 0 PID: 25 Comm: kworker/u9:0 Not tainted 6.16.0-rc3+ #23 PREEMPT(full) [ 5.044441][ T25] Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011 [ 5.044442][ T25] Workqueue: async async_run_entry_fn [ 5.044445][ T25] Call Trace: [ 5.044446][ T25] <TASK> [ 5.044449][ T25] dump_stack_lvl+0x6f/0xb0 [ 5.044453][ T25] lockdep_rcu_suspicious.cold+0x4f/0xb1 [ 5.044457][ T25] nvme_mpath_add_sysfs_link.part.0+0x2fb/0x3a0 [ 5.044459][ T25] ? queue_work_on+0x90/0xf0 [ 5.044461][ T25] ? lockdep_hardirqs_on+0x78/0x110 [ 5.044466][ T25] nvme_mpath_set_live+0x1e9/0x4f0 [ 5.044470][ T25] nvme_mpath_add_disk+0x240/0x2f0 [ 5.044472][ T25] ? __pfx_nvme_mpath_add_disk+0x10/0x10 [ 5.044475][ T25] ? add_disk_fwnode+0x361/0x580 [ 5.044480][ T25] nvme_alloc_ns+0x81c/0x17c0 [ 5.044483][ T25] ? kasan_quarantine_put+0x104/0x240 [ 5.044487][ T25] ? __pfx_nvme_alloc_ns+0x10/0x10 [ 5.044495][ T25] ? __pfx_nvme_find_get_ns+0x10/0x10 [ 5.044496][ T25] ? rcu_read_lock_any_held+0x45/0xa0 [ 5.044498][ T25] ? validate_chain+0x232/0x4f0 [ 5.044503][ T25] nvme_scan_ns+0x4c8/0x810 [ 5.044506][ T25] ? __pfx_nvme_scan_ns+0x10/0x10 [ 5.044508][ T25] ? find_held_lock+0x2b/0x80 [ 5.044512][ T25] ? ktime_get+0x16d/0x220 [ 5.044517][ T25] ? kvm_clock_get_cycles+0x18/0x30 [ 5.044520][ T25] ? __pfx_nvme_scan_ns_async+0x10/0x10 [ 5.044522][ T25] async_run_entry_fn+0x97/0x560 [ 5.044523][ T25] ? rcu_is_watching+0x12/0xc0 [ 5.044526][ T25] process_one_work+0xd3c/0x1350 [ 5.044532][ T25] ? __pfx_process_one_work+0x10/0x10 [ 5.044536][ T25] ? assign_work+0x16c/0x240 [ 5.044539][ T25] worker_thread+0x4da/0xd50 [ 5.044545][ T25] ? __pfx_worker_thread+0x10/0x10 [ 5.044546][ T25] kthread+0x356/0x5c0 [ 5.044548][ T25] ? __pfx_kthread+0x10/0x10 [ 5.044549][ T25] ? ret_from_fork+0x1b/0x2e0 [ 5.044552][ T25] ? __lock_release.isra.0+0x5d/0x180 [ 5.044553][ T25] ? ret_from_fork+0x1b/0x2e0 [ 5.044555][ T25] ? rcu_is_watching+0x12/0xc0 [ 5.044557][ T25] ? __pfx_kthread+0x10/0x10 [ 5.04 ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/a432383e6cd86d9fda00a6073ed35c1067a836d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d6811074203b13f715ce2480ac64c5b1c773f2a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38398,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:29.303,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: spi: spi-qpic-snand: reallocate BAM transactions Using the mtd_nandbiterrs module for testing the driver occasionally results in weird things like below. 1. swiotlb mapping fails with the following message: [ 85.926216] qcom_snand 79b0000.spi: swiotlb buffer is full (sz: 4294967294 bytes), total 512 (slots), used 0 (slots) [ 85.932937] qcom_snand 79b0000.spi: failure in mapping desc [ 87.999314] qcom_snand 79b0000.spi: failure to write raw page [ 87.999352] mtd_nandbiterrs: error: write_oob failed (-110) Rebooting the board after this causes a panic due to a NULL pointer dereference. 2. If the swiotlb mapping does not fail, rebooting the board may result in a different panic due to a bad spinlock magic: [ 256.104459] BUG: spinlock bad magic on CPU#3, procd/2241 [ 256.104488] Unable to handle kernel paging request at virtual address ffffffff0000049b ... Investigating the issue revealed that these symptoms are results of memory corruption which is caused by out of bounds access within the driver. The driver uses a dynamically allocated structure for BAM transactions, which structure must have enough space for all possible variations of different flash operations initiated by the driver. The required space heavily depends on the actual number of 'codewords' which is calculated from the pagesize of the actual NAND chip. Although the qcom_nandc_alloc() function allocates memory for the BAM transactions during probe, but since the actual number of 'codewords' is not yet know the allocation is done for one 'codeword' only. Because of this, whenever the driver does a flash operation, and the number of the required transactions exceeds the size of the allocated arrays the driver accesses memory out of the allocated range. To avoid this, change the code to free the initially allocated BAM transactions memory, and allocate a new one once the actual number of 'codewords' required for a given NAND chip is known.",,"[{""url"":""https://git.kernel.org/stable/c/86fb36de1132b560f9305f0c78fa69f459fa0980"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d85d0380292a7e618915069c3579ae23c7c80339"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38399,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:29.417,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: target: Fix NULL pointer dereference in core_scsi3_decode_spec_i_port() The function core_scsi3_decode_spec_i_port(), in its error code path, unconditionally calls core_scsi3_lunacl_undepend_item() passing the dest_se_deve pointer, which may be NULL. This can lead to a NULL pointer dereference if dest_se_deve remains unset. SPC-3 PR SPEC_I_PT: Unable to locate dest_tpg Unable to handle kernel paging request at virtual address dfff800000000012 Call trace: core_scsi3_lunacl_undepend_item+0x2c/0xf0 [target_core_mod] (P) core_scsi3_decode_spec_i_port+0x120c/0x1c30 [target_core_mod] core_scsi3_emulate_pro_register+0x6b8/0xcd8 [target_core_mod] target_scsi3_emulate_pr_out+0x56c/0x840 [target_core_mod] Fix this by adding a NULL check before calling core_scsi3_lunacl_undepend_item()",,"[{""url"":""https://git.kernel.org/stable/c/1129e0e0a833acf90429e0f13951068d5f026e4f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1627dda4d70ceb1ba62af2e401af73c09abb1eb5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/55dfffc5e94730370b08de02c0cf3b7c951bbe9e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/70ddb8133fdb512d4b1f2b4fd1c9e518514f182c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7296c938df2445f342be456a6ff0b3931d97f4e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c412185d557578d3f936537ed639c4ffaaed4075"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d8ab68bdb294b09a761e967dad374f2965e1913f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38400,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:29.533,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nfs: Clean up /proc/net/rpc/nfs when nfs_fs_proc_net_init() fails. syzbot reported a warning below [1] following a fault injection in nfs_fs_proc_net_init(). [0] When nfs_fs_proc_net_init() fails, /proc/net/rpc/nfs is not removed. Later, rpc_proc_exit() tries to remove /proc/net/rpc, and the warning is logged as the directory is not empty. Let's handle the error of nfs_fs_proc_net_init() properly. [0]: FAULT_INJECTION: forcing a failure. name failslab, interval 1, probability 0, space 0, times 0 CPU: 1 UID: 0 PID: 6120 Comm: syz.2.27 Not tainted 6.16.0-rc1-syzkaller-00010-g2c4a1f3fe03e #0 PREEMPT(full) Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025 Call Trace: <TASK> dump_stack_lvl (lib/dump_stack.c:123) should_fail_ex (lib/fault-inject.c:73 lib/fault-inject.c:174) should_failslab (mm/failslab.c:46) kmem_cache_alloc_noprof (mm/slub.c:4178 mm/slub.c:4204) __proc_create (fs/proc/generic.c:427) proc_create_reg (fs/proc/generic.c:554) proc_create_net_data (fs/proc/proc_net.c:120) nfs_fs_proc_net_init (fs/nfs/client.c:1409) nfs_net_init (fs/nfs/inode.c:2600) ops_init (net/core/net_namespace.c:138) setup_net (net/core/net_namespace.c:443) copy_net_ns (net/core/net_namespace.c:576) create_new_namespaces (kernel/nsproxy.c:110) unshare_nsproxy_namespaces (kernel/nsproxy.c:218 (discriminator 4)) ksys_unshare (kernel/fork.c:3123) __x64_sys_unshare (kernel/fork.c:3190) do_syscall_64 (arch/x86/entry/syscall_64.c:63 arch/x86/entry/syscall_64.c:94) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130) </TASK> [1]: remove_proc_entry: removing non-empty directory 'net/rpc', leaking at least 'nfs' WARNING: CPU: 1 PID: 6120 at fs/proc/generic.c:727 remove_proc_entry+0x45e/0x530 fs/proc/generic.c:727 Modules linked in: CPU: 1 UID: 0 PID: 6120 Comm: syz.2.27 Not tainted 6.16.0-rc1-syzkaller-00010-g2c4a1f3fe03e #0 PREEMPT(full) Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025 RIP: 0010:remove_proc_entry+0x45e/0x530 fs/proc/generic.c:727 Code: 3c 02 00 0f 85 85 00 00 00 48 8b 93 d8 00 00 00 4d 89 f0 4c 89 e9 48 c7 c6 40 ba a2 8b 48 c7 c7 60 b9 a2 8b e8 33 81 1d ff 90 <0f> 0b 90 90 e9 5f fe ff ff e8 04 69 5e ff 90 48 b8 00 00 00 00 00 RSP: 0018:ffffc90003637b08 EFLAGS: 00010282 RAX: 0000000000000000 RBX: ffff88805f534140 RCX: ffffffff817a92c8 RDX: ffff88807da99e00 RSI: ffffffff817a92d5 RDI: 0000000000000001 RBP: ffff888033431ac0 R08: 0000000000000001 R09: 0000000000000000 R10: 0000000000000001 R11: 0000000000000001 R12: ffff888033431a00 R13: ffff888033431ae4 R14: ffff888033184724 R15: dffffc0000000000 FS: 0000555580328500(0000) GS:ffff888124a62000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f71733743e0 CR3: 000000007f618000 CR4: 00000000003526f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> sunrpc_exit_net+0x46/0x90 net/sunrpc/sunrpc_syms.c:76 ops_exit_list net/core/net_namespace.c:200 [inline] ops_undo_list+0x2eb/0xab0 net/core/net_namespace.c:253 setup_net+0x2e1/0x510 net/core/net_namespace.c:457 copy_net_ns+0x2a6/0x5f0 net/core/net_namespace.c:574 create_new_namespaces+0x3ea/0xa90 kernel/nsproxy.c:110 unshare_nsproxy_namespaces+0xc0/0x1f0 kernel/nsproxy.c:218 ksys_unshare+0x45b/0xa40 kernel/fork.c:3121 __do_sys_unshare kernel/fork.c:3192 [inline] __se_sys_unshare kernel/fork.c:3190 [inline] __x64_sys_unshare+0x31/0x40 kernel/fork.c:3190 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xcd/0x490 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7fa1a6b8e929 Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/3c94212b57bedec3a386ef3da1ef00602f5c3d1d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/412534a1fb76958b88dca48360c6f3ad4f3390f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6acf340f8c1d296bcf535986175f5d0d6f2aab09"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7701c245ff1ac1a126bf431e72b24547519046ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8785701fd7cd52ae74c0d2b35b82568df74e9dbb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b92397ce96743e4cc090207e2df2a856cb4cef08"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d0877c479f44fe475f4c8c02c88ce9ad43e90298"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e8d6f3ab59468e230f3253efe5cb63efa35289f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38401,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:29.660,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mtk-sd: Prevent memory corruption from DMA map failure If msdc_prepare_data() fails to map the DMA region, the request is not prepared for data receiving, but msdc_start_data() proceeds the DMA with previous setting. Since this will lead a memory corruption, we have to stop the request operation soon after the msdc_prepare_data() fails to prepare it.",,"[{""url"":""https://git.kernel.org/stable/c/3419bc6a7b65cbbb91417bb9970208478e034c79"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/48bf4f3dfcdab02b22581d8e350a2d23130b72c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5ac9e9e2e9cd6247d8c2d99780eae4556049e1cc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/61cdd663564674ea21ceb50aa9d3697cbe9e45f9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/63e8953f16acdcb23e2d4dd8a566d3c34df3e200"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a5f5f67b284d81776d4a3eb1f8607e4b7f91f11c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d54771571f74a82c59830a32e76af78a8e57ac69"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f5de469990f19569627ea0dd56536ff5a13beaa3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38402,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T13:15:29.780,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: idpf: return 0 size for RSS key if not supported Returning -EOPNOTSUPP from function returning u32 is leading to cast and invalid size value as a result. -EOPNOTSUPP as a size probably will lead to allocation fail. Command: ethtool -x eth0 It is visible on all devices that don't have RSS caps set. [ 136.615917] Call Trace: [ 136.615921] <TASK> [ 136.615927] ? __warn+0x89/0x130 [ 136.615942] ? __alloc_frozen_pages_noprof+0x322/0x330 [ 136.615953] ? report_bug+0x164/0x190 [ 136.615968] ? handle_bug+0x58/0x90 [ 136.615979] ? exc_invalid_op+0x17/0x70 [ 136.615987] ? asm_exc_invalid_op+0x1a/0x20 [ 136.616001] ? rss_prepare_get.constprop.0+0xb9/0x170 [ 136.616016] ? __alloc_frozen_pages_noprof+0x322/0x330 [ 136.616028] __alloc_pages_noprof+0xe/0x20 [ 136.616038] ___kmalloc_large_node+0x80/0x110 [ 136.616072] __kmalloc_large_node_noprof+0x1d/0xa0 [ 136.616081] __kmalloc_noprof+0x32c/0x4c0 [ 136.616098] ? rss_prepare_get.constprop.0+0xb9/0x170 [ 136.616105] rss_prepare_get.constprop.0+0xb9/0x170 [ 136.616114] ethnl_default_doit+0x107/0x3d0 [ 136.616131] genl_family_rcv_msg_doit+0x100/0x160 [ 136.616147] genl_rcv_msg+0x1b8/0x2c0 [ 136.616156] ? __pfx_ethnl_default_doit+0x10/0x10 [ 136.616168] ? __pfx_genl_rcv_msg+0x10/0x10 [ 136.616176] netlink_rcv_skb+0x58/0x110 [ 136.616186] genl_rcv+0x28/0x40 [ 136.616195] netlink_unicast+0x19b/0x290 [ 136.616206] netlink_sendmsg+0x222/0x490 [ 136.616215] __sys_sendto+0x1fd/0x210 [ 136.616233] __x64_sys_sendto+0x24/0x30 [ 136.616242] do_syscall_64+0x82/0x160 [ 136.616252] ? __sys_recvmsg+0x83/0xe0 [ 136.616265] ? syscall_exit_to_user_mode+0x10/0x210 [ 136.616275] ? do_syscall_64+0x8e/0x160 [ 136.616282] ? __count_memcg_events+0xa1/0x130 [ 136.616295] ? count_memcg_events.constprop.0+0x1a/0x30 [ 136.616306] ? handle_mm_fault+0xae/0x2d0 [ 136.616319] ? do_user_addr_fault+0x379/0x670 [ 136.616328] ? clear_bhb_loop+0x45/0xa0 [ 136.616340] ? clear_bhb_loop+0x45/0xa0 [ 136.616349] ? clear_bhb_loop+0x45/0xa0 [ 136.616359] entry_SYSCALL_64_after_hwframe+0x76/0x7e [ 136.616369] RIP: 0033:0x7fd30ba7b047 [ 136.616376] Code: 0c 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b8 0f 1f 00 f3 0f 1e fa 80 3d bd d5 0c 00 00 41 89 ca 74 10 b8 2c 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 71 c3 55 48 83 ec 30 44 89 4c 24 2c 4c 89 44 [ 136.616381] RSP: 002b:00007ffde1796d68 EFLAGS: 00000202 ORIG_RAX: 000000000000002c [ 136.616388] RAX: ffffffffffffffda RBX: 000055d7bd89f2a0 RCX: 00007fd30ba7b047 [ 136.616392] RDX: 0000000000000028 RSI: 000055d7bd89f3b0 RDI: 0000000000000003 [ 136.616396] RBP: 00007ffde1796e10 R08: 00007fd30bb4e200 R09: 000000000000000c [ 136.616399] R10: 0000000000000000 R11: 0000000000000202 R12: 000055d7bd89f340 [ 136.616403] R13: 000055d7bd89f3b0 R14: 000055d78943f200 R15: 0000000000000000",,"[{""url"":""https://git.kernel.org/stable/c/018ff57fd79c38be989b8b3248bbe69bcfb77160"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/326e384ee7acbebf0541ac064ac7a4dd1f1dde1d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f77bf1ebf8ff6301ccdbc346f7b52db928f9cbf8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38403,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T14:15:31.803,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: vsock/vmci: Clear the vmci transport packet properly when initializing it In vmci_transport_packet_init memset the vmci_transport_packet before populating the fields to avoid any uninitialised data being left in the structure.",,"[{""url"":""https://git.kernel.org/stable/c/0a01021317375b8d1895152f544421ce49299eb1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/19c2cc01ff9a8031398a802676ffb0f4692dd95d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1c1bcb0e78230f533b4103e8cf271d17c3f469f0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/223e2288f4b8c262a864e2c03964ffac91744cd5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2d44723a091bc853272e1a51a488a3d22b80be5e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/75705b44e0b9aaa74f4c163d93d388bcba9e386a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/94d0c326cb3ee6b0f8bd00e209550b93fcc5c839"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e9a673153d578fd439919a24e99851b2f87ecbce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38404,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T14:15:31.950,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: typec: displayport: Fix potential deadlock The deadlock can occur due to a recursive lock acquisition of `cros_typec_altmode_data::mutex`. The call chain is as follows: 1. cros_typec_altmode_work() acquires the mutex 2. typec_altmode_vdm() -> dp_altmode_vdm() -> 3. typec_altmode_exit() -> cros_typec_altmode_exit() 4. cros_typec_altmode_exit() attempts to acquire the mutex again To prevent this, defer the `typec_altmode_exit()` call by scheduling it rather than calling it directly from within the mutex-protected context.",,"[{""url"":""https://git.kernel.org/stable/c/099cf1fbb8afc3771f408109f62bdec66f85160e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/63cff9f57e86b2dc25d7487ca0118df89a665296"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/749d9076735fb497aae60fbea9fff563f9ea3254"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/76cf1f33e7319fe74c94ac92f9814094ee8cc84b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7be0d1ea71f52595499da39cea484a895e8ed042"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/80c25d7916a44715338d4f8924c8e52af50d0b9f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c782f98eef14197affa8a7b91e6981420f109ea9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb08fca56f1f39e4038cb9bac9864464b13b00aa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38405,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T14:15:32.077,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nvmet: fix memory leak of bio integrity If nvmet receives commands with metadata there is a continuous memory leak of kmalloc-128 slab or more precisely bio->bi_integrity. Since commit bf4c89fc8797 (""block: don't call bio_uninit from bio_endio"") each user of bio_init has to use bio_uninit as well. Otherwise the bio integrity is not getting free. Nvmet uses bio_init for inline bios. Uninit the inline bio to complete deallocation of integrity in bio.",,"[{""url"":""https://git.kernel.org/stable/c/190f4c2c863af7cc5bb354b70e0805f06419c038"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2e2028fcf924d1c6df017033c8d6e28b735a0508"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/431e58d56fcb5ff1f9eb630724a922e0d2a941df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38406,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T14:15:32.180,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath6kl: remove WARN on bad firmware input If the firmware gives bad input, that's nothing to do with the driver's stack at this point etc., so the WARN_ON() doesn't add any value. Additionally, this is one of the top syzbot reports now. Just print a message, and as an added bonus, print the sizes too.",,"[{""url"":""https://git.kernel.org/stable/c/27d07deea35ae67f2e75913242e25bdb7e1114e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/327997afbb5e62532c28c1861ab5534c01969c9a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/347827bd0c5680dac2dd59674616840c4d5154f1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/46b47d4b06fa7f234d93f0f8ac43798feafcff89"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7a2afdc5af3b82b601f6a2f0d1c90d5f0bc27aeb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/89bd133529a4d2d68287128b357e49adc00ec690"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e6c49f0b203a987c306676d241066451b74db1a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e7417421d89358da071fd2930f91e67c7128fbff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38407,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T14:15:32.317,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: riscv: cpu_ops_sbi: Use static array for boot_data Since commit 6b9f29b81b15 (""riscv: Enable pcpu page first chunk allocator""), if NUMA is enabled, the page percpu allocator may be used on very sparse configurations, or when requested on boot with percpu_alloc=page. In that case, percpu data gets put in the vmalloc area. However, sbi_hsm_hart_start() needs the physical address of a sbi_hart_boot_data, and simply assumes that __pa() would work. This causes the just started hart to immediately access an invalid address and hang. Fortunately, struct sbi_hart_boot_data is not too large, so we can simply allocate an array for boot_data statically, putting it in the kernel image. This fixes NUMA=y SMP boot on Sophgo SG2042. To reproduce on QEMU: Set CONFIG_NUMA=y and CONFIG_DEBUG_VIRTUAL=y, then run with: qemu-system-riscv64 -M virt -smp 2 -nographic \ -kernel arch/riscv/boot/Image \ -append ""percpu_alloc=page"" Kernel output: [ 0.000000] Booting Linux on hartid 0 [ 0.000000] Linux version 6.16.0-rc1 (dram@sakuya) (riscv64-unknown-linux-gnu-gcc (GCC) 14.2.1 20250322, GNU ld (GNU Binutils) 2.44) #11 SMP Tue Jun 24 14:56:22 CST 2025 ... [ 0.000000] percpu: 28 4K pages/cpu s85784 r8192 d20712 ... [ 0.083192] smp: Bringing up secondary CPUs ... [ 0.086722] ------------[ cut here ]------------ [ 0.086849] virt_to_phys used for non-linear address: (____ptrval____) (0xff2000000001d080) [ 0.088001] WARNING: CPU: 0 PID: 1 at arch/riscv/mm/physaddr.c:14 __virt_to_phys+0xae/0xe8 [ 0.088376] Modules linked in: [ 0.088656] CPU: 0 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.16.0-rc1 #11 NONE [ 0.088833] Hardware name: riscv-virtio,qemu (DT) [ 0.088948] epc : __virt_to_phys+0xae/0xe8 [ 0.089001] ra : __virt_to_phys+0xae/0xe8 [ 0.089037] epc : ffffffff80021eaa ra : ffffffff80021eaa sp : ff2000000004bbc0 [ 0.089057] gp : ffffffff817f49c0 tp : ff60000001d60000 t0 : 5f6f745f74726976 [ 0.089076] t1 : 0000000000000076 t2 : 705f6f745f747269 s0 : ff2000000004bbe0 [ 0.089095] s1 : ff2000000001d080 a0 : 0000000000000000 a1 : 0000000000000000 [ 0.089113] a2 : 0000000000000000 a3 : 0000000000000000 a4 : 0000000000000000 [ 0.089131] a5 : 0000000000000000 a6 : 0000000000000000 a7 : 0000000000000000 [ 0.089155] s2 : ffffffff8130dc00 s3 : 0000000000000001 s4 : 0000000000000001 [ 0.089174] s5 : ffffffff8185eff8 s6 : ff2000007f1eb000 s7 : ffffffff8002a2ec [ 0.089193] s8 : 0000000000000001 s9 : 0000000000000001 s10: 0000000000000000 [ 0.089211] s11: 0000000000000000 t3 : ffffffff8180a9f7 t4 : ffffffff8180a9f7 [ 0.089960] t5 : ffffffff8180a9f8 t6 : ff2000000004b9d8 [ 0.089984] status: 0000000200000120 badaddr: ffffffff80021eaa cause: 0000000000000003 [ 0.090101] [<ffffffff80021eaa>] __virt_to_phys+0xae/0xe8 [ 0.090228] [<ffffffff8001d796>] sbi_cpu_start+0x6e/0xe8 [ 0.090247] [<ffffffff8001a5da>] __cpu_up+0x1e/0x8c [ 0.090260] [<ffffffff8002a32e>] bringup_cpu+0x42/0x258 [ 0.090277] [<ffffffff8002914c>] cpuhp_invoke_callback+0xe0/0x40c [ 0.090292] [<ffffffff800294e0>] __cpuhp_invoke_callback_range+0x68/0xfc [ 0.090320] [<ffffffff8002a96a>] _cpu_up+0x11a/0x244 [ 0.090334] [<ffffffff8002aae6>] cpu_up+0x52/0x90 [ 0.090384] [<ffffffff80c09350>] bringup_nonboot_cpus+0x78/0x118 [ 0.090411] [<ffffffff80c11060>] smp_init+0x34/0xb8 [ 0.090425] [<ffffffff80c01220>] kernel_init_freeable+0x148/0x2e4 [ 0.090442] [<ffffffff80b83802>] kernel_init+0x1e/0x14c [ 0.090455] [<ffffffff800124ca>] ret_from_fork_kernel+0xe/0xf0 [ 0.090471] [<ffffffff80b8d9c2>] ret_from_fork_kernel_asm+0x16/0x18 [ 0.090560] ---[ end trace 0000000000000000 ]--- [ 1.179875] CPU1: failed to come online [ 1.190324] smp: Brought up 1 node, 1 CPU",,"[{""url"":""https://git.kernel.org/stable/c/02c725cd55eb5052b88eeaa3f60a391ef4dcaec5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2b29be967ae456fc09c320d91d52278cf721be1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f5fe094f35a37adea40b2fd52c99bb1333be9b07"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38408,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T14:15:32.440,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: genirq/irq_sim: Initialize work context pointers properly Initialize `ops` member's pointers properly by using kzalloc() instead of kmalloc() when allocating the simulation work context. Otherwise the pointers contain random content leading to invalid dereferencing.",,"[{""url"":""https://git.kernel.org/stable/c/19bd7597858dd15802c1d99fcc38e528f469080a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f73d1def72532bac4d55ea8838f457a6bed955c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8a2277a3c9e4cc5398f80821afe7ecbe9bdf2819"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38409,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T14:15:32.553,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/msm: Fix another leak in the submit error path put_unused_fd() doesn't free the installed file, if we've already done fd_install(). So we need to also free the sync_file. Patchwork: https://patchwork.freedesktop.org/patch/653583/",,"[{""url"":""https://git.kernel.org/stable/c/00b3401f692082ddf6342500d1be25560bba46d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/30d3819b0b9173e31b84d662a592af8bad351427"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f6ce8433a9035b0aa810e1f5b708e9dc1c367b0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c40ad1c04d306f7fde26337fdcf8a5979657d93f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f681c2aa8676a890eacc84044717ab0fd26e058f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38410,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T14:15:32.667,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/msm: Fix a fence leak in submit error path In error paths, we could unref the submit without calling drm_sched_entity_push_job(), so msm_job_free() will never get called. Since drm_sched_job_cleanup() will NULL out the s_fence, we can use that to detect this case. Patchwork: https://patchwork.freedesktop.org/patch/653584/",,"[{""url"":""https://git.kernel.org/stable/c/0dc817f852e5f8ec8501d19ef7dcc01affa181d0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0eaa495b3d5710e5ba72051d2e01bb28292c625c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/201eba5c9652a900c0b248070263f9acd3735689"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5d319f75ccf7f0927425a7545aa1a22b3eedc189"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5deab0fa6cfd0cd7def17598db15ceb84f950584"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe2695b2f63bd77e0e03bc0fc779164115bb4699"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38411,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T14:15:32.790,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfs: Fix double put of request If a netfs request finishes during the pause loop, it will have the ref that belongs to the IN_PROGRESS flag removed at that point - however, if it then goes to the final wait loop, that will *also* put the ref because it sees that the IN_PROGRESS flag is clear and incorrectly assumes that this happened when it called the collector. In fact, since IN_PROGRESS is clear, we shouldn't call the collector again since it's done all the cleanup, such as calling ->ki_complete(). Fix this by making netfs_collect_in_app() just return, indicating that we're done if IN_PROGRESS is removed.",,"[{""url"":""https://git.kernel.org/stable/c/9df7b5ebead649b00bf9a53a798e4bf83a1318fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d18facba5a5795ad44b2a00a052e3db2fa77ab12"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38412,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T14:15:32.903,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: platform/x86: dell-wmi-sysman: Fix WMI data block retrieval in sysfs callbacks After retrieving WMI data blocks in sysfs callbacks, check for the validity of them before dereferencing their content.",,"[{""url"":""https://git.kernel.org/stable/c/0deb3eb78ebf225cb41aa9b2b2150f46cbfd359e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5df3b870bc389a1767c72448a3ce1c576ef4deab"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/68e9963583d11963ceca5d276e9c44684509f759"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/92c2d914b5337431d885597a79a3a3d9d55e80b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aaf847dcb4114fe8b25d4c1c790bedcb6088cb3d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb617dd25ca176f3fee24f873f0fd60010773d67"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38413,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T14:15:33.017,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: virtio-net: xsk: rx: fix the frame's length check When calling buf_to_xdp, the len argument is the frame data's length without virtio header's length (vi->hdr_len). We check that len with xsk_pool_get_rx_frame_size() + vi->hdr_len to ensure the provided len does not larger than the allocated chunk size. The additional vi->hdr_len is because in virtnet_add_recvbuf_xsk, we use part of XDP_PACKET_HEADROOM for virtio header and ask the vhost to start placing data from hard_start + XDP_PACKET_HEADROOM - vi->hdr_len not hard_start + XDP_PACKET_HEADROOM But the first buffer has virtio_header, so the maximum frame's length in the first buffer can only be xsk_pool_get_rx_frame_size() not xsk_pool_get_rx_frame_size() + vi->hdr_len like in the current check. This commit adds an additional argument to buf_to_xdp differentiate between the first buffer and other ones to correctly calculate the maximum frame's length.",,"[{""url"":""https://git.kernel.org/stable/c/5177373c31318c3c6a190383bfd232e6cf565c36"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6013bb6bc24c2cac3f45b37a15b71b232a5b00ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/892f6ed9a4a38bb3360fdff091b9241cfa105b61"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38414,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T14:15:33.140,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: fix GCC_GCC_PCIE_HOT_RST definition for WCN7850 GCC_GCC_PCIE_HOT_RST is wrongly defined for WCN7850, causing kernel crash on some specific platforms. Since this register is divergent for WCN7850 and QCN9274, move it to register table to allow different definitions. Then correct the register address for WCN7850 to fix this issue. Note IPQ5332 is not affected as it is not PCIe based device. Tested-on: WCN7850 hw2.0 PCI WLAN.HMT.1.0.c5-00481-QCAHMTSWPL_V1.0_V2.0_SILICONZ-3",,"[{""url"":""https://git.kernel.org/stable/c/569972c5bdb839b0eaf8aba6ce76ea0b78e2acf8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7588a893cde5385ad308400ff167d29a29913b3a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d71ac5694b33c80f1de97d074f6fbdc6c01a9d61"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38415,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T14:15:33.250,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Squashfs: check return result of sb_min_blocksize Syzkaller reports an ""UBSAN: shift-out-of-bounds in squashfs_bio_read"" bug. Syzkaller forks multiple processes which after mounting the Squashfs filesystem, issues an ioctl(""/dev/loop0"", LOOP_SET_BLOCK_SIZE, 0x8000). Now if this ioctl occurs at the same time another process is in the process of mounting a Squashfs filesystem on /dev/loop0, the failure occurs. When this happens the following code in squashfs_fill_super() fails. ---- msblk->devblksize = sb_min_blocksize(sb, SQUASHFS_DEVBLK_SIZE); msblk->devblksize_log2 = ffz(~msblk->devblksize); ---- sb_min_blocksize() returns 0, which means msblk->devblksize is set to 0. As a result, ffz(~msblk->devblksize) returns 64, and msblk->devblksize_log2 is set to 64. This subsequently causes the UBSAN: shift-out-of-bounds in fs/squashfs/block.c:195:36 shift exponent 64 is too large for 64-bit type 'u64' (aka 'unsigned long long') This commit adds a check for a 0 return by sb_min_blocksize().",,"[{""url"":""https://git.kernel.org/stable/c/0aff95d9bc7fb5400ca8af507429c4b067bdb425"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/295ab18c2dbce8d0ac6ecf7c5187e16e1ac8b282"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4f99357dadbf9c979ad737156ad4c37fadf7c56b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/549f9e3d7b60d53808c98b9fde49b4f46d0524a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5c51aa862cbeed2f3887f0382a2708956710bd68"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6abf6b78c6fb112eee495f5636ffcc350dd2ce25"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/734aa85390ea693bb7eaf2240623d41b03705c84"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/db7096ea160e40d78c67fce52e7cc51bde049497"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38416,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T14:15:33.373,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: NFC: nci: uart: Set tty->disc_data only in success path Setting tty->disc_data before opening the NCI device means we need to clean it up on error paths. This also opens some short window if device starts sending data, even before NCIUARTSETDRIVER IOCTL succeeded (broken hardware?). Close the window by exposing tty->disc_data only on the success path, when opening of the NCI device and try_module_get() succeeds. The code differs in error path in one aspect: tty->disc_data won't be ever assigned thus NULL-ified. This however should not be relevant difference, because of ""tty->disc_data=NULL"" in nci_uart_tty_open().",,"[{""url"":""https://git.kernel.org/stable/c/000bfbc6bc334a93fffca8f5aa9583e7b6356cb5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/55c3dbd8389636161090a2b2b6d2d709b9602e9c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a514fca2b8e95838a3ba600f31a18fa60b76d893"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a8acc7080ad55c5402a1b818b3008998247dda87"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac6992f72bd8e22679c1e147ac214de6a7093c23"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc7722619a9c307e9938d735cf4a2210d3d48dcb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e9799db771b2d574d5bf0dfb3177485e5f40d4d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc27ab48904ceb7e4792f0c400f1ef175edf16fe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38417,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T14:15:33.493,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ice: fix eswitch code memory leak in reset scenario Add simple eswitch mode checker in attaching VF procedure and allocate required port representor memory structures only in switchdev mode. The reset flows triggers VF (if present) detach/attach procedure. It might involve VF port representor(s) re-creation if the device is configured is switchdev mode (not legacy one). The memory was blindly allocated in current implementation, regardless of the mode and not freed if in legacy mode. Kmemeleak trace: unreferenced object (percpu) 0x7e3bce5b888458 (size 40): comm ""bash"", pid 1784, jiffies 4295743894 hex dump (first 32 bytes on cpu 45): 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ backtrace (crc 0): pcpu_alloc_noprof+0x4c4/0x7c0 ice_repr_create+0x66/0x130 [ice] ice_repr_create_vf+0x22/0x70 [ice] ice_eswitch_attach_vf+0x1b/0xa0 [ice] ice_reset_all_vfs+0x1dd/0x2f0 [ice] ice_pci_err_resume+0x3b/0xb0 [ice] pci_reset_function+0x8f/0x120 reset_store+0x56/0xa0 kernfs_fop_write_iter+0x120/0x1b0 vfs_write+0x31c/0x430 ksys_write+0x61/0xd0 do_syscall_64+0x5b/0x180 entry_SYSCALL_64_after_hwframe+0x76/0x7e Testing hints (ethX is PF netdev): - create at least one VF echo 1 > /sys/class/net/ethX/device/sriov_numvfs - trigger the reset echo 1 > /sys/class/net/ethX/device/reset",,"[{""url"":""https://git.kernel.org/stable/c/48c8b214974dc55283bd5f12e3a483b27c403bbc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d6715193de439b79f1d6a4c03593c7529239b545"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e97a7a051b55f55f276c1568491d0ed7f890ee94"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38418,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T14:15:33.603,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: remoteproc: core: Release rproc->clean_table after rproc_attach() fails When rproc->state = RPROC_DETACHED is attached to remote processor through rproc_attach(), if rproc_handle_resources() returns failure, then the clean table should be released, otherwise the following memory leak will occur. unreferenced object 0xffff000086a99800 (size 1024): comm ""kworker/u12:3"", pid 59, jiffies 4294893670 (age 121.140s) hex dump (first 32 bytes): 00 00 00 00 00 80 00 00 00 00 00 00 00 00 10 00 ............ 00 00 00 00 00 00 08 00 00 00 00 00 00 00 00 00 ............ backtrace: [<000000008bbe4ca8>] slab_post_alloc_hook+0x98/0x3fc [<000000003b8a272b>] __kmem_cache_alloc_node+0x13c/0x230 [<000000007a507c51>] __kmalloc_node_track_caller+0x5c/0x260 [<0000000037818dae>] kmemdup+0x34/0x60 [<00000000610f7f57>] rproc_boot+0x35c/0x56c [<0000000065f8871a>] rproc_add+0x124/0x17c [<00000000497416ee>] imx_rproc_probe+0x4ec/0x5d4 [<000000003bcaa37d>] platform_probe+0x68/0xd8 [<00000000771577f9>] really_probe+0x110/0x27c [<00000000531fea59>] __driver_probe_device+0x78/0x12c [<0000000080036a04>] driver_probe_device+0x3c/0x118 [<000000007e0bddcb>] __device_attach_driver+0xb8/0xf8 [<000000000cf1fa33>] bus_for_each_drv+0x84/0xe4 [<000000001a53b53e>] __device_attach+0xfc/0x18c [<00000000d1a2a32c>] device_initial_probe+0x14/0x20 [<00000000d8f8b7ae>] bus_probe_device+0xb0/0xb4 unreferenced object 0xffff0000864c9690 (size 16):",,"[{""url"":""https://git.kernel.org/stable/c/3562c09feeb8d8e9d102ce6840e8c7d57a7feb5c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ee979709e16a83b257bc9a544a7ff71fd445ea9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6fe9486d709e4a60990843832501ef6556440ca7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bcd241230fdbc6005230f80a4f8646ff5a84f15b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf876fd9dc2d0c9fff96aef63d4346719f206fc1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f4ef928ca504c996f9222eb2c59ac6d6eefd9c75"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38419,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T14:15:33.727,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: remoteproc: core: Cleanup acquired resources when rproc_handle_resources() fails in rproc_attach() When rproc->state = RPROC_DETACHED and rproc_attach() is used to attach to the remote processor, if rproc_handle_resources() returns a failure, the resources allocated by imx_rproc_prepare() should be released, otherwise the following memory leak will occur. Since almost the same thing is done in imx_rproc_prepare() and rproc_resource_cleanup(), Function rproc_resource_cleanup() is able to deal with empty lists so it is better to fix the ""goto"" statements in rproc_attach(). replace the ""unprepare_device"" goto statement with ""clean_up_resources"" and get rid of the ""unprepare_device"" label. unreferenced object 0xffff0000861c5d00 (size 128): comm ""kworker/u12:3"", pid 59, jiffies 4294893509 (age 149.220s) hex dump (first 32 bytes): 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00 00 02 88 00 00 00 00 00 00 10 00 00 00 00 00 ............ backtrace: [<00000000f949fe18>] slab_post_alloc_hook+0x98/0x37c [<00000000adbfb3e7>] __kmem_cache_alloc_node+0x138/0x2e0 [<00000000521c0345>] kmalloc_trace+0x40/0x158 [<000000004e330a49>] rproc_mem_entry_init+0x60/0xf8 [<000000002815755e>] imx_rproc_prepare+0xe0/0x180 [<0000000003f61b4e>] rproc_boot+0x2ec/0x528 [<00000000e7e994ac>] rproc_add+0x124/0x17c [<0000000048594076>] imx_rproc_probe+0x4ec/0x5d4 [<00000000efc298a1>] platform_probe+0x68/0xd8 [<00000000110be6fe>] really_probe+0x110/0x27c [<00000000e245c0ae>] __driver_probe_device+0x78/0x12c [<00000000f61f6f5e>] driver_probe_device+0x3c/0x118 [<00000000a7874938>] __device_attach_driver+0xb8/0xf8 [<0000000065319e69>] bus_for_each_drv+0x84/0xe4 [<00000000db3eb243>] __device_attach+0xfc/0x18c [<0000000072e4e1a4>] device_initial_probe+0x14/0x20",,"[{""url"":""https://git.kernel.org/stable/c/5434d9f2fd68722b514c14b417b53a8af02c4d24"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7692c9fbedd9087dc9050903f58095915458d9b1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/82208ce9505abb057afdece7c62a14687c52c9ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/92776ca0ccfe78b9bfe847af206bad641fb11121"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9515d74c9d1ae7308a02e8bd4f894eb8137cf8df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c56d6ef2711ee51b54f160ad0f25a381561f0287"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38420,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T15:15:26.793,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: carl9170: do not ping device which has failed to load firmware Syzkaller reports [1, 2] crashes caused by an attempts to ping the device which has failed to load firmware. Since such a device doesn't pass 'ieee80211_register_hw()', an internal workqueue managed by 'ieee80211_queue_work()' is not yet created and an attempt to queue work on it causes null-ptr-deref. [1] https://syzkaller.appspot.com/bug?extid=9a4aec827829942045ff [2] https://syzkaller.appspot.com/bug?extid=0d8afba53e8fb2633217",,"[{""url"":""https://git.kernel.org/stable/c/0140d3d37f0f1759d1fdedd854c7875a86e15f8d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/11ef72b3312752c2ff92f3c1e64912be3228ed36"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/15d25307692312cec4b57052da73387f91a2e870"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/301268dbaac8e9013719e162a000202eac8054be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4e9ab5c48ad5153cc908dd29abad0cd2a92951e4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/527fad1ae32ffa2d4853a1425fe1c8dbb8c9744c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8a3734a6f4c05fd24605148f21fb2066690d61b3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bfeede26e97ce4a15a0b961118de4a0e28c9907a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38421,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T15:15:26.927,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: platform/x86/amd: pmf: Use device managed allocations If setting up smart PC fails for any reason then this can lead to a double free when unloading amd-pmf. This is because dev->buf was freed but never set to NULL and is again freed in amd_pmf_remove(). To avoid subtle allocation bugs in failures leading to a double free change all allocations into device managed allocations.",,"[{""url"":""https://git.kernel.org/stable/c/0d10b532f861253c283863522d59d099fcb0796d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d9db3a941270d92bbd1a6a6b54a10324484f2f2d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38422,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T15:15:27.037,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: lan743x: Modify the EEPROM and OTP size for PCI1xxxx devices Maximum OTP and EEPROM size for hearthstone PCI1xxxx devices are 8 Kb and 64 Kb respectively. Adjust max size definitions and return correct EEPROM length based on device. Also prevent out-of-bound read/write.",,"[{""url"":""https://git.kernel.org/stable/c/088279ff18cdc437d6fac5890e0c52c624f78a5b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3b9935586a9b54d2da27901b830d3cf46ad66a1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/51318d644c993b3f7a60b8616a6a5adc1e967cd2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6b4201d74d0a49af2123abf2c9d142e59566714b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9c41d2a2aa3817946eb613522200cab55513ddaa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38423,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T15:15:27.153,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: codecs: wcd9375: Fix double free of regulator supplies Driver gets regulator supplies in probe path with devm_regulator_bulk_get(), so should not call regulator_bulk_free() in error and remove paths to avoid double free.",,"[{""url"":""https://git.kernel.org/stable/c/63fe298652d4eda07d738bfcbbc59d1343a675ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c8228b5f3d74fd8ad4dfc79d5d601eb6fca5e63e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce30258c05d39b62a05c99016d7148b3bf60fbdc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38424,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T15:15:27.260,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: perf: Fix sample vs do_exit() Baisheng Gao reported an ARM64 crash, which Mark decoded as being a synchronous external abort -- most likely due to trying to access MMIO in bad ways. The crash further shows perf trying to do a user stack sample while in exit_mmap()'s tlb_finish_mmu() -- i.e. while tearing down the address space it is trying to access. It turns out that we stop perf after we tear down the userspace mm; a receipie for disaster, since perf likes to access userspace for various reasons. Flip this order by moving up where we stop perf in do_exit(). Additionally, harden PERF_SAMPLE_CALLCHAIN and PERF_SAMPLE_STACK_USER to abort when the current task does not have an mm (exit_mm() makes sure to set current->mm = NULL; before commencing with the actual teardown). Such that CPU wide events don't trip on this same problem.",,"[{""url"":""https://git.kernel.org/stable/c/2ee6044a693735396bb47eeaba1ac3ae26c1c99b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/456019adaa2f5366b89c868dea9b483179bece54"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4f6fc782128355931527cefe3eb45338abd8ab39"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/507c9a595bad3abd107c6a8857d7fd125d89f386"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7311970d07c4606362081250da95f2c7901fc0db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7b8f3c72175c6a63a95cf2e219f8b78e2baad34e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/975ffddfa2e19823c719459d2364fcaa17673964"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9f6aab7910a0ef2895797f15c947f6d1053160f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38425,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T15:15:27.390,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: i2c: tegra: check msg length in SMBUS block read For SMBUS block read, do not continue to read if the message length passed from the device is '0' or greater than the maximum allowed bytes.",,"[{""url"":""https://git.kernel.org/stable/c/3f03f77ce688d02da284174e1884b6065d6159bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/75a864f21ceeb8c1e8ce1b7589174fec2c3a039e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6e04f05ce0b070ab39d5775580e65c7d943da0b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be5f6a65509cd5675362f15eb0440fb28b0f9d64"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c39d1a9ae4ad66afcecab124d7789722bfe909fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38426,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T15:15:27.510,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Add basic validation for RAS header If RAS header read from EEPROM is corrupted, it could result in trying to allocate huge memory for reading the records. Add some validation to header fields.",,"[{""url"":""https://git.kernel.org/stable/c/5df0d6addb7e9b6f71f7162d1253762a5be9138e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b52f52bc5ba9feb026c0be600f8ac584fd12d187"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38427,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T15:15:27.623,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: video: screen_info: Relocate framebuffers behind PCI bridges Apply PCI host-bridge window offsets to screen_info framebuffers. Fixes invalid access to I/O memory. Resources behind a PCI host bridge can be relocated by a certain offset in the kernel's CPU address range used for I/O. The framebuffer memory range stored in screen_info refers to the CPU addresses as seen during boot (where the offset is 0). During boot up, firmware may assign a different memory offset to the PCI host bridge and thereby relocating the framebuffer address of the PCI graphics device as seen by the kernel. The information in screen_info must be updated as well. The helper pcibios_bus_to_resource() performs the relocation of the screen_info's framebuffer resource (given in PCI bus addresses). The result matches the I/O-memory resource of the PCI graphics device (given in CPU addresses). As before, we store away the information necessary to later update the information in screen_info itself. Commit 78aa89d1dfba (""firmware/sysfb: Update screen_info for relocated EFI framebuffers"") added the code for updating screen_info. It is based on similar functionality that pre-existed in efifb. Efifb uses a pointer to the PCI resource, while the newer code does a memcpy of the region. Hence efifb sees any updates to the PCI resource and avoids the issue. v3: - Only use struct pci_bus_region for PCI bus addresses (Bjorn) - Clarify address semantics in commit messages and comments (Bjorn) v2: - Fixed tags (Takashi, Ivan) - Updated information on efifb",,"[{""url"":""https://git.kernel.org/stable/c/2f29b5c231011b94007d2c8a6d793992f2275db1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5c70e3ad85d2890d8af375333699429de26327f2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aeda386d86d79269a08f470dbdc53d13a91e51fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc3cc41ed67054a03134bea42408c720eec0fa04"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38428,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T15:15:27.737,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Input: ims-pcu - check record size in ims_pcu_flash_firmware() The ""len"" variable comes from the firmware and we generally do trust firmware, but it's always better to double check. If the ""len"" is too large it could result in memory corruption when we do ""memcpy(fragment->data, rec->data, len);""",,"[{""url"":""https://git.kernel.org/stable/c/17474a56acf708bf6b2d174c06ed26abad0a9fd6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a8cd6ae8393e2eaebf51d420d5374821ef2af87"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74661516daee1eadebede8dc607b6830530096ec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e03f1c7d50343bf21da54873301bc4fa647479f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a95ef0199e80f3384eb992889322957d26c00102"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c1b9d140b0807c6aee4bb53e1bfa4e391e3dc204"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d63706d9f73846106fde28b284f08e01b92ce9f1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e5a2481dc2a0b430f49276d7482793a8923631d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38429,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T15:15:27.870,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bus: mhi: ep: Update read pointer only after buffer is written Inside mhi_ep_ring_add_element, the read pointer (rd_offset) is updated before the buffer is written, potentially causing race conditions where the host sees an updated read pointer before the buffer is actually written. Updating rd_offset prematurely can lead to the host accessing an uninitialized or incomplete element, resulting in data corruption. Invoke the buffer write before updating rd_offset to ensure the element is fully written before signaling its availability.",,"[{""url"":""https://git.kernel.org/stable/c/0007ef098dab48f1ba58364c40b4809f1e21b130"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/44b9620e82bbec2b9a6ac77f63913636d84f96dc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6f18d174b73d0ceeaa341f46c0986436b3aefc9a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f704a80d9fa268e51a6cc5242714502c3c1fa605"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38430,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T15:15:27.980,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nfsd: nfsd4_spo_must_allow() must check this is a v4 compound request If the request being processed is not a v4 compound request, then examining the cstate can have undefined results. This patch adds a check that the rpc procedure being executed (rq_procinfo) is the NFSPROC4_COMPOUND procedure.",,"[{""url"":""https://git.kernel.org/stable/c/1244f0b2c3cecd3f349a877006e67c9492b41807"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2c54bd5a380ebf646fb9efbc4ae782ff3a83a5af"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/425efc6b3292a3c79bfee4a1661cf043dcd9cf2f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/64a723b0281ecaa59d31aad73ef8e408a84cb603"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7a75a956692aa64211a9e95781af1ec461642de4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b1d0323a09a29f81572c7391e0d80d78724729c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf78a2706ce975981eb5167f2d3b609eb5d24c19"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e7e943ddd1c6731812357a28e7954ade3a7d8517"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38431,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T15:15:28.133,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: smb: client: fix regression with native SMB symlinks Some users and customers reported that their backup/copy tools started to fail when the directory being copied contained symlink targets that the client couldn't parse - even when those symlinks weren't followed. Fix this by allowing lstat(2) and readlink(2) to succeed even when the client can't resolve the symlink target, restoring old behavior.",,"[{""url"":""https://git.kernel.org/stable/c/6ddaf7567080c7de2e0c99efca2ee1e6b79beea5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff8abbd248c1f52df0c321690b88454b13ff54b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38432,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T15:15:28.263,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: netpoll: Initialize UDP checksum field before checksumming commit f1fce08e63fe (""netpoll: Eliminate redundant assignment"") removed the initialization of the UDP checksum, which was wrong and broke netpoll IPv6 transmission due to bad checksumming. udph->check needs to be set before calling csum_ipv6_magic().",,"[{""url"":""https://git.kernel.org/stable/c/353016ec159f939a380ff6746476a779367ba9a3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f5990207026987a353d5a95204c4d9cb725637fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38433,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T15:15:28.570,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: riscv: fix runtime constant support for nommu kernels the `__runtime_fixup_32` function does not handle the case where `val` is zero correctly (as might occur when patching a nommu kernel and referring to a physical address below the 4GiB boundary whose upper 32 bits are all zero) because nothing in the existing logic prevents the code from taking the `else` branch of both nop-checks and emitting two `nop` instructions. This leaves random garbage in the register that is supposed to receive the upper 32 bits of the pointer instead of zero that when combined with the value for the lower 32 bits yields an invalid pointer and causes a kernel panic when that pointer is eventually accessed. The author clearly considered the fact that if the `lui` is converted into a `nop` that the second instruction needs to be adjusted to become an `li` instead of an `addi`, hence introducing the `addi_insn_mask` variable, but didn't follow that logic through fully to the case where the `else` branch executes. To fix it just adjust the logic to ensure that the second `else` branch is not taken if the first instruction will be patched to a `nop`.",,"[{""url"":""https://git.kernel.org/stable/c/0a24b00dcde83934a3cc13e4c6b775522903496b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8d90d9872edae7e78c3a12b98e239bfaa66f3639"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38434,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T15:15:28.707,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Revert ""riscv: Define TASK_SIZE_MAX for __access_ok()"" This reverts commit ad5643cf2f69 (""riscv: Define TASK_SIZE_MAX for __access_ok()""). This commit changes TASK_SIZE_MAX to be LONG_MAX to optimize access_ok(), because the previous TASK_SIZE_MAX (default to TASK_SIZE) requires some computation. The reasoning was that all user addresses are less than LONG_MAX, and all kernel addresses are greater than LONG_MAX. Therefore access_ok() can filter kernel addresses. Addresses between TASK_SIZE and LONG_MAX are not valid user addresses, but access_ok() let them pass. That was thought to be okay, because they are not valid addresses at hardware level. Unfortunately, one case is missed: get_user_pages_fast() happily accepts addresses between TASK_SIZE and LONG_MAX. futex(), for instance, uses get_user_pages_fast(). This causes the problem reported by Robert [1]. Therefore, revert this commit. TASK_SIZE_MAX is changed to the default: TASK_SIZE. This unfortunately reduces performance, because TASK_SIZE is more expensive to compute compared to LONG_MAX. But correctness first, we can think about optimization later, if required.",,"[{""url"":""https://git.kernel.org/stable/c/890ba5be6335dbbbc99af14ea007befb5f83f174"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8b1898748dfeb4f9b67b6a6d661f354b9de3523"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe30c30bf3bb68d4a4d8c7c814769857b5c973e6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38435,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T15:15:28.837,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: riscv: vector: Fix context save/restore with xtheadvector Previously only v0-v7 were correctly saved/restored, and the context of v8-v31 are damanged. Correctly save/restore v8-v31 to avoid breaking userspace.",,"[{""url"":""https://git.kernel.org/stable/c/4262bd0d9cc704ea1365ac00afc1272400c2cbef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dd5ceea8d50e9e108a10d1e0d89fa2c9ff442ca2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38436,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T15:15:29.000,2025-07-25T15:29:19.837,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/scheduler: signal scheduled fence when kill job When an entity from application B is killed, drm_sched_entity_kill() removes all jobs belonging to that entity through drm_sched_entity_kill_jobs_work(). If application A's job depends on a scheduled fence from application B's job, and that fence is not properly signaled during the killing process, application A's dependency cannot be cleared. This leads to application A hanging indefinitely while waiting for a dependency that will never be resolved. Fix this issue by ensuring that scheduled fences are properly signaled when an entity is killed, allowing dependent applications to continue execution.",,"[{""url"":""https://git.kernel.org/stable/c/471db2c2d4f80ee94225a1ef246e4f5011733e50"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa382a8b6ed483e9812d0e63b6d1bdcba0186f29"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aefd0a935625165a6ca36d0258d2d053901555df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c5734f9bab6f0d40577ad0633af4090a5fda2407"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38437,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:29.030,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix potential use-after-free in oplock/lease break ack If ksmbd_iov_pin_rsp return error, use-after-free can happen by accessing opinfo->state and opinfo_put and ksmbd_fd_put could called twice.",,"[{""url"":""https://git.kernel.org/stable/c/50f930db22365738d9387c974416f38a06e8057e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8106adc21a2270c16abf69cd74ccd7c79c6e7acd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/815f1161d6dbc4c54ccf94b7d3fdeab34b4d7477"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/97c355989928a5f60b228ef5266c1be67a46cdf9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e38ec88a2b42c494601b1213816d75f0b54d9bf0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38438,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:29.143,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: SOF: Intel: hda: Use devm_kstrdup() to avoid memleak. sof_pdata->tplg_filename can have address allocated by kstrdup() and can be overwritten. Memory leak was detected with kmemleak: unreferenced object 0xffff88812391ff60 (size 16): comm ""kworker/4:1"", pid 161, jiffies 4294802931 hex dump (first 16 bytes): 73 6f 66 2d 68 64 61 2d 67 65 6e 65 72 69 63 00 sof-hda-generic. backtrace (crc 4bf1675c): __kmalloc_node_track_caller_noprof+0x49c/0x6b0 kstrdup+0x46/0xc0 hda_machine_select.cold+0x1de/0x12cf [snd_sof_intel_hda_generic] sof_init_environment+0x16f/0xb50 [snd_sof] sof_probe_continue+0x45/0x7c0 [snd_sof] sof_probe_work+0x1e/0x40 [snd_sof] process_one_work+0x894/0x14b0 worker_thread+0x5e5/0xfb0 kthread+0x39d/0x760 ret_from_fork+0x31/0x70 ret_from_fork_asm+0x1a/0x30",,"[{""url"":""https://git.kernel.org/stable/c/58ecf51af12cb32b890858b52b2c34e80590c74a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/68397fda2caa90e99a7c0bcb2cf604e42ef3b91f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c038b58a2dc5a008c7e7a1297f5aaa4deaaaa7e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38439,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:29.257,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bnxt_en: Set DMA unmap len correctly for XDP_REDIRECT When transmitting an XDP_REDIRECT packet, call dma_unmap_len_set() with the proper length instead of 0. This bug triggers this warning on a system with IOMMU enabled: WARNING: CPU: 36 PID: 0 at drivers/iommu/dma-iommu.c:842 __iommu_dma_unmap+0x159/0x170 RIP: 0010:__iommu_dma_unmap+0x159/0x170 Code: a8 00 00 00 00 48 c7 45 b0 00 00 00 00 48 c7 45 c8 00 00 00 00 48 c7 45 a0 ff ff ff ff 4c 89 45 b8 4c 89 45 c0 e9 77 ff ff ff <0f> 0b e9 60 ff ff ff e8 8b bf 6a 00 66 66 2e 0f 1f 84 00 00 00 00 RSP: 0018:ff22d31181150c88 EFLAGS: 00010206 RAX: 0000000000002000 RBX: 00000000e13a0000 RCX: 0000000000000000 RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000 RBP: ff22d31181150cf0 R08: ff22d31181150ca8 R09: 0000000000000000 R10: 0000000000000000 R11: ff22d311d36c9d80 R12: 0000000000001000 R13: ff13544d10645010 R14: ff22d31181150c90 R15: ff13544d0b2bac00 FS: 0000000000000000(0000) GS:ff13550908a00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00005be909dacff8 CR3: 0008000173408003 CR4: 0000000000f71ef0 PKRU: 55555554 Call Trace: <IRQ> ? show_regs+0x6d/0x80 ? __warn+0x89/0x160 ? __iommu_dma_unmap+0x159/0x170 ? report_bug+0x17e/0x1b0 ? handle_bug+0x46/0x90 ? exc_invalid_op+0x18/0x80 ? asm_exc_invalid_op+0x1b/0x20 ? __iommu_dma_unmap+0x159/0x170 ? __iommu_dma_unmap+0xb3/0x170 iommu_dma_unmap_page+0x4f/0x100 dma_unmap_page_attrs+0x52/0x220 ? srso_alias_return_thunk+0x5/0xfbef5 ? xdp_return_frame+0x2e/0xd0 bnxt_tx_int_xdp+0xdf/0x440 [bnxt_en] __bnxt_poll_work_done+0x81/0x1e0 [bnxt_en] bnxt_poll+0xd3/0x1e0 [bnxt_en]",,"[{""url"":""https://git.kernel.org/stable/c/16ae306602163fcb7ae83f2701b542e43c100cee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3cdf199d4755d477972ee87110b2aebc88b3cfad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/50dad9909715094e7d9ca25e9e0412b875987519"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5909679a82cd74cf0343d9e3ddf4b6931aa7e613"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8d672a1a6bfc81fef9151925c9c0481f4acf4bec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e260f4d49370c85a4701d43c6d16b8c39f8b605f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f154e41e1d9d15ab21300ba7bbf0ebb5cb3b9c2a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f9eaf6d036075dc820520e1194692c0619b7297b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38440,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:29.390,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/mlx5e: Fix race between DIM disable and net_dim() There's a race between disabling DIM and NAPI callbacks using the dim pointer on the RQ or SQ. If NAPI checks the DIM state bit and sees it still set, it assumes `rq->dim` or `sq->dim` is valid. But if DIM gets disabled right after that check, the pointer might already be set to NULL, leading to a NULL pointer dereference in net_dim(). Fix this by calling `synchronize_net()` before freeing the DIM context. This ensures all in-progress NAPI callbacks are finished before the pointer is cleared. Kernel log: BUG: kernel NULL pointer dereference, address: 0000000000000000 ... RIP: 0010:net_dim+0x23/0x190 ... Call Trace: <TASK> ? __die+0x20/0x60 ? page_fault_oops+0x150/0x3e0 ? common_interrupt+0xf/0xa0 ? sysvec_call_function_single+0xb/0x90 ? exc_page_fault+0x74/0x130 ? asm_exc_page_fault+0x22/0x30 ? net_dim+0x23/0x190 ? mlx5e_poll_ico_cq+0x41/0x6f0 [mlx5_core] ? sysvec_apic_timer_interrupt+0xb/0x90 mlx5e_handle_rx_dim+0x92/0xd0 [mlx5_core] mlx5e_napi_poll+0x2cd/0xac0 [mlx5_core] ? mlx5e_poll_ico_cq+0xe5/0x6f0 [mlx5_core] busy_poll_stop+0xa2/0x200 ? mlx5e_napi_poll+0x1d9/0xac0 [mlx5_core] ? mlx5e_trigger_irq+0x130/0x130 [mlx5_core] __napi_busy_loop+0x345/0x3b0 ? sysvec_call_function_single+0xb/0x90 ? asm_sysvec_call_function_single+0x16/0x20 ? sysvec_apic_timer_interrupt+0xb/0x90 ? pcpu_free_area+0x1e4/0x2e0 napi_busy_loop+0x11/0x20 xsk_recvmsg+0x10c/0x130 sock_recvmsg+0x44/0x70 __sys_recvfrom+0xbc/0x130 ? __schedule+0x398/0x890 __x64_sys_recvfrom+0x20/0x30 do_syscall_64+0x4c/0x100 entry_SYSCALL_64_after_hwframe+0x4b/0x53 ... ---[ end trace 0000000000000000 ]--- ... ---[ end Kernel panic - not syncing: Fatal exception in interrupt ]---",,"[{""url"":""https://git.kernel.org/stable/c/2bc6fb90486e42dd80e660ef7a40c02b2516c6d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7581afc051542e11ccf3ade68acd01b7fb1a3cde"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb41a264a3a576dc040ee37c3d9d6b7e2d9be968"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38441,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:29.497,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: flowtable: account for Ethernet header in nf_flow_pppoe_proto() syzbot found a potential access to uninit-value in nf_flow_pppoe_proto() Blamed commit forgot the Ethernet header. BUG: KMSAN: uninit-value in nf_flow_offload_inet_hook+0x7e4/0x940 net/netfilter/nf_flow_table_inet.c:27 nf_flow_offload_inet_hook+0x7e4/0x940 net/netfilter/nf_flow_table_inet.c:27 nf_hook_entry_hookfn include/linux/netfilter.h:157 [inline] nf_hook_slow+0xe1/0x3d0 net/netfilter/core.c:623 nf_hook_ingress include/linux/netfilter_netdev.h:34 [inline] nf_ingress net/core/dev.c:5742 [inline] __netif_receive_skb_core+0x4aff/0x70c0 net/core/dev.c:5837 __netif_receive_skb_one_core net/core/dev.c:5975 [inline] __netif_receive_skb+0xcc/0xac0 net/core/dev.c:6090 netif_receive_skb_internal net/core/dev.c:6176 [inline] netif_receive_skb+0x57/0x630 net/core/dev.c:6235 tun_rx_batched+0x1df/0x980 drivers/net/tun.c:1485 tun_get_user+0x4ee0/0x6b40 drivers/net/tun.c:1938 tun_chr_write_iter+0x3e9/0x5c0 drivers/net/tun.c:1984 new_sync_write fs/read_write.c:593 [inline] vfs_write+0xb4b/0x1580 fs/read_write.c:686 ksys_write fs/read_write.c:738 [inline] __do_sys_write fs/read_write.c:749 [inline]",,"[{""url"":""https://git.kernel.org/stable/c/18cdb3d982da8976b28d57691eb256ec5688fad2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9fbc49429a23b02595ba82536c5ea425fdabb221"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a3aea97d55964e70a1e6426aa4cafdc036e8a2dd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cfbf0665969af2c69d10c377d4c3d306e717efb4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0dd2e9729660f3f4fcb16e0aef87342911528ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eed8960b289327235185b7c32649c3470a3e969b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38442,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:29.630,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: block: reject bs > ps block devices when THP is disabled If THP is disabled and when a block device with logical block size > page size is present, the following null ptr deref panic happens during boot: [ [13.2 mK AOSAN: null-ptr-deref in range [0x0000000000000000-0x0000000000K0 0 0[07] [ 13.017749] RIP: 0010:create_empty_buffers+0x3b/0x380 <snip> [ 13.025448] Call Trace: [ 13.025692] <TASK> [ 13.025895] block_read_full_folio+0x610/0x780 [ 13.026379] ? __pfx_blkdev_get_block+0x10/0x10 [ 13.027008] ? __folio_batch_add_and_move+0x1fa/0x2b0 [ 13.027548] ? __pfx_blkdev_read_folio+0x10/0x10 [ 13.028080] filemap_read_folio+0x9b/0x200 [ 13.028526] ? __pfx_filemap_read_folio+0x10/0x10 [ 13.029030] ? __filemap_get_folio+0x43/0x620 [ 13.029497] do_read_cache_folio+0x155/0x3b0 [ 13.029962] ? __pfx_blkdev_read_folio+0x10/0x10 [ 13.030381] read_part_sector+0xb7/0x2a0 [ 13.030805] read_lba+0x174/0x2c0 <snip> [ 13.045348] nvme_scan_ns+0x684/0x850 [nvme_core] [ 13.045858] ? __pfx_nvme_scan_ns+0x10/0x10 [nvme_core] [ 13.046414] ? _raw_spin_unlock+0x15/0x40 [ 13.046843] ? __switch_to+0x523/0x10a0 [ 13.047253] ? kvm_clock_get_cycles+0x14/0x30 [ 13.047742] ? __pfx_nvme_scan_ns_async+0x10/0x10 [nvme_core] [ 13.048353] async_run_entry_fn+0x96/0x4f0 [ 13.048787] process_one_work+0x667/0x10a0 [ 13.049219] worker_thread+0x63c/0xf60 As large folio support depends on THP, only allow bs > ps block devices if THP is enabled.",,"[{""url"":""https://git.kernel.org/stable/c/4cdf1bdd45ac78a088773722f009883af30ad318"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b025d81b96bfe8a62b6e3e6ac776608206ccbf6d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38443,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:29.737,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nbd: fix uaf in nbd_genl_connect() error path There is a use-after-free issue in nbd: block nbd6: Receive control failed (result -104) block nbd6: shutting down sockets ================================================================== BUG: KASAN: slab-use-after-free in recv_work+0x694/0xa80 drivers/block/nbd.c:1022 Write of size 4 at addr ffff8880295de478 by task kworker/u33:0/67 CPU: 2 UID: 0 PID: 67 Comm: kworker/u33:0 Not tainted 6.15.0-rc5-syzkaller-00123-g2c89c1b655c0 #0 PREEMPT(full) Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 Workqueue: nbd6-recv recv_work Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:408 [inline] print_report+0xc3/0x670 mm/kasan/report.c:521 kasan_report+0xe0/0x110 mm/kasan/report.c:634 check_region_inline mm/kasan/generic.c:183 [inline] kasan_check_range+0xef/0x1a0 mm/kasan/generic.c:189 instrument_atomic_read_write include/linux/instrumented.h:96 [inline] atomic_dec include/linux/atomic/atomic-instrumented.h:592 [inline] recv_work+0x694/0xa80 drivers/block/nbd.c:1022 process_one_work+0x9cc/0x1b70 kernel/workqueue.c:3238 process_scheduled_works kernel/workqueue.c:3319 [inline] worker_thread+0x6c8/0xf10 kernel/workqueue.c:3400 kthread+0x3c2/0x780 kernel/kthread.c:464 ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:153 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:245 </TASK> nbd_genl_connect() does not properly stop the device on certain error paths after nbd_start_device() has been called. This causes the error path to put nbd->config while recv_work continue to use the config after putting it, leading to use-after-free in recv_work. This patch moves nbd_start_device() after the backend file creation.",,"[{""url"":""https://git.kernel.org/stable/c/002aca89753f666d878ca0eb8584c372684ac4ba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8586552df591e0a367eff44af0c586213eeecc3f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/91fa560c73a8126868848ed6cd70607cbf8d87e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa9552438ebf015fc5f9f890dbfe39f0c53cf37e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cb121c47f364b51776c4db904a6a5a90ab0a7ec5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d46186eb7bbd9a11c145120f2d77effa8d4d44c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38444,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:29.860,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: raid10: cleanup memleak at raid10_make_request If raid10_read_request or raid10_write_request registers a new request and the REQ_NOWAIT flag is set, the code does not free the malloc from the mempool. unreferenced object 0xffff8884802c3200 (size 192): comm ""fio"", pid 9197, jiffies 4298078271 hex dump (first 32 bytes): 00 00 00 00 00 00 00 00 88 41 02 00 00 00 00 00 .........A...... 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ backtrace (crc c1a049a2): __kmalloc+0x2bb/0x450 mempool_alloc+0x11b/0x320 raid10_make_request+0x19e/0x650 [raid10] md_handle_request+0x3b3/0x9e0 __submit_bio+0x394/0x560 __submit_bio_noacct+0x145/0x530 submit_bio_noacct_nocheck+0x682/0x830 __blkdev_direct_IO_async+0x4dc/0x6b0 blkdev_read_iter+0x1e5/0x3b0 __io_read+0x230/0x1110 io_read+0x13/0x30 io_issue_sqe+0x134/0x1180 io_submit_sqes+0x48c/0xe90 __do_sys_io_uring_enter+0x574/0x8b0 do_syscall_64+0x5c/0xe0 entry_SYSCALL_64_after_hwframe+0x76/0x7e V4: changing backing tree to see if CKI tests will pass. The patch code has not changed between any versions.",,"[{""url"":""https://git.kernel.org/stable/c/10c6021a609deb95f23f0cc2f89aa9d4bffb14c7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2941155d9a5ae098b480d551f3a5f8605d4f9af5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/43806c3d5b9bb7d74ba4e33a6a8a41ac988bde24"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8fc3d7b23d139e3cbc944c15d99b3cdbed797d2d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9af149ca9d0dab6e59e813519d309eff62499864"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ed7bcd9f617e4107ac0813c516e72e6b8f6029bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38445,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:29.980,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: md/raid1: Fix stack memory use after return in raid1_reshape In the raid1_reshape function, newpool is allocated on the stack and assigned to conf->r1bio_pool. This results in conf->r1bio_pool.wait.head pointing to a stack address. Accessing this address later can lead to a kernel panic. Example access path: raid1_reshape() { // newpool is on the stack mempool_t newpool, oldpool; // initialize newpool.wait.head to stack address mempool_init(&newpool, ...); conf->r1bio_pool = newpool; } raid1_read_request() or raid1_write_request() { alloc_r1bio() { mempool_alloc() { // if pool->alloc fails remove_element() { --pool->curr_nr; } } } } mempool_free() { if (pool->curr_nr < pool->min_nr) { // pool->wait.head is a stack address // wake_up() will try to access this invalid address // which leads to a kernel panic return; wake_up(&pool->wait); } } Fix: reinit conf->r1bio_pool.wait after assigning newpool.",,"[{""url"":""https://git.kernel.org/stable/c/12b00ec99624f8da8c325f2dd6e807df26df0025"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/48da050b4f54ed639b66278d0ae6f4107b2c4e2d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5f35e48b76655e45522df338876dfef88dafcc71"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/61fd5e93006cf82ec8ee5c115ab5cf4bbd104bdb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/776e6186dc9ecbdb8a1b706e989166c8a99bbf64"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d67ed2ccd2d1dcfda9292c0ea8697a9d0f2f0d98"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d8a6853d00fbaa810765c8ed2f452a5832273968"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/df5894014a92ff0196dbc212a7764e97366fd2b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38446,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:30.100,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: clk: imx: Fix an out-of-bounds access in dispmix_csr_clk_dev_data When num_parents is 4, __clk_register() occurs an out-of-bounds when accessing parent_names member. Use ARRAY_SIZE() instead of hardcode number here. BUG: KASAN: global-out-of-bounds in __clk_register+0x1844/0x20d8 Read of size 8 at addr ffff800086988e78 by task kworker/u24:3/59 Hardware name: NXP i.MX95 19X19 board (DT) Workqueue: events_unbound deferred_probe_work_func Call trace: dump_backtrace+0x94/0xec show_stack+0x18/0x24 dump_stack_lvl+0x8c/0xcc print_report+0x398/0x5fc kasan_report+0xd4/0x114 __asan_report_load8_noabort+0x20/0x2c __clk_register+0x1844/0x20d8 clk_hw_register+0x44/0x110 __clk_hw_register_mux+0x284/0x3a8 imx95_bc_probe+0x4f4/0xa70",,"[{""url"":""https://git.kernel.org/stable/c/a956daad67cec454ee985e103e167711fab5b9b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aacc875a448d363332b9df0621dde6d3a225ea9f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fcee75daecc5234ee3482d8cf3518bf021d8a0a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38447,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:30.210,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm/rmap: fix potential out-of-bounds page table access during batched unmap As pointed out by David[1], the batched unmap logic in try_to_unmap_one() may read past the end of a PTE table when a large folio's PTE mappings are not fully contained within a single page table. While this scenario might be rare, an issue triggerable from userspace must be fixed regardless of its likelihood. This patch fixes the out-of-bounds access by refactoring the logic into a new helper, folio_unmap_pte_batch(). The new helper correctly calculates the safe batch size by capping the scan at both the VMA and PMD boundaries. To simplify the code, it also supports partial batching (i.e., any number of pages from 1 up to the calculated safe maximum), as there is no strong reason to special-case for fully mapped folios.",,"[{""url"":""https://git.kernel.org/stable/c/510fe9c15d07e765d96be9a9dc37e5057c6c09f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ddd05742b45b083975a0855ef6ebbf88cf1f532a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38448,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:30.317,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: gadget: u_serial: Fix race condition in TTY wakeup A race condition occurs when gs_start_io() calls either gs_start_rx() or gs_start_tx(), as those functions briefly drop the port_lock for usb_ep_queue(). This allows gs_close() and gserial_disconnect() to clear port.tty and port_usb, respectively. Use the null-safe TTY Port helper function to wake up TTY. Example CPU1: CPU2: gserial_connect() // lock gs_close() // await lock gs_start_rx() // unlock usb_ep_queue() gs_close() // lock, reset port.tty and unlock gs_start_rx() // lock tty_wakeup() // NPE",,"[{""url"":""https://git.kernel.org/stable/c/18d58a467ccf011078352d91b4d6a0108c7318e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a5012673d49788f16bb4e375b002d7743eb642d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/abf3620cba68e0e51e5c21054ce4f925f75b3661"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c529c3730bd09115684644e26bf01ecbd7e2c2c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c6eb4a05af3d0ba3bc4e8159287722fb9abc6359"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c8c80a3a35c2e3488409de2d5376ef7e662a2bf5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d43657b59f36e88289a6066f15bc9a80df5014eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee8d688e2ba558f3bb8ac225113740be5f335417"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38449,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:30.443,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/gem: Acquire references on GEM handles for framebuffers A GEM handle can be released while the GEM buffer object is attached to a DRM framebuffer. This leads to the release of the dma-buf backing the buffer object, if any. [1] Trying to use the framebuffer in further mode-setting operations leads to a segmentation fault. Most easily happens with driver that use shadow planes for vmap-ing the dma-buf during a page flip. An example is shown below. [ 156.791968] ------------[ cut here ]------------ [ 156.796830] WARNING: CPU: 2 PID: 2255 at drivers/dma-buf/dma-buf.c:1527 dma_buf_vmap+0x224/0x430 [...] [ 156.942028] RIP: 0010:dma_buf_vmap+0x224/0x430 [ 157.043420] Call Trace: [ 157.045898] <TASK> [ 157.048030] ? show_trace_log_lvl+0x1af/0x2c0 [ 157.052436] ? show_trace_log_lvl+0x1af/0x2c0 [ 157.056836] ? show_trace_log_lvl+0x1af/0x2c0 [ 157.061253] ? drm_gem_shmem_vmap+0x74/0x710 [ 157.065567] ? dma_buf_vmap+0x224/0x430 [ 157.069446] ? __warn.cold+0x58/0xe4 [ 157.073061] ? dma_buf_vmap+0x224/0x430 [ 157.077111] ? report_bug+0x1dd/0x390 [ 157.080842] ? handle_bug+0x5e/0xa0 [ 157.084389] ? exc_invalid_op+0x14/0x50 [ 157.088291] ? asm_exc_invalid_op+0x16/0x20 [ 157.092548] ? dma_buf_vmap+0x224/0x430 [ 157.096663] ? dma_resv_get_singleton+0x6d/0x230 [ 157.101341] ? __pfx_dma_buf_vmap+0x10/0x10 [ 157.105588] ? __pfx_dma_resv_get_singleton+0x10/0x10 [ 157.110697] drm_gem_shmem_vmap+0x74/0x710 [ 157.114866] drm_gem_vmap+0xa9/0x1b0 [ 157.118763] drm_gem_vmap_unlocked+0x46/0xa0 [ 157.123086] drm_gem_fb_vmap+0xab/0x300 [ 157.126979] drm_atomic_helper_prepare_planes.part.0+0x487/0xb10 [ 157.133032] ? lockdep_init_map_type+0x19d/0x880 [ 157.137701] drm_atomic_helper_commit+0x13d/0x2e0 [ 157.142671] ? drm_atomic_nonblocking_commit+0xa0/0x180 [ 157.147988] drm_mode_atomic_ioctl+0x766/0xe40 [...] [ 157.346424] ---[ end trace 0000000000000000 ]--- Acquiring GEM handles for the framebuffer's GEM buffer objects prevents this from happening. The framebuffer's cleanup later puts the handle references. Commit 1a148af06000 (""drm/gem-shmem: Use dma_buf from GEM object instance"") triggers the segmentation fault easily by using the dma-buf field more widely. The underlying issue with reference counting has been present before. v2: - acquire the handle instead of the BO (Christian) - fix comment style (Christian) - drop the Fixes tag (Christian) - rename err_ gotos - add missing Link tag",,"[{""url"":""https://git.kernel.org/stable/c/08480e285c6a82ce689008d643e4a51db0aaef8b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3cf520d9860d4ec9f7f32068825da31f18dd3f25"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5307dce878d4126e1b375587318955bd019c3741"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cb4c956a15f8b7f870649454771fc3761f504b5f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38450,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:30.560,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: mt7925: prevent NULL pointer dereference in mt7925_sta_set_decap_offload() Add a NULL check for msta->vif before accessing its members to prevent a kernel panic in AP mode deployment. This also fix the issue reported in [1]. The crash occurs when this function is triggered before the station is fully initialized. The call trace shows a page fault at mt7925_sta_set_decap_offload() due to accessing resources when msta->vif is NULL. Fix this by adding an early return if msta->vif is NULL and also check wcid.sta is ready. This ensures we only proceed with decap offload configuration when the station's state is properly initialized. [14739.655703] Unable to handle kernel paging request at virtual address ffffffffffffffa0 [14739.811820] CPU: 0 UID: 0 PID: 895854 Comm: hostapd Tainted: G [14739.821394] Tainted: [C]=CRAP, [O]=OOT_MODULE [14739.825746] Hardware name: Raspberry Pi 4 Model B Rev 1.1 (DT) [14739.831577] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [14739.838538] pc : mt7925_sta_set_decap_offload+0xc0/0x1b8 [mt7925_common] [14739.845271] lr : mt7925_sta_set_decap_offload+0x58/0x1b8 [mt7925_common] [14739.851985] sp : ffffffc085efb500 [14739.855295] x29: ffffffc085efb500 x28: 0000000000000000 x27: ffffff807803a158 [14739.862436] x26: ffffff8041ececb8 x25: 0000000000000001 x24: 0000000000000001 [14739.869577] x23: 0000000000000001 x22: 0000000000000008 x21: ffffff8041ecea88 [14739.876715] x20: ffffff8041c19ca0 x19: ffffff8078031fe0 x18: 0000000000000000 [14739.883853] x17: 0000000000000000 x16: ffffffe2aeac1110 x15: 000000559da48080 [14739.890991] x14: 0000000000000001 x13: 0000000000000000 x12: 0000000000000000 [14739.898130] x11: 0a10020001008e88 x10: 0000000000001a50 x9 : ffffffe26457bfa0 [14739.905269] x8 : ffffff8042013bb0 x7 : ffffff807fb6cbf8 x6 : dead000000000100 [14739.912407] x5 : dead000000000122 x4 : ffffff80780326c8 x3 : 0000000000000000 [14739.919546] x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffffff8041ececb8 [14739.926686] Call trace: [14739.929130] mt7925_sta_set_decap_offload+0xc0/0x1b8 [mt7925_common] [14739.935505] ieee80211_check_fast_rx+0x19c/0x510 [mac80211] [14739.941344] _sta_info_move_state+0xe4/0x510 [mac80211] [14739.946860] sta_info_move_state+0x1c/0x30 [mac80211] [14739.952116] sta_apply_auth_flags.constprop.0+0x90/0x1b0 [mac80211] [14739.958708] sta_apply_parameters+0x234/0x5e0 [mac80211] [14739.964332] ieee80211_add_station+0xdc/0x190 [mac80211] [14739.969950] nl80211_new_station+0x46c/0x670 [cfg80211] [14739.975516] genl_family_rcv_msg_doit+0xdc/0x150 [14739.980158] genl_rcv_msg+0x218/0x298 [14739.983830] netlink_rcv_skb+0x64/0x138 [14739.987670] genl_rcv+0x40/0x60 [14739.990816] netlink_unicast+0x314/0x380 [14739.994742] netlink_sendmsg+0x198/0x3f0 [14739.998664] __sock_sendmsg+0x64/0xc0 [14740.002324] ____sys_sendmsg+0x260/0x298 [14740.006242] ___sys_sendmsg+0xb4/0x110",,"[{""url"":""https://git.kernel.org/stable/c/35ad47c0b3da04b00b19a8b9ed5632e2f2520472"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/91c3dec2453b3742e8f666957b99945edc30577f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9b50874f297fcc62adc7396f35209878e51010b0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38451,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:30.680,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: md/md-bitmap: fix GPF in bitmap_get_stats() The commit message of commit 6ec1f0239485 (""md/md-bitmap: fix stats collection for external bitmaps"") states: Remove the external bitmap check as the statistics should be available regardless of bitmap storage location. Return -EINVAL only for invalid bitmap with no storage (neither in superblock nor in external file). But, the code does not adhere to the above, as it does only check for a valid super-block for ""internal"" bitmaps. Hence, we observe: Oops: GPF, probably for non-canonical address 0x1cd66f1f40000028 RIP: 0010:bitmap_get_stats+0x45/0xd0 Call Trace: seq_read_iter+0x2b9/0x46a seq_read+0x12f/0x180 proc_reg_read+0x57/0xb0 vfs_read+0xf6/0x380 ksys_read+0x6d/0xf0 do_syscall_64+0x8c/0x1b0 entry_SYSCALL_64_after_hwframe+0x76/0x7e We fix this by checking the existence of a super-block for both the internal and external case.",,"[{""url"":""https://git.kernel.org/stable/c/3d82a729530bd2110ba66e4a1f73461c776edec2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3e0542701b37aa25b025d8531583458e4f014c2e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a18f9b08c70e10ea3a897058fee8a4f3b4c146ec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a23b16ba3274961494f5ad236345d238364349ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c17fb542dbd1db745c9feac15617056506dd7195"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38452,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:30.800,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: ethernet: rtsn: Fix a null pointer dereference in rtsn_probe() Add check for the return value of rcar_gen4_ptp_alloc() to prevent potential null pointer dereference.",,"[{""url"":""https://git.kernel.org/stable/c/95a234f6affbf51f06338383537ab80d637bb785"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9f260e16b297f8134c5f90bb5a20e805ff57e853"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d52eb4f0e0ca9a5213b8795abbeb11a325d9b22d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38453,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:30.913,2025-09-09T17:15:44.790,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: io_uring/msg_ring: ensure io_kiocb freeing is deferred for RCU syzbot reports that defer/local task_work adding via msg_ring can hit a request that has been freed: CPU: 1 UID: 0 PID: 19356 Comm: iou-wrk-19354 Not tainted 6.16.0-rc4-syzkaller-00108-g17bbde2e1716 #0 PREEMPT(full) Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025 Call Trace: <TASK> dump_stack_lvl+0x189/0x250 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:408 [inline] print_report+0xd2/0x2b0 mm/kasan/report.c:521 kasan_report+0x118/0x150 mm/kasan/report.c:634 io_req_local_work_add io_uring/io_uring.c:1184 [inline] __io_req_task_work_add+0x589/0x950 io_uring/io_uring.c:1252 io_msg_remote_post io_uring/msg_ring.c:103 [inline] io_msg_data_remote io_uring/msg_ring.c:133 [inline] __io_msg_ring_data+0x820/0xaa0 io_uring/msg_ring.c:151 io_msg_ring_data io_uring/msg_ring.c:173 [inline] io_msg_ring+0x134/0xa00 io_uring/msg_ring.c:314 __io_issue_sqe+0x17e/0x4b0 io_uring/io_uring.c:1739 io_issue_sqe+0x165/0xfd0 io_uring/io_uring.c:1762 io_wq_submit_work+0x6e9/0xb90 io_uring/io_uring.c:1874 io_worker_handle_work+0x7cd/0x1180 io_uring/io-wq.c:642 io_wq_worker+0x42f/0xeb0 io_uring/io-wq.c:696 ret_from_fork+0x3fc/0x770 arch/x86/kernel/process.c:148 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:245 </TASK> which is supposed to be safe with how requests are allocated. But msg ring requests alloc and free on their own, and hence must defer freeing to a sane time. Add an rcu_head and use kfree_rcu() in both spots where requests are freed. Only the one in io_msg_tw_complete() is strictly required as it has been visible on the other ring, but use it consistently in the other spot as well. This should not cause any other issues outside of KASAN rightfully complaining about it.",,"[{""url"":""https://git.kernel.org/stable/c/094ba14a471cc6c68078c7ad488539eaf32c2277"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e5b3432f4a6b418b8bd8fc91f38efbf17a77167a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc582cd26e888b0652bc1494f252329453fd3b23"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38454,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:31.030,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ALSA: ad1816a: Fix potential NULL pointer deref in snd_card_ad1816a_pnp() Use pr_warn() instead of dev_warn() when 'pdev' is NULL to avoid a potential NULL pointer dereference.",,"[{""url"":""https://git.kernel.org/stable/c/043faef334a1f3d96ae88e1b7618bfa2b4946388"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e14bffc90866596ba19ffe549f199d7870da4241"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ef84c94d11ff972ecc3507f1ed092046bf6204b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38455,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:31.143,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: KVM: SVM: Reject SEV{-ES} intra host migration if vCPU creation is in-flight Reject migration of SEV{-ES} state if either the source or destination VM is actively creating a vCPU, i.e. if kvm_vm_ioctl_create_vcpu() is in the section between incrementing created_vcpus and online_vcpus. The bulk of vCPU creation runs _outside_ of kvm->lock to allow creating multiple vCPUs in parallel, and so sev_info.es_active can get toggled from false=>true in the destination VM after (or during) svm_vcpu_create(), resulting in an SEV{-ES} VM effectively having a non-SEV{-ES} vCPU. The issue manifests most visibly as a crash when trying to free a vCPU's NULL VMSA page in an SEV-ES VM, but any number of things can go wrong. BUG: unable to handle page fault for address: ffffebde00000000 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 0 P4D 0 Oops: Oops: 0000 [#1] SMP KASAN NOPTI CPU: 227 UID: 0 PID: 64063 Comm: syz.5.60023 Tainted: G U O 6.15.0-smp-DEV #2 NONE Tainted: [U]=USER, [O]=OOT_MODULE Hardware name: Google, Inc. Arcadia_IT_80/Arcadia_IT_80, BIOS 12.52.0-0 10/28/2024 RIP: 0010:constant_test_bit arch/x86/include/asm/bitops.h:206 [inline] RIP: 0010:arch_test_bit arch/x86/include/asm/bitops.h:238 [inline] RIP: 0010:_test_bit include/asm-generic/bitops/instrumented-non-atomic.h:142 [inline] RIP: 0010:PageHead include/linux/page-flags.h:866 [inline] RIP: 0010:___free_pages+0x3e/0x120 mm/page_alloc.c:5067 Code: <49> f7 06 40 00 00 00 75 05 45 31 ff eb 0c 66 90 4c 89 f0 4c 39 f0 RSP: 0018:ffff8984551978d0 EFLAGS: 00010246 RAX: 0000777f80000001 RBX: 0000000000000000 RCX: ffffffff918aeb98 RDX: 0000000000000000 RSI: 0000000000000008 RDI: ffffebde00000000 RBP: 0000000000000000 R08: ffffebde00000007 R09: 1ffffd7bc0000000 R10: dffffc0000000000 R11: fffff97bc0000001 R12: dffffc0000000000 R13: ffff8983e19751a8 R14: ffffebde00000000 R15: 1ffffd7bc0000000 FS: 0000000000000000(0000) GS:ffff89ee661d3000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: ffffebde00000000 CR3: 000000793ceaa000 CR4: 0000000000350ef0 DR0: 0000000000000000 DR1: 0000000000000b5f DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400 Call Trace: <TASK> sev_free_vcpu+0x413/0x630 arch/x86/kvm/svm/sev.c:3169 svm_vcpu_free+0x13a/0x2a0 arch/x86/kvm/svm/svm.c:1515 kvm_arch_vcpu_destroy+0x6a/0x1d0 arch/x86/kvm/x86.c:12396 kvm_vcpu_destroy virt/kvm/kvm_main.c:470 [inline] kvm_destroy_vcpus+0xd1/0x300 virt/kvm/kvm_main.c:490 kvm_arch_destroy_vm+0x636/0x820 arch/x86/kvm/x86.c:12895 kvm_put_kvm+0xb8e/0xfb0 virt/kvm/kvm_main.c:1310 kvm_vm_release+0x48/0x60 virt/kvm/kvm_main.c:1369 __fput+0x3e4/0x9e0 fs/file_table.c:465 task_work_run+0x1a9/0x220 kernel/task_work.c:227 exit_task_work include/linux/task_work.h:40 [inline] do_exit+0x7f0/0x25b0 kernel/exit.c:953 do_group_exit+0x203/0x2d0 kernel/exit.c:1102 get_signal+0x1357/0x1480 kernel/signal.c:3034 arch_do_signal_or_restart+0x40/0x690 arch/x86/kernel/signal.c:337 exit_to_user_mode_loop kernel/entry/common.c:111 [inline] exit_to_user_mode_prepare include/linux/entry-common.h:329 [inline] __syscall_exit_to_user_mode_work kernel/entry/common.c:207 [inline] syscall_exit_to_user_mode+0x67/0xb0 kernel/entry/common.c:218 do_syscall_64+0x7c/0x150 arch/x86/entry/syscall_64.c:100 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7f87a898e969 </TASK> Modules linked in: gq(O) gsmi: Log Shutdown Reason 0x03 CR2: ffffebde00000000 ---[ end trace 0000000000000000 ]--- Deliberately don't check for a NULL VMSA when freeing the vCPU, as crashing the host is likely desirable due to the VMSA being consumed by hardware. E.g. if KVM manages to allow VMRUN on the vCPU, hardware may read/write a bogus VMSA page. Accessing P ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/8c8e8d4d7544bb783e15078eda8ba2580e192246"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b5725213149597cd9c2b075b87bc4e0f87e906c1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0d9a7cf37ca09c513420dc88e0d0e805a4f0820"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ecf371f8b02d5e31b9aa1da7f159f1b2107bdb01"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd044c99d831e9f837518816c7c366b04014d405"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38456,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:31.283,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ipmi:msghandler: Fix potential memory corruption in ipmi_create_user() The ""intf"" list iterator is an invalid pointer if the correct ""intf->intf_num"" is not found. Calling atomic_dec(&intf->nr_users) on and invalid pointer will lead to memory corruption. We don't really need to call atomic_dec() if we haven't called atomic_add_return() so update the if (intf->in_shutdown) path as well.",,"[{""url"":""https://git.kernel.org/stable/c/7c1a6ddb99858e7d68961f74ae27caeeeca67b6a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9e0d33e75c1604c3fad5586ad4dfa3b2695a3950"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cbc1670297f675854e982d23c8583900ff0cc67a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e2d5c005dfc96fe857676d1d8ac46b29275cb89b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa332f5dc6fc662ad7d3200048772c96b861cf6b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38457,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:31.403,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/sched: Abort __tc_modify_qdisc if parent class does not exist Lion's patch [1] revealed an ancient bug in the qdisc API. Whenever a user creates/modifies a qdisc specifying as a parent another qdisc, the qdisc API will, during grafting, detect that the user is not trying to attach to a class and reject. However grafting is performed after qdisc_create (and thus the qdiscs' init callback) is executed. In qdiscs that eventually call qdisc_tree_reduce_backlog during init or change (such as fq, hhf, choke, etc), an issue arises. For example, executing the following commands: sudo tc qdisc add dev lo root handle a: htb default 2 sudo tc qdisc add dev lo parent a: handle beef fq Qdiscs such as fq, hhf, choke, etc unconditionally invoke qdisc_tree_reduce_backlog() in their control path init() or change() which then causes a failure to find the child class; however, that does not stop the unconditional invocation of the assumed child qdisc's qlen_notify with a null class. All these qdiscs make the assumption that class is non-null. The solution is ensure that qdisc_leaf() which looks up the parent class, and is invoked prior to qdisc_create(), should return failure on not finding the class. In this patch, we leverage qdisc_leaf to return ERR_PTRs whenever the parentid doesn't correspond to a class, so that we can detect it earlier on and abort before qdisc_create is called. [1] https://lore.kernel.org/netdev/d912cbd7-193b-4269-9857-525bee8bbb6a@gmail.com/",,"[{""url"":""https://git.kernel.org/stable/c/23c165dde88eac405eebb59051ea1fe139a45803"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/25452638f133ac19d75af3f928327d8016952c8e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c691d1b6b6dbd73f30ed9ee7da05f037b0c49af"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ecd651ef24ab50123692a4e3e25db93cb11602a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90436e72c9622c2f70389070088325a3232d339f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/923a276c74e25073ae391e930792ac86a9f77f1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e28a383d6485c3bb51dc5953552f76c4dea33eea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ffdde7bf5a439aaa1955ebd581f5c64ab1533963"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38458,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:31.530,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: atm: clip: Fix NULL pointer dereference in vcc_sendmsg() atmarpd_dev_ops does not implement the send method, which may cause crash as bellow. BUG: kernel NULL pointer dereference, address: 0000000000000000 PGD 0 P4D 0 Oops: Oops: 0010 [#1] SMP KASAN NOPTI CPU: 0 UID: 0 PID: 5324 Comm: syz.0.0 Not tainted 6.15.0-rc6-syzkaller-00346-g5723cc3450bc #0 PREEMPT(full) Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 RIP: 0010:0x0 Code: Unable to access opcode bytes at 0xffffffffffffffd6. RSP: 0018:ffffc9000d3cf778 EFLAGS: 00010246 RAX: 1ffffffff1910dd1 RBX: 00000000000000c0 RCX: dffffc0000000000 RDX: ffffc9000dc82000 RSI: ffff88803e4c4640 RDI: ffff888052cd0000 RBP: ffffc9000d3cf8d0 R08: ffff888052c9143f R09: 1ffff1100a592287 R10: dffffc0000000000 R11: 0000000000000000 R12: 1ffff92001a79f00 R13: ffff888052cd0000 R14: ffff88803e4c4640 R15: ffffffff8c886e88 FS: 00007fbc762566c0(0000) GS:ffff88808d6c2000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: ffffffffffffffd6 CR3: 0000000041f1b000 CR4: 0000000000352ef0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> vcc_sendmsg+0xa10/0xc50 net/atm/common.c:644 sock_sendmsg_nosec net/socket.c:712 [inline] __sock_sendmsg+0x219/0x270 net/socket.c:727 ____sys_sendmsg+0x52d/0x830 net/socket.c:2566 ___sys_sendmsg+0x21f/0x2a0 net/socket.c:2620 __sys_sendmmsg+0x227/0x430 net/socket.c:2709 __do_sys_sendmmsg net/socket.c:2736 [inline] __se_sys_sendmmsg net/socket.c:2733 [inline] __x64_sys_sendmmsg+0xa0/0xc0 net/socket.c:2733 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xf6/0x210 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f",,"[{""url"":""https://git.kernel.org/stable/c/07b585ae3699c0a5026f86ac846f144e34875eee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/22fc46cea91df3dce140a7dc6847c6fcf0354505"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/27b5bb7ea1a8fa7b8c4cfde4d2bf8650cca2e8e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/34a09d6240a25185ef6fc5a19dbb3cdbb6a78bc0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f1cad84ac1a6af42d9d57e879de47ce37995024"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f8a9b396037daae453a108faec5b28886361323"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ec7e943aee5c28c173933f9defd40892fb3be3d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a16fbe6087e91c8e7c4aa50e1af7ad56edbd9e3e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38459,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:31.660,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: atm: clip: Fix infinite recursive call of clip_push(). syzbot reported the splat below. [0] This happens if we call ioctl(ATMARP_MKIP) more than once. During the first call, clip_mkip() sets clip_push() to vcc->push(), and the second call copies it to clip_vcc->old_push(). Later, when the socket is close()d, vcc_destroy_socket() passes NULL skb to clip_push(), which calls clip_vcc->old_push(), triggering the infinite recursion. Let's prevent the second ioctl(ATMARP_MKIP) by checking vcc->user_back, which is allocated by the first call as clip_vcc. Note also that we use lock_sock() to prevent racy calls. [0]: BUG: TASK stack guard page was hit at ffffc9000d66fff8 (stack is ffffc9000d670000..ffffc9000d678000) Oops: stack guard page: 0000 [#1] SMP KASAN NOPTI CPU: 0 UID: 0 PID: 5322 Comm: syz.0.0 Not tainted 6.16.0-rc4-syzkaller #0 PREEMPT(full) Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 RIP: 0010:clip_push+0x5/0x720 net/atm/clip.c:191 Code: e0 8f aa 8c e8 1c ad 5b fa eb ae 66 2e 0f 1f 84 00 00 00 00 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 55 <41> 57 41 56 41 55 41 54 53 48 83 ec 20 48 89 f3 49 89 fd 48 bd 00 RSP: 0018:ffffc9000d670000 EFLAGS: 00010246 RAX: 1ffff1100235a4a5 RBX: ffff888011ad2508 RCX: ffff8880003c0000 RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff888037f01000 RBP: dffffc0000000000 R08: ffffffff8fa104f7 R09: 1ffffffff1f4209e R10: dffffc0000000000 R11: ffffffff8a99b300 R12: ffffffff8a99b300 R13: ffff888037f01000 R14: ffff888011ad2500 R15: ffff888037f01578 FS: 000055557ab6d500(0000) GS:ffff88808d250000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: ffffc9000d66fff8 CR3: 0000000043172000 CR4: 0000000000352ef0 Call Trace: <TASK> clip_push+0x6dc/0x720 net/atm/clip.c:200 clip_push+0x6dc/0x720 net/atm/clip.c:200 clip_push+0x6dc/0x720 net/atm/clip.c:200 ... clip_push+0x6dc/0x720 net/atm/clip.c:200 clip_push+0x6dc/0x720 net/atm/clip.c:200 clip_push+0x6dc/0x720 net/atm/clip.c:200 vcc_destroy_socket net/atm/common.c:183 [inline] vcc_release+0x157/0x460 net/atm/common.c:205 __sock_release net/socket.c:647 [inline] sock_close+0xc0/0x240 net/socket.c:1391 __fput+0x449/0xa70 fs/file_table.c:465 task_work_run+0x1d1/0x260 kernel/task_work.c:227 resume_user_mode_work include/linux/resume_user_mode.h:50 [inline] exit_to_user_mode_loop+0xec/0x110 kernel/entry/common.c:114 exit_to_user_mode_prepare include/linux/entry-common.h:330 [inline] syscall_exit_to_user_mode_work include/linux/entry-common.h:414 [inline] syscall_exit_to_user_mode include/linux/entry-common.h:449 [inline] do_syscall_64+0x2bd/0x3b0 arch/x86/entry/syscall_64.c:100 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7ff31c98e929 Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007fffb5aa1f78 EFLAGS: 00000246 ORIG_RAX: 00000000000001b4 RAX: 0000000000000000 RBX: 0000000000012747 RCX: 00007ff31c98e929 RDX: 0000000000000000 RSI: 000000000000001e RDI: 0000000000000003 RBP: 00007ff31cbb7ba0 R08: 0000000000000001 R09: 0000000db5aa226f R10: 00007ff31c7ff030 R11: 0000000000000246 R12: 00007ff31cbb608c R13: 00007ff31cbb6080 R14: ffffffffffffffff R15: 00007fffb5aa2090 </TASK> Modules linked in:",,"[{""url"":""https://git.kernel.org/stable/c/024876b247a882972095b22087734dcd23396a4e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/125166347d5676466d368aadc0bbc31ee7714352"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1579a2777cb914a249de22c789ba4d41b154509f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f61b997fe014bbfcc208a9fcbd363a1fe7e3a31"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5641019dfbaee5e85fe093b590f0451c9dd4d6f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c489f3283dbfc0f3c00c312149cae90d27552c45"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/df0312d8859763aa15b8b56ac151a1ea4a4e5b88"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f493f31a63847624fd3199ac836a8bd8828e50e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38460,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:31.787,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: atm: clip: Fix potential null-ptr-deref in to_atmarpd(). atmarpd is protected by RTNL since commit f3a0592b37b8 (""[ATM]: clip causes unregister hang""). However, it is not enough because to_atmarpd() is called without RTNL, especially clip_neigh_solicit() / neigh_ops->solicit() is unsleepable. Also, there is no RTNL dependency around atmarpd. Let's use a private mutex and RCU to protect access to atmarpd in to_atmarpd().",,"[{""url"":""https://git.kernel.org/stable/c/06935c50cfa3ac57cce80bba67b6d38ec1406e92"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3251ce3979f41bd228f77a7615f9dd616d06a110"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/36caab990b69ef4eec1d81c52a19f080b7daa059"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/706cc36477139c1616a9b2b96610a8bb520b7119"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/70eac9ba7ce25d99c1d99bbf4ddb058940f631f9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a4c5785feb979cd996a99cfaad8bf353b2e79301"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee4d9e4ddf3f9c4ee2ec0a3aad6196ee36d30e57"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f58e4270c73e7f086322978d585ea67c8076ce49"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38461,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:31.923,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: vsock: Fix transport_* TOCTOU Transport assignment may race with module unload. Protect new_transport from becoming a stale pointer. This also takes care of an insecure call in vsock_use_local_transport(); add a lockdep assert. BUG: unable to handle page fault for address: fffffbfff8056000 Oops: Oops: 0000 [#1] SMP KASAN RIP: 0010:vsock_assign_transport+0x366/0x600 Call Trace: vsock_connect+0x59c/0xc40 __sys_connect+0xe8/0x100 __x64_sys_connect+0x6e/0xc0 do_syscall_64+0x92/0x1c0 entry_SYSCALL_64_after_hwframe+0x4b/0x53",,"[{""url"":""https://git.kernel.org/stable/c/36a439049b34cca0b3661276049b84a1f76cc21a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/687aa0c5581b8d4aa87fd92973e4ee576b550cdf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7b73bddf54777fb62d4d8c7729d0affe6df04477"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8667e8d0eb46bc54fdae30ba2f4786407d3d88eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ce53e744f18e73059d3124070e960f3aa9902bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d24bb6780282b0255b9929abe5e8f98007e2c6e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ae2c712ba39c7007de63cb0c75b51ce1caaf1da5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38462,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:32.117,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: vsock: Fix transport_{g2h,h2g} TOCTOU vsock_find_cid() and vsock_dev_do_ioctl() may race with module unload. transport_{g2h,h2g} may become NULL after the NULL check. Introduce vsock_transport_local_cid() to protect from a potential null-ptr-deref. KASAN: null-ptr-deref in range [0x0000000000000118-0x000000000000011f] RIP: 0010:vsock_find_cid+0x47/0x90 Call Trace: __vsock_bind+0x4b2/0x720 vsock_bind+0x90/0xe0 __sys_bind+0x14d/0x1e0 __x64_sys_bind+0x6e/0xc0 do_syscall_64+0x92/0x1c0 entry_SYSCALL_64_after_hwframe+0x4b/0x53 KASAN: null-ptr-deref in range [0x0000000000000118-0x000000000000011f] RIP: 0010:vsock_dev_do_ioctl.isra.0+0x58/0xf0 Call Trace: __x64_sys_ioctl+0x12d/0x190 do_syscall_64+0x92/0x1c0 entry_SYSCALL_64_after_hwframe+0x4b/0x53",,"[{""url"":""https://git.kernel.org/stable/c/209fd720838aaf1420416494c5505096478156b4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3734d78210cceb2ee5615719a62a5c55ed381ff8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/401239811fa728fcdd53e360a91f157ffd23e1f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5752d8dbb3dfd7f1a9faf0f65377e60826ea9a17"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6a1bcab67bea797d83aa9dd948a0ac6ed52d121d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/80d7dc15805a93d520a249ac6d13d4f4df161c1b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c5496ee685c48ed1cc183cd4263602579bb4a615"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38463,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:32.253,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tcp: Correct signedness in skb remaining space calculation Syzkaller reported a bug [1] where sk->sk_forward_alloc can overflow. When we send data, if an skb exists at the tail of the write queue, the kernel will attempt to append the new data to that skb. However, the code that checks for available space in the skb is flawed: ''' copy = size_goal - skb->len ''' The types of the variables involved are: ''' copy: ssize_t (s64 on 64-bit systems) size_goal: int skb->len: unsigned int ''' Due to C's type promotion rules, the signed size_goal is converted to an unsigned int to match skb->len before the subtraction. The result is an unsigned int. When this unsigned int result is then assigned to the s64 copy variable, it is zero-extended, preserving its non-negative value. Consequently, copy is always >= 0. Assume we are sending 2GB of data and size_goal has been adjusted to a value smaller than skb->len. The subtraction will result in copy holding a very large positive integer. In the subsequent logic, this large value is used to update sk->sk_forward_alloc, which can easily cause it to overflow. The syzkaller reproducer uses TCP_REPAIR to reliably create this condition. However, this can also occur in real-world scenarios. The tcp_bound_to_half_wnd() function can also reduce size_goal to a small value. This would cause the subsequent tcp_wmem_schedule() to set sk->sk_forward_alloc to a value close to INT_MAX. Further memory allocation requests would then cause sk_forward_alloc to wrap around and become negative. [1]: https://syzkaller.appspot.com/bug?extid=de6565462ab540f50e47",,"[{""url"":""https://git.kernel.org/stable/c/62e6160cfb5514787bda833d466509edc38fde23"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/81373cd1d72d87c7d844d4454a526b8f53e72d00"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9f164fa6bb09fbcc60fa5c3ff551ce9eec1befd7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3a5f2871adc0c61c61869f37f3e697d97f03d8c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38464,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:32.383,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tipc: Fix use-after-free in tipc_conn_close(). syzbot reported a null-ptr-deref in tipc_conn_close() during netns dismantle. [0] tipc_topsrv_stop() iterates tipc_net(net)->topsrv->conn_idr and calls tipc_conn_close() for each tipc_conn. The problem is that tipc_conn_close() is called after releasing the IDR lock. At the same time, there might be tipc_conn_recv_work() running and it could call tipc_conn_close() for the same tipc_conn and release its last ->kref. Once we release the IDR lock in tipc_topsrv_stop(), there is no guarantee that the tipc_conn is alive. Let's hold the ref before releasing the lock and put the ref after tipc_conn_close() in tipc_topsrv_stop(). [0]: BUG: KASAN: use-after-free in tipc_conn_close+0x122/0x140 net/tipc/topsrv.c:165 Read of size 8 at addr ffff888099305a08 by task kworker/u4:3/435 CPU: 0 PID: 435 Comm: kworker/u4:3 Not tainted 4.19.204-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: netns cleanup_net Call Trace: __dump_stack lib/dump_stack.c:77 [inline] dump_stack+0x1fc/0x2ef lib/dump_stack.c:118 print_address_description.cold+0x54/0x219 mm/kasan/report.c:256 kasan_report_error.cold+0x8a/0x1b9 mm/kasan/report.c:354 kasan_report mm/kasan/report.c:412 [inline] __asan_report_load8_noabort+0x88/0x90 mm/kasan/report.c:433 tipc_conn_close+0x122/0x140 net/tipc/topsrv.c:165 tipc_topsrv_stop net/tipc/topsrv.c:701 [inline] tipc_topsrv_exit_net+0x27b/0x5c0 net/tipc/topsrv.c:722 ops_exit_list+0xa5/0x150 net/core/net_namespace.c:153 cleanup_net+0x3b4/0x8b0 net/core/net_namespace.c:553 process_one_work+0x864/0x1570 kernel/workqueue.c:2153 worker_thread+0x64c/0x1130 kernel/workqueue.c:2296 kthread+0x33f/0x460 kernel/kthread.c:259 ret_from_fork+0x24/0x30 arch/x86/entry/entry_64.S:415 Allocated by task 23: kmem_cache_alloc_trace+0x12f/0x380 mm/slab.c:3625 kmalloc include/linux/slab.h:515 [inline] kzalloc include/linux/slab.h:709 [inline] tipc_conn_alloc+0x43/0x4f0 net/tipc/topsrv.c:192 tipc_topsrv_accept+0x1b5/0x280 net/tipc/topsrv.c:470 process_one_work+0x864/0x1570 kernel/workqueue.c:2153 worker_thread+0x64c/0x1130 kernel/workqueue.c:2296 kthread+0x33f/0x460 kernel/kthread.c:259 ret_from_fork+0x24/0x30 arch/x86/entry/entry_64.S:415 Freed by task 23: __cache_free mm/slab.c:3503 [inline] kfree+0xcc/0x210 mm/slab.c:3822 tipc_conn_kref_release net/tipc/topsrv.c:150 [inline] kref_put include/linux/kref.h:70 [inline] conn_put+0x2cd/0x3a0 net/tipc/topsrv.c:155 process_one_work+0x864/0x1570 kernel/workqueue.c:2153 worker_thread+0x64c/0x1130 kernel/workqueue.c:2296 kthread+0x33f/0x460 kernel/kthread.c:259 ret_from_fork+0x24/0x30 arch/x86/entry/entry_64.S:415 The buggy address belongs to the object at ffff888099305a00 which belongs to the cache kmalloc-512 of size 512 The buggy address is located 8 bytes inside of 512-byte region [ffff888099305a00, ffff888099305c00) The buggy address belongs to the page: page:ffffea000264c140 count:1 mapcount:0 mapping:ffff88813bff0940 index:0x0 flags: 0xfff00000000100(slab) raw: 00fff00000000100 ffffea00028b6b88 ffffea0002cd2b08 ffff88813bff0940 raw: 0000000000000000 ffff888099305000 0000000100000006 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffff888099305900: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ffff888099305980: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc >ffff888099305a00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ^ ffff888099305a80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ffff888099305b00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb",,"[{""url"":""https://git.kernel.org/stable/c/03dcdd2558e1e55bf843822fe4363dcb48743f2b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/15a6f4971e2f157d57e09ea748d1fbc714277aa4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1dbf7cd2454a28b1da700085b99346b5445aeabb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3b89e17b2fd64012682bed158d9eb3d2e96dec42"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/50aa2d121bc2cfe2d825f8a331ea75dfaaab6a50"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/667eeab4999e981c96b447a4df5f20bdf5c26f13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be4b8392da7978294f2f368799d29dd509fb6c4d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dab8ded2e5ff41012a6ff400b44dbe76ccf3592a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38465,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:32.527,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netlink: Fix wraparounds of sk->sk_rmem_alloc. Netlink has this pattern in some places if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf) atomic_add(skb->truesize, &sk->sk_rmem_alloc); , which has the same problem fixed by commit 5a465a0da13e (""udp: Fix multiple wraparounds of sk->sk_rmem_alloc.""). For example, if we set INT_MAX to SO_RCVBUFFORCE, the condition is always false as the two operands are of int. Then, a single socket can eat as many skb as possible until OOM happens, and we can see multiple wraparounds of sk->sk_rmem_alloc. Let's fix it by using atomic_add_return() and comparing the two variables as unsigned int. Before: [root@fedora ~]# ss -f netlink Recv-Q Send-Q Local Address:Port Peer Address:Port -1668710080 0 rtnl:nl_wraparound/293 * After: [root@fedora ~]# ss -f netlink Recv-Q Send-Q Local Address:Port Peer Address:Port 2147483072 0 rtnl:nl_wraparound/290 * ^ `--- INT_MAX - 576",,"[{""url"":""https://git.kernel.org/stable/c/4b8e18af7bea92f8b7fb92d40aeae729209db250"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/55baecb9eb90238f60a8350660d6762046ebd3bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/76602d8e13864524382b0687dc32cd8f19164d5a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9da025150b7c14a8390fc06aea314c0a4011e82c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ae8f160e7eb24240a2a79fc4c815c6a0d4ee16cc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c4ceaac5c5ba0b992ee1dc88e2a02421549e5c98"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd7ff61bfffd7000143c42bbffb85eeb792466d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd69af06101090eaa60b3d216ae715f9c0a58e5b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38466,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:32.673,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: perf: Revert to requiring CAP_SYS_ADMIN for uprobes Jann reports that uprobes can be used destructively when used in the middle of an instruction. The kernel only verifies there is a valid instruction at the requested offset, but due to variable instruction length cannot determine if this is an instruction as seen by the intended execution stream. Additionally, Mark Rutland notes that on architectures that mix data in the text segment (like arm64), a similar things can be done if the data word is 'mistaken' for an instruction. As such, require CAP_SYS_ADMIN for uprobes.",,"[{""url"":""https://git.kernel.org/stable/c/183bdb89af1b5193b1d1d9316986053b15ca6fa4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e8bf7bc6aa6f583336c2fda280b6cea0aed5612"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a0a8009083e569b5526c64f7d3f2a62baca95164"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba677dbe77af5ffe6204e0f3f547f3ba059c6302"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c0aec35f861fa746ca45aa816161c74352e6ada8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d5074256b642cdeb46a70ce2f15193e766edca68"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d7ef1afd5b3f43f4924326164cee5397b66abd9c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38467,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-25T16:15:33.267,2025-07-29T14:14:55.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/exynos: exynos7_drm_decon: add vblank check in IRQ handling If there's support for another console device (such as a TTY serial), the kernel occasionally panics during boot. The panic message and a relevant snippet of the call stack is as follows: Unable to handle kernel NULL pointer dereference at virtual address 000000000000000 Call trace: drm_crtc_handle_vblank+0x10/0x30 (P) decon_irq_handler+0x88/0xb4 [...] Otherwise, the panics don't happen. This indicates that it's some sort of race condition. Add a check to validate if the drm device can handle vblanks before calling drm_crtc_handle_vblank() to avoid this.",,"[{""url"":""https://git.kernel.org/stable/c/391e5ea5b877230b844c9bd8bbcd91b681b1ce2d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/87825fbd1e176cd5b896940f3959e7c9a916945d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/996740652e620ef8ee1e5c65832cf2ffa498577d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a2130463fc9451005660b0eda7b61d5f746f7d74"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a40a35166f7e4f6dcd4b087d620c8228922dcb0a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b4e72c0bf878f02faa00a7dc7c9ffc4ff7c116a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b846350aa272de99bf6fecfa6b08e64ebfb13173"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e9d9b25f376737b81f06de9c5aa422b488f47184"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38468,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:28.503,2025-08-28T15:15:49.033,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/sched: Return NULL when htb_lookup_leaf encounters an empty rbtree htb_lookup_leaf has a BUG_ON that can trigger with the following: tc qdisc del dev lo root tc qdisc add dev lo root handle 1: htb default 1 tc class add dev lo parent 1: classid 1:1 htb rate 64bit tc qdisc add dev lo parent 1:1 handle 2: netem tc qdisc add dev lo parent 2:1 handle 3: blackhole ping -I lo -c1 -W0.001 127.0.0.1 The root cause is the following: 1. htb_dequeue calls htb_dequeue_tree which calls the dequeue handler on the selected leaf qdisc 2. netem_dequeue calls enqueue on the child qdisc 3. blackhole_enqueue drops the packet and returns a value that is not just NET_XMIT_SUCCESS 4. Because of this, netem_dequeue calls qdisc_tree_reduce_backlog, and since qlen is now 0, it calls htb_qlen_notify -> htb_deactivate -> htb_deactiviate_prios -> htb_remove_class_from_row -> htb_safe_rb_erase 5. As this is the only class in the selected hprio rbtree, __rb_change_child in __rb_erase_augmented sets the rb_root pointer to NULL 6. Because blackhole_dequeue returns NULL, netem_dequeue returns NULL, which causes htb_dequeue_tree to call htb_lookup_leaf with the same hprio rbtree, and fail the BUG_ON The function graph for this scenario is shown here: 0) | htb_enqueue() { 0) + 13.635 us | netem_enqueue(); 0) 4.719 us | htb_activate_prios(); 0) # 2249.199 us | } 0) | htb_dequeue() { 0) 2.355 us | htb_lookup_leaf(); 0) | netem_dequeue() { 0) + 11.061 us | blackhole_enqueue(); 0) | qdisc_tree_reduce_backlog() { 0) | qdisc_lookup_rcu() { 0) 1.873 us | qdisc_match_from_root(); 0) 6.292 us | } 0) 1.894 us | htb_search(); 0) | htb_qlen_notify() { 0) 2.655 us | htb_deactivate_prios(); 0) 6.933 us | } 0) + 25.227 us | } 0) 1.983 us | blackhole_dequeue(); 0) + 86.553 us | } 0) # 2932.761 us | qdisc_warn_nonwc(); 0) | htb_lookup_leaf() { 0) | BUG_ON(); ------------------------------------------ The full original bug report can be seen here [1]. We can fix this just by returning NULL instead of the BUG_ON, as htb_dequeue_tree returns NULL when htb_lookup_leaf returns NULL. [1] https://lore.kernel.org/netdev/pF5XOOIim0IuEfhI-SOxTgRvNoDwuux7UHKnE_Y5-zVd4wmGvNk2ceHjKb8ORnzw0cGwfmVu42g9dL7XyJLf1NEzaztboTWcm0Ogxuojoeo=@willsroot.io/",,"[{""url"":""https://git.kernel.org/stable/c/0e1d5d9b5c5966e2e42e298670808590db5ed628"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3691f84269a23f7edd263e9b6edbc27b7ae332f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5c0506cd1b1a3b145bda2612bbf7fe78d186c355"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ff2d83ecf2619060f30ecf9fad4f2a700fca344"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/850226aef8d28a00cf966ef26d2f8f2bff344535"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/890a5d423ef0a7bd13447ceaffad21189f557301"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e5c480dc62a3025b8428d4818e722da30ad6804f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fed3570e548a6c9f95c5f4c9e1a7afc1679fd90d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38469,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:28.640,2025-07-29T14:14:29.590,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: KVM: x86/xen: Fix cleanup logic in emulation of Xen schedop poll hypercalls kvm_xen_schedop_poll does a kmalloc_array() when a VM polls the host for more than one event channel potr (nr_ports > 1). After the kmalloc_array(), the error paths need to go through the ""out"" label, but the call to kvm_read_guest_virt() does not. [Adjusted commit message. - Paolo]",,"[{""url"":""https://git.kernel.org/stable/c/061c553c66bc1638c280739999224c8000fd4602"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ee59c38ae7369ad1f7b846e05633ccf0d159fab"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a53249d149f48b558368c5338b9921b76a12f8c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd627ac8a5cff4d45269f164b13ddddc0726f2cc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38470,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:28.760,2025-08-28T15:15:49.170,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: vlan: fix VLAN 0 refcount imbalance of toggling filtering during runtime Assuming the ""rx-vlan-filter"" feature is enabled on a net device, the 8021q module will automatically add or remove VLAN 0 when the net device is put administratively up or down, respectively. There are a couple of problems with the above scheme. The first problem is a memory leak that can happen if the ""rx-vlan-filter"" feature is disabled while the device is running: # ip link add bond1 up type bond mode 0 # ethtool -K bond1 rx-vlan-filter off # ip link del dev bond1 When the device is put administratively down the ""rx-vlan-filter"" feature is disabled, so the 8021q module will not remove VLAN 0 and the memory will be leaked [1]. Another problem that can happen is that the kernel can automatically delete VLAN 0 when the device is put administratively down despite not adding it when the device was put administratively up since during that time the ""rx-vlan-filter"" feature was disabled. null-ptr-unref or bug_on[2] will be triggered by unregister_vlan_dev() for refcount imbalance if toggling filtering during runtime: $ ip link add bond0 type bond mode 0 $ ip link add link bond0 name vlan0 type vlan id 0 protocol 802.1q $ ethtool -K bond0 rx-vlan-filter off $ ifconfig bond0 up $ ethtool -K bond0 rx-vlan-filter on $ ifconfig bond0 down $ ip link del vlan0 Root cause is as below: step1: add vlan0 for real_dev, such as bond, team. register_vlan_dev vlan_vid_add(real_dev,htons(ETH_P_8021Q),0) //refcnt=1 step2: disable vlan filter feature and enable real_dev step3: change filter from 0 to 1 vlan_device_event vlan_filter_push_vids ndo_vlan_rx_add_vid //No refcnt added to real_dev vlan0 step4: real_dev down vlan_device_event vlan_vid_del(dev, htons(ETH_P_8021Q), 0); //refcnt=0 vlan_info_rcu_free //free vlan0 step5: delete vlan0 unregister_vlan_dev BUG_ON(!vlan_info); //vlan_info is null Fix both problems by noting in the VLAN info whether VLAN 0 was automatically added upon NETDEV_UP and based on that decide whether it should be deleted upon NETDEV_DOWN, regardless of the state of the ""rx-vlan-filter"" feature. [1] unreferenced object 0xffff8880068e3100 (size 256): comm ""ip"", pid 384, jiffies 4296130254 hex dump (first 32 bytes): 00 20 30 0d 80 88 ff ff 00 00 00 00 00 00 00 00 . 0............. 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ backtrace (crc 81ce31fa): __kmalloc_cache_noprof+0x2b5/0x340 vlan_vid_add+0x434/0x940 vlan_device_event.cold+0x75/0xa8 notifier_call_chain+0xca/0x150 __dev_notify_flags+0xe3/0x250 rtnl_configure_link+0x193/0x260 rtnl_newlink_create+0x383/0x8e0 __rtnl_newlink+0x22c/0xa40 rtnl_newlink+0x627/0xb00 rtnetlink_rcv_msg+0x6fb/0xb70 netlink_rcv_skb+0x11f/0x350 netlink_unicast+0x426/0x710 netlink_sendmsg+0x75a/0xc20 __sock_sendmsg+0xc1/0x150 ____sys_sendmsg+0x5aa/0x7b0 ___sys_sendmsg+0xfc/0x180 [2] kernel BUG at net/8021q/vlan.c:99! Oops: invalid opcode: 0000 [#1] SMP KASAN PTI CPU: 0 UID: 0 PID: 382 Comm: ip Not tainted 6.16.0-rc3 #61 PREEMPT(voluntary) Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 RIP: 0010:unregister_vlan_dev (net/8021q/vlan.c:99 (discriminator 1)) RSP: 0018:ffff88810badf310 EFLAGS: 00010246 RAX: 0000000000000000 RBX: ffff88810da84000 RCX: ffffffffb47ceb9a RDX: dffffc0000000000 RSI: 0000000000000008 RDI: ffff88810e8b43c8 RBP: 0000000000000000 R08: 0000000000000000 R09: fffffbfff6cefe80 R10: ffffffffb677f407 R11: ffff88810badf3c0 R12: ffff88810e8b4000 R13: 0000000000000000 R14: ffff88810642a5c0 R15: 000000000000017e FS: 00007f1ff68c20c0(0000) GS:ffff888163a24000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f1ff5dad240 CR3: 0000000107e56000 CR4: 00000000000006f0 Call Trace: <TASK ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/047b61a24d7c866c502aeeea482892969a68f216"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/35142b3816832889e50164d993018ea5810955ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/579d4f9ca9a9a605184a9b162355f6ba131f678d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8984bcbd1edf5bee5be06ad771d157333b790c33"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/93715aa2d80e6c5cea1bb486321fc4585076928b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba48d3993af23753e1f1f01c8d592de9c7785f24"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bb515c41306454937464da055609b5fb0a27821b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d43ef15bf4856c8c4c6c3572922331a5f06deb77"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38471,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:28.890,2025-07-29T14:14:29.590,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tls: always refresh the queue when reading sock After recent changes in net-next TCP compacts skbs much more aggressively. This unearthed a bug in TLS where we may try to operate on an old skb when checking if all skbs in the queue have matching decrypt state and geometry. BUG: KASAN: slab-use-after-free in tls_strp_check_rcv+0x898/0x9a0 [tls] (net/tls/tls_strp.c:436 net/tls/tls_strp.c:530 net/tls/tls_strp.c:544) Read of size 4 at addr ffff888013085750 by task tls/13529 CPU: 2 UID: 0 PID: 13529 Comm: tls Not tainted 6.16.0-rc5-virtme Call Trace: kasan_report+0xca/0x100 tls_strp_check_rcv+0x898/0x9a0 [tls] tls_rx_rec_wait+0x2c9/0x8d0 [tls] tls_sw_recvmsg+0x40f/0x1aa0 [tls] inet_recvmsg+0x1c3/0x1f0 Always reload the queue, fast path is to have the record in the queue when we wake, anyway (IOW the path going down ""if !strp->stm.full_len"").",,"[{""url"":""https://git.kernel.org/stable/c/1f3a429c21e0e43e8b8c55d30701e91411a4df02"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4ab26bce3969f8fd925fe6f6f551e4d1a508c68b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/730fed2ff5e259495712518e18d9f521f61972bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c76f6f437c46b2390888e0e1dc7aafafa9f4e0c6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cdb767915fc9a15d88d19d52a1455f1dc3e5ddc8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38472,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:29.003,2025-07-29T14:14:29.590,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: nf_conntrack: fix crash due to removal of uninitialised entry A crash in conntrack was reported while trying to unlink the conntrack entry from the hash bucket list: [exception RIP: __nf_ct_delete_from_lists+172] [..] #7 [ff539b5a2b043aa0] nf_ct_delete at ffffffffc124d421 [nf_conntrack] #8 [ff539b5a2b043ad0] nf_ct_gc_expired at ffffffffc124d999 [nf_conntrack] #9 [ff539b5a2b043ae0] __nf_conntrack_find_get at ffffffffc124efbc [nf_conntrack] [..] The nf_conn struct is marked as allocated from slab but appears to be in a partially initialised state: ct hlist pointer is garbage; looks like the ct hash value (hence crash). ct->status is equal to IPS_CONFIRMED|IPS_DYING, which is expected ct->timeout is 30000 (=30s), which is unexpected. Everything else looks like normal udp conntrack entry. If we ignore ct->status and pretend its 0, the entry matches those that are newly allocated but not yet inserted into the hash: - ct hlist pointers are overloaded and store/cache the raw tuple hash - ct->timeout matches the relative time expected for a new udp flow rather than the absolute 'jiffies' value. If it were not for the presence of IPS_CONFIRMED, __nf_conntrack_find_get() would have skipped the entry. Theory is that we did hit following race: cpu x cpu y cpu z found entry E found entry E E is expired <preemption> nf_ct_delete() return E to rcu slab init_conntrack E is re-inited, ct->status set to 0 reply tuplehash hnnode.pprev stores hash value. cpu y found E right before it was deleted on cpu x. E is now re-inited on cpu z. cpu y was preempted before checking for expiry and/or confirm bit. ->refcnt set to 1 E now owned by skb ->timeout set to 30000 If cpu y were to resume now, it would observe E as expired but would skip E due to missing CONFIRMED bit. nf_conntrack_confirm gets called sets: ct->status |= CONFIRMED This is wrong: E is not yet added to hashtable. cpu y resumes, it observes E as expired but CONFIRMED: <resumes> nf_ct_expired() -> yes (ct->timeout is 30s) confirmed bit set. cpu y will try to delete E from the hashtable: nf_ct_delete() -> set DYING bit __nf_ct_delete_from_lists Even this scenario doesn't guarantee a crash: cpu z still holds the table bucket lock(s) so y blocks: wait for spinlock held by z CONFIRMED is set but there is no guarantee ct will be added to hash: ""chaintoolong"" or ""clash resolution"" logic both skip the insert step. reply hnnode.pprev still stores the hash value. unlocks spinlock return NF_DROP <unblocks, then crashes on hlist_nulls_del_rcu pprev> In case CPU z does insert the entry into the hashtable, cpu y will unlink E again right away but no crash occurs. Without 'cpu y' race, 'garbage' hlist is of no consequence: ct refcnt remains at 1, eventually skb will be free'd and E gets destroyed via: nf_conntrack_put -> nf_conntrack_destroy -> nf_ct_destroy. To resolve this, move the IPS_CONFIRMED assignment after the table insertion but before the unlock. Pablo points out that the confirm-bit-store could be reordered to happen before hlist add resp. the timeout fixup, so switch to set_bit and before_atomic memory barrier to prevent this. It doesn't matter if other CPUs can observe a newly inserted entry right before the CONFIRMED bit was set: Such event cannot be distinguished from above ""E is the old incarnation"" case: the entry will be skipped. Also change nf_ct_should_gc() to first check the confirmed bit. The gc sequence is: 1. Check if entry has expired, if not skip to next entry 2. Obtain a reference to the expired entry. 3. Call nf_ct_should_gc() to double-check step 1. nf_ct_should_gc() is thus called only for entries that already failed an expiry check. After this patch, once the confirmed bit check pas ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/2d72afb340657f03f7261e9243b44457a9228ac7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/76179961c423cd698080b5e4d5583cf7f4fcdde9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/938ce0e8422d3793fe30df2ed0e37f6bc0598379"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a47ef874189d47f934d0809ae738886307c0ea22"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc38c249c622ff5e3011b8845fd49dbfd9289afc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38473,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:29.123,2025-08-28T15:15:49.310,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: Fix null-ptr-deref in l2cap_sock_resume_cb() syzbot reported null-ptr-deref in l2cap_sock_resume_cb(). [0] l2cap_sock_resume_cb() has a similar problem that was fixed by commit 1bff51ea59a9 (""Bluetooth: fix use-after-free error in lock_sock_nested()""). Since both l2cap_sock_kill() and l2cap_sock_resume_cb() are executed under l2cap_sock_resume_cb(), we can avoid the issue simply by checking if chan->data is NULL. Let's not access to the killed socket in l2cap_sock_resume_cb(). [0]: BUG: KASAN: null-ptr-deref in instrument_atomic_write include/linux/instrumented.h:82 [inline] BUG: KASAN: null-ptr-deref in clear_bit include/asm-generic/bitops/instrumented-atomic.h:41 [inline] BUG: KASAN: null-ptr-deref in l2cap_sock_resume_cb+0xb4/0x17c net/bluetooth/l2cap_sock.c:1711 Write of size 8 at addr 0000000000000570 by task kworker/u9:0/52 CPU: 1 UID: 0 PID: 52 Comm: kworker/u9:0 Not tainted 6.16.0-rc4-syzkaller-g7482bb149b9f #0 PREEMPT Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025 Workqueue: hci0 hci_rx_work Call trace: show_stack+0x2c/0x3c arch/arm64/kernel/stacktrace.c:501 (C) __dump_stack+0x30/0x40 lib/dump_stack.c:94 dump_stack_lvl+0xd8/0x12c lib/dump_stack.c:120 print_report+0x58/0x84 mm/kasan/report.c:524 kasan_report+0xb0/0x110 mm/kasan/report.c:634 check_region_inline mm/kasan/generic.c:-1 [inline] kasan_check_range+0x264/0x2a4 mm/kasan/generic.c:189 __kasan_check_write+0x20/0x30 mm/kasan/shadow.c:37 instrument_atomic_write include/linux/instrumented.h:82 [inline] clear_bit include/asm-generic/bitops/instrumented-atomic.h:41 [inline] l2cap_sock_resume_cb+0xb4/0x17c net/bluetooth/l2cap_sock.c:1711 l2cap_security_cfm+0x524/0xea0 net/bluetooth/l2cap_core.c:7357 hci_auth_cfm include/net/bluetooth/hci_core.h:2092 [inline] hci_auth_complete_evt+0x2e8/0xa4c net/bluetooth/hci_event.c:3514 hci_event_func net/bluetooth/hci_event.c:7511 [inline] hci_event_packet+0x650/0xe9c net/bluetooth/hci_event.c:7565 hci_rx_work+0x320/0xb18 net/bluetooth/hci_core.c:4070 process_one_work+0x7e8/0x155c kernel/workqueue.c:3238 process_scheduled_works kernel/workqueue.c:3321 [inline] worker_thread+0x958/0xed8 kernel/workqueue.c:3402 kthread+0x5fc/0x75c kernel/kthread.c:464 ret_from_fork+0x10/0x20 arch/arm64/kernel/entry.S:847",,"[{""url"":""https://git.kernel.org/stable/c/262cd18f5f7ede6a586580cadc5d0799e52e2e7c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2b27b389006623673e8cfff4ce1e119cce640b05"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3a4eca2a1859955c65f07a570156bd2d9048ce33"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6d63901dcd592a1e3f71d7c6d78f9be5e8d7eef0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a0075accbf0d76c2dad1ad3993d2e944505d99a0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac3a8147bb24314fb3e84986590148e79f9872ec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b97be7ee8a1cd96b89817cbd64a9f5cc16c17d08"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c4f16f6b071a74ac7eefe5c28985285cbbe2cd96"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38474,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:29.247,2025-08-28T15:15:49.450,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: net: sierra: check for no status endpoint The driver checks for having three endpoints and having bulk in and out endpoints, but not that the third endpoint is interrupt input. Rectify the omission.",,"[{""url"":""https://git.kernel.org/stable/c/0a263ccb905b4ae2af381cd4280bd8d2477b98b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c4ca3c46167518f8534ed70f6e3b4bf86c4d158"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5408cc668e596c81cdd29e137225432aa40d1785"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5849980faea1c792d1d5e54fdbf1e69ac0a9bfb9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5dd6a441748dad2f02e27b256984ca0b2d4546b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/65c666aff44eb7f9079c55331abd9687fb77ba2d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6a238c4126eb3ddb495d3f960193ca5bb778d92"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bfe8ef373986e8f185d3d6613eb1801a8749837a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38475,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:29.367,2025-07-29T14:14:29.590,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: smc: Fix various oops due to inet_sock type confusion. syzbot reported weird splats [0][1] in cipso_v4_sock_setattr() while freeing inet_sk(sk)->inet_opt. The address was freed multiple times even though it was read-only memory. cipso_v4_sock_setattr() did nothing wrong, and the root cause was type confusion. The cited commit made it possible to create smc_sock as an INET socket. The issue is that struct smc_sock does not have struct inet_sock as the first member but hijacks AF_INET and AF_INET6 sk_family, which confuses various places. In this case, inet_sock.inet_opt was actually smc_sock.clcsk_data_ready(), which is an address of a function in the text segment. $ pahole -C inet_sock vmlinux struct inet_sock { ... struct ip_options_rcu * inet_opt; /* 784 8 */ $ pahole -C smc_sock vmlinux struct smc_sock { ... void (*clcsk_data_ready)(struct sock *); /* 784 8 */ The same issue for another field was reported before. [2][3] At that time, an ugly hack was suggested [4], but it makes both INET and SMC code error-prone and hard to change. Also, yet another variant was fixed by a hacky commit 98d4435efcbf3 (""net/smc: prevent NULL pointer dereference in txopt_get""). Instead of papering over the root cause by such hacks, we should not allow non-INET socket to reuse the INET infra. Let's add inet_sock as the first member of smc_sock. [0]: kvfree_call_rcu(): Double-freed call. rcu_head 000000006921da73 WARNING: CPU: 0 PID: 6718 at mm/slab_common.c:1956 kvfree_call_rcu+0x94/0x3f0 mm/slab_common.c:1955 Modules linked in: CPU: 0 UID: 0 PID: 6718 Comm: syz.0.17 Tainted: G W 6.16.0-rc4-syzkaller-g7482bb149b9f #0 PREEMPT Tainted: [W]=WARN Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025 pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : kvfree_call_rcu+0x94/0x3f0 mm/slab_common.c:1955 lr : kvfree_call_rcu+0x94/0x3f0 mm/slab_common.c:1955 sp : ffff8000a03a7730 x29: ffff8000a03a7730 x28: 00000000fffffff5 x27: 1fffe000184823d3 x26: dfff800000000000 x25: ffff0000c2411e9e x24: ffff0000dd88da00 x23: ffff8000891ac9a0 x22: 00000000ffffffea x21: ffff8000891ac9a0 x20: ffff8000891ac9a0 x19: ffff80008afc2480 x18: 00000000ffffffff x17: 0000000000000000 x16: ffff80008ae642c8 x15: ffff700011ede14c x14: 1ffff00011ede14c x13: 0000000000000004 x12: ffffffffffffffff x11: ffff700011ede14c x10: 0000000000ff0100 x9 : 5fa3c1ffaf0ff000 x8 : 5fa3c1ffaf0ff000 x7 : 0000000000000001 x6 : 0000000000000001 x5 : ffff8000a03a7078 x4 : ffff80008f766c20 x3 : ffff80008054d360 x2 : 0000000000000000 x1 : 0000000000000201 x0 : 0000000000000000 Call trace: kvfree_call_rcu+0x94/0x3f0 mm/slab_common.c:1955 (P) cipso_v4_sock_setattr+0x2f0/0x3f4 net/ipv4/cipso_ipv4.c:1914 netlbl_sock_setattr+0x240/0x334 net/netlabel/netlabel_kapi.c:1000 smack_netlbl_add+0xa8/0x158 security/smack/smack_lsm.c:2581 smack_inode_setsecurity+0x378/0x430 security/smack/smack_lsm.c:2912 security_inode_setsecurity+0x118/0x3c0 security/security.c:2706 __vfs_setxattr_noperm+0x174/0x5c4 fs/xattr.c:251 __vfs_setxattr_locked+0x1ec/0x218 fs/xattr.c:295 vfs_setxattr+0x158/0x2ac fs/xattr.c:321 do_setxattr fs/xattr.c:636 [inline] file_setxattr+0x1b8/0x294 fs/xattr.c:646 path_setxattrat+0x2ac/0x320 fs/xattr.c:711 __do_sys_fsetxattr fs/xattr.c:761 [inline] __se_sys_fsetxattr fs/xattr.c:758 [inline] __arm64_sys_fsetxattr+0xc0/0xdc fs/xattr.c:758 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline] invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151 el0_svc+0x58/0x180 arch/arm64/kernel/entry-common.c:879 el0t_64_sync_handler+0x84/0x12c arch/arm64/kernel/entry-common.c:898 el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600 [ ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/5b02e397929e5b13b969ef1f8e43c7951e2864f5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/60ada4fe644edaa6c2da97364184b0425e8aeaf5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/67a167a6b8b45607bc34aa541d1c75097d18d460"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38476,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:29.483,2025-08-28T15:15:49.590,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: rpl: Fix use-after-free in rpl_do_srh_inline(). Running lwt_dst_cache_ref_loop.sh in selftest with KASAN triggers the splat below [0]. rpl_do_srh_inline() fetches ipv6_hdr(skb) and accesses it after skb_cow_head(), which is illegal as the header could be freed then. Let's fix it by making oldhdr to a local struct instead of a pointer. [0]: [root@fedora net]# ./lwt_dst_cache_ref_loop.sh ... TEST: rpl (input) [ 57.631529] ================================================================== BUG: KASAN: slab-use-after-free in rpl_do_srh_inline.isra.0 (net/ipv6/rpl_iptunnel.c:174) Read of size 40 at addr ffff888122bf96d8 by task ping6/1543 CPU: 50 UID: 0 PID: 1543 Comm: ping6 Not tainted 6.16.0-rc5-01302-gfadd1e6231b1 #23 PREEMPT(voluntary) Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 Call Trace: <IRQ> dump_stack_lvl (lib/dump_stack.c:122) print_report (mm/kasan/report.c:409 mm/kasan/report.c:521) kasan_report (mm/kasan/report.c:221 mm/kasan/report.c:636) kasan_check_range (mm/kasan/generic.c:175 (discriminator 1) mm/kasan/generic.c:189 (discriminator 1)) __asan_memmove (mm/kasan/shadow.c:94 (discriminator 2)) rpl_do_srh_inline.isra.0 (net/ipv6/rpl_iptunnel.c:174) rpl_input (net/ipv6/rpl_iptunnel.c:201 net/ipv6/rpl_iptunnel.c:282) lwtunnel_input (net/core/lwtunnel.c:459) ipv6_rcv (./include/net/dst.h:471 (discriminator 1) ./include/net/dst.h:469 (discriminator 1) net/ipv6/ip6_input.c:79 (discriminator 1) ./include/linux/netfilter.h:317 (discriminator 1) ./include/linux/netfilter.h:311 (discriminator 1) net/ipv6/ip6_input.c:311 (discriminator 1)) __netif_receive_skb_one_core (net/core/dev.c:5967) process_backlog (./include/linux/rcupdate.h:869 net/core/dev.c:6440) __napi_poll.constprop.0 (net/core/dev.c:7452) net_rx_action (net/core/dev.c:7518 net/core/dev.c:7643) handle_softirqs (kernel/softirq.c:579) do_softirq (kernel/softirq.c:480 (discriminator 20)) </IRQ> <TASK> __local_bh_enable_ip (kernel/softirq.c:407) __dev_queue_xmit (net/core/dev.c:4740) ip6_finish_output2 (./include/linux/netdevice.h:3358 ./include/net/neighbour.h:526 ./include/net/neighbour.h:540 net/ipv6/ip6_output.c:141) ip6_finish_output (net/ipv6/ip6_output.c:215 net/ipv6/ip6_output.c:226) ip6_output (./include/linux/netfilter.h:306 net/ipv6/ip6_output.c:248) ip6_send_skb (net/ipv6/ip6_output.c:1983) rawv6_sendmsg (net/ipv6/raw.c:588 net/ipv6/raw.c:918) __sys_sendto (net/socket.c:714 (discriminator 1) net/socket.c:729 (discriminator 1) net/socket.c:2228 (discriminator 1)) __x64_sys_sendto (net/socket.c:2231) do_syscall_64 (arch/x86/entry/syscall_64.c:63 (discriminator 1) arch/x86/entry/syscall_64.c:94 (discriminator 1)) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130) RIP: 0033:0x7f68cffb2a06 Code: 5d e8 41 8b 93 08 03 00 00 59 5e 48 83 f8 fc 75 19 83 e2 39 83 fa 08 75 11 e8 26 ff ff ff 66 0f 1f 44 00 00 48 8b 45 10 0f 05 <48> 8b 5d f8 c9 c3 0f 1f 40 00 f3 0f 1e fa 55 48 89 e5 48 83 ec 08 RSP: 002b:00007ffefb7c53d0 EFLAGS: 00000202 ORIG_RAX: 000000000000002c RAX: ffffffffffffffda RBX: 0000564cd69f10a0 RCX: 00007f68cffb2a06 RDX: 0000000000000040 RSI: 0000564cd69f10a4 RDI: 0000000000000003 RBP: 00007ffefb7c53f0 R08: 0000564cd6a032ac R09: 000000000000001c R10: 0000000000000000 R11: 0000000000000202 R12: 0000564cd69f10a4 R13: 0000000000000040 R14: 00007ffefb7c66e0 R15: 0000564cd69f10a0 </TASK> Allocated by task 1543: kasan_save_stack (mm/kasan/common.c:48) kasan_save_track (mm/kasan/common.c:60 (discriminator 1) mm/kasan/common.c:69 (discriminator 1)) __kasan_slab_alloc (mm/kasan/common.c:319 mm/kasan/common.c:345) kmem_cache_alloc_node_noprof (./include/linux/kasan.h:250 mm/slub.c:4148 mm/slub.c:4197 mm/slub.c:4249) kmalloc_reserve (net/core/skbuff.c:581 (discriminator 88)) __alloc_skb (net/core/skbuff.c:669) __ip6_append_data (net/ipv6/ip6_output.c:1672 (discriminator 1)) ip6_ ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/034b428aa3583373a5a20b1c5931bb2b3cae1f36"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/06ec83b6c792fde1f710c1de3e836da6e257c4c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/62dcd9d6e61c39122d2f251a26829e2e55b0a11d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ba6c2362b85089b8972ac5f20b24fc71a4b8ffc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b640daa2822a39ff76e70200cb2b7b892b896dce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c09e21dfc08d8afb92d9ea3bee3457adbe3ef297"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e8101506ab86dd78f823b7028f2036a380f3a12a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38477,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:29.617,2025-08-28T15:15:49.747,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/sched: sch_qfq: Fix race condition on qfq_aggregate A race condition can occur when 'agg' is modified in qfq_change_agg (called during qfq_enqueue) while other threads access it concurrently. For example, qfq_dump_class may trigger a NULL dereference, and qfq_delete_class may cause a use-after-free. This patch addresses the issue by: 1. Moved qfq_destroy_class into the critical section. 2. Added sch_tree_lock protection to qfq_dump_class and qfq_dump_class_stats.",,"[{""url"":""https://git.kernel.org/stable/c/466e10194ab81caa2ee6a332d33ba16bcceeeba6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e28d5a3f774f118896aec17a3a20a9c5c9dfc64"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6d735100f602c830c16d69fb6d780eebd8c9ae1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa7a22c4d678bf649fd3a1d27debec583563414d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c000a3a330d97f6c073ace5aa5faf94b9adb4b79"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c6df794000147a3a02f79984aada4ce83f8d0a1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d841aa5518508ab195b6781ad0d73ee378d713dd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fbe48f06e64134dfeafa89ad23387f66ebca3527"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38478,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:29.733,2025-08-28T15:15:49.890,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: comedi: Fix initialization of data for instructions that write to subdevice Some Comedi subdevice instruction handlers are known to access instruction data elements beyond the first `insn->n` elements in some cases. The `do_insn_ioctl()` and `do_insnlist_ioctl()` functions allocate at least `MIN_SAMPLES` (16) data elements to deal with this, but they do not initialize all of that. For Comedi instruction codes that write to the subdevice, the first `insn->n` data elements are copied from user-space, but the remaining elements are left uninitialized. That could be a problem if the subdevice instruction handler reads the uninitialized data. Ensure that the first `MIN_SAMPLES` elements are initialized before calling these instruction handlers, filling the uncopied elements with 0. For `do_insnlist_ioctl()`, the same data buffer elements are used for handling a list of instructions, so ensure the first `MIN_SAMPLES` elements are initialized for each instruction that writes to the subdevice.",,"[{""url"":""https://git.kernel.org/stable/c/020eed5681d0f9bced73970368078a92d6cfaa9c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/13e4d9038a1e869445a996a3f604a84ef52fe8f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/46d8c744136ce2454aa4c35c138cc06817f92b8e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/673ee92bd2d31055bca98a1d96b653f5284289c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6f38c6380c3b38a05032b8881e41137385a6ce02"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c42116dc70af6664526f7aa82cf937824ab42649"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3436638738ace8f101af7bdee2eae1bc38e9b29"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe8713fb4e4e82a4f91910d9a41bf0613e69a0b9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38479,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-04-18T07:15:43.613,2025-04-21T14:23:45.950,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dmaengine: fsl-edma: free irq correctly in remove path Add fsl_edma->txirq/errirq check to avoid below warning because no errirq at i.MX9 platform. Otherwise there will be kernel dump: WARNING: CPU: 0 PID: 11 at kernel/irq/devres.c:144 devm_free_irq+0x74/0x80 Modules linked in: CPU: 0 UID: 0 PID: 11 Comm: kworker/u8:0 Not tainted 6.12.0-rc7#18 Hardware name: NXP i.MX93 11X11 EVK board (DT) Workqueue: events_unbound deferred_probe_work_func pstate: 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : devm_free_irq+0x74/0x80 lr : devm_free_irq+0x48/0x80 Call trace: devm_free_irq+0x74/0x80 (P) devm_free_irq+0x48/0x80 (L) fsl_edma_remove+0xc4/0xc8 platform_remove+0x28/0x44 device_remove+0x4c/0x80",,"[{""url"":""https://git.kernel.org/stable/c/38ff8769074db27387cb2323aaa751e59d168e6a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/55e2dbe2ba787d4fc2306f6bb2f43fb32176e184"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f3834d2d68749e4760c27325149765930ad876fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa70c4c3c580c239a0f9e83a14770ab026e8d820"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38480,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:29.853,2025-08-28T15:15:50.023,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: comedi: Fix use of uninitialized data in insn_rw_emulate_bits() For Comedi `INSN_READ` and `INSN_WRITE` instructions on ""digital"" subdevices (subdevice types `COMEDI_SUBD_DI`, `COMEDI_SUBD_DO`, and `COMEDI_SUBD_DIO`), it is common for the subdevice driver not to have `insn_read` and `insn_write` handler functions, but to have an `insn_bits` handler function for handling Comedi `INSN_BITS` instructions. In that case, the subdevice's `insn_read` and/or `insn_write` function handler pointers are set to point to the `insn_rw_emulate_bits()` function by `__comedi_device_postconfig()`. For `INSN_WRITE`, `insn_rw_emulate_bits()` currently assumes that the supplied `data[0]` value is a valid copy from user memory. It will at least exist because `do_insnlist_ioctl()` and `do_insn_ioctl()` in ""comedi_fops.c"" ensure at lease `MIN_SAMPLES` (16) elements are allocated. However, if `insn->n` is 0 (which is allowable for `INSN_READ` and `INSN_WRITE` instructions, then `data[0]` may contain uninitialized data, and certainly contains invalid data, possibly from a different instruction in the array of instructions handled by `do_insnlist_ioctl()`. This will result in an incorrect value being written to the digital output channel (or to the digital input/output channel if configured as an output), and may be reflected in the internal saved state of the channel. Fix it by returning 0 early if `insn->n` is 0, before reaching the code that accesses `data[0]`. Previously, the function always returned 1 on success, but it is supposed to be the number of data samples actually read or written up to `insn->n`, which is 0 in this case.",,"[{""url"":""https://git.kernel.org/stable/c/10f9024a8c824a41827fff1fefefb314c98e2c88"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/16256d7efcf7acc9f39abe21522c4c6b77f67c00"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2af1e7d389c2619219171d23f5b96dbcbb7f9656"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3050d197d6bc9ef128944a70210f42d2430b3000"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ab55ffaaf75d0c7b68e332c1cdcc1b0e0044870"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c2981bf30401adfcdbfece4ab6f411f7c5875a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c53570e62b5b28bdb56bb563190227f8307817a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e9cb26291d009243a4478a7ffb37b3a9175bfce9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38481,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:29.980,2025-08-28T15:15:50.173,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: comedi: Fail COMEDI_INSNLIST ioctl if n_insns is too large The handling of the `COMEDI_INSNLIST` ioctl allocates a kernel buffer to hold the array of `struct comedi_insn`, getting the length from the `n_insns` member of the `struct comedi_insnlist` supplied by the user. The allocation will fail with a WARNING and a stack dump if it is too large. Avoid that by failing with an `-EINVAL` error if the supplied `n_insns` value is unreasonable. Define the limit on the `n_insns` value in the `MAX_INSNS` macro. Set this to the same value as `MAX_SAMPLES` (65536), which is the maximum allowed sum of the values of the member `n` in the array of `struct comedi_insn`, and sensible comedi instructions will have an `n` of at least 1.",,"[{""url"":""https://git.kernel.org/stable/c/08ae4b20f5e82101d77326ecab9089e110f224cc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/454d732dfd0aef7d7aa950c409215ca06d717e93"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/69dc06b9514522de532e997a21d035cd29b0db44"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/992d600f284e719242a434166e86c1999649b71c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c68257588e87f45530235701a42496b7e9e56adb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c9d3d9667443caafa804cd07940aeaef8e53aa90"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d4c73ce13f5b5a0fe0319f1f352ff602f0ace8e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3b8322cc8081d142ee4c1a43e1d702bdba1ed76"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38482,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:30.117,2025-08-28T15:15:50.300,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: comedi: das6402: Fix bit shift out of bounds When checking for a supported IRQ number, the following test is used: /* IRQs 2,3,5,6,7, 10,11,15 are valid for ""enhanced"" mode */ if ((1 << it->options[1]) & 0x8cec) { However, `it->options[i]` is an unchecked `int` value from userspace, so the shift amount could be negative or out of bounds. Fix the test by requiring `it->options[1]` to be within bounds before proceeding with the original test. Valid `it->options[1]` values that select the IRQ will be in the range [1,15]. The value 0 explicitly disables the use of interrupts.",,"[{""url"":""https://git.kernel.org/stable/c/3eab654f5d199ecd45403c6588cda63e491fcfca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4a3c18cde02e35aba87e0ad5672b3e1c72dda5a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/70f2b28b5243df557f51c054c20058ae207baaac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73f34d609397805c20d6b2ef5c07a4cbf7c4d63a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8a3637027ceeba4ca5e500b23cb7d24c25592513"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a15e9c175f783298c4ee48146be6841335400406"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a18a42e77545afcacd6a2b8d9fc16191b87454df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de8da1063cce9234d55c8270d9bdf4cf84411c80"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38483,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:30.253,2025-08-28T15:15:50.437,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: comedi: das16m1: Fix bit shift out of bounds When checking for a supported IRQ number, the following test is used: /* only irqs 2, 3, 4, 5, 6, 7, 10, 11, 12, 14, and 15 are valid */ if ((1 << it->options[1]) & 0xdcfc) { However, `it->options[i]` is an unchecked `int` value from userspace, so the shift amount could be negative or out of bounds. Fix the test by requiring `it->options[1]` to be within bounds before proceeding with the original test.",,"[{""url"":""https://git.kernel.org/stable/c/076b13ee60eb01ed0d140ef261f95534562a3077"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/539bdff832adac9ea653859fa0b6bc62e743329c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/65c03e6fc524eb2868abedffd8a4613d78abc288"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/adb7df8a8f9d788423e161b779764527dd3ec2d0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3c95fa508e5dc3da60520eea92a5241095ceef1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d1291c69f46d6572b2cf75960dd8975d7ab2176b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ed93c6f68a3be06e4e0c331c6e751f462dee3932"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f211572818ed5bec2b3f5d4e0719ef8699b3c269"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38484,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:30.367,2025-07-29T14:14:29.590,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iio: backend: fix out-of-bound write The buffer is set to 80 character. If a caller write more characters, count is truncated to the max available space in ""simple_write_to_buffer"". But afterwards a string terminator is written to the buffer at offset count without boundary check. The zero termination is written OUT-OF-BOUND. Add a check that the given buffer is smaller then the buffer to prevent.",,"[{""url"":""https://git.kernel.org/stable/c/01e941aa7f5175125df4ac5d3aab099961525602"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6eea9f7648ddb9e4903735a1f77cf196c957aa38"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da9374819eb3885636934c1006d450c3cb1a02ed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38485,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:30.487,2025-07-29T14:14:29.590,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iio: accel: fxls8962af: Fix use after free in fxls8962af_fifo_flush fxls8962af_fifo_flush() uses indio_dev->active_scan_mask (with iio_for_each_active_channel()) without making sure the indio_dev stays in buffer mode. There is a race if indio_dev exits buffer mode in the middle of the interrupt that flushes the fifo. Fix this by calling synchronize_irq() to ensure that no interrupt is currently running when disabling buffer mode. Unable to handle kernel NULL pointer dereference at virtual address 00000000 when read [...] _find_first_bit_le from fxls8962af_fifo_flush+0x17c/0x290 fxls8962af_fifo_flush from fxls8962af_interrupt+0x80/0x178 fxls8962af_interrupt from irq_thread_fn+0x1c/0x7c irq_thread_fn from irq_thread+0x110/0x1f4 irq_thread from kthread+0xe0/0xfc kthread from ret_from_fork+0x14/0x2c",,"[{""url"":""https://git.kernel.org/stable/c/1803d372460aaa9ae0188a30c9421d3f157f2f04"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1fe16dc1a2f5057772e5391ec042ed7442966c9a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6ecd61c201b27ad2760b3975437ad2b97d725b98"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bfcda3e1015791b3a63fb4d3aad408da9cf76e8f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dda42f23a8f5439eaac9521ce0531547d880cc54"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38486,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:30.600,2025-07-29T14:14:29.590,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: soundwire: Revert ""soundwire: qcom: Add set_channel_map api support"" This reverts commit 7796c97df6b1b2206681a07f3c80f6023a6593d5. This patch broke Dragonboard 845c (sdm845). I see: Unexpected kernel BRK exception at EL1 Internal error: BRK handler: 00000000f20003e8 [#1] SMP pc : qcom_swrm_set_channel_map+0x7c/0x80 [soundwire_qcom] lr : snd_soc_dai_set_channel_map+0x34/0x78 Call trace: qcom_swrm_set_channel_map+0x7c/0x80 [soundwire_qcom] (P) sdm845_dai_init+0x18c/0x2e0 [snd_soc_sdm845] snd_soc_link_init+0x28/0x6c snd_soc_bind_card+0x5f4/0xb0c snd_soc_register_card+0x148/0x1a4 devm_snd_soc_register_card+0x50/0xb0 sdm845_snd_platform_probe+0x124/0x148 [snd_soc_sdm845] platform_probe+0x6c/0xd0 really_probe+0xc0/0x2a4 __driver_probe_device+0x7c/0x130 driver_probe_device+0x40/0x118 __device_attach_driver+0xc4/0x108 bus_for_each_drv+0x8c/0xf0 __device_attach+0xa4/0x198 device_initial_probe+0x18/0x28 bus_probe_device+0xb8/0xbc deferred_probe_work_func+0xac/0xfc process_one_work+0x244/0x658 worker_thread+0x1b4/0x360 kthread+0x148/0x228 ret_from_fork+0x10/0x20 Kernel panic - not syncing: BRK handler: Fatal exception Dan has also reported following issues with the original patch https://lore.kernel.org/all/33fe8fe7-719a-405a-9ed2-d9f816ce1d57@sabinyo.mountain/ Bug #1: The zeroeth element of ctrl->pconfig[] is supposed to be unused. We start counting at 1. However this code sets ctrl->pconfig[0].ch_mask = 128. Bug #2: There are SLIM_MAX_TX_PORTS (16) elements in tx_ch[] array but only QCOM_SDW_MAX_PORTS + 1 (15) in the ctrl->pconfig[] array so it corrupts memory like Yongqin Liu pointed out. Bug 3: Like Jie Gan pointed out, it erases all the tx information with the rx information.",,"[{""url"":""https://git.kernel.org/stable/c/207cea8b72fcbdf4e6db178e54186ed4f1514b3c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/834bce6a715ae9a9c4dce7892454a19adf22b013"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38487,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:30.720,2025-08-28T15:15:50.567,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: soc: aspeed: lpc-snoop: Don't disable channels that aren't enabled Mitigate e.g. the following: # echo 1e789080.lpc-snoop > /sys/bus/platform/drivers/aspeed-lpc-snoop/unbind ... [ 120.363594] Unable to handle kernel NULL pointer dereference at virtual address 00000004 when write [ 120.373866] [00000004] *pgd=00000000 [ 120.377910] Internal error: Oops: 805 [#1] SMP ARM [ 120.383306] CPU: 1 UID: 0 PID: 315 Comm: sh Not tainted 6.15.0-rc1-00009-g926217bc7d7d-dirty #20 NONE ... [ 120.679543] Call trace: [ 120.679559] misc_deregister from aspeed_lpc_snoop_remove+0x84/0xac [ 120.692462] aspeed_lpc_snoop_remove from platform_remove+0x28/0x38 [ 120.700996] platform_remove from device_release_driver_internal+0x188/0x200 ...",,"[{""url"":""https://git.kernel.org/stable/c/166afe964e8433d52c641f5d1c09102bacee9a92"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/329a80adc0e5f815d0514a6d403aaaf0995cd9be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/56448e78a6bb4e1a8528a0e2efe94eff0400c247"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/62e51f51d97477ea4e78c82e7076a171dac86c75"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9e1d2b97f5e2a36a2fd30a8bd30ead9dac5e3a51"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac10ed9862104936a412f8b475c869e99f048448"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b361598b7352f02456619a6105c7da952ef69f8f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc5598482e2d3b234f6d72d6f5568e24f603e51a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38488,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:30.857,2025-08-28T15:15:50.700,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: smb: client: fix use-after-free in crypt_message when using async crypto The CVE-2024-50047 fix removed asynchronous crypto handling from crypt_message(), assuming all crypto operations are synchronous. However, when hardware crypto accelerators are used, this can cause use-after-free crashes: crypt_message() // Allocate the creq buffer containing the req creq = smb2_get_aead_req(..., &req); // Async encryption returns -EINPROGRESS immediately rc = enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req); // Free creq while async operation is still in progress kvfree_sensitive(creq, ...); Hardware crypto modules often implement async AEAD operations for performance. When crypto_aead_encrypt/decrypt() returns -EINPROGRESS, the operation completes asynchronously. Without crypto_wait_req(), the function immediately frees the request buffer, leading to crashes when the driver later accesses the freed memory. This results in a use-after-free condition when the hardware crypto driver later accesses the freed request structure, leading to kernel crashes with NULL pointer dereferences. The issue occurs because crypto_alloc_aead() with mask=0 doesn't guarantee synchronous operation. Even without CRYPTO_ALG_ASYNC in the mask, async implementations can be selected. Fix by restoring the async crypto handling: - DECLARE_CRYPTO_WAIT(wait) for completion tracking - aead_request_set_callback() for async completion notification - crypto_wait_req() to wait for operation completion This ensures the request buffer isn't freed until the crypto operation completes, whether synchronous or asynchronous, while preserving the CVE-2024-50047 fix.",,"[{""url"":""https://git.kernel.org/stable/c/15a0a5de49507062bc3be4014a403d8cea5533de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2a76bc2b24ed889a689fb1c9015307bf16aafb5b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5d047b12f86cc3b9fde1171c02d9bccf4dba0632"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6550b2bef095d0dd2d2c8390d2ea4c3837028833"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ac90f6824fc44d2e55a82503ddfc95defb19ae0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9a1d3e8d40f151c2d5a5f40c410e6e433f62f438"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b220bed63330c0e1733dc06ea8e75d5b9962b6b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38489,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:30.990,2025-07-29T14:14:29.590,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: s390/bpf: Fix bpf_arch_text_poke() with new_addr == NULL again Commit 7ded842b356d (""s390/bpf: Fix bpf_plt pointer arithmetic"") has accidentally removed the critical piece of commit c730fce7c70c (""s390/bpf: Fix bpf_arch_text_poke() with new_addr == NULL""), causing intermittent kernel panics in e.g. perf's on_switch() prog to reappear. Restore the fix and add a comment.",,"[{""url"":""https://git.kernel.org/stable/c/0c7b20f7785cfdd59403333612c90b458b12307c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6a5abf8cf182f577c7ae6c62f14debc9754ec986"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a4f9c7846b1ac428921ce9676b1b8c80ed60093c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d5629d1af0600f8cc7c9245e8d832a66358ef889"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38490,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:31.113,2025-07-29T14:14:29.590,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: libwx: remove duplicate page_pool_put_full_page() page_pool_put_full_page() should only be invoked when freeing Rx buffers or building a skb if the size is too short. At other times, the pages need to be reused. So remove the redundant page put. In the original code, double free pages cause kernel panic: [ 876.949834] __irq_exit_rcu+0xc7/0x130 [ 876.949836] common_interrupt+0xb8/0xd0 [ 876.949838] </IRQ> [ 876.949838] <TASK> [ 876.949840] asm_common_interrupt+0x22/0x40 [ 876.949841] RIP: 0010:cpuidle_enter_state+0xc2/0x420 [ 876.949843] Code: 00 00 e8 d1 1d 5e ff e8 ac f0 ff ff 49 89 c5 0f 1f 44 00 00 31 ff e8 cd fc 5c ff 45 84 ff 0f 85 40 02 00 00 fb 0f 1f 44 00 00 <45> 85 f6 0f 88 84 01 00 00 49 63 d6 48 8d 04 52 48 8d 04 82 49 8d [ 876.949844] RSP: 0018:ffffaa7340267e78 EFLAGS: 00000246 [ 876.949845] RAX: ffff9e3f135be000 RBX: 0000000000000002 RCX: 0000000000000000 [ 876.949846] RDX: 000000cc2dc4cb7c RSI: ffffffff89ee49ae RDI: ffffffff89ef9f9e [ 876.949847] RBP: ffff9e378f940800 R08: 0000000000000002 R09: 00000000000000ed [ 876.949848] R10: 000000000000afc8 R11: ffff9e3e9e5a9b6c R12: ffffffff8a6d8580 [ 876.949849] R13: 000000cc2dc4cb7c R14: 0000000000000002 R15: 0000000000000000 [ 876.949852] ? cpuidle_enter_state+0xb3/0x420 [ 876.949855] cpuidle_enter+0x29/0x40 [ 876.949857] cpuidle_idle_call+0xfd/0x170 [ 876.949859] do_idle+0x7a/0xc0 [ 876.949861] cpu_startup_entry+0x25/0x30 [ 876.949862] start_secondary+0x117/0x140 [ 876.949864] common_startup_64+0x13e/0x148 [ 876.949867] </TASK> [ 876.949868] ---[ end trace 0000000000000000 ]--- [ 876.949869] ------------[ cut here ]------------ [ 876.949870] list_del corruption, ffffead40445a348->next is NULL [ 876.949873] WARNING: CPU: 14 PID: 0 at lib/list_debug.c:52 __list_del_entry_valid_or_report+0x67/0x120 [ 876.949875] Modules linked in: snd_hrtimer(E) bnep(E) binfmt_misc(E) amdgpu(E) squashfs(E) vfat(E) loop(E) fat(E) amd_atl(E) snd_hda_codec_realtek(E) intel_rapl_msr(E) snd_hda_codec_generic(E) intel_rapl_common(E) snd_hda_scodec_component(E) snd_hda_codec_hdmi(E) snd_hda_intel(E) edac_mce_amd(E) snd_intel_dspcfg(E) snd_hda_codec(E) snd_hda_core(E) amdxcp(E) kvm_amd(E) snd_hwdep(E) gpu_sched(E) drm_panel_backlight_quirks(E) cec(E) snd_pcm(E) drm_buddy(E) snd_seq_dummy(E) drm_ttm_helper(E) btusb(E) kvm(E) snd_seq_oss(E) btrtl(E) ttm(E) btintel(E) snd_seq_midi(E) btbcm(E) drm_exec(E) snd_seq_midi_event(E) i2c_algo_bit(E) snd_rawmidi(E) bluetooth(E) drm_suballoc_helper(E) irqbypass(E) snd_seq(E) ghash_clmulni_intel(E) sha512_ssse3(E) drm_display_helper(E) aesni_intel(E) snd_seq_device(E) rfkill(E) snd_timer(E) gf128mul(E) drm_client_lib(E) drm_kms_helper(E) snd(E) i2c_piix4(E) joydev(E) soundcore(E) wmi_bmof(E) ccp(E) k10temp(E) i2c_smbus(E) gpio_amdpt(E) i2c_designware_platform(E) gpio_generic(E) sg(E) [ 876.949914] i2c_designware_core(E) sch_fq_codel(E) parport_pc(E) drm(E) ppdev(E) lp(E) parport(E) fuse(E) nfnetlink(E) ip_tables(E) ext4 crc16 mbcache jbd2 sd_mod sfp mdio_i2c i2c_core txgbe ahci ngbe pcs_xpcs libahci libwx r8169 phylink libata realtek ptp pps_core video wmi [ 876.949933] CPU: 14 UID: 0 PID: 0 Comm: swapper/14 Kdump: loaded Tainted: G W E 6.16.0-rc2+ #20 PREEMPT(voluntary) [ 876.949935] Tainted: [W]=WARN, [E]=UNSIGNED_MODULE [ 876.949936] Hardware name: Micro-Star International Co., Ltd. MS-7E16/X670E GAMING PLUS WIFI (MS-7E16), BIOS 1.90 12/31/2024 [ 876.949936] RIP: 0010:__list_del_entry_valid_or_report+0x67/0x120 [ 876.949938] Code: 00 00 00 48 39 7d 08 0f 85 a6 00 00 00 5b b8 01 00 00 00 5d 41 5c e9 73 0d 93 ff 48 89 fe 48 c7 c7 a0 31 e8 89 e8 59 7c b3 ff <0f> 0b 31 c0 5b 5d 41 5c e9 57 0d 93 ff 48 89 fe 48 c7 c7 c8 31 e8 [ 876.949940] RSP: 0018:ffffaa73405d0c60 EFLAGS: 00010282 [ 876.949941] RAX: 0000000000000000 RBX: ffffead40445a348 RCX: 0000000000000000 [ 876.949942] RDX: 0000000000000105 RSI: 00000 ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/003e4765d8661be97e650a833868c53d35574130"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/08d18bda0d03f5ec376929a8c6c4495f9594593a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1b7e585c04cd5f0731dd25ffd396277e55fae0e6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3c91a56762b1f0d1e4af2d86c2cba83b61ed9eaa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38491,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:31.240,2025-08-28T15:15:50.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mptcp: make fallback action and fallback decision atomic Syzkaller reported the following splat: WARNING: CPU: 1 PID: 7704 at net/mptcp/protocol.h:1223 __mptcp_do_fallback net/mptcp/protocol.h:1223 [inline] WARNING: CPU: 1 PID: 7704 at net/mptcp/protocol.h:1223 mptcp_do_fallback net/mptcp/protocol.h:1244 [inline] WARNING: CPU: 1 PID: 7704 at net/mptcp/protocol.h:1223 check_fully_established net/mptcp/options.c:982 [inline] WARNING: CPU: 1 PID: 7704 at net/mptcp/protocol.h:1223 mptcp_incoming_options+0x21a8/0x2510 net/mptcp/options.c:1153 Modules linked in: CPU: 1 UID: 0 PID: 7704 Comm: syz.3.1419 Not tainted 6.16.0-rc3-gbd5ce2324dba #20 PREEMPT(voluntary) Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 RIP: 0010:__mptcp_do_fallback net/mptcp/protocol.h:1223 [inline] RIP: 0010:mptcp_do_fallback net/mptcp/protocol.h:1244 [inline] RIP: 0010:check_fully_established net/mptcp/options.c:982 [inline] RIP: 0010:mptcp_incoming_options+0x21a8/0x2510 net/mptcp/options.c:1153 Code: 24 18 e8 bb 2a 00 fd e9 1b df ff ff e8 b1 21 0f 00 e8 ec 5f c4 fc 44 0f b7 ac 24 b0 00 00 00 e9 54 f1 ff ff e8 d9 5f c4 fc 90 <0f> 0b 90 e9 b8 f4 ff ff e8 8b 2a 00 fd e9 8d e6 ff ff e8 81 2a 00 RSP: 0018:ffff8880a3f08448 EFLAGS: 00010246 RAX: 0000000000000000 RBX: ffff8880180a8000 RCX: ffffffff84afcf45 RDX: ffff888090223700 RSI: ffffffff84afdaa7 RDI: 0000000000000001 RBP: ffff888017955780 R08: 0000000000000001 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000 R13: ffff8880180a8910 R14: ffff8880a3e9d058 R15: 0000000000000000 FS: 00005555791b8500(0000) GS:ffff88811c495000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000000110c2800b7 CR3: 0000000058e44000 CR4: 0000000000350ef0 Call Trace: <IRQ> tcp_reset+0x26f/0x2b0 net/ipv4/tcp_input.c:4432 tcp_validate_incoming+0x1057/0x1b60 net/ipv4/tcp_input.c:5975 tcp_rcv_established+0x5b5/0x21f0 net/ipv4/tcp_input.c:6166 tcp_v4_do_rcv+0x5dc/0xa70 net/ipv4/tcp_ipv4.c:1925 tcp_v4_rcv+0x3473/0x44a0 net/ipv4/tcp_ipv4.c:2363 ip_protocol_deliver_rcu+0xba/0x480 net/ipv4/ip_input.c:205 ip_local_deliver_finish+0x2f1/0x500 net/ipv4/ip_input.c:233 NF_HOOK include/linux/netfilter.h:317 [inline] NF_HOOK include/linux/netfilter.h:311 [inline] ip_local_deliver+0x1be/0x560 net/ipv4/ip_input.c:254 dst_input include/net/dst.h:469 [inline] ip_rcv_finish net/ipv4/ip_input.c:447 [inline] NF_HOOK include/linux/netfilter.h:317 [inline] NF_HOOK include/linux/netfilter.h:311 [inline] ip_rcv+0x514/0x810 net/ipv4/ip_input.c:567 __netif_receive_skb_one_core+0x197/0x1e0 net/core/dev.c:5975 __netif_receive_skb+0x1f/0x120 net/core/dev.c:6088 process_backlog+0x301/0x1360 net/core/dev.c:6440 __napi_poll.constprop.0+0xba/0x550 net/core/dev.c:7453 napi_poll net/core/dev.c:7517 [inline] net_rx_action+0xb44/0x1010 net/core/dev.c:7644 handle_softirqs+0x1d0/0x770 kernel/softirq.c:579 do_softirq+0x3f/0x90 kernel/softirq.c:480 </IRQ> <TASK> __local_bh_enable_ip+0xed/0x110 kernel/softirq.c:407 local_bh_enable include/linux/bottom_half.h:33 [inline] inet_csk_listen_stop+0x2c5/0x1070 net/ipv4/inet_connection_sock.c:1524 mptcp_check_listen_stop.part.0+0x1cc/0x220 net/mptcp/protocol.c:2985 mptcp_check_listen_stop net/mptcp/mib.h:118 [inline] __mptcp_close+0x9b9/0xbd0 net/mptcp/protocol.c:3000 mptcp_close+0x2f/0x140 net/mptcp/protocol.c:3066 inet_release+0xed/0x200 net/ipv4/af_inet.c:435 inet6_release+0x4f/0x70 net/ipv6/af_inet6.c:487 __sock_release+0xb3/0x270 net/socket.c:649 sock_close+0x1c/0x30 net/socket.c:1439 __fput+0x402/0xb70 fs/file_table.c:465 task_work_run+0x150/0x240 kernel/task_work.c:227 resume_user_mode_work include/linux/resume_user_mode.h:50 [inline] exit_to_user_mode_loop+0xd4 ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/1d82a8fe6ee4afdc92f4e8808c9dad2a6095bbc5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/54999dea879fecb761225e28f274b40662918c30"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5586518bec27666c747cd52aabb62d485686d0bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/75a4c9ab8a7af0d76b31ccd1188ed178c38b35d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8a1d9b18c5efc76784f5a326e905f641f839894"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38492,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:31.367,2025-07-29T14:14:29.590,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfs: Fix race between cache write completion and ALL_QUEUED being set When netfslib is issuing subrequests, the subrequests start processing immediately and may complete before we reach the end of the issuing function. At the end of the issuing function we set NETFS_RREQ_ALL_QUEUED to indicate to the collector that we aren't going to issue any more subreqs and that it can do the final notifications and cleanup. Now, this isn't a problem if the request is synchronous (NETFS_RREQ_OFFLOAD_COLLECTION is unset) as the result collection will be done in-thread and we're guaranteed an opportunity to run the collector. However, if the request is asynchronous, collection is primarily triggered by the termination of subrequests queuing it on a workqueue. Now, a race can occur here if the app thread sets ALL_QUEUED after the last subrequest terminates. This can happen most easily with the copy2cache code (as used by Ceph) where, in the collection routine of a read request, an asynchronous write request is spawned to copy data to the cache. Folios are added to the write request as they're unlocked, but there may be a delay before ALL_QUEUED is set as the write subrequests may complete before we get there. If all the write subreqs have finished by the ALL_QUEUED point, no further events happen and the collection never happens, leaving the request hanging. Fix this by queuing the collector after setting ALL_QUEUED. This is a bit heavy-handed and it may be sufficient to do it only if there are no extant subreqs. Also add a tracepoint to cross-reference both requests in a copy-to-request operation and add a trace to the netfs_rreq tracepoint to indicate the setting of ALL_QUEUED.",,"[{""url"":""https://git.kernel.org/stable/c/110188a13c4853bd4c342e600ced4dfd26c3feb5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/89635eae076cd8eaa5cb752f66538c9dc6c9fdc3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38493,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:31.483,2025-07-29T14:14:29.590,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tracing/osnoise: Fix crash in timerlat_dump_stack() We have observed kernel panics when using timerlat with stack saving, with the following dmesg output: memcpy: detected buffer overflow: 88 byte write of buffer size 0 WARNING: CPU: 2 PID: 8153 at lib/string_helpers.c:1032 __fortify_report+0x55/0xa0 CPU: 2 UID: 0 PID: 8153 Comm: timerlatu/2 Kdump: loaded Not tainted 6.15.3-200.fc42.x86_64 #1 PREEMPT(lazy) Call Trace: <TASK> ? trace_buffer_lock_reserve+0x2a/0x60 __fortify_panic+0xd/0xf __timerlat_dump_stack.cold+0xd/0xd timerlat_dump_stack.part.0+0x47/0x80 timerlat_fd_read+0x36d/0x390 vfs_read+0xe2/0x390 ? syscall_exit_to_user_mode+0x1d5/0x210 ksys_read+0x73/0xe0 do_syscall_64+0x7b/0x160 ? exc_page_fault+0x7e/0x1a0 entry_SYSCALL_64_after_hwframe+0x76/0x7e __timerlat_dump_stack() constructs the ftrace stack entry like this: struct stack_entry *entry; ... memcpy(&entry->caller, fstack->calls, size); entry->size = fstack->nr_entries; Since commit e7186af7fb26 (""tracing: Add back FORTIFY_SOURCE logic to kernel_stack event structure""), struct stack_entry marks its caller field with __counted_by(size). At the time of the memcpy, entry->size contains garbage from the ringbuffer, which under some circumstances is zero, triggering a kernel panic by buffer overflow. Populate the size field before the memcpy so that the out-of-bounds check knows the correct size. This is analogous to __ftrace_trace_stack().",,"[{""url"":""https://git.kernel.org/stable/c/7bb9ea515cda027c9e717e27fefcf34f092e7c41"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/823d798900481875ba6c68217af028c5ffd2976b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/85a3bce695b361d85fc528e6fbb33e4c8089c806"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fbf90f5aa7ac7cddc69148a71d58f12c8709ce2b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38494,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:31.607,2025-08-28T15:15:50.970,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: HID: core: do not bypass hid_hw_raw_request hid_hw_raw_request() is actually useful to ensure the provided buffer and length are valid. Directly calling in the low level transport driver function bypassed those checks and allowed invalid paramto be used.",,"[{""url"":""https://git.kernel.org/stable/c/0e5017d84d650ca0eeaf4a3fe9264c5dbc886b81"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/19d1314d46c0d8a5c08ab53ddeb62280c77698c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/40e25aa7e4e0f2440c73a683ee448e41c7c344ed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a62a895edb2bfebffa865b5129a66e3b4287f34f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c2ca42f190b6714d6c481dfd3d9b62ea091c946b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d18f63e848840100dbc351a82e7042eac5a28cf5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dd8e8314f2ce225dade5248dcfb9e2ac0edda624"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f10923b8d32a473b229477b63f23bbd72b1e9910"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38495,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:31.727,2025-08-28T15:15:51.113,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: HID: core: ensure the allocated report buffer can contain the reserved report ID When the report ID is not used, the low level transport drivers expect the first byte to be 0. However, currently the allocated buffer not account for that extra byte, meaning that instead of having 8 guaranteed bytes for implement to be working, we only have 7.",,"[{""url"":""https://git.kernel.org/stable/c/4f15ee98304b96e164ff2340e1dfd6181c3f42aa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7228e36c7875e4b035374cf68ca5e44dffa596b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7fa83d0043370003e9a0b46ab7ae8f53b00fab06"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9f2892f7233a8f1320fe671d0f95f122191bfbcd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a262370f385e53ff7470efdcdaf40468e5756717"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a47d9d9895bad9ce0e840a39836f19ca0b2a343a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3ed1d84a84538a39b3eb2055d6a97a936c108f2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fcda39a9c5b834346088c14b1374336b079466c1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38496,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:31.847,2025-07-29T14:14:29.590,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dm-bufio: fix sched in atomic context If ""try_verify_in_tasklet"" is set for dm-verity, DM_BUFIO_CLIENT_NO_SLEEP is enabled for dm-bufio. However, when bufio tries to evict buffers, there is a chance to trigger scheduling in spin_lock_bh, the following warning is hit: BUG: sleeping function called from invalid context at drivers/md/dm-bufio.c:2745 in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 123, name: kworker/2:2 preempt_count: 201, expected: 0 RCU nest depth: 0, expected: 0 4 locks held by kworker/2:2/123: #0: ffff88800a2d1548 ((wq_completion)dm_bufio_cache){....}-{0:0}, at: process_one_work+0xe46/0x1970 #1: ffffc90000d97d20 ((work_completion)(&dm_bufio_replacement_work)){....}-{0:0}, at: process_one_work+0x763/0x1970 #2: ffffffff8555b528 (dm_bufio_clients_lock){....}-{3:3}, at: do_global_cleanup+0x1ce/0x710 #3: ffff88801d5820b8 (&c->spinlock){....}-{2:2}, at: do_global_cleanup+0x2a5/0x710 Preemption disabled at: [<0000000000000000>] 0x0 CPU: 2 UID: 0 PID: 123 Comm: kworker/2:2 Not tainted 6.16.0-rc3-g90548c634bd0 #305 PREEMPT(voluntary) Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014 Workqueue: dm_bufio_cache do_global_cleanup Call Trace: <TASK> dump_stack_lvl+0x53/0x70 __might_resched+0x360/0x4e0 do_global_cleanup+0x2f5/0x710 process_one_work+0x7db/0x1970 worker_thread+0x518/0xea0 kthread+0x359/0x690 ret_from_fork+0xf3/0x1b0 ret_from_fork_asm+0x1a/0x30 </TASK> That can be reproduced by: veritysetup format --data-block-size=4096 --hash-block-size=4096 /dev/vda /dev/vdb SIZE=$(blockdev --getsz /dev/vda) dmsetup create myverity -r --table ""0 $SIZE verity 1 /dev/vda /dev/vdb 4096 4096 <data_blocks> 1 sha256 <root_hash> <salt> 1 try_verify_in_tasklet"" mount /dev/dm-0 /mnt -o ro echo 102400 > /sys/module/dm_bufio/parameters/max_cache_size_bytes [read files in /mnt]",,"[{""url"":""https://git.kernel.org/stable/c/3edfdb1d4ef81320dae0caa40bc24baf8c1bbb86"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/469a39a33a9934af157299bf11c58f6e6cb53f85"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/68860d1ade385eef9fcdbf6552f061283091fdb8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b1bf1a782fdf5c482215c0c661b5da98b8e75773"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38497,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-28T12:15:31.963,2025-08-28T15:15:51.247,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: gadget: configfs: Fix OOB read on empty string write When writing an empty string to either 'qw_sign' or 'landingPage' sysfs attributes, the store functions attempt to access page[l - 1] before validating that the length 'l' is greater than zero. This patch fixes the vulnerability by adding a check at the beginning of os_desc_qw_sign_store() and webusb_landingPage_store() to handle the zero-length input case gracefully by returning immediately.",,"[{""url"":""https://git.kernel.org/stable/c/15a87206879951712915c03c8952a73d6a74721e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/22b7897c289cc25d99c603f5144096142a30d897"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2798111f8e504ac747cce911226135d50b8de468"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3014168731b7930300aab656085af784edc861f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/58bdd5160184645771553ea732da5c2887fc9bd1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/783ea37b237a9b524f1e5ca018ea17d772ee0ea0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/78b41148cfea2a3f04d87adf3a71b21735820a37"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d68b7c8fefbaeae8f065b84e40cf64baf4cc0c76"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38498,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-07-30T06:15:27.527,2025-07-31T18:42:37.870,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: do_change_type(): refuse to operate on unmounted/not ours mounts Ensure that propagation settings can only be changed for mounts located in the caller's mount namespace. This change aligns permission checking with the rest of mount(2).",,"[{""url"":""https://git.kernel.org/stable/c/064014f7812744451d5d0592f3d2bcd727f2ee93"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/12f147ddd6de7382dad54812e65f3f08d05809fc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/19554c79a2095ddde850906a067915c1ef3a4114"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/432a171d60056489270c462e651e6c3a13f855b1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4f091ad0862b02dc42a19a120b7048de848561f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/787937c4e373f1722c4343e5a5a4eb0f8543e589"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9c1ddfeb662b668fff69c5f1cfdd9f5d23d55d23"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c7d11fdf8e5db5f34a6c062c7e6ba3a0971879d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38499,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-11T16:15:30.057,2025-08-28T15:15:51.383,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: clone_private_mnt(): make sure that caller has CAP_SYS_ADMIN in the right userns What we want is to verify there is that clone won't expose something hidden by a mount we wouldn't be able to undo. ""Wouldn't be able to undo"" may be a result of MNT_LOCKED on a child, but it may also come from lacking admin rights in the userns of the namespace mount belongs to. clone_private_mnt() checks the former, but not the latter. There's a number of rather confusing CAP_SYS_ADMIN checks in various userns during the mount, especially with the new mount API; they serve different purposes and in case of clone_private_mnt() they usually, but not always end up covering the missing check mentioned above.",,"[{""url"":""https://git.kernel.org/stable/c/36fecd740de2d542d2091d65d36554ee2bcf9c65"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/38628ae06e2a37770cd794802a3f1310cf9846e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c28f922c9dcee0e4876a2c095939d77fe7e15116"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d717325b5ecf2a40daca85c61923e17f32306179"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc6a664089f10eab0fb36b6e4f705022210191d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e77078e52fbf018ab986efb3c79065ab35025607"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38500,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-12T16:15:27.277,2025-08-15T16:15:29.433,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: xfrm: interface: fix use-after-free after changing collect_md xfrm interface collect_md property on xfrm interfaces can only be set on device creation, thus xfrmi_changelink() should fail when called on such interfaces. The check to enforce this was done only in the case where the xi was returned from xfrmi_locate() which doesn't look for the collect_md interface, and thus the validation was never reached. Calling changelink would thus errornously place the special interface xi in the xfrmi_net->xfrmi hash, but since it also exists in the xfrmi_net->collect_md_xfrmi pointer it would lead to a double free when the net namespace was taken down [1]. Change the check to use the xi from netdev_priv which is available earlier in the function to prevent changes in xfrm collect_md interfaces. [1] resulting oops: [ 8.516540] kernel BUG at net/core/dev.c:12029! [ 8.516552] Oops: invalid opcode: 0000 [#1] SMP NOPTI [ 8.516559] CPU: 0 UID: 0 PID: 12 Comm: kworker/u80:0 Not tainted 6.15.0-virtme #5 PREEMPT(voluntary) [ 8.516565] Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 [ 8.516569] Workqueue: netns cleanup_net [ 8.516579] RIP: 0010:unregister_netdevice_many_notify+0x101/0xab0 [ 8.516590] Code: 90 0f 0b 90 48 8b b0 78 01 00 00 48 8b 90 80 01 00 00 48 89 56 08 48 89 32 4c 89 80 78 01 00 00 48 89 b8 80 01 00 00 eb ac 90 <0f> 0b 48 8b 45 00 4c 8d a0 88 fe ff ff 48 39 c5 74 5c 41 80 bc 24 [ 8.516593] RSP: 0018:ffffa93b8006bd30 EFLAGS: 00010206 [ 8.516598] RAX: ffff98fe4226e000 RBX: ffffa93b8006bd58 RCX: ffffa93b8006bc60 [ 8.516601] RDX: 0000000000000004 RSI: 0000000000000000 RDI: dead000000000122 [ 8.516603] RBP: ffffa93b8006bdd8 R08: dead000000000100 R09: ffff98fe4133c100 [ 8.516605] R10: 0000000000000000 R11: 00000000000003d2 R12: ffffa93b8006be00 [ 8.516608] R13: ffffffff96c1a510 R14: ffffffff96c1a510 R15: ffffa93b8006be00 [ 8.516615] FS: 0000000000000000(0000) GS:ffff98fee73b7000(0000) knlGS:0000000000000000 [ 8.516619] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 8.516622] CR2: 00007fcd2abd0700 CR3: 000000003aa40000 CR4: 0000000000752ef0 [ 8.516625] PKRU: 55555554 [ 8.516627] Call Trace: [ 8.516632] <TASK> [ 8.516635] ? rtnl_is_locked+0x15/0x20 [ 8.516641] ? unregister_netdevice_queue+0x29/0xf0 [ 8.516650] ops_undo_list+0x1f2/0x220 [ 8.516659] cleanup_net+0x1ad/0x2e0 [ 8.516664] process_one_work+0x160/0x380 [ 8.516673] worker_thread+0x2aa/0x3c0 [ 8.516679] ? __pfx_worker_thread+0x10/0x10 [ 8.516686] kthread+0xfb/0x200 [ 8.516690] ? __pfx_kthread+0x10/0x10 [ 8.516693] ? __pfx_kthread+0x10/0x10 [ 8.516697] ret_from_fork+0x82/0xf0 [ 8.516705] ? __pfx_kthread+0x10/0x10 [ 8.516709] ret_from_fork_asm+0x1a/0x30 [ 8.516718] </TASK>",,"[{""url"":""https://git.kernel.org/stable/c/5918c3f4800a3aef2173865e5903370f21e24f47"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/69a31f7a6a81f5ffd3812c442e09ff0be22960f1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a8d4748b954584ab7bd800f1a4e46d5b0eeb5ce4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a90b2a1aaacbcf0f91d7e4868ad6c51c5dee814b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bfebdb85496e1da21d3cf05de099210915c3e706"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38501,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T06:15:27.923,2025-09-15T18:15:37.603,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: limit repeated connections from clients with the same IP Repeated connections from clients with the same IP address may exhaust the max connections and prevent other normal client connections. This patch limit repeated connections from clients with the same IP.",,"[{""url"":""https://git.kernel.org/stable/c/6073afe64510c302b7a0683a01e32c012eff715d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7e5d91d3e6c62a9755b36f29c35288f06c3cd86b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cb092fc3a62972a4aa47c9fe356c2c6a01cd840b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e6bb9193974059ddbb0ce7763fa3882bd60d4dc3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1ce9258bcbce2491f9f71f7882b6eed0b33ec65"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa1c47af4ff641cf9197ecdb1f8240cbb30389c1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://github.com/keymaker-arch/KSMBDrain"",""source"":""af854a3a-2127-422b-91ae-364da2661108""}]",,,,,,,,,,
CVE-2025-38502,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T10:15:25.653,2025-09-09T17:15:44.933,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf: Fix oob access in cgroup local storage Lonial reported that an out-of-bounds access in cgroup local storage can be crafted via tail calls. Given two programs each utilizing a cgroup local storage with a different value size, and one program doing a tail call into the other. The verifier will validate each of the indivial programs just fine. However, in the runtime context the bpf_cg_run_ctx holds an bpf_prog_array_item which contains the BPF program as well as any cgroup local storage flavor the program uses. Helpers such as bpf_get_local_storage() pick this up from the runtime context: ctx = container_of(current->bpf_ctx, struct bpf_cg_run_ctx, run_ctx); storage = ctx->prog_item->cgroup_storage[stype]; if (stype == BPF_CGROUP_STORAGE_SHARED) ptr = &READ_ONCE(storage->buf)->data[0]; else ptr = this_cpu_ptr(storage->percpu_buf); For the second program which was called from the originally attached one, this means bpf_get_local_storage() will pick up the former program's map, not its own. With mismatching sizes, this can result in an unintended out-of-bounds access. To fix this issue, we need to extend bpf_map_owner with an array of storage_cookie[] to match on i) the exact maps from the original program if the second program was using bpf_get_local_storage(), or ii) allow the tail call combination if the second program was not using any of the cgroup local storage maps.",,"[{""url"":""https://git.kernel.org/stable/c/19341d5c59e8c7e8528e40f8663e99d67810473c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/41688d1fc5d163a6c2c0e95c0419e2cb31a44648"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/66da7cee78590259b400e51a70622ccd41da7bb2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7acfa07c585e3d7a64654d38f0a5c762877d0b9b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/abad3d0bad72a52137e0c350c59542d75ae4f513"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c1c74584b9b4043c52e41fec415226e582d266a3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38503,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T11:15:42.373,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: fix assertion when building free space tree When building the free space tree with the block group tree feature enabled, we can hit an assertion failure like this: BTRFS info (device loop0 state M): rebuilding free space tree assertion failed: ret == 0, in fs/btrfs/free-space-tree.c:1102 ------------[ cut here ]------------ kernel BUG at fs/btrfs/free-space-tree.c:1102! Internal error: Oops - BUG: 00000000f2000800 [#1] SMP Modules linked in: CPU: 1 UID: 0 PID: 6592 Comm: syz-executor322 Not tainted 6.15.0-rc7-syzkaller-gd7fa1af5b33e #0 PREEMPT Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025 pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : populate_free_space_tree+0x514/0x518 fs/btrfs/free-space-tree.c:1102 lr : populate_free_space_tree+0x514/0x518 fs/btrfs/free-space-tree.c:1102 sp : ffff8000a4ce7600 x29: ffff8000a4ce76e0 x28: ffff0000c9bc6000 x27: ffff0000ddfff3d8 x26: ffff0000ddfff378 x25: dfff800000000000 x24: 0000000000000001 x23: ffff8000a4ce7660 x22: ffff70001499cecc x21: ffff0000e1d8c160 x20: ffff0000e1cb7800 x19: ffff0000e1d8c0b0 x18: 00000000ffffffff x17: ffff800092f39000 x16: ffff80008ad27e48 x15: ffff700011e740c0 x14: 1ffff00011e740c0 x13: 0000000000000004 x12: ffffffffffffffff x11: ffff700011e740c0 x10: 0000000000ff0100 x9 : 94ef24f55d2dbc00 x8 : 94ef24f55d2dbc00 x7 : 0000000000000001 x6 : 0000000000000001 x5 : ffff8000a4ce6f98 x4 : ffff80008f415ba0 x3 : ffff800080548ef0 x2 : 0000000000000000 x1 : 0000000100000000 x0 : 000000000000003e Call trace: populate_free_space_tree+0x514/0x518 fs/btrfs/free-space-tree.c:1102 (P) btrfs_rebuild_free_space_tree+0x14c/0x54c fs/btrfs/free-space-tree.c:1337 btrfs_start_pre_rw_mount+0xa78/0xe10 fs/btrfs/disk-io.c:3074 btrfs_remount_rw fs/btrfs/super.c:1319 [inline] btrfs_reconfigure+0x828/0x2418 fs/btrfs/super.c:1543 reconfigure_super+0x1d4/0x6f0 fs/super.c:1083 do_remount fs/namespace.c:3365 [inline] path_mount+0xb34/0xde0 fs/namespace.c:4200 do_mount fs/namespace.c:4221 [inline] __do_sys_mount fs/namespace.c:4432 [inline] __se_sys_mount fs/namespace.c:4409 [inline] __arm64_sys_mount+0x3e8/0x468 fs/namespace.c:4409 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline] invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151 el0_svc+0x58/0x17c arch/arm64/kernel/entry-common.c:767 el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:786 el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600 Code: f0047182 91178042 528089c3 9771d47b (d4210000) ---[ end trace 0000000000000000 ]--- This happens because we are processing an empty block group, which has no extents allocated from it, there are no items for this block group, including the block group item since block group items are stored in a dedicated tree when using the block group tree feature. It also means this is the block group with the highest start offset, so there are no higher keys in the extent root, hence btrfs_search_slot_for_read() returns 1 (no higher key found). Fix this by asserting 'ret' is 0 only if the block group tree feature is not enabled, in which case we should find a block group item for the block group since it's stored in the extent root and block group item keys are greater than extent item keys (the value for BTRFS_BLOCK_GROUP_ITEM_KEY is 192 and for BTRFS_EXTENT_ITEM_KEY and BTRFS_METADATA_ITEM_KEY the values are 168 and 169 respectively). In case 'ret' is 1, we just need to add a record to the free space tree which spans the whole block group, and we can achieve this by making 'ret == 0' as the while loop's condition.",,"[{""url"":""https://git.kernel.org/stable/c/0bcc14f36c7ad37121cf5c0ae18cdde5bfad9c4e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1961d20f6fa8903266ed9bd77c691924c22c8f02"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6bbe6530b1db7b4365ce9e86144c18c5d73b2c5b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c77df23324f60bcff0ea44392e2c82e9486640c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f4428b2d4c68732653e93f748f538bdee639ff80"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38504,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T11:15:43.293,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: io_uring/zcrx: fix pp destruction warnings With multiple page pools and in some other cases we can have allocated niovs on page pool destruction. Remove a misplaced warning checking that all niovs are returned to zcrx on io_pp_zc_destroy(). It was reported before but apparently got lost.",,"[{""url"":""https://git.kernel.org/stable/c/203817de269539c062724d97dfa5af3cdf77a3ec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad9f1b5bed082b9c910e2a24bae0286a70846909"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38505,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T11:15:43.407,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mwifiex: discard erroneous disassoc frames on STA interface When operating in concurrent STA/AP mode with host MLME enabled, the firmware incorrectly sends disassociation frames to the STA interface when clients disconnect from the AP interface. This causes kernel warnings as the STA interface processes disconnect events that don't apply to it: [ 1303.240540] WARNING: CPU: 0 PID: 513 at net/wireless/mlme.c:141 cfg80211_process_disassoc+0x78/0xec [cfg80211] [ 1303.250861] Modules linked in: 8021q garp stp mrp llc rfcomm bnep btnxpuart nls_iso8859_1 nls_cp437 onboard_us [ 1303.327651] CPU: 0 UID: 0 PID: 513 Comm: kworker/u9:2 Not tainted 6.16.0-rc1+ #3 PREEMPT [ 1303.335937] Hardware name: Toradex Verdin AM62 WB on Verdin Development Board (DT) [ 1303.343588] Workqueue: MWIFIEX_RX_WORK_QUEUE mwifiex_rx_work_queue [mwifiex] [ 1303.350856] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 1303.357904] pc : cfg80211_process_disassoc+0x78/0xec [cfg80211] [ 1303.364065] lr : cfg80211_process_disassoc+0x70/0xec [cfg80211] [ 1303.370221] sp : ffff800083053be0 [ 1303.373590] x29: ffff800083053be0 x28: 0000000000000000 x27: 0000000000000000 [ 1303.380855] x26: 0000000000000000 x25: 00000000ffffffff x24: ffff000002c5b8ae [ 1303.388120] x23: ffff000002c5b884 x22: 0000000000000001 x21: 0000000000000008 [ 1303.395382] x20: ffff000002c5b8ae x19: ffff0000064dd408 x18: 0000000000000006 [ 1303.402646] x17: 3a36333a61623a30 x16: 32206d6f72662063 x15: ffff800080bfe048 [ 1303.409910] x14: ffff000003625300 x13: 0000000000000001 x12: 0000000000000000 [ 1303.417173] x11: 0000000000000002 x10: ffff000003958600 x9 : ffff000003625300 [ 1303.424434] x8 : ffff00003fd9ef40 x7 : ffff0000039fc280 x6 : 0000000000000002 [ 1303.431695] x5 : ffff0000038976d4 x4 : 0000000000000000 x3 : 0000000000003186 [ 1303.438956] x2 : 000000004836ba20 x1 : 0000000000006986 x0 : 00000000d00479de [ 1303.446221] Call trace: [ 1303.448722] cfg80211_process_disassoc+0x78/0xec [cfg80211] (P) [ 1303.454894] cfg80211_rx_mlme_mgmt+0x64/0xf8 [cfg80211] [ 1303.460362] mwifiex_process_mgmt_packet+0x1ec/0x460 [mwifiex] [ 1303.466380] mwifiex_process_sta_rx_packet+0x1bc/0x2a0 [mwifiex] [ 1303.472573] mwifiex_handle_rx_packet+0xb4/0x13c [mwifiex] [ 1303.478243] mwifiex_rx_work_queue+0x158/0x198 [mwifiex] [ 1303.483734] process_one_work+0x14c/0x28c [ 1303.487845] worker_thread+0x2cc/0x3d4 [ 1303.491680] kthread+0x12c/0x208 [ 1303.495014] ret_from_fork+0x10/0x20 Add validation in the STA receive path to verify that disassoc/deauth frames originate from the connected AP. Frames that fail this check are discarded early, preventing them from reaching the MLME layer and triggering WARN_ON(). This filtering logic is similar with that used in the ieee80211_rx_mgmt_disassoc() function in mac80211, which drops disassoc frames that don't match the current BSSID (!ether_addr_equal(mgmt->bssid, sdata->vif.cfg.ap_addr)), ensuring only relevant frames are processed. Tested on: - 8997 with FW 16.68.1.p197",,"[{""url"":""https://git.kernel.org/stable/c/3b602ddc0df723992721b0d286c90c9bdd755b34"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/52654cebaac23dae31a9c97ae0da5be649f1ab4d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a963819a121f5dd61e0b39934d8b5dec529da96a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38506,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T11:15:43.527,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: KVM: Allow CPU to reschedule while setting per-page memory attributes When running an SEV-SNP guest with a sufficiently large amount of memory (1TB+), the host can experience CPU soft lockups when running an operation in kvm_vm_set_mem_attributes() to set memory attributes on the whole range of guest memory. watchdog: BUG: soft lockup - CPU#8 stuck for 26s! [qemu-kvm:6372] CPU: 8 UID: 0 PID: 6372 Comm: qemu-kvm Kdump: loaded Not tainted 6.15.0-rc7.20250520.el9uek.rc1.x86_64 #1 PREEMPT(voluntary) Hardware name: Oracle Corporation ORACLE SERVER E4-2c/Asm,MB Tray,2U,E4-2c, BIOS 78016600 11/13/2024 RIP: 0010:xas_create+0x78/0x1f0 Code: 00 00 00 41 80 fc 01 0f 84 82 00 00 00 ba 06 00 00 00 bd 06 00 00 00 49 8b 45 08 4d 8d 65 08 41 39 d6 73 20 83 ed 06 48 85 c0 <74> 67 48 89 c2 83 e2 03 48 83 fa 02 75 0c 48 3d 00 10 00 00 0f 87 RSP: 0018:ffffad890a34b940 EFLAGS: 00000286 RAX: ffff96f30b261daa RBX: ffffad890a34b9c8 RCX: 0000000000000000 RDX: 000000000000001e RSI: 0000000000000000 RDI: 0000000000000000 RBP: 0000000000000018 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000000 R12: ffffad890a356868 R13: ffffad890a356860 R14: 0000000000000000 R15: ffffad890a356868 FS: 00007f5578a2a400(0000) GS:ffff97ed317e1000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f015c70fb18 CR3: 00000001109fd006 CR4: 0000000000f70ef0 PKRU: 55555554 Call Trace: <TASK> xas_store+0x58/0x630 __xa_store+0xa5/0x130 xa_store+0x2c/0x50 kvm_vm_set_mem_attributes+0x343/0x710 [kvm] kvm_vm_ioctl+0x796/0xab0 [kvm] __x64_sys_ioctl+0xa3/0xd0 do_syscall_64+0x8c/0x7a0 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7f5578d031bb Code: ff ff ff 85 c0 79 9b 49 c7 c4 ff ff ff ff 5b 5d 4c 89 e0 41 5c c3 66 0f 1f 84 00 00 00 00 00 f3 0f 1e fa b8 10 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 2d 4c 0f 00 f7 d8 64 89 01 48 RSP: 002b:00007ffe0a742b88 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 000000004020aed2 RCX: 00007f5578d031bb RDX: 00007ffe0a742c80 RSI: 000000004020aed2 RDI: 000000000000000b RBP: 0000010000000000 R08: 0000010000000000 R09: 0000017680000000 R10: 0000000000000080 R11: 0000000000000246 R12: 00005575e5f95120 R13: 00007ffe0a742c80 R14: 0000000000000008 R15: 00005575e5f961e0 While looping through the range of memory setting the attributes, call cond_resched() to give the scheduler a chance to run a higher priority task on the runqueue if necessary and avoid staying in kernel mode long enough to trigger the lockup.",,"[{""url"":""https://git.kernel.org/stable/c/1ef45ae7a3938f0844032ba670b4f89180a5bffc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/47bb584237cc285e3a860b70c01f7bda9dcfb05b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d9bd1163c8d8f716f45e54d034ee28757cc85549"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38507,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T11:15:43.653,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: HID: nintendo: avoid bluetooth suspend/resume stalls Ensure we don't stall or panic the kernel when using bluetooth-connected controllers. This was reported as an issue on android devices using kernel 6.6 due to the resume hook which had been added for usb joycons. First, set a new state value to JOYCON_CTLR_STATE_SUSPENDED in a newly-added nintendo_hid_suspend. This makes sure we will not stall out the kernel waiting for input reports during led classdev suspend. The stalls could happen if connectivity is unreliable or lost to the controller prior to suspend. Second, since we lose connectivity during suspend, do not try joycon_init() for bluetooth controllers in the nintendo_hid_resume path. Tested via multiple suspend/resume flows when using the controller both in USB and bluetooth modes.",,"[{""url"":""https://git.kernel.org/stable/c/4a0381080397e77792a5168069f174d3e56175ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/72cb7eef06a5cde42b324dea85fa11fd5bb6a08a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7b4a026313529a487821ef6ab494a61f12c1db08"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38508,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T11:15:43.773,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: x86/sev: Use TSC_FACTOR for Secure TSC frequency calculation When using Secure TSC, the GUEST_TSC_FREQ MSR reports a frequency based on the nominal P0 frequency, which deviates slightly (typically ~0.2%) from the actual mean TSC frequency due to clocking parameters. Over extended VM uptime, this discrepancy accumulates, causing clock skew between the hypervisor and a SEV-SNP VM, leading to early timer interrupts as perceived by the guest. The guest kernel relies on the reported nominal frequency for TSC-based timekeeping, while the actual frequency set during SNP_LAUNCH_START may differ. This mismatch results in inaccurate time calculations, causing the guest to perceive hrtimers as firing earlier than expected. Utilize the TSC_FACTOR from the SEV firmware's secrets page (see ""Secrets Page Format"" in the SNP Firmware ABI Specification) to calculate the mean TSC frequency, ensuring accurate timekeeping and mitigating clock skew in SEV-SNP VMs. Use early_ioremap_encrypted() to map the secrets page as ioremap_encrypted() uses kmalloc() which is not available during early TSC initialization and causes a panic. [ bp: Drop the silly dummy var: https://lore.kernel.org/r/20250630192726.GBaGLlHl84xIopx4Pt@fat_crate.local ]",,"[{""url"":""https://git.kernel.org/stable/c/52e1a03e6cf61ae165f59f41c44394a653a0a788"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d0195c42e65805938c9eb507657e7cdf8e1e9522"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38509,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T11:15:43.893,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mac80211: reject VHT opmode for unsupported channel widths VHT operating mode notifications are not defined for channel widths below 20 MHz. In particular, 5 MHz and 10 MHz are not valid under the VHT specification and must be rejected. Without this check, malformed notifications using these widths may reach ieee80211_chan_width_to_rx_bw(), leading to a WARN_ON due to invalid input. This issue was reported by syzbot. Reject these unsupported widths early in sta_link_apply_parameters() when opmode_notif is used. The accepted set includes 20, 40, 80, 160, and 80+80 MHz, which are valid for VHT. While 320 MHz is not defined for VHT, it is allowed to avoid rejecting HE or EHT clients that may still send a VHT opmode notification.",,"[{""url"":""https://git.kernel.org/stable/c/18eca59a04500b68a90e0c5c873f97c9d1ea2bfa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/58fcb1b4287ce38850402bb2bb16d09bf77b91d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38510,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T11:15:44.010,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: kasan: remove kasan_find_vm_area() to prevent possible deadlock find_vm_area() couldn't be called in atomic_context. If find_vm_area() is called to reports vm area information, kasan can trigger deadlock like: CPU0 CPU1 vmalloc(); alloc_vmap_area(); spin_lock(&vn->busy.lock) spin_lock_bh(&some_lock); <interrupt occurs> <in softirq> spin_lock(&some_lock); <access invalid address> kasan_report(); print_report(); print_address_description(); kasan_find_vm_area(); find_vm_area(); spin_lock(&vn->busy.lock) // deadlock! To prevent possible deadlock while kasan reports, remove kasan_find_vm_area().",,"[{""url"":""https://git.kernel.org/stable/c/0c3566d831def922cd56322c772a7b20d8b0e0c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2d89dab1ea6086e6cbe6fe92531b496fb6808cb9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/595f78d99b9051600233c0a5c4c47e1097e6ed01"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6ee9b3d84775944fb8c8a447961cd01274ac671c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8377d7744bdce5c4b3f1b58924eebd3fdc078dfc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38511,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T11:15:44.140,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/xe/pf: Clear all LMTT pages on alloc Our LMEM buffer objects are not cleared by default on alloc and during VF provisioning we only setup LMTT PTEs for the actually provisioned LMEM range. But beyond that valid range we might leave some stale data that could either point to some other VFs allocations or even to the PF pages. Explicitly clear all new LMTT page to avoid the risk that a malicious VF would try to exploit that gap. While around add asserts to catch any undesired PTE overwrites and low-level debug traces to track LMTT PT life-cycle. (cherry picked from commit 3fae6918a3e27cce20ded2551f863fb05d4bef8d)",,"[{""url"":""https://git.kernel.org/stable/c/5d21892c2e15b6a27f8bc907693eca7c6b7cc269"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/705a412a367f383430fa34bada387af2e52eb043"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff4b8c9ade1b82979fdd01e6f45b60f92eed26d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38512,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T11:15:44.263,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: prevent A-MSDU attacks in mesh networks This patch is a mitigation to prevent the A-MSDU spoofing vulnerability for mesh networks. The initial update to the IEEE 802.11 standard, in response to the FragAttacks, missed this case (CVE-2025-27558). It can be considered a variant of CVE-2020-24588 but for mesh networks. This patch tries to detect if a standard MSDU was turned into an A-MSDU by an adversary. This is done by parsing a received A-MSDU as a standard MSDU, calculating the length of the Mesh Control header, and seeing if the 6 bytes after this header equal the start of an rfc1042 header. If equal, this is a strong indication of an ongoing attack attempt. This defense was tested with mac80211_hwsim against a mesh network that uses an empty Mesh Address Extension field, i.e., when four addresses are used, and when using a 12-byte Mesh Address Extension field, i.e., when six addresses are used. Functionality of normal MSDUs and A-MSDUs was also tested, and confirmed working, when using both an empty and 12-byte Mesh Address Extension field. It was also tested with mac80211_hwsim that A-MSDU attacks in non-mesh networks keep being detected and prevented. Note that the vulnerability being patched, and the defense being implemented, was also discussed in the following paper and in the following IEEE 802.11 presentation: https://papers.mathyvanhoef.com/wisec2025.pdf https://mentor.ieee.org/802.11/dcn/25/11-25-0949-00-000m-a-msdu-mesh-spoof-protection.docx",,"[{""url"":""https://git.kernel.org/stable/c/6e3b09402cc6c3e3474fa548e8adf6897dda05de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/737bb912ebbe4571195c56eba557c4d7315b26fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e01851f6e9a665a6011b14714b271d3e6b0b8d32"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e2c8a3c0388aef6bfc4aabfba07bc7dff16eea80"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec6392061de6681148b63ee6c8744da833498cdd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38513,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T11:15:44.383,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: zd1211rw: Fix potential NULL pointer dereference in zd_mac_tx_to_dev() There is a potential NULL pointer dereference in zd_mac_tx_to_dev(). For example, the following is possible: T0 T1 zd_mac_tx_to_dev() /* len == skb_queue_len(q) */ while (len > ZD_MAC_MAX_ACK_WAITERS) { filter_ack() spin_lock_irqsave(&q->lock, flags); /* position == skb_queue_len(q) */ for (i=1; i<position; i++) skb = __skb_dequeue(q) if (mac->type == NL80211_IFTYPE_AP) skb = __skb_dequeue(q); spin_unlock_irqrestore(&q->lock, flags); skb_dequeue() -> NULL Since there is a small gap between checking skb queue length and skb being unconditionally dequeued in zd_mac_tx_to_dev(), skb_dequeue() can return NULL. Then the pointer is passed to zd_mac_tx_status() where it is dereferenced. In order to avoid potential NULL pointer dereference due to situations like above, check if skb is not NULL before passing it to zd_mac_tx_status(). Found by Linux Verification Center (linuxtesting.org) with SVACE.",,"[{""url"":""https://git.kernel.org/stable/c/014c34dc132015c4f918ada4982e952947ac1047"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5420de65efbeb6503bcf1d43451c9df67ad60298"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/602b4eb2f25668de15de69860ec99caf65b3684d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74b1ec9f5d627d2bdd5e5b6f3f81c23317657023"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/adf08c96b963c7cd7ec1ee1c0c556228d9bedaae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b24f65c184540dfb967479320ecf7e8c2e9220dc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c1958270de947604cc6de05fc96dbba256b49cf0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fcd9c923b58e86501450b9b442ccc7ce4a8d0fda"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38514,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T11:15:44.510,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: rxrpc: Fix oops due to non-existence of prealloc backlog struct If an AF_RXRPC service socket is opened and bound, but calls are preallocated, then rxrpc_alloc_incoming_call() will oops because the rxrpc_backlog struct doesn't get allocated until the first preallocation is made. Fix this by returning NULL from rxrpc_alloc_incoming_call() if there is no backlog struct. This will cause the incoming call to be aborted.",,"[{""url"":""https://git.kernel.org/stable/c/0eef29385d715d4c7fd707b18d4a9b76c76dd5e6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2c2e9ebeb036f9b1b09325ec5cfdfe0e78f357c3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/880a88f318cf1d2a0f4c0a7ff7b07e2062b434a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf0ca6a1bc4fb904b598137c6718785a107e3adf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d1ff5f9d2c5405681457262e23c720b08977c11f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/efc1b2b7c1a308b60df8f36bc2d7ce16d3999364"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f5e72b7824d08c206ce106d30cb37c4642900ccc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f7afb3ff01c42c49e8a143cdce400b95844bb506"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38515,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T11:15:44.637,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/sched: Increment job count before swapping tail spsc queue A small race exists between spsc_queue_push and the run-job worker, in which spsc_queue_push may return not-first while the run-job worker has already idled due to the job count being zero. If this race occurs, job scheduling stops, leading to hangs while waiting on the jobs DMA fences. Seal this race by incrementing the job count before appending to the SPSC queue. This race was observed on a drm-tip 6.16-rc1 build with the Xe driver in an SVM test case.",,"[{""url"":""https://git.kernel.org/stable/c/549a9c78c3ea6807d0dc4162a4f5ba59f217d5a0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8af39ec5cf2be522c8eb43a3d8005ed59e4daaee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c64f5310530baf75328292f9b9f3f2961d185183"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e2d6547dc8b9b332f9bc00875197287a6a4db65a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e62f51d0ec8a9baf324caf9a564f8e318d36a551"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ef58a95457466849fa7b31fd3953801a5af0f58b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ef841f8e4e1ff67817ca899bedc5ebb00847c0a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f9a4f28a4fc4ee453a92a9abbe36e26224d17749"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38516,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T11:15:44.763,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: pinctrl: qcom: msm: mark certain pins as invalid for interrupts On some platforms, the UFS-reset pin has no interrupt logic in TLMM but is nevertheless registered as a GPIO in the kernel. This enables the user-space to trigger a BUG() in the pinctrl-msm driver by running, for example: `gpiomon -c 0 113` on RB2. The exact culprit is requesting pins whose intr_detection_width setting is not 1 or 2 for interrupts. This hits a BUG() in msm_gpio_irq_set_type(). Potentially crashing the kernel due to an invalid request from user-space is not optimal, so let's go through the pins and mark those that would fail the check as invalid for the irq chip as we should not even register them as available irqs. This function can be extended if we determine that there are more corner-cases like this.",,"[{""url"":""https://git.kernel.org/stable/c/1d57f7132662e96aace3b8a000616efde289aae1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/275605a8b48002fe98675a5c06f3e39c09067ff2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f8fc02c2582c1dfad1785e9c7bc8b4e1521af0a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6a89563ccf9cd0d745e2291302878a061508573f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/93712205ce2f1fb047739494c0399a26ea4f0890"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/97c9c7daeeb00c6e1d5e84084041f79c2d2dce22"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cb4b08a095b1fa4b3fca782757517e4e9a917d8e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc145e02d6b8494c48f91958d52fa76b7e577f7b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38517,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T11:15:44.897,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: lib/alloc_tag: do not acquire non-existent lock in alloc_tag_top_users() alloc_tag_top_users() attempts to lock alloc_tag_cttype->mod_lock even when the alloc_tag_cttype is not allocated because: 1) alloc tagging is disabled because mem profiling is disabled (!alloc_tag_cttype) 2) alloc tagging is enabled, but not yet initialized (!alloc_tag_cttype) 3) alloc tagging is enabled, but failed initialization (!alloc_tag_cttype or IS_ERR(alloc_tag_cttype)) In all cases, alloc_tag_cttype is not allocated, and therefore alloc_tag_top_users() should not attempt to acquire the semaphore. This leads to a crash on memory allocation failure by attempting to acquire a non-existent semaphore: Oops: general protection fault, probably for non-canonical address 0xdffffc000000001b: 0000 [#3] SMP KASAN NOPTI KASAN: null-ptr-deref in range [0x00000000000000d8-0x00000000000000df] CPU: 2 UID: 0 PID: 1 Comm: systemd Tainted: G D 6.16.0-rc2 #1 VOLUNTARY Tainted: [D]=DIE Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014 RIP: 0010:down_read_trylock+0xaa/0x3b0 Code: d0 7c 08 84 d2 0f 85 a0 02 00 00 8b 0d df 31 dd 04 85 c9 75 29 48 b8 00 00 00 00 00 fc ff df 48 8d 6b 68 48 89 ea 48 c1 ea 03 <80> 3c 02 00 0f 85 88 02 00 00 48 3b 5b 68 0f 85 53 01 00 00 65 ff RSP: 0000:ffff8881002ce9b8 EFLAGS: 00010016 RAX: dffffc0000000000 RBX: 0000000000000070 RCX: 0000000000000000 RDX: 000000000000001b RSI: 000000000000000a RDI: 0000000000000070 RBP: 00000000000000d8 R08: 0000000000000001 R09: ffffed107dde49d1 R10: ffff8883eef24e8b R11: ffff8881002cec20 R12: 1ffff11020059d37 R13: 00000000003fff7b R14: ffff8881002cec20 R15: dffffc0000000000 FS: 00007f963f21d940(0000) GS:ffff888458ca6000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f963f5edf71 CR3: 000000010672c000 CR4: 0000000000350ef0 Call Trace: <TASK> codetag_trylock_module_list+0xd/0x20 alloc_tag_top_users+0x369/0x4b0 __show_mem+0x1cd/0x6e0 warn_alloc+0x2b1/0x390 __alloc_frozen_pages_noprof+0x12b9/0x21a0 alloc_pages_mpol+0x135/0x3e0 alloc_slab_page+0x82/0xe0 new_slab+0x212/0x240 ___slab_alloc+0x82a/0xe00 </TASK> As David Wang points out, this issue became easier to trigger after commit 780138b12381 (""alloc_tag: check mem_profiling_support in alloc_tag_init""). Before the commit, the issue occurred only when it failed to allocate and initialize alloc_tag_cttype or if a memory allocation fails before alloc_tag_init() is called. After the commit, it can be easily triggered when memory profiling is compiled but disabled at boot. To properly determine whether alloc_tag_init() has been called and its data structures initialized, verify that alloc_tag_cttype is a valid pointer before acquiring the semaphore. If the variable is NULL or an error value, it has not been properly initialized. In such a case, just skip and do not attempt to acquire the semaphore. [harry.yoo@oracle.com: v3]",,"[{""url"":""https://git.kernel.org/stable/c/22bf79c0c2301b6e15a688220284b147774d277e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/99af22cd34688cc0d535a1919e0bea4cbc6c1ea1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/febc0b5dbabda414565bdfaaaa59d26f787d5fe7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38518,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T11:15:45.020,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: x86/CPU/AMD: Disable INVLPGB on Zen2 AMD Cyan Skillfish (Family 17h, Model 47h, Stepping 0h) has an issue that causes system oopses and panics when performing TLB flush using INVLPGB. However, the problem is that that machine has misconfigured CPUID and should not report the INVLPGB bit in the first place. So zap the kernel's representation of the flag so that nothing gets confused. [ bp: Massage. ]",,"[{""url"":""https://git.kernel.org/stable/c/357f121517924e3ec3021f9d0dd0189adcd09867"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a74bb5f202dabddfea96abc1328fcedae8aa140a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38519,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T11:15:45.160,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm/damon: fix divide by zero in damon_get_intervals_score() The current implementation allows having zero size regions with no special reasons, but damon_get_intervals_score() gets crashed by divide by zero when the region size is zero. [ 29.403950] Oops: divide error: 0000 [#1] SMP NOPTI This patch fixes the bug, but does not disallow zero size regions to keep the backward compatibility since disallowing zero size regions might be a breaking change for some users. In addition, the same crash can happen when intervals_goal.access_bp is zero so this should be fixed in stable trees as well.",,"[{""url"":""https://git.kernel.org/stable/c/bd225b9591442065beb876da72656f4a2d627d03"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca4bb9ac706f05ead8ac1cce7b8245fc0645a687"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38520,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T11:15:45.283,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdkfd: Don't call mmput from MMU notifier callback If the process is exiting, the mmput inside mmu notifier callback from compactd or fork or numa balancing could release the last reference of mm struct to call exit_mmap and free_pgtable, this triggers deadlock with below backtrace. The deadlock will leak kfd process as mmu notifier release is not called and cause VRAM leaking. The fix is to take mm reference mmget_non_zero when adding prange to the deferred list to pair with mmput in deferred list work. If prange split and add into pchild list, the pchild work_item.mm is not used, so remove the mm parameter from svm_range_unmap_split and svm_range_add_child. The backtrace of hung task: INFO: task python:348105 blocked for more than 64512 seconds. Call Trace: __schedule+0x1c3/0x550 schedule+0x46/0xb0 rwsem_down_write_slowpath+0x24b/0x4c0 unlink_anon_vmas+0xb1/0x1c0 free_pgtables+0xa9/0x130 exit_mmap+0xbc/0x1a0 mmput+0x5a/0x140 svm_range_cpu_invalidate_pagetables+0x2b/0x40 [amdgpu] mn_itree_invalidate+0x72/0xc0 __mmu_notifier_invalidate_range_start+0x48/0x60 try_to_unmap_one+0x10fa/0x1400 rmap_walk_anon+0x196/0x460 try_to_unmap+0xbb/0x210 migrate_page_unmap+0x54d/0x7e0 migrate_pages_batch+0x1c3/0xae0 migrate_pages_sync+0x98/0x240 migrate_pages+0x25c/0x520 compact_zone+0x29d/0x590 compact_zone_order+0xb6/0xf0 try_to_compact_pages+0xbe/0x220 __alloc_pages_direct_compact+0x96/0x1a0 __alloc_pages_slowpath+0x410/0x930 __alloc_pages_nodemask+0x3a9/0x3e0 do_huge_pmd_anonymous_page+0xd7/0x3e0 __handle_mm_fault+0x5e3/0x5f0 handle_mm_fault+0xf7/0x2e0 hmm_vma_fault.isra.0+0x4d/0xa0 walk_pmd_range.isra.0+0xa8/0x310 walk_pud_range+0x167/0x240 walk_pgd_range+0x55/0x100 __walk_page_range+0x87/0x90 walk_page_range+0xf6/0x160 hmm_range_fault+0x4f/0x90 amdgpu_hmm_range_get_pages+0x123/0x230 [amdgpu] amdgpu_ttm_tt_get_user_pages+0xb1/0x150 [amdgpu] init_user_pages+0xb1/0x2a0 [amdgpu] amdgpu_amdkfd_gpuvm_alloc_memory_of_gpu+0x543/0x7d0 [amdgpu] kfd_ioctl_alloc_memory_of_gpu+0x24c/0x4e0 [amdgpu] kfd_ioctl+0x29d/0x500 [amdgpu] (cherry picked from commit a29e067bd38946f752b0ef855f3dfff87e77bec7)",,"[{""url"":""https://git.kernel.org/stable/c/145a56bd68f4bff098d59fbc7c263d20dfef4fc4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a7eb0a25010a674c8fdfbece38353ef7be8c5834"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c1bde9d48e09933c361521720f77a8072083c83a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cf234231fcbc7d391e2135b9518613218cc5347f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e90ee15ce28c61f6d83a0511c3e02e2662478350"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38521,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T11:15:45.413,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/imagination: Fix kernel crash when hard resetting the GPU The GPU hard reset sequence calls pm_runtime_force_suspend() and pm_runtime_force_resume(), which according to their documentation should only be used during system-wide PM transitions to sleep states. The main issue though is that depending on some internal runtime PM state as seen by pm_runtime_force_suspend() (whether the usage count is <= 1), pm_runtime_force_resume() might not resume the device unless needed. If that happens, the runtime PM resume callback pvr_power_device_resume() is not called, the GPU clocks are not re-enabled, and the kernel crashes on the next attempt to access GPU registers as part of the power-on sequence. Replace calls to pm_runtime_force_suspend() and pm_runtime_force_resume() with direct calls to the driver's runtime PM callbacks, pvr_power_device_suspend() and pvr_power_device_resume(), to ensure clocks are re-enabled and avoid the kernel crash.",,"[{""url"":""https://git.kernel.org/stable/c/9f852d301f642223c4798f3c13ba15e91165d078"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d38376b3ee48d073c64e75e150510d7e6b4b04f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e066cc6e0f094ca2120f1928d126d56f686cd73e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38522,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:27.523,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: sched/ext: Prevent update_locked_rq() calls with NULL rq Avoid invoking update_locked_rq() when the runqueue (rq) pointer is NULL in the SCX_CALL_OP and SCX_CALL_OP_RET macros. Previously, calling update_locked_rq(NULL) with preemption enabled could trigger the following warning: BUG: using __this_cpu_write() in preemptible [00000000] This happens because __this_cpu_write() is unsafe to use in preemptible context. rq is NULL when an ops invoked from an unlocked context. In such cases, we don't need to store any rq, since the value should already be NULL (unlocked). Ensure that update_locked_rq() is only called when rq is non-NULL, preventing calling __this_cpu_write() on preemptible context.",,"[{""url"":""https://git.kernel.org/stable/c/237c43037b336e36a49eb9f2daac1c7719ec7f8b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e14fd98c6d66cb76694b12c05768e4f9e8c95664"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38523,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:27.667,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: cifs: Fix the smbd_response slab to allow usercopy The handling of received data in the smbdirect client code involves using copy_to_iter() to copy data from the smbd_reponse struct's packet trailer to a folioq buffer provided by netfslib that encapsulates a chunk of pagecache. If, however, CONFIG_HARDENED_USERCOPY=y, this will result in the checks then performed in copy_to_iter() oopsing with something like the following: CIFS: Attempting to mount //172.31.9.1/test CIFS: VFS: RDMA transport established usercopy: Kernel memory exposure attempt detected from SLUB object 'smbd_response_0000000091e24ea1' (offset 81, size 63)! ------------[ cut here ]------------ kernel BUG at mm/usercopy.c:102! ... RIP: 0010:usercopy_abort+0x6c/0x80 ... Call Trace: <TASK> __check_heap_object+0xe3/0x120 __check_object_size+0x4dc/0x6d0 smbd_recv+0x77f/0xfe0 [cifs] cifs_readv_from_socket+0x276/0x8f0 [cifs] cifs_read_from_socket+0xcd/0x120 [cifs] cifs_demultiplex_thread+0x7e9/0x2d50 [cifs] kthread+0x396/0x830 ret_from_fork+0x2b8/0x3b0 ret_from_fork_asm+0x1a/0x30 The problem is that the smbd_response slab's packet field isn't marked as being permitted for usercopy. Fix this by passing parameters to kmem_slab_create() to indicate that copy_to_iter() is permitted from the packet region of the smbd_response slab objects, less the header space.",,"[{""url"":""https://git.kernel.org/stable/c/43e7e284fc77b710d899569360ea46fa3374ae22"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/87dcc7e33fc3dcb8ed32333cec016528b5bb6ce4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f0dd353d47f7051afa98c6c60c7486831eb1a410"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38524,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:27.800,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: rxrpc: Fix recv-recv race of completed call If a call receives an event (such as incoming data), the call gets placed on the socket's queue and a thread in recvmsg can be awakened to go and process it. Once the thread has picked up the call off of the queue, further events will cause it to be requeued, and once the socket lock is dropped (recvmsg uses call->user_mutex to allow the socket to be used in parallel), a second thread can come in and its recvmsg can pop the call off the socket queue again. In such a case, the first thread will be receiving stuff from the call and the second thread will be blocked on call->user_mutex. The first thread can, at this point, process both the event that it picked call for and the event that the second thread picked the call for and may see the call terminate - in which case the call will be ""released"", decoupling the call from the user call ID assigned to it (RXRPC_USER_CALL_ID in the control message). The first thread will return okay, but then the second thread will wake up holding the user_mutex and, if it sees that the call has been released by the first thread, it will BUG thusly: kernel BUG at net/rxrpc/recvmsg.c:474! Fix this by just dequeuing the call and ignoring it if it is seen to be already released. We can't tell userspace about it anyway as the user call ID has become stale.",,"[{""url"":""https://git.kernel.org/stable/c/6c75a97a32a5fa2060c3dd30207e63b6914b606d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7692bde890061797f3dece0148d7859e85c55778"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/839fe96c15209dc2255c064bb44b636efe04f032"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/962fb1f651c2cf2083e0c3ef53ba69e3b96d3fbc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38525,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:27.933,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: rxrpc: Fix irq-disabled in local_bh_enable() The rxrpc_assess_MTU_size() function calls down into the IP layer to find out the MTU size for a route. When accepting an incoming call, this is called from rxrpc_new_incoming_call() which holds interrupts disabled across the code that calls down to it. Unfortunately, the IP layer uses local_bh_enable() which, config dependent, throws a warning if IRQs are enabled: WARNING: CPU: 1 PID: 5544 at kernel/softirq.c:387 __local_bh_enable_ip+0x43/0xd0 ... RIP: 0010:__local_bh_enable_ip+0x43/0xd0 ... Call Trace: <TASK> rt_cache_route+0x7e/0xa0 rt_set_nexthop.isra.0+0x3b3/0x3f0 __mkroute_output+0x43a/0x460 ip_route_output_key_hash+0xf7/0x140 ip_route_output_flow+0x1b/0x90 rxrpc_assess_MTU_size.isra.0+0x2a0/0x590 rxrpc_new_incoming_peer+0x46/0x120 rxrpc_alloc_incoming_call+0x1b1/0x400 rxrpc_new_incoming_call+0x1da/0x5e0 rxrpc_input_packet+0x827/0x900 rxrpc_io_thread+0x403/0xb60 kthread+0x2f7/0x310 ret_from_fork+0x2a/0x230 ret_from_fork_asm+0x1a/0x30 ... hardirqs last enabled at (23): _raw_spin_unlock_irq+0x24/0x50 hardirqs last disabled at (24): _raw_read_lock_irq+0x17/0x70 softirqs last enabled at (0): copy_process+0xc61/0x2730 softirqs last disabled at (25): rt_add_uncached_list+0x3c/0x90 Fix this by moving the call to rxrpc_assess_MTU_size() out of rxrpc_init_peer() and further up the stack where it can be done without interrupts disabled. It shouldn't be a problem for rxrpc_new_incoming_call() to do it after the locks are dropped as pmtud is going to be performed by the I/O thread - and we're in the I/O thread at this point.",,"[{""url"":""https://git.kernel.org/stable/c/2029f21f10dedb88c0f86abffcf8d6c21dcf6040"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e4d2878369d590bf8455e3678a644e503172eafa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38526,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:28.060,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ice: add NULL check in eswitch lag check The function ice_lag_is_switchdev_running() is being called from outside of the LAG event handler code. This results in the lag->upper_netdev being NULL sometimes. To avoid a NULL-pointer dereference, there needs to be a check before it is dereferenced.",,"[{""url"":""https://git.kernel.org/stable/c/245917d3c5ed7c6ae720302b64eac5c6f0c85177"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/27591d926191e42b2332e4bad3bcd3a49def393b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ce58b01ada408b372f15b7c992ed0519840e3cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a5d64f0eec82076b2c09fee2195d640cfbe3379"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38527,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:28.183,2025-08-28T15:15:51.520,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: smb: client: fix use-after-free in cifs_oplock_break A race condition can occur in cifs_oplock_break() leading to a use-after-free of the cinode structure when unmounting: cifs_oplock_break() _cifsFileInfo_put(cfile) cifsFileInfo_put_final() cifs_sb_deactive() [last ref, start releasing sb] kill_sb() kill_anon_super() generic_shutdown_super() evict_inodes() dispose_list() evict() destroy_inode() call_rcu(&inode->i_rcu, i_callback) spin_lock(&cinode->open_file_lock) <- OK [later] i_callback() cifs_free_inode() kmem_cache_free(cinode) spin_unlock(&cinode->open_file_lock) <- UAF cifs_done_oplock_break(cinode) <- UAF The issue occurs when umount has already released its reference to the superblock. When _cifsFileInfo_put() calls cifs_sb_deactive(), this releases the last reference, triggering the immediate cleanup of all inodes under RCU. However, cifs_oplock_break() continues to access the cinode after this point, resulting in use-after-free. Fix this by holding an extra reference to the superblock during the entire oplock break operation. This ensures that the superblock and its inodes remain valid until the oplock break completes.",,"[{""url"":""https://git.kernel.org/stable/c/09bce2138a30ef10d8821c8c3f73a4ab7a5726bc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0a4eec84d4d2c4085d4ed8630fd74e4b39033c1b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2baaf5bbab2ac474c4f92c10fcb3310f824db995"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4256a483fe58af66a46cbf3dc48ff26e580d3308"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/705c79101ccf9edea5a00d761491a03ced314210"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da11bd4b697b393a207f19a2ed7d382a811a3ddc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38528,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:28.313,2025-08-28T15:15:51.657,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf: Reject %p% format string in bprintf-like helpers static const char fmt[] = ""%p%""; bpf_trace_printk(fmt, sizeof(fmt)); The above BPF program isn't rejected and causes a kernel warning at runtime: Please remove unsupported %\x00 in format string WARNING: CPU: 1 PID: 7244 at lib/vsprintf.c:2680 format_decode+0x49c/0x5d0 This happens because bpf_bprintf_prepare skips over the second %, detected as punctuation, while processing %p. This patch fixes it by not skipping over punctuation. %\x00 is then processed in the next iteration and rejected.",,"[{""url"":""https://git.kernel.org/stable/c/1c5f5fd47bbda17cb885fe6f03730702cd53d3f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/61d5fa45ed13e42af14c7e959baba9908b8ee6d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6952aeace93f8c9ea01849efecac24dd3152c9c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/97303e541e12f1fea97834ec64b98991e8775f39"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e7be679124bae8cf4fa6e40d7e1661baddfb3289"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8242745871f81a3ac37f9f51853d12854fd0b58"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38529,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:28.443,2025-08-28T15:15:51.783,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: comedi: aio_iiro_16: Fix bit shift out of bounds When checking for a supported IRQ number, the following test is used: if ((1 << it->options[1]) & 0xdcfc) { However, `it->options[i]` is an unchecked `int` value from userspace, so the shift amount could be negative or out of bounds. Fix the test by requiring `it->options[1]` to be within bounds before proceeding with the original test. Valid `it->options[1]` values that select the IRQ will be in the range [1,15]. The value 0 explicitly disables the use of interrupts.",,"[{""url"":""https://git.kernel.org/stable/c/43ddd82e6a91913cea1c078e782afd8de60c3a53"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5ac7c60439236fb691b8c7987390e2327bbf18fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/66acb1586737a22dd7b78abc63213b1bcaa100e4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/955e8835855fed8e87f7d8c8075564a1746c1b4c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a88692245c315bf8e225f205297a6f4b13d6856a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c593215385f0c0163015cca4512ed3ff42875d19"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0f3c0867d7d231c70984f05c97752caacd0daba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff30dd3f15f443d2a0085b12ec2cc95d44f35fa7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38530,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:28.570,2025-08-28T15:15:51.920,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: comedi: pcl812: Fix bit shift out of bounds When checking for a supported IRQ number, the following test is used: if ((1 << it->options[1]) & board->irq_bits) { However, `it->options[i]` is an unchecked `int` value from userspace, so the shift amount could be negative or out of bounds. Fix the test by requiring `it->options[1]` to be within bounds before proceeding with the original test. Valid `it->options[1]` values that select the IRQ will be in the range [1,15]. The value 0 explicitly disables the use of interrupts.",,"[{""url"":""https://git.kernel.org/stable/c/0489c30d080f07cc7f09d04de723d8c2ccdb61ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/16c173abee315953fd17a279352fec4a1faee862"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/29ef03e5b84431171d6b77b822985b54bc44b793"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/374d9b3eb4b08407997ef1fce96119d31e0c0bc4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5bfa301e1e59a9b1a7b62a800b54852337c97416"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7e470d8efd10725b189ca8951973a8425932398a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a27e27eee313fe1c450b6af1e80e64412546cab4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b14b076ce593f72585412fc7fd3747e03a5e3632"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38531,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:28.693,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iio: common: st_sensors: Fix use of uninitialize device structs Throughout the various probe functions &indio_dev->dev is used before it is initialized. This caused a kernel panic in st_sensors_power_enable() when the call to devm_regulator_bulk_get_enable() fails and then calls dev_err_probe() with the uninitialized device. This seems to only cause a panic with dev_err_probe(), dev_err(), dev_warn() and dev_info() don't seem to cause a panic, but are fixed as well. The issue is reported and traced here: [1]",,"[{""url"":""https://git.kernel.org/stable/c/3297a9016a45144883ec990bd4bd5b1d79cafb46"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/610615c9668037e3eca11132063b93b2d945af13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9f92e93e257b33e73622640a9205f8642ec16ddd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38532,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:28.823,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: libwx: properly reset Rx ring descriptor When device reset is triggered by feature changes such as toggling Rx VLAN offload, wx->do_reset() is called to reinitialize Rx rings. The hardware descriptor ring may retain stale values from previous sessions. And only set the length to 0 in rx_desc[0] would result in building malformed SKBs. Fix it to ensure a clean slate after device reset. [ 549.186435] [ C16] ------------[ cut here ]------------ [ 549.186457] [ C16] kernel BUG at net/core/skbuff.c:2814! [ 549.186468] [ C16] Oops: invalid opcode: 0000 [#1] SMP NOPTI [ 549.186472] [ C16] CPU: 16 UID: 0 PID: 0 Comm: swapper/16 Kdump: loaded Not tainted 6.16.0-rc4+ #23 PREEMPT(voluntary) [ 549.186476] [ C16] Hardware name: Micro-Star International Co., Ltd. MS-7E16/X670E GAMING PLUS WIFI (MS-7E16), BIOS 1.90 12/31/2024 [ 549.186478] [ C16] RIP: 0010:__pskb_pull_tail+0x3ff/0x510 [ 549.186484] [ C16] Code: 06 f0 ff 4f 34 74 7b 4d 8b 8c 24 c8 00 00 00 45 8b 84 24 c0 00 00 00 e9 c8 fd ff ff 48 c7 44 24 08 00 00 00 00 e9 5e fe ff ff <0f> 0b 31 c0 e9 23 90 5b ff 41 f7 c6 ff 0f 00 00 75 bf 49 8b 06 a8 [ 549.186487] [ C16] RSP: 0018:ffffb391c0640d70 EFLAGS: 00010282 [ 549.186490] [ C16] RAX: 00000000fffffff2 RBX: ffff8fe7e4d40200 RCX: 00000000fffffff2 [ 549.186492] [ C16] RDX: ffff8fe7c3a4bf8e RSI: 0000000000000180 RDI: ffff8fe7c3a4bf40 [ 549.186494] [ C16] RBP: ffffb391c0640da8 R08: ffff8fe7c3a4c0c0 R09: 000000000000000e [ 549.186496] [ C16] R10: ffffb391c0640d88 R11: 000000000000000e R12: ffff8fe7e4d40200 [ 549.186497] [ C16] R13: 00000000fffffff2 R14: ffff8fe7fa01a000 R15: 00000000fffffff2 [ 549.186499] [ C16] FS: 0000000000000000(0000) GS:ffff8fef5ae40000(0000) knlGS:0000000000000000 [ 549.186502] [ C16] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 549.186503] [ C16] CR2: 00007f77d81d6000 CR3: 000000051a032000 CR4: 0000000000750ef0 [ 549.186505] [ C16] PKRU: 55555554 [ 549.186507] [ C16] Call Trace: [ 549.186510] [ C16] <IRQ> [ 549.186513] [ C16] ? srso_alias_return_thunk+0x5/0xfbef5 [ 549.186517] [ C16] __skb_pad+0xc7/0xf0 [ 549.186523] [ C16] wx_clean_rx_irq+0x355/0x3b0 [libwx] [ 549.186533] [ C16] wx_poll+0x92/0x120 [libwx] [ 549.186540] [ C16] __napi_poll+0x28/0x190 [ 549.186544] [ C16] net_rx_action+0x301/0x3f0 [ 549.186548] [ C16] ? srso_alias_return_thunk+0x5/0xfbef5 [ 549.186551] [ C16] ? __raw_spin_lock_irqsave+0x1e/0x50 [ 549.186554] [ C16] ? srso_alias_return_thunk+0x5/0xfbef5 [ 549.186557] [ C16] ? wake_up_nohz_cpu+0x35/0x160 [ 549.186559] [ C16] ? srso_alias_return_thunk+0x5/0xfbef5 [ 549.186563] [ C16] handle_softirqs+0xf9/0x2c0 [ 549.186568] [ C16] __irq_exit_rcu+0xc7/0x130 [ 549.186572] [ C16] common_interrupt+0xb8/0xd0 [ 549.186576] [ C16] </IRQ> [ 549.186577] [ C16] <TASK> [ 549.186579] [ C16] asm_common_interrupt+0x22/0x40 [ 549.186582] [ C16] RIP: 0010:cpuidle_enter_state+0xc2/0x420 [ 549.186585] [ C16] Code: 00 00 e8 11 0e 5e ff e8 ac f0 ff ff 49 89 c5 0f 1f 44 00 00 31 ff e8 0d ed 5c ff 45 84 ff 0f 85 40 02 00 00 fb 0f 1f 44 00 00 <45> 85 f6 0f 88 84 01 00 00 49 63 d6 48 8d 04 52 48 8d 04 82 49 8d [ 549.186587] [ C16] RSP: 0018:ffffb391c0277e78 EFLAGS: 00000246 [ 549.186590] [ C16] RAX: ffff8fef5ae40000 RBX: 0000000000000003 RCX: 0000000000000000 [ 549.186591] [ C16] RDX: 0000007fde0faac5 RSI: ffffffff826e53f6 RDI: ffffffff826fa9b3 [ 549.186593] [ C16] RBP: ffff8fe7c3a20800 R08: 0000000000000002 R09: 0000000000000000 [ 549.186595] [ C16] R10: 0000000000000000 R11: 000000000000ffff R12: ffffffff82ed7a40 [ 549.186596] [ C16] R13: 0000007fde0faac5 R14: 0000000000000003 R15: 0000000000000000 [ 549.186601] [ C16] ? cpuidle_enter_state+0xb3/0x420 [ 549.186605] [ C16] cpuidle_en ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/10e27b2a6ebeda49e9c2897a699d3ce1ded565ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d510116c80b37efb100ce8d5ee326214b0157293"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d992ed7e1b687ad7df0763d3e015a5358646210b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee527d3fba4dae1d619d2d0438624002c8e99e24"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38533,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:28.957,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: libwx: fix the using of Rx buffer DMA The wx_rx_buffer structure contained two DMA address fields: 'dma' and 'page_dma'. However, only 'page_dma' was actually initialized and used to program the Rx descriptor. But 'dma' was uninitialized and used in some paths. This could lead to undefined behavior, including DMA errors or use-after-free, if the uninitialized 'dma' was used. Althrough such error has not yet occurred, it is worth fixing in the code.",,"[{""url"":""https://git.kernel.org/stable/c/027701180a7bcb64c42eab291133ef0c87b5b6c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/05c37b574997892a40a0e9b9b88a481566b2367d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5fd77cc6bd9b368431a815a780e407b7781bcca0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba7c793f96c1c2b944bb6f423d7243f3afc30fe9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38534,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:29.087,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfs: Fix copy-to-cache so that it performs collection with ceph+fscache The netfs copy-to-cache that is used by Ceph with local caching sets up a new request to write data just read to the cache. The request is started and then left to look after itself whilst the app continues. The request gets notified by the backing fs upon completion of the async DIO write, but then tries to wake up the app because NETFS_RREQ_OFFLOAD_COLLECTION isn't set - but the app isn't waiting there, and so the request just hangs. Fix this by setting NETFS_RREQ_OFFLOAD_COLLECTION which causes the notification from the backing filesystem to put the collection onto a work queue instead.",,"[{""url"":""https://git.kernel.org/stable/c/1ebe58cef84eab22b41b4d5e72c2051ebf00af50"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c238e30774e3022a505fa54311273add7570f13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38535,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:29.217,2025-08-28T15:15:52.050,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: phy: tegra: xusb: Fix unbalanced regulator disable in UTMI PHY mode When transitioning from USB_ROLE_DEVICE to USB_ROLE_NONE, the code assumed that the regulator should be disabled. However, if the regulator is marked as always-on, regulator_is_enabled() continues to return true, leading to an incorrect attempt to disable a regulator which is not enabled. This can result in warnings such as: [ 250.155624] WARNING: CPU: 1 PID: 7326 at drivers/regulator/core.c:3004 _regulator_disable+0xe4/0x1a0 [ 250.155652] unbalanced disables for VIN_SYS_5V0 To fix this, we move the regulator control logic into tegra186_xusb_padctl_id_override() function since it's directly related to the ID override state. The regulator is now only disabled when the role transitions from USB_ROLE_HOST to USB_ROLE_NONE, by checking the VBUS_ID register. This ensures that regulator enable/disable operations are properly balanced and only occur when actually transitioning to/from host mode.",,"[{""url"":""https://git.kernel.org/stable/c/1bb85b5c2bd43b687c3d54eb6328917f90dd38fc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5367cdeb75cb6c687ca468450bceb2602ab239d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cdcb0ffd6448f6be898956913a42bd08e59fb2ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ceb645ac6ce052609ee5c8f819a80e8881789b04"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cefc1caee9dd06c69e2d807edc5949b329f52b22"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eaa420339658615d26c1cc95cd6cf720b9aebfca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec7f98ff05f0649af0adeb4808c7ba23d6111ef9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38536,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:29.347,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: airoha: fix potential use-after-free in airoha_npu_get() np->name was being used after calling of_node_put(np), which releases the node and can lead to a use-after-free bug. Previously, of_node_put(np) was called unconditionally after of_find_device_by_node(np), which could result in a use-after-free if pdev is NULL. This patch moves of_node_put(np) after the error check to ensure the node is only released after both the error and success cases are handled appropriately, preventing potential resource issues.",,"[{""url"":""https://git.kernel.org/stable/c/3cd582e7d0787506990ef0180405eb6224fa90a6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/df6bf96b41e547e350667bc4c143be53646d070d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38537,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:29.467,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: phy: Don't register LEDs for genphy If a PHY has no driver, the genphy driver is probed/removed directly in phy_attach/detach. If the PHY's ofnode has an ""leds"" subnode, then the LEDs will be (un)registered when probing/removing the genphy driver. This could occur if the leds are for a non-generic driver that isn't loaded for whatever reason. Synchronously removing the PHY device in phy_detach leads to the following deadlock: rtnl_lock() ndo_close() ... phy_detach() phy_remove() phy_leds_unregister() led_classdev_unregister() led_trigger_set() netdev_trigger_deactivate() unregister_netdevice_notifier() rtnl_lock() There is a corresponding deadlock on the open/register side of things (and that one is reported by lockdep), but it requires a race while this one is deterministic. Generic PHYs do not support LEDs anyway, so don't bother registering them.",,"[{""url"":""https://git.kernel.org/stable/c/75e1b2079ef0653a2f7aa69be515d86b7faf1908"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec158d05eaa91b2809cab65f8068290e3c05ebdd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f0f2b992d8185a0366be951685e08643aae17d6d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd6493533af9e5d73d0d42ff2a8ded978a701dc6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38538,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:29.593,2025-08-28T15:15:52.183,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dmaengine: nbpfaxi: Fix memory corruption in probe() The nbpf->chan[] array is allocated earlier in the nbpf_probe() function and it has ""num_channels"" elements. These three loops iterate one element farther than they should and corrupt memory. The changes to the second loop are more involved. In this case, we're copying data from the irqbuf[] array into the nbpf->chan[] array. If the data in irqbuf[i] is the error IRQ then we skip it, so the iterators are not in sync. I added a check to ensure that we don't go beyond the end of the irqbuf[] array. I'm pretty sure this can't happen, but it seemed harmless to add a check. On the other hand, after the loop has ended there is a check to ensure that the ""chan"" iterator is where we expect it to be. In the original code we went one element beyond the end of the array so the iterator wasn't in the correct place and it would always return -EINVAL. However, now it will always be in the correct place. I deleted the check since we know the result.",,"[{""url"":""https://git.kernel.org/stable/c/122160289adf8ebf15060f1cbf6265b55a914948"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/188c6ba1dd925849c5d94885c8bbdeb0b3dcf510"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/24861ef8b517a309a4225f2793be0cd8fa0bec9e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4bb016438335ec02b01f96bf1367378c2bfe03e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/84fff8e6f11b9af1407e273995b5257d99ff0cff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aec396b4f736f3f8d2c28a9cd2924a4ada57ae87"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d6bbd67ab5de37a74ac85c83c5a26664b62034dd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f366b36c5e3ce29c9a3c8eed3d1631908e4fc8bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38539,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:29.717,2025-08-28T15:15:52.317,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tracing: Add down_write(trace_event_sem) when adding trace event When a module is loaded, it adds trace events defined by the module. It may also need to modify the modules trace printk formats to replace enum names with their values. If two modules are loaded at the same time, the adding of the event to the ftrace_events list can corrupt the walking of the list in the code that is modifying the printk format strings and crash the kernel. The addition of the event should take the trace_event_sem for write while it adds the new event. Also add a lockdep_assert_held() on that semaphore in __trace_add_event_dirs() as it iterates the list.",,"[{""url"":""https://git.kernel.org/stable/c/33e20747b47ddc03569b6bc27a2d6894c1428182"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6bc94f20a4c304997288f9a45278c9d0c06987d3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/70fecd519caad0c1741c3379d5348c9000a5b29d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7803b28c9aa8d8bd4e19ebcf5f0db9612b0f333b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b5e8acc14dcb314a9b61ff19dcd9fdd0d88f70df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca60064ea03f14e06c763de018403cb56ba3207d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/db45632479ceecb669612ed8dbce927e3c6279fc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e70f5ee4c8824736332351b703c46f9469ed7f6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38540,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:29.830,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: HID: quirks: Add quirk for 2 Chicony Electronics HP 5MP Cameras The Chicony Electronics HP 5MP Cameras (USB ID 04F2:B824 & 04F2:B82C) report a HID sensor interface that is not actually implemented. Attempting to access this non-functional sensor via iio_info causes system hangs as runtime PM tries to wake up an unresponsive sensor. Add these 2 devices to the HID ignore list since the sensor interface is non-functional by design and should not be exposed to userspace.",,"[{""url"":""https://git.kernel.org/stable/c/1b297ab6f38ca60a4ca7298b297944ec6043b2f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2b0931eee48208c25bb77486946dea8e96aa6a36"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/35f1a5360ac68d9629abbb3930a0a07901cba296"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ce1d87d1f5d80322757aa917182deb7370963b9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/54bae4c17c11688339eb73a04fd24203bb6e7494"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ac00f019698f614a49cce34c198d0568ab0e1c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a2a91abd19c574b598b1c69ad76ad9c7eedaf062"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c72536350e82b53a1be0f3bfdf1511bba2827102"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38541,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:29.957,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: mt7925: Fix null-ptr-deref in mt7925_thermal_init() devm_kasprintf() returns NULL on error. Currently, mt7925_thermal_init() does not check for this case, which results in a NULL pointer dereference. Add NULL check after devm_kasprintf() to prevent this issue.",,"[{""url"":""https://git.kernel.org/stable/c/03ee8f73801a8f46d83dfc2bf73fb9ffa5a21602"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1bbdf4213711bb6dc365e7628430a63dd3280794"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2e99e9b34ece0b6d3e82cb757e9f60fa414da999"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38542,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:30.083,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: appletalk: Fix device refcount leak in atrtr_create() When updating an existing route entry in atrtr_create(), the old device reference was not being released before assigning the new device, leading to a device refcount leak. Fix this by calling dev_put() to release the old device reference before holding the new one.",,"[{""url"":""https://git.kernel.org/stable/c/473f3eadfc73b0fb6d8dee5829d19a5772e387f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4a17370da6e476d3d275534e9e9cd2d02c57ca46"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/64124cf0aab0dd1e18c0fb5ae66e45741e727f8b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/711c80f7d8b163d3ecd463cd96f07230f488e750"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a7852b01793669248dce0348d14df89e77a32afd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b2f5dfa87367fdce9f8b995bc6c38f64f9ea2c90"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b92bedf71f25303e203a4e657489d76691a58119"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d2e9f50f0bdad73b64a871f25186b899624518c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38543,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:30.237,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/tegra: nvdec: Fix dma_alloc_coherent error check Check for NULL return value with dma_alloc_coherent, in line with Robin's fix for vic.c in 'drm/tegra: vic: Fix DMA API misuse'.",,"[{""url"":""https://git.kernel.org/stable/c/2e0812eedccd0629d73c9d0b1184a5db055df1da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/44306a684cd1699b8562a54945ddc43e2abc9eab"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/61b8d20962d00b7df117011c52f97cbb9c76a669"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a560de522374af931fa994d161db3667b0bb2545"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d1240029f97ac8c06db4dd4407bbbf83e8d08570"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38544,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:30.373,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: rxrpc: Fix bug due to prealloc collision When userspace is using AF_RXRPC to provide a server, it has to preallocate incoming calls and assign to them call IDs that will be used to thread related recvmsg() and sendmsg() together. The preallocated call IDs will automatically be attached to calls as they come in until the pool is empty. To the kernel, the call IDs are just arbitrary numbers, but userspace can use the call ID to hold a pointer to prepared structs. In any case, the user isn't permitted to create two calls with the same call ID (call IDs become available again when the call ends) and EBADSLT should result from sendmsg() if an attempt is made to preallocate a call with an in-use call ID. However, the cleanup in the error handling will trigger both assertions in rxrpc_cleanup_call() because the call isn't marked complete and isn't marked as having been released. Fix this by setting the call state in rxrpc_service_prealloc_one() and then marking it as being released before calling the cleanup function.",,"[{""url"":""https://git.kernel.org/stable/c/432c5363cd6fe5a928bbc94524d28b05515684dd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5385ad53793de2ab11e396bdcdaa65bb04b4dad6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/69e4186773c6445b258fb45b6e1df18df831ec45"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d8ffb47a443919277cb093c3db1ec6c0a06880b1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38545,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:30.500,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: ethernet: ti: am65-cpsw-nuss: Fix skb size by accounting for skb_shared_info While transitioning from netdev_alloc_ip_align() to build_skb(), memory for the ""skb_shared_info"" member of an ""skb"" was not allocated. Fix this by allocating ""PAGE_SIZE"" as the skb length, accounting for the packet length, headroom and tailroom, thereby including the required memory space for skb_shared_info.",,"[{""url"":""https://git.kernel.org/stable/c/02c4d6c26f1f662da8885b299c224ca6628ad232"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d6ca0c8c0caf9a13cae2de763bb1f2a9ea7eabb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc2fffa2facac15ce711e95f98f954426e025bc5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38546,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:30.620,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: atm: clip: Fix memory leak of struct clip_vcc. ioctl(ATMARP_MKIP) allocates struct clip_vcc and set it to vcc->user_back. The code assumes that vcc_destroy_socket() passes NULL skb to vcc->push() when the socket is close()d, and then clip_push() frees clip_vcc. However, ioctl(ATMARPD_CTRL) sets NULL to vcc->push() in atm_init_atmarp(), resulting in memory leak. Let's serialise two ioctl() by lock_sock() and check vcc->push() in atm_init_atmarp() to prevent memleak.",,"[{""url"":""https://git.kernel.org/stable/c/0c17ff462d98c997d707ee5cf4e4a9b1b52b9d90"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1c075e88d5859a2c6b43b27e0e46fb281cef8039"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1fb9fb5a4b5cec2d56e26525ef8c519de858fa60"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2fb37ab3226606cbfc9b2b6f9e301b0b735734c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/62dba28275a9a3104d4e33595c7b3328d4032d8d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9e4dbeee56f614e3f1e166e5d0655a999ea185ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9f771816f14da6d6157a8c30069091abf6b566fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cb2e4a2f8f268d8fba6662f663a2e57846f14a8d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38547,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:30.757,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iio: adc: axp20x_adc: Add missing sentinel to AXP717 ADC channel maps The AXP717 ADC channel maps is missing a sentinel entry at the end. This causes a KASAN warning. Add the missing sentinel entry.",,"[{""url"":""https://git.kernel.org/stable/c/086a76474121bf2351438e311376ec67b410b2ea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0c0c01c88bb69951539539d2001e67f0c613001f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3281ddcea6429f7bc1fdb39d407752dd1371aba9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38548,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:30.880,2025-08-28T15:15:52.460,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: hwmon: (corsair-cpro) Validate the size of the received input buffer Add buffer_recv_size to store the size of the received bytes. Validate buffer_recv_size in send_usb_cmd().",,"[{""url"":""https://git.kernel.org/stable/c/0db770e2922389753ddbd6663a5516a32b97b743"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2771d2ee3d95700f34e1e4df6a445c90565cd4e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2e6f4d9cfbda52700c126c5a2b93dd2042e8680c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3c4bdc8a852e446080adc8ceb90ddd67a56e1bb8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/495a4f0dce9c8c4478c242209748f1ee9e4d5820"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4eb5cc48399f89b63acdbfe912fa5c8fe2900147"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eda5e38cc4dd2dcb422840540374910ef2818494"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38549,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:31.003,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: efivarfs: Fix memory leak of efivarfs_fs_info in fs_context error paths When processing mount options, efivarfs allocates efivarfs_fs_info (sfi) early in fs_context initialization. However, sfi is associated with the superblock and typically freed when the superblock is destroyed. If the fs_context is released (final put) before fill_super is calledsuch as on error paths or during reconfigurationthe sfi structure would leak, as ownership never transfers to the superblock. Implement the .free callback in efivarfs_context_ops to ensure any allocated sfi is properly freed if the fs_context is torn down before fill_super, preventing this memory leak.",,"[{""url"":""https://git.kernel.org/stable/c/64e135f1eaba0bbb0cdee859af3328c68d5b9789"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/816d36973467d1c9c08a48bdffe4675e219a2e84"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e9fabe7036bb8be6071f39dc38605508f5f57b20"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38550,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:31.137,2025-08-28T15:15:52.657,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ipv6: mcast: Delay put pmc->idev in mld_del_delrec() pmc->idev is still used in ip6_mc_clear_src(), so as mld_clear_delrec() does, the reference should be put after ip6_mc_clear_src() return.",,"[{""url"":""https://git.kernel.org/stable/c/5f18e0130194550dff734e155029ae734378b5ea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6e4eec86fe5f6b3fdbc702d1d36ac2a6e7ec0806"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/728db00a14cacb37f36e9382ab5fad55caf890cc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7929d27c747eafe8fca3eecd74a334503ee4c839"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ae3264a25a4635531264728859dbe9c659fad554"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dcbc346f50a009d8b7f4e330f9f2e22d6442fa26"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38551,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:31.267,2025-08-18T20:16:28.750,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: virtio-net: fix recursived rtnl_lock() during probe() The deadlock appears in a stack trace like: virtnet_probe() rtnl_lock() virtio_config_changed_work() netdev_notify_peers() rtnl_lock() It happens if the VMM sends a VIRTIO_NET_S_ANNOUNCE request while the virtio-net driver is still probing. The config_work in probe() will get scheduled until virtnet_open() enables the config change notification via virtio_config_driver_enable().",,"[{""url"":""https://git.kernel.org/stable/c/3859f137b3c1fa1f0031d54263234566bdcdd7aa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4e7c46362550b229354aeb52038f414e231b0037"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be5dcaed694e4255dc02dd0acfe036708c535def"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38552,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-16T12:15:31.400,2025-08-28T15:15:52.797,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mptcp: plug races between subflow fail and subflow creation We have races similar to the one addressed by the previous patch between subflow failing and additional subflow creation. They are just harder to trigger. The solution is similar. Use a separate flag to track the condition 'socket state prevent any additional subflow creation' protected by the fallback lock. The socket fallback makes such flag true, and also receiving or sending an MP_FAIL option. The field 'allow_infinite_fallback' is now always touched under the relevant lock, we can drop the ONCE annotation on write.",,"[{""url"":""https://git.kernel.org/stable/c/659da22dee5ff316ba63bdaeeac7b58b5442f6c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c96d519ee15a130842a6513530b4d20acd2bfcd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c476d627584b7589a134a8b48dd5c6639e4401c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/def5b7b2643ebba696fc60ddf675dca13f073486"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f81b6fbe13c7fc413b5158cdffc6a59391a2a8db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38553,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T06:15:33.407,2025-08-28T15:15:52.923,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/sched: Restrict conditions for adding duplicating netems to qdisc tree netem_enqueue's duplication prevention logic breaks when a netem resides in a qdisc tree with other netems - this can lead to a soft lockup and OOM loop in netem_dequeue, as seen in [1]. Ensure that a duplicating netem cannot exist in a tree with other netems. Previous approaches suggested in discussions in chronological order: 1) Track duplication status or ttl in the sk_buff struct. Considered too specific a use case to extend such a struct, though this would be a resilient fix and address other previous and potential future DOS bugs like the one described in loopy fun [2]. 2) Restrict netem_enqueue recursion depth like in act_mirred with a per cpu variable. However, netem_dequeue can call enqueue on its child, and the depth restriction could be bypassed if the child is a netem. 3) Use the same approach as in 2, but add metadata in netem_skb_cb to handle the netem_dequeue case and track a packet's involvement in duplication. This is an overly complex approach, and Jamal notes that the skb cb can be overwritten to circumvent this safeguard. 4) Prevent the addition of a netem to a qdisc tree if its ancestral path contains a netem. However, filters and actions can cause a packet to change paths when re-enqueued to the root from netem duplication, leading us to the current solution: prevent a duplicating netem from inhabiting the same tree as other netems. [1] https://lore.kernel.org/netdev/8DuRWwfqjoRDLDmBMlIfbrsZg9Gx50DHJc1ilxsEBNe2D6NMoigR_eIRIG0LOjMc3r10nUUZtArXx4oZBIdUfZQrwjcQhdinnMis_0G7VEk=@willsroot.io/ [2] https://lwn.net/Articles/719297/",,"[{""url"":""https://git.kernel.org/stable/c/09317dfb681ac5a96fc69bea0c54441cf91b8270"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/103c4e27ec9f5fe53022e46e976abf52c7221baf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/250f8796006c0f2bc638ce545f601d49ae8d528b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/325f5ec67cc0a77f2d0d453445b9857f1cd06c76"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/795cb393e38977aa991e70a9363da0ee734b2114"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad340a4b4adb855b18b3666f26ad65c8968e2deb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cab2809944989889f88a1a8b5cff1c78460c72cb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec8e0e3d7adef940cdf9475e2352c0680189d14e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f088b6ebe8797a3f948d2cae47f34bfb45cc6522"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38554,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:31.510,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm: fix a UAF when vma->mm is freed after vma->vm_refcnt got dropped By inducing delays in the right places, Jann Horn created a reproducer for a hard to hit UAF issue that became possible after VMAs were allowed to be recycled by adding SLAB_TYPESAFE_BY_RCU to their cache. Race description is borrowed from Jann's discovery report: lock_vma_under_rcu() looks up a VMA locklessly with mas_walk() under rcu_read_lock(). At that point, the VMA may be concurrently freed, and it can be recycled by another process. vma_start_read() then increments the vma->vm_refcnt (if it is in an acceptable range), and if this succeeds, vma_start_read() can return a recycled VMA. In this scenario where the VMA has been recycled, lock_vma_under_rcu() will then detect the mismatching ->vm_mm pointer and drop the VMA through vma_end_read(), which calls vma_refcount_put(). vma_refcount_put() drops the refcount and then calls rcuwait_wake_up() using a copy of vma->vm_mm. This is wrong: It implicitly assumes that the caller is keeping the VMA's mm alive, but in this scenario the caller has no relation to the VMA's mm, so the rcuwait_wake_up() can cause UAF. The diagram depicting the race: T1 T2 T3 == == == lock_vma_under_rcu mas_walk <VMA gets removed from mm> mmap <the same VMA is reallocated> vma_start_read __refcount_inc_not_zero_limited_acquire munmap __vma_enter_locked refcount_add_not_zero vma_end_read vma_refcount_put __refcount_dec_and_test rcuwait_wait_event <finish operation> rcuwait_wake_up [UAF] Note that rcuwait_wait_event() in T3 does not block because refcount was already dropped by T1. At this point T3 can exit and free the mm causing UAF in T1. To avoid this we move vma->vm_mm verification into vma_start_read() and grab vma->vm_mm to stabilize it before vma_refcount_put() operation. [surenb@google.com: v3]",,"[{""url"":""https://git.kernel.org/stable/c/1bcd236a2536a451e385f8d6d2bb589689ec812f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6e88fe54721dee17d3496bc998f0c7d243896348"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9bbffee67ffd16360179327b57f3b1245579ef08"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38555,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:31.667,2025-08-28T15:15:53.063,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: gadget : fix use-after-free in composite_dev_cleanup() 1. In func configfs_composite_bind() -> composite_os_desc_req_prepare(): if kmalloc fails, the pointer cdev->os_desc_req will be freed but not set to NULL. Then it will return a failure to the upper-level function. 2. in func configfs_composite_bind() -> composite_dev_cleanup(): it will checks whether cdev->os_desc_req is NULL. If it is not NULL, it will attempt to use it.This will lead to a use-after-free issue. BUG: KASAN: use-after-free in composite_dev_cleanup+0xf4/0x2c0 Read of size 8 at addr 0000004827837a00 by task init/1 CPU: 10 PID: 1 Comm: init Tainted: G O 5.10.97-oh #1 kasan_report+0x188/0x1cc __asan_load8+0xb4/0xbc composite_dev_cleanup+0xf4/0x2c0 configfs_composite_bind+0x210/0x7ac udc_bind_to_driver+0xb4/0x1ec usb_gadget_probe_driver+0xec/0x21c gadget_dev_desc_UDC_store+0x264/0x27c",,"[{""url"":""https://git.kernel.org/stable/c/151c0aa896c47a4459e07fee7d4843f44c1bb18e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2db29235e900a084a656dea7e0939b0abb7bb897"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5f06ee9f9a3665d43133f125c17e5258a13f3963"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8afb22aa063f706f3343707cdfb8cda4d021dd33"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aada327a9f8028c573636fa60c0abc80fb8135c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd3c4ef60baf7f65c963f3e12d9d7b2b091e20ba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dba96dfa5a0f685b959dd28a52ac8dab0b805204"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e1be1f380c82a69f80c68c96a7cfe8759fb30355"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e624bf26127645a2f7821e73fdf6dc64bad07835"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38556,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:31.817,2025-09-09T17:15:45.080,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: HID: core: Harden s32ton() against conversion to 0 bits Testing by the syzbot fuzzer showed that the HID core gets a shift-out-of-bounds exception when it tries to convert a 32-bit quantity to a 0-bit quantity. Ideally this should never occur, but there are buggy devices and some might have a report field with size set to zero; we shouldn't reject the report or the device just because of that. Instead, harden the s32ton() routine so that it returns a reasonable result instead of crashing when it is called with the number of bits set to 0 -- the same as what snto32() does.",,"[{""url"":""https://git.kernel.org/stable/c/865ad8469fa24de1559f247d9426ab01e5ce3a56"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8b4a94b1510f6a46ec48494b52ee8f67eb4fc836"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6b87bfc2ab5bccb7ad953693c85d9062aef3fdd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3b504146c111548ab60b6ef7aad00bfb1db05a2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38557,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:31.960,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: HID: apple: validate feature-report field count to prevent NULL pointer dereference A malicious HID device with quirk APPLE_MAGIC_BACKLIGHT can trigger a NULL pointer dereference whilst the power feature-report is toggled and sent to the device in apple_magic_backlight_report_set(). The power feature-report is expected to have two data fields, but if the descriptor declares one field then accessing field[1] and dereferencing it in apple_magic_backlight_report_set() becomes invalid since field[1] will be NULL. An example of a minimal descriptor which can cause the crash is something like the following where the report with ID 3 (power report) only references a single 1-byte field. When hid core parses the descriptor it will encounter the final feature tag, allocate a hid_report (all members of field[] will be zeroed out), create field structure and populate it, increasing the maxfield to 1. The subsequent field[1] access and dereference causes the crash. Usage Page (Vendor Defined 0xFF00) Usage (0x0F) Collection (Application) Report ID (1) Usage (0x01) Logical Minimum (0) Logical Maximum (255) Report Size (8) Report Count (1) Feature (Data,Var,Abs) Usage (0x02) Logical Maximum (32767) Report Size (16) Report Count (1) Feature (Data,Var,Abs) Report ID (3) Usage (0x03) Logical Minimum (0) Logical Maximum (1) Report Size (8) Report Count (1) Feature (Data,Var,Abs) End Collection Here we see the KASAN splat when the kernel dereferences the NULL pointer and crashes: [ 15.164723] Oops: general protection fault, probably for non-canonical address 0xdffffc0000000006: 0000 [#1] SMP KASAN NOPTI [ 15.165691] KASAN: null-ptr-deref in range [0x0000000000000030-0x0000000000000037] [ 15.165691] CPU: 0 UID: 0 PID: 10 Comm: kworker/0:1 Not tainted 6.15.0 #31 PREEMPT(voluntary) [ 15.165691] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014 [ 15.165691] RIP: 0010:apple_magic_backlight_report_set+0xbf/0x210 [ 15.165691] Call Trace: [ 15.165691] <TASK> [ 15.165691] apple_probe+0x571/0xa20 [ 15.165691] hid_device_probe+0x2e2/0x6f0 [ 15.165691] really_probe+0x1ca/0x5c0 [ 15.165691] __driver_probe_device+0x24f/0x310 [ 15.165691] driver_probe_device+0x4a/0xd0 [ 15.165691] __device_attach_driver+0x169/0x220 [ 15.165691] bus_for_each_drv+0x118/0x1b0 [ 15.165691] __device_attach+0x1d5/0x380 [ 15.165691] device_initial_probe+0x12/0x20 [ 15.165691] bus_probe_device+0x13d/0x180 [ 15.165691] device_add+0xd87/0x1510 [...] To fix this issue we should validate the number of fields that the backlight and power reports have and if they do not have the required number of fields then bail.",,"[{""url"":""https://git.kernel.org/stable/c/00896c3f41cb6b74fec853386076115ba50baf0a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1bb3363da862e0464ec050eea2fb5472a36ad86b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7e15d1eaa88179c5185e57a38ab05fe852d0cb8d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba08cc6801ec5fb98f2d02b5f0c614c931845325"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38558,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:32.100,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: gadget: uvc: Initialize frame-based format color matching descriptor Fix NULL pointer crash in uvcg_framebased_make due to uninitialized color matching descriptor for frame-based format which was added in commit f5e7bdd34aca (""usb: gadget: uvc: Allow creating new color matching descriptors"") that added handling for uncompressed and mjpeg format. Crash is seen when userspace configuration (via configfs) does not explicitly define the color matching descriptor. If color_matching is not found, config_group_find_item() returns NULL. The code then jumps to out_put_cm, where it calls config_item_put(color_matching);. If color_matching is NULL, this will dereference a null pointer, leading to a crash. [ 2.746440] Unable to handle kernel NULL pointer dereference at virtual address 000000000000008c [ 2.756273] Mem abort info: [ 2.760080] ESR = 0x0000000096000005 [ 2.764872] EC = 0x25: DABT (current EL), IL = 32 bits [ 2.771068] SET = 0, FnV = 0 [ 2.771069] EA = 0, S1PTW = 0 [ 2.771070] FSC = 0x05: level 1 translation fault [ 2.771071] Data abort info: [ 2.771072] ISV = 0, ISS = 0x00000005, ISS2 = 0x00000000 [ 2.771073] CM = 0, WnR = 0, TnD = 0, TagAccess = 0 [ 2.771074] GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 [ 2.771075] user pgtable: 4k pages, 39-bit VAs, pgdp=00000000a3e59000 [ 2.771077] [000000000000008c] pgd=0000000000000000, p4d=0000000000000000, pud=0000000000000000 [ 2.771081] Internal error: Oops: 0000000096000005 [#1] PREEMPT SMP [ 2.771084] Dumping ftrace buffer: [ 2.771085] (ftrace buffer empty) [ 2.771138] CPU: 7 PID: 486 Comm: ln Tainted: G W E 6.6.58-android15 [ 2.771139] Hardware name: Qualcomm Technologies, Inc. SunP QRD HDK (DT) [ 2.771140] pstate: 61400005 (nZCv daif +PAN -UAO -TCO +DIT -SSBS BTYPE=--) [ 2.771141] pc : __uvcg_fill_strm+0x198/0x2cc [ 2.771145] lr : __uvcg_iter_strm_cls+0xc8/0x17c [ 2.771146] sp : ffffffc08140bbb0 [ 2.771146] x29: ffffffc08140bbb0 x28: ffffff803bc81380 x27: ffffff8023bbd250 [ 2.771147] x26: ffffff8023bbd250 x25: ffffff803c361348 x24: ffffff803d8e6768 [ 2.771148] x23: 0000000000000004 x22: 0000000000000003 x21: ffffffc08140bc48 [ 2.771149] x20: 0000000000000000 x19: ffffffc08140bc48 x18: ffffffe9f8cf4a00 [ 2.771150] x17: 000000001bf64ec3 x16: 000000001bf64ec3 x15: ffffff8023bbd250 [ 2.771151] x14: 000000000000000f x13: 004c4b40000f4240 x12: 000a2c2a00051615 [ 2.771152] x11: 000000000000004f x10: ffffffe9f76b40ec x9 : ffffffe9f7e389d0 [ 2.771153] x8 : ffffff803d0d31ce x7 : 000f4240000a2c2a x6 : 0005161500028b0a [ 2.771154] x5 : ffffff803d0d31ce x4 : 0000000000000003 x3 : 0000000000000000 [ 2.771155] x2 : ffffffc08140bc50 x1 : ffffffc08140bc48 x0 : 0000000000000000 [ 2.771156] Call trace: [ 2.771157] __uvcg_fill_strm+0x198/0x2cc [ 2.771157] __uvcg_iter_strm_cls+0xc8/0x17c [ 2.771158] uvcg_streaming_class_allow_link+0x240/0x290 [ 2.771159] configfs_symlink+0x1f8/0x630 [ 2.771161] vfs_symlink+0x114/0x1a0 [ 2.771163] do_symlinkat+0x94/0x28c [ 2.771164] __arm64_sys_symlinkat+0x54/0x70 [ 2.771164] invoke_syscall+0x58/0x114 [ 2.771166] el0_svc_common+0x80/0xe0 [ 2.771168] do_el0_svc+0x1c/0x28 [ 2.771169] el0_svc+0x3c/0x70 [ 2.771172] el0t_64_sync_handler+0x68/0xbc [ 2.771173] el0t_64_sync+0x1a8/0x1ac Initialize color matching descriptor for frame-based format to prevent NULL pointer crash by mirroring the handling done for uncompressed and mjpeg formats.",,"[{""url"":""https://git.kernel.org/stable/c/323a80a1a5ace319a722909c006d5bdb2a35d273"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6db61c1aa23075eeee90e083ca3f6567a5635da6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f8576fc9d1a203d12474bf52710c7af68cae490"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38559,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:32.233,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: platform/x86/intel/pmt: fix a crashlog NULL pointer access Usage of the intel_pmt_read() for binary sysfs, requires a pcidev. The current use of the endpoint value is only valid for telemetry endpoint usage. Without the ep, the crashlog usage causes the following NULL pointer exception: BUG: kernel NULL pointer dereference, address: 0000000000000000 Oops: Oops: 0000 [#1] SMP NOPTI RIP: 0010:intel_pmt_read+0x3b/0x70 [pmt_class] Code: Call Trace: <TASK> ? sysfs_kf_bin_read+0xc0/0xe0 kernfs_fop_read_iter+0xac/0x1a0 vfs_read+0x26d/0x350 ksys_read+0x6b/0xe0 __x64_sys_read+0x1d/0x30 x64_sys_call+0x1bc8/0x1d70 do_syscall_64+0x6d/0x110 Augment struct intel_pmt_entry with a pointer to the pcidev to avoid the NULL pointer exception.",,"[{""url"":""https://git.kernel.org/stable/c/089d05266b2caf020ac2ae2cd2be78f580268f5d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/18d53b543b5447478e259c96ca4688393f327c98"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/54d5cd4719c5e87f33d271c9ac2e393147d934f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/860d93bd6a21f08883711196344c353bc3936a2b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38560,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:32.370,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: x86/sev: Evict cache lines during SNP memory validation An SNP cache coherency vulnerability requires a cache line eviction mitigation when validating memory after a page state change to private. The specific mitigation is to touch the first and last byte of each 4K page that is being validated. There is no need to perform the mitigation when performing a page state change to shared and rescinding validation. CPUID bit Fn8000001F_EBX[31] defines the COHERENCY_SFW_NO CPUID bit that, when set, indicates that the software mitigation for this vulnerability is not needed. Implement the mitigation and invoke it when validating memory (making it private) and the COHERENCY_SFW_NO bit is not set, indicating the SNP guest is vulnerable.",,"[{""url"":""https://git.kernel.org/stable/c/1fb873971e23c35c53823c62809a474a92bc3022"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1fec416c03d0a64cc21aa04ce4aa14254b017e6a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7b306dfa326f70114312b320d083b21fa9481e1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a762a4c8d9e768b538b3cc60615361a8cf377de8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aed15fc08f15dbb15822b2a0b653f67e76aa0fdf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f92af52e6dbd8d066d77beba451e0230482dc45b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38561,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:32.503,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix Preauh_HashValue race condition If client send multiple session setup requests to ksmbd, Preauh_HashValue race condition could happen. There is no need to free sess->Preauh_HashValue at session setup phase. It can be freed together with session at connection termination phase.",,"[{""url"":""https://git.kernel.org/stable/c/44a3059c4c8cc635a1fb2afd692d0730ca1ba4b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6613887da1d18dd2ecfd6c6148a873c4d903ebdc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d7c0c5304c88bcbd7a85e9bcd61d27e998ba5fc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b69fd87076daa66f3d186bd421a7b0ee0cb45829"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/edeecc7871e8fc0878d53ce286c75040a0e38f6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fbf5c0845ed15122a770bca9be1d9b60b470d3aa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38562,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:32.653,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix null pointer dereference error in generate_encryptionkey If client send two session setups with krb5 authenticate to ksmbd, null pointer dereference error in generate_encryptionkey could happen. sess->Preauth_HashValue is set to NULL if session is valid. So this patch skip generate encryption key if session is valid.",,"[{""url"":""https://git.kernel.org/stable/c/015ef163d65496ae3ba6192c96140a22743f0353"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2a30ed6428ce83afedca1a6c5c5c4247bcf12d0e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/96a82e19434a2522525baab59c33332658bc7653"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9b493ab6f35178afd8d619800df9071992f715de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9c2dbbc959e1fcc6f603a1a843e9cf743ba383bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d79c8bebaa622ee223128be7c66d8aaeeb634a57"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38563,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:32.790,2025-08-28T15:15:53.200,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: perf/core: Prevent VMA split of buffer mappings The perf mmap code is careful about mmap()'ing the user page with the ringbuffer and additionally the auxiliary buffer, when the event supports it. Once the first mapping is established, subsequent mapping have to use the same offset and the same size in both cases. The reference counting for the ringbuffer and the auxiliary buffer depends on this being correct. Though perf does not prevent that a related mapping is split via mmap(2), munmap(2) or mremap(2). A split of a VMA results in perf_mmap_open() calls, which take reference counts, but then the subsequent perf_mmap_close() calls are not longer fulfilling the offset and size checks. This leads to reference count leaks. As perf already has the requirement for subsequent mappings to match the initial mapping, the obvious consequence is that VMA splits, caused by resizing of a mapping or partial unmapping, have to be prevented. Implement the vm_operations_struct::may_split() callback and return unconditionally -EINVAL. That ensures that the mapping offsets and sizes cannot be changed after the fact. Remapping to a different fixed address with the same size is still possible as it takes the references for the new mapping and drops those of the old mapping.",,"[{""url"":""https://git.kernel.org/stable/c/3bd518cc7ea61076bcd725e36ff0e690754977c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/65311aad4c808bedad0c05d9bb8b06c47dae73eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6757a31a8e295ae4f01717a954afda173f25a121"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7b84cb58d1f0aa07656802eae24689566e5f5b1b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b024d7b56c77191cde544f838debb7f8451cd0d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d52451a9210f2e5a079ba052918c93563518a9ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e4346ffec2c44d6b0be834d59b20632b5bb5729e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e529888b7e8092912dd8789bdfc76685ccd2ff5f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff668930871e0198c7f4e325058b8b7c286787bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38564,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:32.933,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: perf/core: Handle buffer mapping fail correctly in perf_mmap() After successful allocation of a buffer or a successful attachment to an existing buffer perf_mmap() tries to map the buffer read only into the page table. If that fails, the already set up page table entries are zapped, but the other perf specific side effects of that failure are not handled. The calling code just cleans up the VMA and does not invoke perf_mmap_close(). This leaks reference counts, corrupts user->vm accounting and also results in an unbalanced invocation of event::event_mapped(). Cure this by moving the event::event_mapped() invocation before the map_range() call so that on map_range() failure perf_mmap_close() can be invoked without causing an unbalanced event::event_unmapped() call. perf_mmap_close() undoes the reference counts and eventually frees buffers.",,"[{""url"":""https://git.kernel.org/stable/c/831e1c90a5d72e6977a57c44f47c46b73a438695"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9025f73c88d9d6e125743a43afc569da3ce5328"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f74b9f4ba63ffdf597aaaa6cad7e284cb8e04820"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38565,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:33.077,2025-08-28T15:15:53.333,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: perf/core: Exit early on perf_mmap() fail When perf_mmap() fails to allocate a buffer, it still invokes the event_mapped() callback of the related event. On X86 this might increase the perf_rdpmc_allowed reference counter. But nothing undoes this as perf_mmap_close() is never called in this case, which causes another reference count leak. Return early on failure to prevent that.",,"[{""url"":""https://git.kernel.org/stable/c/07091aade394f690e7b655578140ef84d0e8d7b0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/163b0d1a209fe0df5476c1df2330ca12b55abf92"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/27d44145bd576bbef9bf6165bcd78128ec3e6cbd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5ffda7f3ed76ec8defc19d985e33b3b82ba07839"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ff8521f30c4c2fcd4e88bd7640486602bf8a650"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/92043120a2e992800580855498ab8507e1b22db9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9b90a48c7de828a15c7a4fc565d46999c6e22d6b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de85e72598d89880a02170a1cbc27b35a7d978a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f41e9eba77bf97626e04296dc5677d02816d2432"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38566,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:33.230,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: sunrpc: fix handling of server side tls alerts Scott Mayhew discovered a security exploit in NFS over TLS in tls_alert_recv() due to its assumption it can read data from the msg iterator's kvec.. kTLS implementation splits TLS non-data record payload between the control message buffer (which includes the type such as TLS aler or TLS cipher change) and the rest of the payload (say TLS alert's level/description) which goes into the msg payload buffer. This patch proposes to rework how control messages are setup and used by sock_recvmsg(). If no control message structure is setup, kTLS layer will read and process TLS data record types. As soon as it encounters a TLS control message, it would return an error. At that point, NFS can setup a kvec backed msg buffer and read in the control message such as a TLS alert. Msg iterator can advance the kvec pointer as a part of the copy process thus we need to revert the iterator before calling into the tls_alert_recv.",,"[{""url"":""https://git.kernel.org/stable/c/25bb3647d30a20486b5fe7cff2b0e503c16c9692"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3b549da875414989f480b66835d514be80a0bd9c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6b33c31cc788073bfbed9297e1f4486ed73d87da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b1df394621710b312f0393e3f240fdac0764f968"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bee47cb026e762841f3faece47b51f985e215edb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38567,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:33.380,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nfsd: avoid ref leak in nfsd_open_local_fh() If two calls to nfsd_open_local_fh() race and both successfully call nfsd_file_acquire_local(), they will both get an extra reference to the net to accompany the file reference stored in *pnf. One of them will fail to store (using xchg()) the file reference in *pnf and will drop that reference but WON'T drop the accompanying reference to the net. This leak means that when the nfs server is shut down it will hang in nfsd_shutdown_net() waiting for &nn->nfsd_net_free_done. This patch adds the missing nfsd_net_put().",,"[{""url"":""https://git.kernel.org/stable/c/c4bf8f26c51e51bbb840935659a7b3b65a802c07"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e5a73150776f18547ee685c9f6bfafe549714899"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fcb0a417fddb605530c4837e0996620f8ed38023"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38568,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:33.523,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/sched: mqprio: fix stack out-of-bounds write in tc entry parsing TCA_MQPRIO_TC_ENTRY_INDEX is validated using NLA_POLICY_MAX(NLA_U32, TC_QOPT_MAX_QUEUE), which allows the value TC_QOPT_MAX_QUEUE (16). This leads to a 4-byte out-of-bounds stack write in the fp[] array, which only has room for 16 elements (015). Fix this by changing the policy to allow only up to TC_QOPT_MAX_QUEUE - 1.",,"[{""url"":""https://git.kernel.org/stable/c/39491e859fd494d0b51adc5c7d54c8a7dcf1d198"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/66fc2ebdd9d5dd6e5a9c7edeace5a61a0ab2cd86"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d00e4125680f7074c4f42ce3c297336f23128e70"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1a9dbcb7d17bf0abb325cdc984957cfabc59693"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ffd2dc4c6c49ff4f1e5d34e454a6a55608104c17"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38569,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:33.663,2025-08-28T15:15:53.463,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: benet: fix BUG when creating VFs benet crashes as soon as SRIOV VFs are created: kernel BUG at mm/vmalloc.c:3457! Oops: invalid opcode: 0000 [#1] SMP KASAN NOPTI CPU: 4 UID: 0 PID: 7408 Comm: test.sh Kdump: loaded Not tainted 6.16.0+ #1 PREEMPT(voluntary) [...] RIP: 0010:vunmap+0x5f/0x70 [...] Call Trace: <TASK> __iommu_dma_free+0xe8/0x1c0 be_cmd_set_mac_list+0x3fe/0x640 [be2net] be_cmd_set_mac+0xaf/0x110 [be2net] be_vf_eth_addr_config+0x19f/0x330 [be2net] be_vf_setup+0x4f7/0x990 [be2net] be_pci_sriov_configure+0x3a1/0x470 [be2net] sriov_numvfs_store+0x20b/0x380 kernfs_fop_write_iter+0x354/0x530 vfs_write+0x9b9/0xf60 ksys_write+0xf3/0x1d0 do_syscall_64+0x8c/0x3d0 be_cmd_set_mac_list() calls dma_free_coherent() under a spin_lock_bh. Fix it by freeing only after the lock has been released.",,"[{""url"":""https://git.kernel.org/stable/c/0ddfe8b127ef1149fddccb79db6e6eaba7738e7d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3697e37e012bbd2bb5a5b467689811ba097b2eff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/46d44a23a3723a89deeb65b13cddb17f8d9f2700"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a40f8af2ba1b9bdf46e2db10e8c9710538fbc63"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/975e73b9102d844a3dc3f091ad631c56145c8b4c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c377ba2be9430d165a98e4b782902ed630bc7546"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d5dc09ee5d74277bc47193fe28ce8703e229331b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f4e4e0c4bc4d799d6fa39055acdbc3af066cd13e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f80b34ebc579216407b128e9d155bfcae875c30f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38570,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:33.810,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: eth: fbnic: unlink NAPIs from queues on error to open CI hit a UaF in fbnic in the AF_XDP portion of the queues.py test. The UaF is in the __sk_mark_napi_id_once() call in xsk_bind(), NAPI has been freed. Looks like the device failed to open earlier, and we lack clearing the NAPI pointer from the queue.",,"[{""url"":""https://git.kernel.org/stable/c/21d3f8441c7f317b93ba6a8029610c8b7e3773db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4b31bcb025cb497da2b01f87173108ff32d350d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4b59f9deff3bdb52b223c85048f1d2924803b817"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38571,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:33.960,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: sunrpc: fix client side handling of tls alerts A security exploit was discovered in NFS over TLS in tls_alert_recv due to its assumption that there is valid data in the msghdr's iterator's kvec. Instead, this patch proposes the rework how control messages are setup and used by sock_recvmsg(). If no control message structure is setup, kTLS layer will read and process TLS data record types. As soon as it encounters a TLS control message, it would return an error. At that point, NFS can setup a kvec backed control buffer and read in the control message such as a TLS alert. Scott found that a msg iterator can advance the kvec pointer as a part of the copy process thus we need to revert the iterator before calling into the tls_alert_recv.",,"[{""url"":""https://git.kernel.org/stable/c/3ee397eaaca4fa04db21bb98c8f1d0c6cc525368"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3feada5baf4dc96e151ff2ca54630e1d274e5458"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a55b3d15331859d9fdd261cfa6d34ca2aeb0fb95"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c36b2fbd60e8f9c6f975522130998608880c93be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc5d59081fa26506d02de2127ab822f40d88bc5a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38572,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:34.117,2025-08-28T15:15:53.597,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ipv6: reject malicious packets in ipv6_gso_segment() syzbot was able to craft a packet with very long IPv6 extension headers leading to an overflow of skb->transport_header. This 16bit field has a limited range. Add skb_reset_transport_header_careful() helper and use it from ipv6_gso_segment() WARNING: CPU: 0 PID: 5871 at ./include/linux/skbuff.h:3032 skb_reset_transport_header include/linux/skbuff.h:3032 [inline] WARNING: CPU: 0 PID: 5871 at ./include/linux/skbuff.h:3032 ipv6_gso_segment+0x15e2/0x21e0 net/ipv6/ip6_offload.c:151 Modules linked in: CPU: 0 UID: 0 PID: 5871 Comm: syz-executor211 Not tainted 6.16.0-rc6-syzkaller-g7abc678e3084 #0 PREEMPT(full) Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 07/12/2025 RIP: 0010:skb_reset_transport_header include/linux/skbuff.h:3032 [inline] RIP: 0010:ipv6_gso_segment+0x15e2/0x21e0 net/ipv6/ip6_offload.c:151 Call Trace: <TASK> skb_mac_gso_segment+0x31c/0x640 net/core/gso.c:53 nsh_gso_segment+0x54a/0xe10 net/nsh/nsh.c:110 skb_mac_gso_segment+0x31c/0x640 net/core/gso.c:53 __skb_gso_segment+0x342/0x510 net/core/gso.c:124 skb_gso_segment include/net/gso.h:83 [inline] validate_xmit_skb+0x857/0x11b0 net/core/dev.c:3950 validate_xmit_skb_list+0x84/0x120 net/core/dev.c:4000 sch_direct_xmit+0xd3/0x4b0 net/sched/sch_generic.c:329 __dev_xmit_skb net/core/dev.c:4102 [inline] __dev_queue_xmit+0x17b6/0x3a70 net/core/dev.c:4679",,"[{""url"":""https://git.kernel.org/stable/c/09ff062b89d8e48165247d677d1ca23d6d607e9b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f638e0b28bde7c3354a0df938ab3a96739455d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5489e7fc6f8be3062f8cb7e49406de4bfd94db67"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/573b8250fc2554761db3bc2bbdbab23789d52d4e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5dc60b2a00ed7629214ac0c48e43f40af2078703"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d45cf1e7d7180256e17c9ce88e32e8061a7887fe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de322cdf600fc9433845a9e944d1ca6b31cfb67e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee851768e4b8371ce151fd446d24bf3ae2d18789"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ef05007b403dcc21e701cb1f30d4572ac0a9da20"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38573,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:34.283,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: spi: cs42l43: Property entry should be a null-terminated array The software node does not specify a count of property entries, so the array must be null-terminated. When unterminated, this can lead to a fault in the downstream cs35l56 amplifier driver, because the node parse walks off the end of the array into unknown memory.",,"[{""url"":""https://git.kernel.org/stable/c/139b5df757a0aa436f763b0038e0b73808d2f4b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/674328102baad76c7a06628efc01974ece5ae27f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9f0035ae38d2571f5ddedc829d74492013caa625"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ffcfd071eec7973e58c4ffff7da4cb0e9ca7b667"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38574,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:34.427,2025-08-28T15:15:53.740,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: pptp: ensure minimal skb length in pptp_xmit() Commit aabc6596ffb3 (""net: ppp: Add bound checking for skb data on ppp_sync_txmung"") fixed ppp_sync_txmunge() We need a similar fix in pptp_xmit(), otherwise we might read uninit data as reported by syzbot. BUG: KMSAN: uninit-value in pptp_xmit+0xc34/0x2720 drivers/net/ppp/pptp.c:193 pptp_xmit+0xc34/0x2720 drivers/net/ppp/pptp.c:193 ppp_channel_bridge_input drivers/net/ppp/ppp_generic.c:2290 [inline] ppp_input+0x1d6/0xe60 drivers/net/ppp/ppp_generic.c:2314 pppoe_rcv_core+0x1e8/0x760 drivers/net/ppp/pppoe.c:379 sk_backlog_rcv+0x142/0x420 include/net/sock.h:1148 __release_sock+0x1d3/0x330 net/core/sock.c:3213 release_sock+0x6b/0x270 net/core/sock.c:3767 pppoe_sendmsg+0x15d/0xcb0 drivers/net/ppp/pppoe.c:904 sock_sendmsg_nosec net/socket.c:712 [inline] __sock_sendmsg+0x330/0x3d0 net/socket.c:727 ____sys_sendmsg+0x893/0xd80 net/socket.c:2566 ___sys_sendmsg+0x271/0x3b0 net/socket.c:2620 __sys_sendmmsg+0x2d9/0x7c0 net/socket.c:2709",,"[{""url"":""https://git.kernel.org/stable/c/1a04db0fd75cb6034fc27a56b67b3b8b9022a98c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/26672f1679b143aa34fca0b6046b7fd0c184770d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5005d24377378a20e5c0e53052fc4ebdcdcbc611"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/504cc4ab91073d2ac7404ad146139f86ecee7193"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5de7513f38f3c19c0610294ee478242bea356f8c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/97b8c5d322c5c0038cac4bc56fdbe237d0be426f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b7dcda76fd0615c0599c89f36873a6cd48e02dbb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de9c4861fb42f0cd72da844c3c34f692d5895b7b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ea99b88b1999ebcb24d5d3a6b7910030f40d3bba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38575,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-04-18T07:15:43.717,2025-04-21T14:23:45.950,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: use aead_request_free to match aead_request_alloc Use aead_request_free() instead of kfree() to properly free memory allocated by aead_request_alloc(). This ensures sensitive crypto data is zeroed before being freed.",,"[{""url"":""https://git.kernel.org/stable/c/1de7fec4d3012672e31eeb6679ea60f7ca010ef9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3e341dbd5f5a6e5a558e67da80731dc38a7f758c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/46caeae23035192b9cc41872c827f30d0233f16e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/571b342d4688801fc1f6a1934389dac09425dc93"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6171063e9d046ffa46f51579b2ca4a43caef581a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6b594868268c3a7bfaeced912525cd2c445529a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aef10ccd74512c52e30c5ee19d0031850973e78d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38576,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:34.573,2025-08-28T15:15:53.867,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: powerpc/eeh: Make EEH driver device hotplug safe Multiple race conditions existed between the PCIe hotplug driver and the EEH driver, leading to a variety of kernel oopses of the same general nature: <pcie device unplug> <eeh driver trigger> <hotplug removal trigger> <pcie tree reconfiguration> <eeh recovery next step> <oops in EEH driver bus iteration loop> A second class of oops is also seen when the underlying bus disappears during device recovery. Refactor the EEH module to be PCI rescan and remove safe. Also clean up a few minor formatting / readability issues.",,"[{""url"":""https://git.kernel.org/stable/c/1010b4c012b0d78dfb9d3132b49aa2ef024a07a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/19d5036e7ad766cf212aebec23b9f1d7924a62bc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/502f08831a9afb72dc98a56ae6504da43e93b250"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/59c6d3d81d42bf543c90597b4f38c53d6874c5a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a426e8a6ae161f51888585b065db0f8f93ab2e16"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d2c60a8a387e9fcc28447ef36c03f8e49fd052a6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d42bbd8f30ac38b1ce54715bf08ec3dac18d6b25"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f56e004b781719d8fdf6c9619b15caf2579bc1f2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38577,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:34.720,2025-08-28T15:15:53.997,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to avoid panic in f2fs_evict_inode As syzbot [1] reported as below: R10: 0000000000000100 R11: 0000000000000206 R12: 00007ffe17473450 R13: 00007f28b1c10854 R14: 000000000000dae5 R15: 00007ffe17474520 </TASK> ---[ end trace 0000000000000000 ]--- ================================================================== BUG: KASAN: use-after-free in __list_del_entry_valid+0xa6/0x130 lib/list_debug.c:62 Read of size 8 at addr ffff88812d962278 by task syz-executor/564 CPU: 1 PID: 564 Comm: syz-executor Tainted: G W 6.1.129-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 02/12/2025 Call Trace: <TASK> __dump_stack+0x21/0x24 lib/dump_stack.c:88 dump_stack_lvl+0xee/0x158 lib/dump_stack.c:106 print_address_description+0x71/0x210 mm/kasan/report.c:316 print_report+0x4a/0x60 mm/kasan/report.c:427 kasan_report+0x122/0x150 mm/kasan/report.c:531 __asan_report_load8_noabort+0x14/0x20 mm/kasan/report_generic.c:351 __list_del_entry_valid+0xa6/0x130 lib/list_debug.c:62 __list_del_entry include/linux/list.h:134 [inline] list_del_init include/linux/list.h:206 [inline] f2fs_inode_synced+0xf7/0x2e0 fs/f2fs/super.c:1531 f2fs_update_inode+0x74/0x1c40 fs/f2fs/inode.c:585 f2fs_update_inode_page+0x137/0x170 fs/f2fs/inode.c:703 f2fs_write_inode+0x4ec/0x770 fs/f2fs/inode.c:731 write_inode fs/fs-writeback.c:1460 [inline] __writeback_single_inode+0x4a0/0xab0 fs/fs-writeback.c:1677 writeback_single_inode+0x221/0x8b0 fs/fs-writeback.c:1733 sync_inode_metadata+0xb6/0x110 fs/fs-writeback.c:2789 f2fs_sync_inode_meta+0x16d/0x2a0 fs/f2fs/checkpoint.c:1159 block_operations fs/f2fs/checkpoint.c:1269 [inline] f2fs_write_checkpoint+0xca3/0x2100 fs/f2fs/checkpoint.c:1658 kill_f2fs_super+0x231/0x390 fs/f2fs/super.c:4668 deactivate_locked_super+0x98/0x100 fs/super.c:332 deactivate_super+0xaf/0xe0 fs/super.c:363 cleanup_mnt+0x45f/0x4e0 fs/namespace.c:1186 __cleanup_mnt+0x19/0x20 fs/namespace.c:1193 task_work_run+0x1c6/0x230 kernel/task_work.c:203 exit_task_work include/linux/task_work.h:39 [inline] do_exit+0x9fb/0x2410 kernel/exit.c:871 do_group_exit+0x210/0x2d0 kernel/exit.c:1021 __do_sys_exit_group kernel/exit.c:1032 [inline] __se_sys_exit_group kernel/exit.c:1030 [inline] __x64_sys_exit_group+0x3f/0x40 kernel/exit.c:1030 x64_sys_call+0x7b4/0x9a0 arch/x86/include/generated/asm/syscalls_64.h:232 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_64+0x4c/0xa0 arch/x86/entry/common.c:81 entry_SYSCALL_64_after_hwframe+0x68/0xd2 RIP: 0033:0x7f28b1b8e169 Code: Unable to access opcode bytes at 0x7f28b1b8e13f. RSP: 002b:00007ffe174710a8 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7 RAX: ffffffffffffffda RBX: 00007f28b1c10879 RCX: 00007f28b1b8e169 RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000001 RBP: 0000000000000002 R08: 00007ffe1746ee47 R09: 00007ffe17472360 R10: 0000000000000009 R11: 0000000000000246 R12: 00007ffe17472360 R13: 00007f28b1c10854 R14: 000000000000dae5 R15: 00007ffe17474520 </TASK> Allocated by task 569: kasan_save_stack mm/kasan/common.c:45 [inline] kasan_set_track+0x4b/0x70 mm/kasan/common.c:52 kasan_save_alloc_info+0x25/0x30 mm/kasan/generic.c:505 __kasan_slab_alloc+0x72/0x80 mm/kasan/common.c:328 kasan_slab_alloc include/linux/kasan.h:201 [inline] slab_post_alloc_hook+0x4f/0x2c0 mm/slab.h:737 slab_alloc_node mm/slub.c:3398 [inline] slab_alloc mm/slub.c:3406 [inline] __kmem_cache_alloc_lru mm/slub.c:3413 [inline] kmem_cache_alloc_lru+0x104/0x220 mm/slub.c:3429 alloc_inode_sb include/linux/fs.h:3245 [inline] f2fs_alloc_inode+0x2d/0x340 fs/f2fs/super.c:1419 alloc_inode fs/inode.c:261 [inline] iget_locked+0x186/0x880 fs/inode.c:1373 f2fs_iget+0x55/0x4c60 fs/f2fs/inode.c:483 f2fs_lookup+0x366/0xab0 fs/f2fs/namei.c:487 __lookup_slow+0x2a3/0x3d0 fs/namei.c:1690 lookup_slow+0x57/0x70 fs/namei.c:1707 walk_component+0x2e6/0x410 fs/namei ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/15df59809c54fbd687cdf27efbd2103a937459be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/42f9ea16aea8b49febaa87950a006a1792209f38"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4732ca17c17f5062426cfa982f43593e6b81963b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5cd99d5aa3d39086bdb53eb5c52df16e98b101a0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/880ef748e78a1eb7df2d8e11a9ef21e98bcaabe5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9535e440fe5bc6c5ac7cfb407e53bf788b8bf8d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/97df495d754116c8c28ac6a4112f831727bde887"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9bbfe83924946552c4c513099c0e8c83af76311a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a509a55f8eecc8970b3980c6f06886bbff0e2f68"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38578,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:34.870,2025-08-28T15:15:54.133,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to avoid UAF in f2fs_sync_inode_meta() syzbot reported an UAF issue as below: [1] [2] [1] https://syzkaller.appspot.com/text?tag=CrashReport&x=16594c60580000 ================================================================== BUG: KASAN: use-after-free in __list_del_entry_valid+0xa6/0x130 lib/list_debug.c:62 Read of size 8 at addr ffff888100567dc8 by task kworker/u4:0/8 CPU: 1 PID: 8 Comm: kworker/u4:0 Tainted: G W 6.1.129-syzkaller-00017-g642656a36791 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 02/12/2025 Workqueue: writeback wb_workfn (flush-7:0) Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x151/0x1b7 lib/dump_stack.c:106 print_address_description mm/kasan/report.c:316 [inline] print_report+0x158/0x4e0 mm/kasan/report.c:427 kasan_report+0x13c/0x170 mm/kasan/report.c:531 __asan_report_load8_noabort+0x14/0x20 mm/kasan/report_generic.c:351 __list_del_entry_valid+0xa6/0x130 lib/list_debug.c:62 __list_del_entry include/linux/list.h:134 [inline] list_del_init include/linux/list.h:206 [inline] f2fs_inode_synced+0x100/0x2e0 fs/f2fs/super.c:1553 f2fs_update_inode+0x72/0x1c40 fs/f2fs/inode.c:588 f2fs_update_inode_page+0x135/0x170 fs/f2fs/inode.c:706 f2fs_write_inode+0x416/0x790 fs/f2fs/inode.c:734 write_inode fs/fs-writeback.c:1460 [inline] __writeback_single_inode+0x4cf/0xb80 fs/fs-writeback.c:1677 writeback_sb_inodes+0xb32/0x1910 fs/fs-writeback.c:1903 __writeback_inodes_wb+0x118/0x3f0 fs/fs-writeback.c:1974 wb_writeback+0x3da/0xa00 fs/fs-writeback.c:2081 wb_check_background_flush fs/fs-writeback.c:2151 [inline] wb_do_writeback fs/fs-writeback.c:2239 [inline] wb_workfn+0xbba/0x1030 fs/fs-writeback.c:2266 process_one_work+0x73d/0xcb0 kernel/workqueue.c:2299 worker_thread+0xa60/0x1260 kernel/workqueue.c:2446 kthread+0x26d/0x300 kernel/kthread.c:386 ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:295 </TASK> Allocated by task 298: kasan_save_stack mm/kasan/common.c:45 [inline] kasan_set_track+0x4b/0x70 mm/kasan/common.c:52 kasan_save_alloc_info+0x1f/0x30 mm/kasan/generic.c:505 __kasan_slab_alloc+0x6c/0x80 mm/kasan/common.c:333 kasan_slab_alloc include/linux/kasan.h:202 [inline] slab_post_alloc_hook+0x53/0x2c0 mm/slab.h:768 slab_alloc_node mm/slub.c:3421 [inline] slab_alloc mm/slub.c:3431 [inline] __kmem_cache_alloc_lru mm/slub.c:3438 [inline] kmem_cache_alloc_lru+0x102/0x270 mm/slub.c:3454 alloc_inode_sb include/linux/fs.h:3255 [inline] f2fs_alloc_inode+0x2d/0x350 fs/f2fs/super.c:1437 alloc_inode fs/inode.c:261 [inline] iget_locked+0x18c/0x7e0 fs/inode.c:1373 f2fs_iget+0x55/0x4ca0 fs/f2fs/inode.c:486 f2fs_lookup+0x3c1/0xb50 fs/f2fs/namei.c:484 __lookup_slow+0x2b9/0x3e0 fs/namei.c:1689 lookup_slow+0x5a/0x80 fs/namei.c:1706 walk_component+0x2e7/0x410 fs/namei.c:1997 lookup_last fs/namei.c:2454 [inline] path_lookupat+0x16d/0x450 fs/namei.c:2478 filename_lookup+0x251/0x600 fs/namei.c:2507 vfs_statx+0x107/0x4b0 fs/stat.c:229 vfs_fstatat fs/stat.c:267 [inline] vfs_lstat include/linux/fs.h:3434 [inline] __do_sys_newlstat fs/stat.c:423 [inline] __se_sys_newlstat+0xda/0x7c0 fs/stat.c:417 __x64_sys_newlstat+0x5b/0x70 fs/stat.c:417 x64_sys_call+0x52/0x9a0 arch/x86/include/generated/asm/syscalls_64.h:7 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_64+0x3b/0x80 arch/x86/entry/common.c:81 entry_SYSCALL_64_after_hwframe+0x68/0xd2 Freed by task 0: kasan_save_stack mm/kasan/common.c:45 [inline] kasan_set_track+0x4b/0x70 mm/kasan/common.c:52 kasan_save_free_info+0x2b/0x40 mm/kasan/generic.c:516 ____kasan_slab_free+0x131/0x180 mm/kasan/common.c:241 __kasan_slab_free+0x11/0x20 mm/kasan/common.c:249 kasan_slab_free include/linux/kasan.h:178 [inline] slab_free_hook mm/slub.c:1745 [inline] slab_free_freelist_hook mm/slub.c:1771 [inline] slab_free mm/slub.c:3686 [inline] kmem_cache_free+0x ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/1edf68272b8cba2b2817ef1488ecb9f0f84cb6a0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/37e78cad7e9e025e63bb35bc200f44637b009bb1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3d37cadaac1a8e108e576297aab9125b24ea2dfe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4dcd830c420f2190ae32f03626039fde7b57b2ad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6cac47af39b2b8edbb41d47c3bd9c332f83e9932"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c30d79930132466f5be7d0b57add14d1a016bda"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/917ae5e280bc263f56c83fba0d0f0be2c4828083"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a4b0cc9e0bba7525a29f37714e88df12a47997a2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dea243f58a8391e76f42ad5eb59ff210519ee772"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38579,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:35.020,2025-08-28T15:15:54.273,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: f2fs: fix KMSAN uninit-value in extent_info usage KMSAN reported a use of uninitialized value in `__is_extent_mergeable()` and `__is_back_mergeable()` via the read extent tree path. The root cause is that `get_read_extent_info()` only initializes three fields (`fofs`, `blk`, `len`) of `struct extent_info`, leaving the remaining fields uninitialized. This leads to undefined behavior when those fields are accessed later, especially during extent merging. Fix it by zero-initializing the `extent_info` struct before population.",,"[{""url"":""https://git.kernel.org/stable/c/01b6f5955e0008af6bc3a181310d2744bb349800"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/08e8ab00a6d20d5544c932ee85a297d833895141"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/154467f4ad033473e5c903a03e7b9bca7df9a0fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/44a79437309e0ee2276ac17aaedc71253af253a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc1615d5aba4f396cf412579928539a2b124c8a0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dabfa3952c8e6bfe6414dbf32e8b6c5f349dc898"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e68b751ec2b15d866967812c57cfdfc1eba6a269"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38580,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:35.160,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: fix inode use after free in ext4_end_io_rsv_work() In ext4_io_end_defer_completion(), check if io_end->list_vec is empty to avoid adding an io_end that requires no conversion to the i_rsv_conversion_list, which in turn prevents starting an unnecessary worker. An ext4_emergency_state() check is also added to avoid attempting to abort the journal in an emergency state. Additionally, ext4_put_io_end_defer() is refactored to call ext4_io_end_defer_completion() directly instead of being open-coded. This also prevents starting an unnecessary worker when EXT4_IO_END_FAILED is set but data_err=abort is not enabled. This ensures that the check in ext4_put_io_end_defer() is consistent with the check in ext4_end_bio(). Otherwise, we might add an io_end to the i_rsv_conversion_list and then call ext4_finish_bio(), after which the inode could be freed before ext4_end_io_rsv_work() is called, triggering a use-after-free issue.",,"[{""url"":""https://git.kernel.org/stable/c/469c44e66e2110054949609dde095788320139d0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac999862b98a0f49e858e509f776be51406f1e77"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c678bdc998754589cea2e6afab9401d7d8312ac4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38581,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:35.280,2025-08-28T15:15:54.400,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: crypto: ccp - Fix crash when rebind ccp device for ccp.ko When CONFIG_CRYPTO_DEV_CCP_DEBUGFS is enabled, rebinding the ccp device causes the following crash: $ echo '0000:0a:00.2' > /sys/bus/pci/drivers/ccp/unbind $ echo '0000:0a:00.2' > /sys/bus/pci/drivers/ccp/bind [ 204.976930] BUG: kernel NULL pointer dereference, address: 0000000000000098 [ 204.978026] #PF: supervisor write access in kernel mode [ 204.979126] #PF: error_code(0x0002) - not-present page [ 204.980226] PGD 0 P4D 0 [ 204.981317] Oops: Oops: 0002 [#1] SMP NOPTI ... [ 204.997852] Call Trace: [ 204.999074] <TASK> [ 205.000297] start_creating+0x9f/0x1c0 [ 205.001533] debugfs_create_dir+0x1f/0x170 [ 205.002769] ? srso_return_thunk+0x5/0x5f [ 205.004000] ccp5_debugfs_setup+0x87/0x170 [ccp] [ 205.005241] ccp5_init+0x8b2/0x960 [ccp] [ 205.006469] ccp_dev_init+0xd4/0x150 [ccp] [ 205.007709] sp_init+0x5f/0x80 [ccp] [ 205.008942] sp_pci_probe+0x283/0x2e0 [ccp] [ 205.010165] ? srso_return_thunk+0x5/0x5f [ 205.011376] local_pci_probe+0x4f/0xb0 [ 205.012584] pci_device_probe+0xdb/0x230 [ 205.013810] really_probe+0xed/0x380 [ 205.015024] __driver_probe_device+0x7e/0x160 [ 205.016240] device_driver_attach+0x2f/0x60 [ 205.017457] bind_store+0x7c/0xb0 [ 205.018663] drv_attr_store+0x28/0x40 [ 205.019868] sysfs_kf_write+0x5f/0x70 [ 205.021065] kernfs_fop_write_iter+0x145/0x1d0 [ 205.022267] vfs_write+0x308/0x440 [ 205.023453] ksys_write+0x6d/0xe0 [ 205.024616] __x64_sys_write+0x1e/0x30 [ 205.025778] x64_sys_call+0x16ba/0x2150 [ 205.026942] do_syscall_64+0x56/0x1e0 [ 205.028108] entry_SYSCALL_64_after_hwframe+0x76/0x7e [ 205.029276] RIP: 0033:0x7fbc36f10104 [ 205.030420] Code: 89 02 48 c7 c0 ff ff ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 8d 05 e1 08 2e 00 8b 00 85 c0 75 13 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 54 f3 c3 66 90 41 54 55 49 89 d4 53 48 89 f5 This patch sets ccp_debugfs_dir to NULL after destroying it in ccp5_debugfs_destroy, allowing the directory dentry to be recreated when rebinding the ccp device. Tested on AMD Ryzen 7 1700X.",,"[{""url"":""https://git.kernel.org/stable/c/181698af38d3f93381229ad89c09b5bd0496661a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/20c0ed8dd65834e6bab464f54cd6ff68659bacb9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2d4060f05e74dbee884ba723f6afd9282befc3c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/64ec9a7e7a6398b172ab6feba60e952163a1c3d5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6eadf50c1d894cb34f3237064063207460946040"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9dea08eac4f6d6fbbae59992978252e2edab995d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a25ab6dfa0ce323ec308966988be6b675eb9d3e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce63a83925964ab7564bd216bd92b80bc365492e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/db111468531777cac8b4beb6515a88a54b0c4a74"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38582,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:35.430,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/hns: Fix double destruction of rsv_qp rsv_qp may be double destroyed in error flow, first in free_mr_init(), and then in hns_roce_exit(). Fix it by moving the free_mr_init() call into hns_roce_v2_init(). list_del corruption, ffff589732eb9b50->next is LIST_POISON1 (dead000000000100) WARNING: CPU: 8 PID: 1047115 at lib/list_debug.c:53 __list_del_entry_valid+0x148/0x240 ... Call trace: __list_del_entry_valid+0x148/0x240 hns_roce_qp_remove+0x4c/0x3f0 [hns_roce_hw_v2] hns_roce_v2_destroy_qp_common+0x1dc/0x5f4 [hns_roce_hw_v2] hns_roce_v2_destroy_qp+0x22c/0x46c [hns_roce_hw_v2] free_mr_exit+0x6c/0x120 [hns_roce_hw_v2] hns_roce_v2_exit+0x170/0x200 [hns_roce_hw_v2] hns_roce_exit+0x118/0x350 [hns_roce_hw_v2] __hns_roce_hw_v2_init_instance+0x1c8/0x304 [hns_roce_hw_v2] hns_roce_hw_v2_reset_notify_init+0x170/0x21c [hns_roce_hw_v2] hns_roce_hw_v2_reset_notify+0x6c/0x190 [hns_roce_hw_v2] hclge_notify_roce_client+0x6c/0x160 [hclge] hclge_reset_rebuild+0x150/0x5c0 [hclge] hclge_reset+0x10c/0x140 [hclge] hclge_reset_subtask+0x80/0x104 [hclge] hclge_reset_service_task+0x168/0x3ac [hclge] hclge_service_task+0x50/0x100 [hclge] process_one_work+0x250/0x9a0 worker_thread+0x324/0x990 kthread+0x190/0x210 ret_from_fork+0x10/0x18",,"[{""url"":""https://git.kernel.org/stable/c/10b083dbba22be19baa848432b6f25aa68ab2db5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c6957b95ecc5b63c5a4bb4ecc28af326cf8f6dc8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dab173bae3303f074f063750a8dead2550d8c782"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc8b0f5b16bab2e032b4cfcd6218d5df3b80b2ea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38583,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:35.577,2025-08-28T15:15:54.537,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: clk: xilinx: vcu: unregister pll_post only if registered correctly If registration of pll_post is failed, it will be set to NULL or ERR, unregistering same will fail with following call trace: Unable to handle kernel NULL pointer dereference at virtual address 008 pc : clk_hw_unregister+0xc/0x20 lr : clk_hw_unregister_fixed_factor+0x18/0x30 sp : ffff800011923850 ... Call trace: clk_hw_unregister+0xc/0x20 clk_hw_unregister_fixed_factor+0x18/0x30 xvcu_unregister_clock_provider+0xcc/0xf4 [xlnx_vcu] xvcu_probe+0x2bc/0x53c [xlnx_vcu]",,"[{""url"":""https://git.kernel.org/stable/c/3b0abc443ac22f7d4f61ddbbbbc5dbb06c87139d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/51990eecf22f446550befdfd1a9f54147eafd636"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7e903da71f8bec4beb7c06707900e1ed8db843ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/86124c5cfceb5ac04d2fddbf1b6f7147332d96a3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/88bd875b7f9c3652c27d6e4bb7a23701b764f762"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a72b1c2d3b53e088bfaeb593949ff6fbd2cbe8ed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1a1be99d5ae53d3b404415f1665eb59e8e02a8c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38584,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:35.723,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: padata: Fix pd UAF once and for all There is a race condition/UAF in padata_reorder that goes back to the initial commit. A reference count is taken at the start of the process in padata_do_parallel, and released at the end in padata_serial_worker. This reference count is (and only is) required for padata_replace to function correctly. If padata_replace is never called then there is no issue. In the function padata_reorder which serves as the core of padata, as soon as padata is added to queue->serial.list, and the associated spin lock released, that padata may be processed and the reference count on pd would go away. Fix this by getting the next padata before the squeue->serial lock is released. In order to make this possible, simplify padata_reorder by only calling it once the next padata arrives.",,"[{""url"":""https://git.kernel.org/stable/c/71203f68c7749609d7fc8ae6ad054bdedeb24f91"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cdf79bd2e1ecb3cc75631c73d8f4149be6019a52"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dbe3e911a59bda6de96e7cae387ff882c2c177fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38585,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:35.877,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: staging: media: atomisp: Fix stack buffer overflow in gmin_get_var_int() When gmin_get_config_var() calls efi.get_variable() and the EFI variable is larger than the expected buffer size, two behaviors combine to create a stack buffer overflow: 1. gmin_get_config_var() does not return the proper error code when efi.get_variable() fails. It returns the stale 'ret' value from earlier operations instead of indicating the EFI failure. 2. When efi.get_variable() returns EFI_BUFFER_TOO_SMALL, it updates *out_len to the required buffer size but writes no data to the output buffer. However, due to bug #1, gmin_get_var_int() believes the call succeeded. The caller gmin_get_var_int() then performs: - Allocates val[CFG_VAR_NAME_MAX + 1] (65 bytes) on stack - Calls gmin_get_config_var(dev, is_gmin, var, val, &len) with len=64 - If EFI variable is >64 bytes, efi.get_variable() sets len=required_size - Due to bug #1, thinks call succeeded with len=required_size - Executes val[len] = 0, writing past end of 65-byte stack buffer This creates a stack buffer overflow when EFI variables are larger than 64 bytes. Since EFI variables can be controlled by firmware or system configuration, this could potentially be exploited for code execution. Fix the bug by returning proper error codes from gmin_get_config_var() based on EFI status instead of stale 'ret' value. The gmin_get_var_int() function is called during device initialization for camera sensor configuration on Intel Bay Trail and Cherry Trail platforms using the atomisp camera stack.",,"[{""url"":""https://git.kernel.org/stable/c/1a7a2f59fb2eb0718a0cff1e5822500cefe50ed9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3d672fe065aa00f4d66f42e3c9720f69a3ed43e7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e6d3453a002e89537e6136f6c774659b297a549b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee4cf798202d285dcbe85e4467a094c44f5ed8e6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38586,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:36.113,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf, arm64: Fix fp initialization for exception boundary In the ARM64 BPF JIT when prog->aux->exception_boundary is set for a BPF program, find_used_callee_regs() is not called because for a program acting as exception boundary, all callee saved registers are saved. find_used_callee_regs() sets `ctx->fp_used = true;` when it sees FP being used in any of the instructions. For programs acting as exception boundary, ctx->fp_used remains false even if frame pointer is used by the program and therefore, FP is not set-up for such programs in the prologue. This can cause the kernel to crash due to a pagefault. Fix it by setting ctx->fp_used = true for exception boundary programs as fp is always saved in such programs.",,"[{""url"":""https://git.kernel.org/stable/c/0dbef493cae7d451f740558665893c000adb2321"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1ce30231e0a2c8c361ee5f8f7f265fc17130adce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b114fcee766d5101eada1aca7bb5fd0a86c89b35"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e23184725dbb72d5d02940222eee36dbba2aa422"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38587,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:36.250,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ipv6: fix possible infinite loop in fib6_info_uses_dev() fib6_info_uses_dev() seems to rely on RCU without an explicit protection. Like the prior fix in rt6_nlmsg_size(), we need to make sure fib6_del_route() or fib6_add_rt2node() have not removed the anchor from the list, or we risk an infinite loop.",,"[{""url"":""https://git.kernel.org/stable/c/16d21816c0918f8058b5fc14cbe8595d62046e2d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9cb6de8ee144a94ae7a40bdb32560329ab7276f0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bc85e62394f008fa848c4ba02c936c735a3e8ef5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/db65739d406c72776fbdbbc334be827ef05880d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e09be457b71b983a085312ff9e981f51e4ed3211"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8d8ce1b515a0a6af72b30502670a406cfb75073"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38588,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:36.383,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ipv6: prevent infinite loop in rt6_nlmsg_size() While testing prior patch, I was able to trigger an infinite loop in rt6_nlmsg_size() in the following place: list_for_each_entry_rcu(sibling, &f6i->fib6_siblings, fib6_siblings) { rt6_nh_nlmsg_size(sibling->fib6_nh, &nexthop_len); } This is because fib6_del_route() and fib6_add_rt2node() uses list_del_rcu(), which can confuse rcu readers, because they might no longer see the head of the list. Restart the loop if f6i->fib6_nsiblings is zero.",,"[{""url"":""https://git.kernel.org/stable/c/3c13db3e47e170bab19e574404e7b6be45ea873d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/46aeb66e9e54ed0d56c18615e1c3dbd502b327ab"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/54e6fe9dd3b0e7c481c2228782c9494d653546da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6d345136c9b875f065d226908a29c25cdf9343f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd8d8bbd9ced4cc5d06d858f67d4aa87745e8f38"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e1b7932af47f92432be8303d2439d1bf77b0be23"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38589,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:36.520,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: neighbour: Fix null-ptr-deref in neigh_flush_dev(). kernel test robot reported null-ptr-deref in neigh_flush_dev(). [0] The cited commit introduced per-netdev neighbour list and converted neigh_flush_dev() to use it instead of the global hash table. One thing we missed is that neigh_table_clear() calls neigh_ifdown() with NULL dev. Let's restore the hash table iteration. Note that IPv6 module is no longer unloadable, so neigh_table_clear() is called only when IPv6 fails to initialise, which is unlikely to happen. [0]: IPv6: Attempt to unregister permanent protocol 136 IPv6: Attempt to unregister permanent protocol 17 Oops: general protection fault, probably for non-canonical address 0xdffffc00000001a0: 0000 [#1] SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000d00-0x0000000000000d07] CPU: 1 UID: 0 PID: 1 Comm: systemd Tainted: G T 6.12.0-rc6-01246-gf7f52738637f #1 Tainted: [T]=RANDSTRUCT Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014 RIP: 0010:neigh_flush_dev.llvm.6395807810224103582+0x52/0x570 Code: c1 e8 03 42 8a 04 38 84 c0 0f 85 15 05 00 00 31 c0 41 83 3e 0a 0f 94 c0 48 8d 1c c3 48 81 c3 f8 0c 00 00 48 89 d8 48 c1 e8 03 <42> 80 3c 38 00 74 08 48 89 df e8 f7 49 93 fe 4c 8b 3b 4d 85 ff 0f RSP: 0000:ffff88810026f408 EFLAGS: 00010206 RAX: 00000000000001a0 RBX: 0000000000000d00 RCX: 0000000000000000 RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffffffc0631640 RBP: ffff88810026f470 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000 R13: ffffffffc0625250 R14: ffffffffc0631640 R15: dffffc0000000000 FS: 00007f575cb83940(0000) GS:ffff8883aee00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f575db40008 CR3: 00000002bf936000 CR4: 00000000000406f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> __neigh_ifdown.llvm.6395807810224103582+0x44/0x390 neigh_table_clear+0xb1/0x268 ndisc_cleanup+0x21/0x38 [ipv6] init_module+0x2f5/0x468 [ipv6] do_one_initcall+0x1ba/0x628 do_init_module+0x21a/0x530 load_module+0x2550/0x2ea0 __se_sys_finit_module+0x3d2/0x620 __x64_sys_finit_module+0x76/0x88 x64_sys_call+0x7ff/0xde8 do_syscall_64+0xfb/0x1e8 entry_SYSCALL_64_after_hwframe+0x67/0x6f RIP: 0033:0x7f575d6f2719 Code: 08 89 e8 5b 5d c3 66 2e 0f 1f 84 00 00 00 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d b7 06 0d 00 f7 d8 64 89 01 48 RSP: 002b:00007fff82a2a268 EFLAGS: 00000246 ORIG_RAX: 0000000000000139 RAX: ffffffffffffffda RBX: 0000557827b45310 RCX: 00007f575d6f2719 RDX: 0000000000000000 RSI: 00007f575d584efd RDI: 0000000000000004 RBP: 00007f575d584efd R08: 0000000000000000 R09: 0000557827b47b00 R10: 0000000000000004 R11: 0000000000000246 R12: 0000000000020000 R13: 0000000000000000 R14: 0000557827b470e0 R15: 00007f575dbb4270 </TASK> Modules linked in: ipv6(+)",,"[{""url"":""https://git.kernel.org/stable/c/1bbb76a899486827394530916f01214d049931b3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/47fbd7f8df19bdfbe334ee83f35568c9a29221ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d9c4328795697ebc392a63fece3901999c09cddd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38590,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:36.653,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/mlx5e: Remove skb secpath if xfrm state is not found Hardware returns a unique identifier for a decrypted packet's xfrm state, this state is looked up in an xarray. However, the state might have been freed by the time of this lookup. Currently, if the state is not found, only a counter is incremented. The secpath (sp) extension on the skb is not removed, resulting in sp->len becoming 0. Subsequently, functions like __xfrm_policy_check() attempt to access fields such as xfrm_input_state(skb)->xso.type (which dereferences sp->xvec[sp->len - 1]) without first validating sp->len. This leads to a crash when dereferencing an invalid state pointer. This patch prevents the crash by explicitly removing the secpath extension from the skb if the xfrm state is not found after hardware decryption. This ensures downstream functions do not operate on a zero-length secpath. BUG: unable to handle page fault for address: ffffffff000002c8 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 282e067 P4D 282e067 PUD 0 Oops: Oops: 0000 [#1] SMP CPU: 12 UID: 0 PID: 0 Comm: swapper/12 Not tainted 6.15.0-rc7_for_upstream_min_debug_2025_05_27_22_44 #1 NONE Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 RIP: 0010:__xfrm_policy_check+0x61a/0xa30 Code: b6 77 7f 83 e6 02 74 14 4d 8b af d8 00 00 00 41 0f b6 45 05 c1 e0 03 48 98 49 01 c5 41 8b 45 00 83 e8 01 48 98 49 8b 44 c5 10 <0f> b6 80 c8 02 00 00 83 e0 0c 3c 04 0f 84 0c 02 00 00 31 ff 80 fa RSP: 0018:ffff88885fb04918 EFLAGS: 00010297 RAX: ffffffff00000000 RBX: 0000000000000002 RCX: 0000000000000000 RDX: 0000000000000002 RSI: 0000000000000002 RDI: 0000000000000000 RBP: ffffffff8311af80 R08: 0000000000000020 R09: 00000000c2eda353 R10: ffff88812be2bbc8 R11: 000000001faab533 R12: ffff88885fb049c8 R13: ffff88812be2bbc8 R14: 0000000000000000 R15: ffff88811896ae00 FS: 0000000000000000(0000) GS:ffff8888dca82000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: ffffffff000002c8 CR3: 0000000243050002 CR4: 0000000000372eb0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <IRQ> ? try_to_wake_up+0x108/0x4c0 ? udp4_lib_lookup2+0xbe/0x150 ? udp_lib_lport_inuse+0x100/0x100 ? __udp4_lib_lookup+0x2b0/0x410 __xfrm_policy_check2.constprop.0+0x11e/0x130 udp_queue_rcv_one_skb+0x1d/0x530 udp_unicast_rcv_skb+0x76/0x90 __udp4_lib_rcv+0xa64/0xe90 ip_protocol_deliver_rcu+0x20/0x130 ip_local_deliver_finish+0x75/0xa0 ip_local_deliver+0xc1/0xd0 ? ip_protocol_deliver_rcu+0x130/0x130 ip_sublist_rcv+0x1f9/0x240 ? ip_rcv_finish_core+0x430/0x430 ip_list_rcv+0xfc/0x130 __netif_receive_skb_list_core+0x181/0x1e0 netif_receive_skb_list_internal+0x200/0x360 ? mlx5e_build_rx_skb+0x1bc/0xda0 [mlx5_core] gro_receive_skb+0xfd/0x210 mlx5e_handle_rx_cqe_mpwrq+0x141/0x280 [mlx5_core] mlx5e_poll_rx_cq+0xcc/0x8e0 [mlx5_core] ? mlx5e_handle_rx_dim+0x91/0xd0 [mlx5_core] mlx5e_napi_poll+0x114/0xab0 [mlx5_core] __napi_poll+0x25/0x170 net_rx_action+0x32d/0x3a0 ? mlx5_eq_comp_int+0x8d/0x280 [mlx5_core] ? notifier_call_chain+0x33/0xa0 handle_softirqs+0xda/0x250 irq_exit_rcu+0x6d/0xc0 common_interrupt+0x81/0xa0 </IRQ>",,"[{""url"":""https://git.kernel.org/stable/c/137b12a4900eb6971b889839eab6036f72cbb217"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/314f568b84b01f6eac1e4313ca47f9ade4349443"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3a5782431d84716b66302b07ff1b32fea1023bd5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6d19c44b5c6dd72f9a357d0399604ec16a77de3c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/781a0bbf377443ef06f3248221f06cb555935530"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38591,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:36.790,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf: Reject narrower access to pointer ctx fields The following BPF program, simplified from a syzkaller repro, causes a kernel warning: r0 = *(u8 *)(r1 + 169); exit; With pointer field sk being at offset 168 in __sk_buff. This access is detected as a narrower read in bpf_skb_is_valid_access because it doesn't match offsetof(struct __sk_buff, sk). It is therefore allowed and later proceeds to bpf_convert_ctx_access. Note that for the ""is_narrower_load"" case in the convert_ctx_accesses(), the insn->off is aligned, so the cnt may not be 0 because it matches the offsetof(struct __sk_buff, sk) in the bpf_convert_ctx_access. However, the target_size stays 0 and the verifier errors with a kernel warning: verifier bug: error during ctx access conversion(1) This patch fixes that to return a proper ""invalid bpf_context access off=X size=Y"" error on the load instruction. The same issue affects multiple other fields in context structures that allow narrow access. Some other non-affected fields (for sk_msg, sk_lookup, and sockopt) were also changed to use bpf_ctx_range_ptr for consistency. Note this syzkaller crash was reported in the ""Closes"" link below, which used to be about a different bug, fixed in commit fce7bd8e385a (""bpf/verifier: Handle BPF_LOAD_ACQ instructions in insn_def_regno()""). Because syzbot somehow confused the two bugs, the new crash and repro didn't get reported to the mailing list.",,"[{""url"":""https://git.kernel.org/stable/c/202900ceeef67458c964c2af6e1427c8e533ea7c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e09299225d5ba3916c91ef70565f7d2187e4cca0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38592,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:36.930,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: hci_devcd_dump: fix out-of-bounds via dev_coredumpv Currently both dev_coredumpv and skb_put_data in hci_devcd_dump use hdev->dump.head. However, dev_coredumpv can free the buffer. From dev_coredumpm_timeout documentation, which is used by dev_coredumpv: > Creates a new device coredump for the given device. If a previous one hasn't > been read yet, the new coredump is discarded. The data lifetime is determined > by the device coredump framework and when it is no longer needed the @free > function will be called to free the data. If the data has not been read by the userspace yet, dev_coredumpv will discard new buffer, freeing hdev->dump.head. This leads to vmalloc-out-of-bounds error when skb_put_data tries to access hdev->dump.head. A crash report from syzbot illustrates this: ================================================================== BUG: KASAN: vmalloc-out-of-bounds in skb_put_data include/linux/skbuff.h:2752 [inline] BUG: KASAN: vmalloc-out-of-bounds in hci_devcd_dump+0x142/0x240 net/bluetooth/coredump.c:258 Read of size 140 at addr ffffc90004ed5000 by task kworker/u9:2/5844 CPU: 1 UID: 0 PID: 5844 Comm: kworker/u9:2 Not tainted 6.14.0-syzkaller-10892-g4e82c87058f4 #0 PREEMPT(full) Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 02/12/2025 Workqueue: hci0 hci_devcd_timeout Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:408 [inline] print_report+0xc3/0x670 mm/kasan/report.c:521 kasan_report+0xe0/0x110 mm/kasan/report.c:634 check_region_inline mm/kasan/generic.c:183 [inline] kasan_check_range+0xef/0x1a0 mm/kasan/generic.c:189 __asan_memcpy+0x23/0x60 mm/kasan/shadow.c:105 skb_put_data include/linux/skbuff.h:2752 [inline] hci_devcd_dump+0x142/0x240 net/bluetooth/coredump.c:258 hci_devcd_timeout+0xb5/0x2e0 net/bluetooth/coredump.c:413 process_one_work+0x9cc/0x1b70 kernel/workqueue.c:3238 process_scheduled_works kernel/workqueue.c:3319 [inline] worker_thread+0x6c8/0xf10 kernel/workqueue.c:3400 kthread+0x3c2/0x780 kernel/kthread.c:464 ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:153 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:245 </TASK> The buggy address ffffc90004ed5000 belongs to a vmalloc virtual mapping Memory state around the buggy address: ffffc90004ed4f00: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 ffffc90004ed4f80: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 >ffffc90004ed5000: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 ^ ffffc90004ed5080: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 ffffc90004ed5100: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 ================================================================== To avoid this issue, reorder dev_coredumpv to be called after skb_put_data that does not free the data.",,"[{""url"":""https://git.kernel.org/stable/c/7af4d7b53502286c6cf946d397ab183e76d14820"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c021ad797f9171d015cf0a932a3fbe5232190f5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/efd55f6a59449f8d4e4953f12c177aa902b7451f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38593,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:37.067,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: hci_sync: fix double free in 'hci_discovery_filter_clear()' Function 'hci_discovery_filter_clear()' frees 'uuids' array and then sets it to NULL. There is a tiny chance of the following race: 'hci_cmd_sync_work()' 'update_passive_scan_sync()' 'hci_update_passive_scan_sync()' 'hci_discovery_filter_clear()' kfree(uuids); <-------------------------preempted--------------------------------> 'start_service_discovery()' 'hci_discovery_filter_clear()' kfree(uuids); // DOUBLE FREE <-------------------------preempted--------------------------------> uuids = NULL; To fix it let's add locking around 'kfree()' call and NULL pointer assignment. Otherwise the following backtrace fires: [ ] ------------[ cut here ]------------ [ ] kernel BUG at mm/slub.c:547! [ ] Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP [ ] CPU: 3 UID: 0 PID: 246 Comm: bluetoothd Tainted: G O 6.12.19-kernel #1 [ ] Tainted: [O]=OOT_MODULE [ ] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ ] pc : __slab_free+0xf8/0x348 [ ] lr : __slab_free+0x48/0x348 ... [ ] Call trace: [ ] __slab_free+0xf8/0x348 [ ] kfree+0x164/0x27c [ ] start_service_discovery+0x1d0/0x2c0 [ ] hci_sock_sendmsg+0x518/0x924 [ ] __sock_sendmsg+0x54/0x60 [ ] sock_write_iter+0x98/0xf8 [ ] do_iter_readv_writev+0xe4/0x1c8 [ ] vfs_writev+0x128/0x2b0 [ ] do_writev+0xfc/0x118 [ ] __arm64_sys_writev+0x20/0x2c [ ] invoke_syscall+0x68/0xf0 [ ] el0_svc_common.constprop.0+0x40/0xe0 [ ] do_el0_svc+0x1c/0x28 [ ] el0_svc+0x30/0xd0 [ ] el0t_64_sync_handler+0x100/0x12c [ ] el0t_64_sync+0x194/0x198 [ ] Code: 8b0002e6 eb17031f 54fffbe1 d503201f (d4210000) [ ] ---[ end trace 0000000000000000 ]---",,"[{""url"":""https://git.kernel.org/stable/c/16852eccbdfaf41a666705e3f8be55cf2864c5ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2935e556850e9c94d7a00adf14d3cd7fe406ac03"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a351ff6b8ecca4229afaa0d98042bead8de64799"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8069f34c4c976786ded97498012225af87435d7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38594,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:37.213,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iommu/vt-d: Fix UAF on sva unbind with pending IOPFs Commit 17fce9d2336d (""iommu/vt-d: Put iopf enablement in domain attach path"") disables IOPF on device by removing the device from its IOMMU's IOPF queue when the last IOPF-capable domain is detached from the device. Unfortunately, it did this in a wrong place where there are still pending IOPFs. As a result, a use-after-free error is potentially triggered and eventually a kernel panic with a kernel trace similar to the following: refcount_t: underflow; use-after-free. WARNING: CPU: 3 PID: 313 at lib/refcount.c:28 refcount_warn_saturate+0xd8/0xe0 Workqueue: iopf_queue/dmar0-iopfq iommu_sva_handle_iopf Call Trace: <TASK> iopf_free_group+0xe/0x20 process_one_work+0x197/0x3d0 worker_thread+0x23a/0x350 ? rescuer_thread+0x4a0/0x4a0 kthread+0xf8/0x230 ? finish_task_switch.isra.0+0x81/0x260 ? kthreads_online_cpu+0x110/0x110 ? kthreads_online_cpu+0x110/0x110 ret_from_fork+0x13b/0x170 ? kthreads_online_cpu+0x110/0x110 ret_from_fork_asm+0x11/0x20 </TASK> ---[ end trace 0000000000000000 ]--- The intel_pasid_tear_down_entry() function is responsible for blocking hardware from generating new page faults and flushing all in-flight ones. Therefore, moving iopf_for_domain_remove() after this function should resolve this.",,"[{""url"":""https://git.kernel.org/stable/c/c68332b7ee893292bba6e87d31ef2080c066c65d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f0b9d31c6edd50a6207489cd1bd4ddac814b9cd2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38595,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:37.343,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: xen: fix UAF in dmabuf_exp_from_pages() [dma_buf_fd() fixes; no preferences regarding the tree it goes through - up to xen folks] As soon as we'd inserted a file reference into descriptor table, another thread could close it. That's fine for the case when all we are doing is returning that descriptor to userland (it's a race, but it's a userland race and there's nothing the kernel can do about it). However, if we follow fd_install() with any kind of access to objects that would be destroyed on close (be it the struct file itself or anything destroyed by its ->release()), we have a UAF. dma_buf_fd() is a combination of reserving a descriptor and fd_install(). gntdev dmabuf_exp_from_pages() calls it and then proceeds to access the objects destroyed on close - starting with gntdev_dmabuf itself. Fix that by doing reserving descriptor before anything else and do fd_install() only when everything had been set up.",,"[{""url"":""https://git.kernel.org/stable/c/3edfd2353f301bfffd5ee41066e37320a59ccc2d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/532c8b51b3a8676cbf533a291f8156774f30ea87"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d59d49af4aeed9a81e673e37c26c6a3bacf1a181"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e5907885260401bba300d4d18d79875c05b82651"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38596,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:37.480,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/panthor: Fix UAF in panthor_gem_create_with_handle() debugfs code The object is potentially already gone after the drm_gem_object_put(). In general the object should be fully constructed before calling drm_gem_handle_create(), except the debugfs tracking uses a separate lock and list and separate flag to denotate whether the object is actually initialized. Since I'm touching this all anyway simplify this by only adding the object to the debugfs when it's ready for that, which allows us to delete that separate flag. panthor_gem_debugfs_bo_rm() already checks whether we've actually been added to the list or this is some error path cleanup. v2: Fix build issues for !CONFIG_DEBUGFS (Adrin) v3: Add linebreak and remove outdated comment (Liviu)",,"[{""url"":""https://git.kernel.org/stable/c/5f2be12442db6a2904e6e31b0e3b5ad5aebf868b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe69a391808404977b1f002a6e7447de3de7a88e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38597,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:37.613,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/rockchip: vop2: fail cleanly if missing a primary plane for a video-port Each window of a vop2 is usable by a specific set of video ports, so while binding the vop2, we look through the list of available windows trying to find one designated as primary-plane and usable by that specific port. The code later wants to use drm_crtc_init_with_planes with that found primary plane, but nothing has checked so far if a primary plane was actually found. For whatever reason, the rk3576 vp2 does not have a usable primary window (if vp0 is also in use) which brought the issue to light and ended in a null-pointer dereference further down. As we expect a primary-plane to exist for a video-port, add a check at the end of the window-iteration and fail probing if none was found.",,"[{""url"":""https://git.kernel.org/stable/c/38682edbbad272b5f8c7bf55128b42cd10626f73"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e1eef239399927b368f70a716044fb10085627c8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f9f68bf1d0efeadb6c427c9dbb30f307a7def19b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38598,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:37.753,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: fix use-after-free in amdgpu_userq_suspend+0x51a/0x5a0 [ +0.000020] BUG: KASAN: slab-use-after-free in amdgpu_userq_suspend+0x51a/0x5a0 [amdgpu] [ +0.000817] Read of size 8 at addr ffff88812eec8c58 by task amd_pci_unplug/1733 [ +0.000027] CPU: 10 UID: 0 PID: 1733 Comm: amd_pci_unplug Tainted: G W 6.14.0+ #2 [ +0.000009] Tainted: [W]=WARN [ +0.000003] Hardware name: ASUS System Product Name/ROG STRIX B550-F GAMING (WI-FI), BIOS 1401 12/03/2020 [ +0.000004] Call Trace: [ +0.000004] <TASK> [ +0.000003] dump_stack_lvl+0x76/0xa0 [ +0.000011] print_report+0xce/0x600 [ +0.000009] ? srso_return_thunk+0x5/0x5f [ +0.000006] ? kasan_complete_mode_report_info+0x76/0x200 [ +0.000007] ? kasan_addr_to_slab+0xd/0xb0 [ +0.000006] ? amdgpu_userq_suspend+0x51a/0x5a0 [amdgpu] [ +0.000707] kasan_report+0xbe/0x110 [ +0.000006] ? amdgpu_userq_suspend+0x51a/0x5a0 [amdgpu] [ +0.000541] __asan_report_load8_noabort+0x14/0x30 [ +0.000005] amdgpu_userq_suspend+0x51a/0x5a0 [amdgpu] [ +0.000535] ? stop_cpsch+0x396/0x600 [amdgpu] [ +0.000556] ? stop_cpsch+0x429/0x600 [amdgpu] [ +0.000536] ? __pfx_amdgpu_userq_suspend+0x10/0x10 [amdgpu] [ +0.000536] ? srso_return_thunk+0x5/0x5f [ +0.000004] ? kgd2kfd_suspend+0x132/0x1d0 [amdgpu] [ +0.000542] amdgpu_device_fini_hw+0x581/0xe90 [amdgpu] [ +0.000485] ? down_write+0xbb/0x140 [ +0.000007] ? __mutex_unlock_slowpath.constprop.0+0x317/0x360 [ +0.000005] ? __pfx_amdgpu_device_fini_hw+0x10/0x10 [amdgpu] [ +0.000482] ? __kasan_check_write+0x14/0x30 [ +0.000004] ? srso_return_thunk+0x5/0x5f [ +0.000004] ? up_write+0x55/0xb0 [ +0.000007] ? srso_return_thunk+0x5/0x5f [ +0.000005] ? blocking_notifier_chain_unregister+0x6c/0xc0 [ +0.000008] amdgpu_driver_unload_kms+0x69/0x90 [amdgpu] [ +0.000484] amdgpu_pci_remove+0x93/0x130 [amdgpu] [ +0.000482] pci_device_remove+0xae/0x1e0 [ +0.000008] device_remove+0xc7/0x180 [ +0.000008] device_release_driver_internal+0x3d4/0x5a0 [ +0.000007] device_release_driver+0x12/0x20 [ +0.000004] pci_stop_bus_device+0x104/0x150 [ +0.000006] pci_stop_and_remove_bus_device_locked+0x1b/0x40 [ +0.000005] remove_store+0xd7/0xf0 [ +0.000005] ? __pfx_remove_store+0x10/0x10 [ +0.000006] ? __pfx__copy_from_iter+0x10/0x10 [ +0.000006] ? __pfx_dev_attr_store+0x10/0x10 [ +0.000006] dev_attr_store+0x3f/0x80 [ +0.000006] sysfs_kf_write+0x125/0x1d0 [ +0.000004] ? srso_return_thunk+0x5/0x5f [ +0.000005] ? __kasan_check_write+0x14/0x30 [ +0.000005] kernfs_fop_write_iter+0x2ea/0x490 [ +0.000005] ? rw_verify_area+0x70/0x420 [ +0.000005] ? __pfx_kernfs_fop_write_iter+0x10/0x10 [ +0.000006] vfs_write+0x90d/0xe70 [ +0.000005] ? srso_return_thunk+0x5/0x5f [ +0.000005] ? __pfx_vfs_write+0x10/0x10 [ +0.000004] ? local_clock+0x15/0x30 [ +0.000008] ? srso_return_thunk+0x5/0x5f [ +0.000004] ? __kasan_slab_free+0x5f/0x80 [ +0.000005] ? srso_return_thunk+0x5/0x5f [ +0.000004] ? __kasan_check_read+0x11/0x20 [ +0.000004] ? srso_return_thunk+0x5/0x5f [ +0.000004] ? fdget_pos+0x1d3/0x500 [ +0.000007] ksys_write+0x119/0x220 [ +0.000005] ? putname+0x1c/0x30 [ +0.000006] ? __pfx_ksys_write+0x10/0x10 [ +0.000007] __x64_sys_write+0x72/0xc0 [ +0.000006] x64_sys_call+0x18ab/0x26f0 [ +0.000006] do_syscall_64+0x7c/0x170 [ +0.000004] ? srso_return_thunk+0x5/0x5f [ +0.000004] ? __pfx___x64_sys_openat+0x10/0x10 [ +0.000006] ? srso_return_thunk+0x5/0x5f [ +0.000004] ? __kasan_check_read+0x11/0x20 [ +0.000003] ? srso_return_thunk+0x5/0x5f [ +0.000004] ? fpregs_assert_state_consistent+0x21/0xb0 [ +0.000006] ? srso_return_thunk+0x5/0x5f [ +0.000004] ? syscall_exit_to_user_mode+0x4e/0x240 [ +0.000005] ? srso_return_thunk+0x5/0x5f [ +0.000004] ? do_syscall_64+0x88/0x170 [ +0.000003] ? srso_return_thunk+0x5/0x5f [ +0.000004] ? irqentry_exit+0x43/0x50 [ +0.000004] ? srso_return_thunk+0x5 ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/96f663ae897b3e6ac17ced1d9b9c2ae9f165ad9a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a886d26f2c8f9e3f3c1869ae368d09c75daac553"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38599,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:37.903,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: mt7996: Fix possible OOB access in mt7996_tx() Fis possible Out-Of-Boundary access in mt7996_tx routine if link_id is set to IEEE80211_LINK_UNSPECIFIED",,"[{""url"":""https://git.kernel.org/stable/c/64cbf0d7ce9afe20666da90ec6ecaec6ba5ac64b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f43e7d8ae4b6a73213032545552bab26f76f113a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f82eabd0ff8067d1ee95515f4174c9a9569d54cb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38600,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:38.080,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: mt7925: fix off by one in mt7925_mcu_hw_scan() The ssid->ssids[] and sreq->ssids[] arrays have MT7925_RNR_SCAN_MAX_BSSIDS elements so this >= needs to be > to prevent an out of bounds access.",,"[{""url"":""https://git.kernel.org/stable/c/4d80d4fa986c5da99042b66bf30a028e7f564156"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3a431fe2e399b2e0cc5f43f7e9d63d63d3710ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38601,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:38.233,2025-08-28T15:15:54.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath11k: clear initialized flag for deinit-ed srng lists In a number of cases we see kernel panics on resume due to ath11k kernel page fault, which happens under the following circumstances: 1) First ath11k_hal_dump_srng_stats() call Last interrupt received for each group: ath11k_pci 0000:01:00.0: group_id 0 22511ms before ath11k_pci 0000:01:00.0: group_id 1 14440788ms before [..] ath11k_pci 0000:01:00.0: failed to receive control response completion, polling.. ath11k_pci 0000:01:00.0: Service connect timeout ath11k_pci 0000:01:00.0: failed to connect to HTT: -110 ath11k_pci 0000:01:00.0: failed to start core: -110 ath11k_pci 0000:01:00.0: firmware crashed: MHI_CB_EE_RDDM ath11k_pci 0000:01:00.0: already resetting count 2 ath11k_pci 0000:01:00.0: failed to wait wlan mode request (mode 4): -110 ath11k_pci 0000:01:00.0: qmi failed to send wlan mode off: -110 ath11k_pci 0000:01:00.0: failed to reconfigure driver on crash recovery [..] 2) At this point reconfiguration fails (we have 2 resets) and ath11k_core_reconfigure_on_crash() calls ath11k_hal_srng_deinit() which destroys srng lists. However, it does not reset per-list ->initialized flag. 3) Second ath11k_hal_dump_srng_stats() call sees stale ->initialized flag and attempts to dump srng stats: Last interrupt received for each group: ath11k_pci 0000:01:00.0: group_id 0 66785ms before ath11k_pci 0000:01:00.0: group_id 1 14485062ms before ath11k_pci 0000:01:00.0: group_id 2 14485062ms before ath11k_pci 0000:01:00.0: group_id 3 14485062ms before ath11k_pci 0000:01:00.0: group_id 4 14780845ms before ath11k_pci 0000:01:00.0: group_id 5 14780845ms before ath11k_pci 0000:01:00.0: group_id 6 14485062ms before ath11k_pci 0000:01:00.0: group_id 7 66814ms before ath11k_pci 0000:01:00.0: group_id 8 68997ms before ath11k_pci 0000:01:00.0: group_id 9 67588ms before ath11k_pci 0000:01:00.0: group_id 10 69511ms before BUG: unable to handle page fault for address: ffffa007404eb010 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 100000067 P4D 100000067 PUD 10022d067 PMD 100b01067 PTE 0 Oops: 0000 [#1] PREEMPT SMP NOPTI RIP: 0010:ath11k_hal_dump_srng_stats+0x2b4/0x3b0 [ath11k] Call Trace: <TASK> ? __die_body+0xae/0xb0 ? page_fault_oops+0x381/0x3e0 ? exc_page_fault+0x69/0xa0 ? asm_exc_page_fault+0x22/0x30 ? ath11k_hal_dump_srng_stats+0x2b4/0x3b0 [ath11k (HASH:6cea 4)] ath11k_qmi_driver_event_work+0xbd/0x1050 [ath11k (HASH:6cea 4)] worker_thread+0x389/0x930 kthread+0x149/0x170 Clear per-list ->initialized flag in ath11k_hal_srng_deinit().",,"[{""url"":""https://git.kernel.org/stable/c/0ebb5fe494501c19f31270008b26ab95201af6fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/16872194c80f2724472fc207991712895ac8a230"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3a6daae987a829534636fd85ed6f84d5f0ad7fa4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5bf201c55fdf303e79005038648dfa1e8af48f54"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/72a48be1f53942793f3bc68a37fad1f38b53b082"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/916ac18d526a26f6072866b1a97622cf1351ef1c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a5b46aa7cf5f05c213316a018e49a8e086efd98e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eff3bb53c18c0ed4ab6f43d412b3ed3aecad52d5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38602,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:38.380,2025-08-28T15:15:54.803,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iwlwifi: Add missing check for alloc_ordered_workqueue Add check for the return value of alloc_ordered_workqueue since it may return NULL pointer.",,"[{""url"":""https://git.kernel.org/stable/c/2e9f85ee3b46453a2f250a57d3a9f10c70c71202"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6663c52608d8d8727bf1911e6d9218069ba1c85e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/70a1b527eaea9430b1bd87de59f3b9f6bd225701"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7dd6350307af6521b6240b295c93b7eec4daebe6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90a0d9f339960448a3acc1437a46730f975efd6a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b398120fbe0acfef60b16f6a0f69902d385d7728"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c0e43c3f6c0a79381b468574c241065998412b7c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c80832d445653baba5ac80cd2c2637c437ac881b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca980f1911a7144d451d1c31298ab8507c6bd88f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38603,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:38.517,2025-09-05T08:15:30.610,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,[],,,,,,,,,,
CVE-2025-38604,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:38.647,2025-08-28T15:15:54.940,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: rtl818x: Kill URBs before clearing tx status queue In rtl8187_stop() move the call of usb_kill_anchored_urbs() before clearing b_tx_status.queue. This change prevents callbacks from using already freed skb due to anchor was not killed before freeing such skb. BUG: kernel NULL pointer dereference, address: 0000000000000080 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 0 P4D 0 Oops: Oops: 0000 [#1] SMP NOPTI CPU: 7 UID: 0 PID: 0 Comm: swapper/7 Not tainted 6.15.0 #8 PREEMPT(voluntary) Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 0.0.0 02/06/2015 RIP: 0010:ieee80211_tx_status_irqsafe+0x21/0xc0 [mac80211] Call Trace: <IRQ> rtl8187_tx_cb+0x116/0x150 [rtl8187] __usb_hcd_giveback_urb+0x9d/0x120 usb_giveback_urb_bh+0xbb/0x140 process_one_work+0x19b/0x3c0 bh_worker+0x1a7/0x210 tasklet_action+0x10/0x30 handle_softirqs+0xf0/0x340 __irq_exit_rcu+0xcd/0xf0 common_interrupt+0x85/0xa0 </IRQ> Tested on RTL8187BvE device. Found by Linux Verification Center (linuxtesting.org) with SVACE.",,"[{""url"":""https://git.kernel.org/stable/c/14ca6952691fa8cc91e7644512e6ff24a595283f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/16d8fd74dbfca0ea58645cd2fca13be10cae3cdd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7858a95566f4ebf59524666683d2dcdba3fca968"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/789415771422f4fb9f444044f86ecfaec55df1bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/81cfe34d0630de4e23ae804dcc08fb6f861dc37d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c767727f331fb9455b0f81daad832b5925688cb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c51a45ad9070a6d296174fcbe5c466352836c12b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c73c773b09e313278f9b960303a2809b8440bac6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e64732ebff9e24258e7326f07adbe2f2b990daf8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38605,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:38.793,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: Pass ab pointer directly to ath12k_dp_tx_get_encap_type() In ath12k_dp_tx_get_encap_type(), the arvif parameter is only used to retrieve the ab pointer. In vdev delete sequence the arvif->ar could become NULL and that would trigger kernel panic. Since the caller ath12k_dp_tx() already has a valid ab pointer, pass it directly to avoid panic and unnecessary dereferencing. PC points to ""ath12k_dp_tx+0x228/0x988 [ath12k]"" LR points to ""ath12k_dp_tx+0xc8/0x988 [ath12k]"". The Backtrace obtained is as follows: ath12k_dp_tx+0x228/0x988 [ath12k] ath12k_mac_tx_check_max_limit+0x608/0x920 [ath12k] ieee80211_process_measurement_req+0x320/0x348 [mac80211] ieee80211_tx_dequeue+0x9ac/0x1518 [mac80211] ieee80211_tx_dequeue+0xb14/0x1518 [mac80211] ieee80211_tx_prepare_skb+0x224/0x254 [mac80211] ieee80211_xmit+0xec/0x100 [mac80211] __ieee80211_subif_start_xmit+0xc50/0xf40 [mac80211] ieee80211_subif_start_xmit+0x2e8/0x308 [mac80211] netdev_start_xmit+0x150/0x18c dev_hard_start_xmit+0x74/0xc0 Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1",,"[{""url"":""https://git.kernel.org/stable/c/05062834350f0bf7ad1abcebc2807220e90220eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b508f370f88f277c95e2bd3bc47217a96d668cee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee4f8e7fa578f9f28cef5f409677db25f4f83d7e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38606,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:38.930,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: Avoid accessing uninitialized arvif->ar during beacon miss During beacon miss handling, ath12k driver iterates over active virtual interfaces (vifs) and attempts to access the radio object (ar) via arvif->deflink->ar. However, after commit aa80f12f3bed (""wifi: ath12k: defer vdev creation for MLO""), arvif is linked to a radio only after vdev creation, typically when a channel is assigned or a scan is requested. For P2P capable devices, a default P2P interface is created by wpa_supplicant along with regular station interfaces, these serve as dummy interfaces for P2P-capable stations, lack an associated netdev and initiate frequent scans to discover neighbor p2p devices. When a scan is initiated on such P2P vifs, driver selects destination radio (ar) based on scan frequency, creates a scan vdev, and attaches arvif to the radio. Once the scan completes or is aborted, the scan vdev is deleted, detaching arvif from the radio and leaving arvif->ar uninitialized. While handling beacon miss for station interfaces, P2P interface is also encountered in the vif iteration and ath12k_mac_handle_beacon_miss_iter() tries to dereference the uninitialized arvif->deflink->ar. Fix this by verifying that vdev is created for the arvif before accessing its ar during beacon miss handling and similar vif iterator callbacks. ========================================================================== wlp6s0: detected beacon loss from AP (missed 7 beacons) - probing KASAN: null-ptr-deref in range [0x0000000000000010-0x0000000000000017] CPU: 5 UID: 0 PID: 0 Comm: swapper/5 Not tainted 6.16.0-rc1-wt-ath+ #2 PREEMPT(full) RIP: 0010:ath12k_mac_handle_beacon_miss_iter+0xb5/0x1a0 [ath12k] Call Trace: __iterate_interfaces+0x11a/0x410 [mac80211] ieee80211_iterate_active_interfaces_atomic+0x61/0x140 [mac80211] ath12k_mac_handle_beacon_miss+0xa1/0xf0 [ath12k] ath12k_roam_event+0x393/0x560 [ath12k] ath12k_wmi_op_rx+0x1486/0x28c0 [ath12k] ath12k_htc_process_trailer.isra.0+0x2fb/0x620 [ath12k] ath12k_htc_rx_completion_handler+0x448/0x830 [ath12k] ath12k_ce_recv_process_cb+0x549/0x9e0 [ath12k] ath12k_ce_per_engine_service+0xbe/0xf0 [ath12k] ath12k_pci_ce_workqueue+0x69/0x120 [ath12k] process_one_work+0xe3a/0x1430 Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.4.1-00199-QCAHKSWPL_SILICONZ-1 Tested-on: WCN7850 hw2.0 PCI WLAN.HMT.1.1.c5-00284.1-QCAHMTSWPL_V1.0_V2.0_SILICONZ-3",,"[{""url"":""https://git.kernel.org/stable/c/1259b6da8303f70fef6ed4aef8ae3dedfecb0f27"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/36670b67de18f1e5d34900c5d2ac60a8970c293c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9b861dfc5c07defd0191fd3e7288a3179cd9a02e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38607,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:39.070,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf: handle jset (if a & b ...) as a jump in CFG computation BPF_JSET is a conditional jump and currently verifier.c:can_jump() does not know about that. This can lead to incorrect live registers and SCC computation. E.g. in the following example: 1: r0 = 1; 2: r2 = 2; 3: if r1 & 0x7 goto +1; 4: exit; 5: r0 = r2; 6: exit; W/o this fix insn_successors(3) will return only (4), a jump to (5) would be missed and r2 won't be marked as alive at (3).",,"[{""url"":""https://git.kernel.org/stable/c/261b30ad1516f4b9edd500aa6e8d6315c8fc109a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3157f7e2999616ac91f4d559a8566214f74000a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/65eb166b8636365ad3d6e36d50a7c5edfe6cc66e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38608,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:39.203,2025-08-28T15:15:55.077,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf, ktls: Fix data corruption when using bpf_msg_pop_data() in ktls When sending plaintext data, we initially calculated the corresponding ciphertext length. However, if we later reduced the plaintext data length via socket policy, we failed to recalculate the ciphertext length. This results in transmitting buffers containing uninitialized data during ciphertext transmission. This causes uninitialized bytes to be appended after a complete ""Application Data"" packet, leading to errors on the receiving end when parsing TLS record.",,"[{""url"":""https://git.kernel.org/stable/c/0e853c1464bcf61207f8b5c32d2ac5ee495e859d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/16aca8bb4ad0d8a13c8b6da4007f4e52d53035bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/178f6a5c8cb3b6be1602de0964cd440243f493c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1e480387d4b42776f8957fb148af9d75ce93b96d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6ba20ff3cdb96a908b9dc93cf247d0b087672e7c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73fc5d04009d3969ff8e8574f0fd769f04124e59"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/849d24dc5aed45ebeb3490df429356739256ac40"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90d6ef67440cec2a0aad71a0108c8f216437345c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee03766d79de0f61ea29ffb6ab1c7b196ea1b02e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38609,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:39.343,2025-08-28T15:15:55.213,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: PM / devfreq: Check governor before using governor->name Commit 96ffcdf239de (""PM / devfreq: Remove redundant governor_name from struct devfreq"") removes governor_name and uses governor->name to replace it. But devfreq->governor may be NULL and directly using devfreq->governor->name may cause null pointer exception. Move the check of governor to before using governor->name.",,"[{""url"":""https://git.kernel.org/stable/c/2731c68f536fddcb71332db7f8d78c5eb4684c04"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/631e101728df2a86b8fb761b49fad9712c651f8a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/75323a49aa603cf5484a6d74d0d329e86d756e11"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/81f50619370045120c133bfdda5b320c8c97d41e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bab7834c03820eb11269bc48f07c3800192460d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d5632359dbc44862fc1ed04093c1f57529830261"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f0479e878d4beb45e73c03e574c59f0a23ccd176"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38610,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:39.490,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: powercap: dtpm_cpu: Fix NULL pointer dereference in get_pd_power_uw() The get_pd_power_uw() function can crash with a NULL pointer dereference when em_cpu_get() returns NULL. This occurs when a CPU becomes impossible during runtime, causing get_cpu_device() to return NULL, which propagates through em_cpu_get() and leads to a crash when em_span_cpus() dereferences the NULL pointer. Add a NULL check after em_cpu_get() and return 0 if unavailable, matching the existing fallback behavior in __dtpm_cpu_setup(). [ rjw: Drop an excess empty code line ]",,"[{""url"":""https://git.kernel.org/stable/c/27914f2b795e2b58e9506f281dcdd98fef09d3c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/27e0318f0ea69fcfa32228847debc384ade14578"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2fd001a0075ac01dc64a28a8e21226b3d989a91d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/46dc57406887dd02565cb264224194a6776d882b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8374ac7d69a57d737e701a851ffe980a0d27d3ad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c6ec27091cf5ac05094c1fe3a6ce914cf711a37c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38611,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:39.633,2025-09-05T20:15:34.917,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,[],,,,,,,,,,
CVE-2025-38612,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:39.777,2025-08-28T15:15:55.497,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: staging: fbtft: fix potential memory leak in fbtft_framebuffer_alloc() In the error paths after fb_info structure is successfully allocated, the memory allocated in fb_deferred_io_init() for info->pagerefs is not freed. Fix that by adding the cleanup function on the error path.",,"[{""url"":""https://git.kernel.org/stable/c/3290f62f23fae05f2ec34085eb86dfb3648ef91f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/47b3d6e8921bbb7b65c2dab8eaa8864901848c1c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6771f121ae87490ddc19eabb7450383af9e01b6d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6f9e2cf9e9c1a891a683329af35bb33ed9d38b5f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/83ea0c7b8d12c67f6c4703d6c458627a7fc45fc0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a3177955f8da3c826a18b75e54881e2e9a9c96f1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b31cf6f7716a5d3e4461763f32d812acdaec6e74"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c3b1c45c48117ed4d8797ee89d1155f16b72d490"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb2cb7dab60f9be0b435ac4a674255429a36d72c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38613,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:39.913,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: staging: gpib: fix unset padding field copy back to userspace The introduction of a padding field in the gpib_board_info_ioctl is showing up as initialized data on the stack frame being copyied back to userspace in function board_info_ioctl. The simplest fix is to initialize the entire struct to zero to ensure all unassigned padding fields are zero'd before being copied back to userspace.",,"[{""url"":""https://git.kernel.org/stable/c/19dedd4f70f5a6505e7c601ef7dd40542d1d9aa5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a739d3b13bff0dfa1aec679d08c7062131a2a425"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38614,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:40.040,2025-08-28T15:15:55.647,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: eventpoll: Fix semi-unbounded recursion Ensure that epoll instances can never form a graph deeper than EP_MAX_NESTS+1 links. Currently, ep_loop_check_proc() ensures that the graph is loop-free and does some recursion depth checks, but those recursion depth checks don't limit the depth of the resulting tree for two reasons: - They don't look upwards in the tree. - If there are multiple downwards paths of different lengths, only one of the paths is actually considered for the depth check since commit 28d82dc1c4ed (""epoll: limit paths""). Essentially, the current recursion depth check in ep_loop_check_proc() just serves to prevent it from recursing too deeply while checking for loops. A more thorough check is done in reverse_path_check() after the new graph edge has already been created; this checks, among other things, that no paths going upwards from any non-epoll file with a length of more than 5 edges exist. However, this check does not apply to non-epoll files. As a result, it is possible to recurse to a depth of at least roughly 500, tested on v6.15. (I am unsure if deeper recursion is possible; and this may have changed with commit 8c44dac8add7 (""eventpoll: Fix priority inversion problem"").) To fix it: 1. In ep_loop_check_proc(), note the subtree depth of each visited node, and use subtree depths for the total depth calculation even when a subtree has already been visited. 2. Add ep_get_upwards_depth_proc() for similarly determining the maximum depth of an upwards walk. 3. In ep_loop_check(), use these values to limit the total path length between epoll nodes to EP_MAX_NESTS edges.",,"[{""url"":""https://git.kernel.org/stable/c/1b13b033062824495554e836a1ff5f85ccf6b039"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2a0c0c974bea9619c6f41794775ae4b97530e0e6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3542c90797bc3ab83ebab54b737d751cf3682036"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/71379495ab70eaba19224bd71b5b9b399eb85e04"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7a2125962c42d5336ca0495a9ce4cb38a63e9161"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ea5f97dbdcb1651581a22bd10afd2f0dd9dc11d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f2e467a48287c868818085aa35389a224d226732"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38615,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-19T17:15:40.177,2025-08-20T14:40:17.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: cancle set bad inode after removing name fails The reproducer uses a file0 on a ntfs3 file system with a corrupted i_link. When renaming, the file0's inode is marked as a bad inode because the file name cannot be deleted. The underlying bug is that make_bad_inode() is called on a live inode. In some cases it's ""icache lookup finds a normal inode, d_splice_alias() is called to attach it to dentry, while another thread decides to call make_bad_inode() on it - that would evict it from icache, but we'd already found it there earlier"". In some it's outright ""we have an inode attached to dentry - that's how we got it in the first place; let's call make_bad_inode() on it just for shits and giggles"".",,"[{""url"":""https://git.kernel.org/stable/c/358d4f821c03add421a4c49290538a705852ccf1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ed2cc6a6e93fbeb8c0cafce1e7fb1f64a331dcc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a285395020780adac1ffbc844069c3d700bf007a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b35a50d639ca5259466ef5fea85529bb4fb17d5b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d99208b91933fd2a58ed9ed321af07dacd06ddc3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38616,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T14:15:46.017,2025-08-28T15:15:55.793,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tls: handle data disappearing from under the TLS ULP TLS expects that it owns the receive queue of the TCP socket. This cannot be guaranteed in case the reader of the TCP socket entered before the TLS ULP was installed, or uses some non-standard read API (eg. zerocopy ones). Replace the WARN_ON() and a buggy early exit (which leaves anchor pointing to a freed skb) with real error handling. Wipe the parsing state and tell the reader to retry. We already reload the anchor every time we (re)acquire the socket lock, so the only condition we need to avoid is an out of bounds read (not having enough bytes in the socket for previously parsed record len). If some data was read from under TLS but there's enough in the queue we'll reload and decrypt what is most likely not a valid TLS record. Leading to some undefined behavior from TLS perspective (corrupting a stream? missing an alert? missing an attack?) but no kernel crash should take place.",,"[{""url"":""https://git.kernel.org/stable/c/2fb97ed9e2672b4f6e24ce206ac1a875ce4bcb38"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6db015fc4b5d5f63a64a193f65d98da3a7fc811d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/db3658a12d5ec4db7185ae7476151a50521b7207"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb0336f213fe88bbdb7d2b19c9c9ec19245a3155"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1fe99919f629f980d0b8a7ff16950bffe06a859"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38617,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T14:15:46.160,2025-08-28T15:15:55.930,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/packet: fix a race in packet_set_ring() and packet_notifier() When packet_set_ring() releases po->bind_lock, another thread can run packet_notifier() and process an NETDEV_UP event. This race and the fix are both similar to that of commit 15fe076edea7 (""net/packet: fix a race in packet_bind() and packet_notifier()""). There too the packet_notifier NETDEV_UP event managed to run while a po->bind_lock critical section had to be temporarily released. And the fix was similarly to temporarily set po->num to zero to keep the socket unhooked until the lock is retaken. The po->bind_lock in packet_set_ring and packet_notifier precede the introduction of git history.",,"[{""url"":""https://git.kernel.org/stable/c/01d3c8417b9c1b884a8a981a3b886da556512f36"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/18f13f2a83eb81be349a9757ba2141ff1da9ad73"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7da733f117533e9b2ebbd530a22ae4028713955c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7de07705007c7e34995a5599aaab1d23e762d7ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/88caf46db8239e6471413d28aabaa6b8bd552805"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba2257034755ae773722f15f4c3ad1dcdad15ca9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e50ccfaca9e3c671cae917dcb994831a859cf588"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1791fd7b845bea0ce9674fcf2febee7bc87a893"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f2e8fcfd2b1bc754920108b7f2cd75082c5a18df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38618,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T14:15:46.303,2025-08-28T15:15:56.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: vsock: Do not allow binding to VMADDR_PORT_ANY It is possible for a vsock to autobind to VMADDR_PORT_ANY. This can cause a use-after-free when a connection is made to the bound socket. The socket returned by accept() also has port VMADDR_PORT_ANY but is not on the list of unbound sockets. Binding it will result in an extra refcount decrement similar to the one fixed in fcdd2242c023 (vsock: Keep the binding until socket destruction). Modify the check in __vsock_bind_connectible() to also prevent binding to VMADDR_PORT_ANY.",,"[{""url"":""https://git.kernel.org/stable/c/32950b1907919be86a7a2697d6f93d57068b3865"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/44bd006d5c93f6a8f28b106cbae2428c5d0275b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8f01093646b49f6330bb2d36761983fd829472b1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aba0c94f61ec05315fa7815d21aefa4c87f6a9f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c04a2c1ca25b9b23104124d3b2d349d934e302de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cf86704798c1b9c46fa59dfc2d662f57d1394d79"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d1a5b1964cef42727668ac0d8532dae4f8c19386"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d73960f0cf03ef1dc9e96ec7a20e538accc26d87"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f138be5d7f301fddad4e65ec66dfc3ceebf79be3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38619,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:35.177,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: ti: j721e-csi2rx: fix list_del corruption If ti_csi2rx_start_dma() fails in ti_csi2rx_dma_callback(), the buffer is marked done with VB2_BUF_STATE_ERROR but is not removed from the DMA queue. This causes the same buffer to be retried in the next iteration, resulting in a double list_del() and eventual list corruption. Fix this by removing the buffer from the queue before calling vb2_buffer_done() on error. This resolves a crash due to list_del corruption: [ 37.811243] j721e-csi2rx 30102000.ticsi2rx: Failed to queue the next buffer for DMA [ 37.832187] slab kmalloc-2k start ffff00000255b000 pointer offset 1064 size 2048 [ 37.839761] list_del corruption. next->prev should be ffff00000255bc28, but was ffff00000255d428. (next=ffff00000255b428) [ 37.850799] ------------[ cut here ]------------ [ 37.855424] kernel BUG at lib/list_debug.c:65! [ 37.859876] Internal error: Oops - BUG: 00000000f2000800 [#1] SMP [ 37.866061] Modules linked in: i2c_dev usb_f_rndis u_ether libcomposite dwc3 udc_core usb_common aes_ce_blk aes_ce_cipher ghash_ce gf128mul sha1_ce cpufreq_dt dwc3_am62 phy_gmii_sel sa2ul [ 37.882830] CPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.16.0-rc3+ #28 VOLUNTARY [ 37.890851] Hardware name: Bosch STLA-GSRV2-B0 (DT) [ 37.895737] pstate: 600000c5 (nZCv daIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 37.902703] pc : __list_del_entry_valid_or_report+0xdc/0x114 [ 37.908390] lr : __list_del_entry_valid_or_report+0xdc/0x114 [ 37.914059] sp : ffff800080003db0 [ 37.917375] x29: ffff800080003db0 x28: 0000000000000007 x27: ffff800080e50000 [ 37.924521] x26: 0000000000000000 x25: ffff0000016abb50 x24: dead000000000122 [ 37.931666] x23: ffff0000016abb78 x22: ffff0000016ab080 x21: ffff800080003de0 [ 37.938810] x20: ffff00000255bc00 x19: ffff00000255b800 x18: 000000000000000a [ 37.945956] x17: 20747562202c3832 x16: 6362353532303030 x15: 0720072007200720 [ 37.953101] x14: 0720072007200720 x13: 0720072007200720 x12: 00000000ffffffea [ 37.960248] x11: ffff800080003b18 x10: 00000000ffffefff x9 : ffff800080f5b568 [ 37.967396] x8 : ffff800080f5b5c0 x7 : 0000000000017fe8 x6 : c0000000ffffefff [ 37.974542] x5 : ffff00000fea6688 x4 : 0000000000000000 x3 : 0000000000000000 [ 37.981686] x2 : 0000000000000000 x1 : ffff800080ef2b40 x0 : 000000000000006d [ 37.988832] Call trace: [ 37.991281] __list_del_entry_valid_or_report+0xdc/0x114 (P) [ 37.996959] ti_csi2rx_dma_callback+0x84/0x1c4 [ 38.001419] udma_vchan_complete+0x1e0/0x344 [ 38.005705] tasklet_action_common+0x118/0x310 [ 38.010163] tasklet_action+0x30/0x3c [ 38.013832] handle_softirqs+0x10c/0x2e0 [ 38.017761] __do_softirq+0x14/0x20 [ 38.021256] ____do_softirq+0x10/0x20 [ 38.024931] call_on_irq_stack+0x24/0x60 [ 38.028873] do_softirq_own_stack+0x1c/0x40 [ 38.033064] __irq_exit_rcu+0x130/0x15c [ 38.036909] irq_exit_rcu+0x10/0x20 [ 38.040403] el1_interrupt+0x38/0x60 [ 38.043987] el1h_64_irq_handler+0x18/0x24 [ 38.048091] el1h_64_irq+0x6c/0x70 [ 38.051501] default_idle_call+0x34/0xe0 (P) [ 38.055783] do_idle+0x1f8/0x250 [ 38.059021] cpu_startup_entry+0x34/0x3c [ 38.062951] rest_init+0xb4/0xc0 [ 38.066186] console_on_rootfs+0x0/0x6c [ 38.070031] __primary_switched+0x88/0x90 [ 38.074059] Code: b00037e0 91378000 f9400462 97e9bf49 (d4210000) [ 38.080168] ---[ end trace 0000000000000000 ]--- [ 38.084795] Kernel panic - not syncing: Oops - BUG: Fatal exception in interrupt [ 38.092197] SMP: stopping secondary CPUs [ 38.096139] Kernel Offset: disabled [ 38.099631] CPU features: 0x0000,00002000,02000801,0400420b [ 38.105202] Memory Limit: none [ 38.108260] ---[ end Kernel panic - not syncing: Oops - BUG: Fatal exception in interrupt ]---",,"[{""url"":""https://git.kernel.org/stable/c/68e5579f4de12207b23c41b44a4c0778b6c2858f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/92d0188f36ca8082af7989d743eb5b44c2d259f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a4a8cb0889927d59ebd839458c8f038bc5298ef9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ae42c6fe531425ef2f47e82f96851427d24bbf6b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38620,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:35.320,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: zloop: fix KASAN use-after-free of tag set When a zoned loop device, or zloop device, is removed, KASAN enabled kernel reports ""BUG KASAN use-after-free"" in blk_mq_free_tag_set(). The BUG happens because zloop_ctl_remove() calls put_disk(), which invokes zloop_free_disk(). The zloop_free_disk() frees the memory allocated for the zlo pointer. However, after the memory is freed, zloop_ctl_remove() calls blk_mq_free_tag_set(&zlo->tag_set), which accesses the freed zlo. Hence the KASAN use-after-free. zloop_ctl_remove() put_disk(zlo->disk) put_device() kobject_put() ... zloop_free_disk() kvfree(zlo) blk_mq_free_tag_set(&zlo->tag_set) To avoid the BUG, move the call to blk_mq_free_tag_set(&zlo->tag_set) from zloop_ctl_remove() into zloop_free_disk(). This ensures that the tag_set is freed before the call to kvfree(zlo).",,"[{""url"":""https://git.kernel.org/stable/c/765761851d89c772f482494d452e266795460278"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c7c87046b41a9ef28ee7ac476c369da5b5228bc5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38621,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:35.460,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: md: make rdev_addable usable for rcu mode Our testcase trigger panic: BUG: kernel NULL pointer dereference, address: 00000000000000e0 ... Oops: Oops: 0000 [#1] SMP NOPTI CPU: 2 UID: 0 PID: 85 Comm: kworker/2:1 Not tainted 6.16.0+ #94 PREEMPT(none) Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.1-2.fc37 04/01/2014 Workqueue: md_misc md_start_sync RIP: 0010:rdev_addable+0x4d/0xf0 ... Call Trace: <TASK> md_start_sync+0x329/0x480 process_one_work+0x226/0x6d0 worker_thread+0x19e/0x340 kthread+0x10f/0x250 ret_from_fork+0x14d/0x180 ret_from_fork_asm+0x1a/0x30 </TASK> Modules linked in: raid10 CR2: 00000000000000e0 ---[ end trace 0000000000000000 ]--- RIP: 0010:rdev_addable+0x4d/0xf0 md_spares_need_change in md_start_sync will call rdev_addable which protected by rcu_read_lock/rcu_read_unlock. This rcu context will help protect rdev won't be released, but rdev->mddev will be set to NULL before we call synchronize_rcu in md_kick_rdev_from_array. Fix this by using READ_ONCE and check does rdev->mddev still alive.",,"[{""url"":""https://git.kernel.org/stable/c/13017b427118f4311471ee47df74872372ca8482"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b5fbe940862339cdcc34dea7a057ad18d18fa137"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38622,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:35.603,2025-08-28T15:15:56.197,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: drop UFO packets in udp_rcv_segment() When sending a packet with virtio_net_hdr to tun device, if the gso_type in virtio_net_hdr is SKB_GSO_UDP and the gso_size is less than udphdr size, below crash may happen. ------------[ cut here ]------------ kernel BUG at net/core/skbuff.c:4572! Oops: invalid opcode: 0000 [#1] SMP NOPTI CPU: 0 UID: 0 PID: 62 Comm: mytest Not tainted 6.16.0-rc7 #203 PREEMPT(voluntary) Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 RIP: 0010:skb_pull_rcsum+0x8e/0xa0 Code: 00 00 5b c3 cc cc cc cc 8b 93 88 00 00 00 f7 da e8 37 44 38 00 f7 d8 89 83 88 00 00 00 48 8b 83 c8 00 00 00 5b c3 cc cc cc cc <0f> 0b 0f 0b 66 66 2e 0f 1f 84 00 000 RSP: 0018:ffffc900001fba38 EFLAGS: 00000297 RAX: 0000000000000004 RBX: ffff8880040c1000 RCX: ffffc900001fb948 RDX: ffff888003e6d700 RSI: 0000000000000008 RDI: ffff88800411a062 RBP: ffff8880040c1000 R08: 0000000000000000 R09: 0000000000000001 R10: ffff888003606c00 R11: 0000000000000001 R12: 0000000000000000 R13: ffff888004060900 R14: ffff888004050000 R15: ffff888004060900 FS: 000000002406d3c0(0000) GS:ffff888084a19000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000020000040 CR3: 0000000004007000 CR4: 00000000000006f0 Call Trace: <TASK> udp_queue_rcv_one_skb+0x176/0x4b0 net/ipv4/udp.c:2445 udp_queue_rcv_skb+0x155/0x1f0 net/ipv4/udp.c:2475 udp_unicast_rcv_skb+0x71/0x90 net/ipv4/udp.c:2626 __udp4_lib_rcv+0x433/0xb00 net/ipv4/udp.c:2690 ip_protocol_deliver_rcu+0xa6/0x160 net/ipv4/ip_input.c:205 ip_local_deliver_finish+0x72/0x90 net/ipv4/ip_input.c:233 ip_sublist_rcv_finish+0x5f/0x70 net/ipv4/ip_input.c:579 ip_sublist_rcv+0x122/0x1b0 net/ipv4/ip_input.c:636 ip_list_rcv+0xf7/0x130 net/ipv4/ip_input.c:670 __netif_receive_skb_list_core+0x21d/0x240 net/core/dev.c:6067 netif_receive_skb_list_internal+0x186/0x2b0 net/core/dev.c:6210 napi_complete_done+0x78/0x180 net/core/dev.c:6580 tun_get_user+0xa63/0x1120 drivers/net/tun.c:1909 tun_chr_write_iter+0x65/0xb0 drivers/net/tun.c:1984 vfs_write+0x300/0x420 fs/read_write.c:593 ksys_write+0x60/0xd0 fs/read_write.c:686 do_syscall_64+0x50/0x1c0 arch/x86/entry/syscall_64.c:63 </TASK> To trigger gso segment in udp_queue_rcv_skb(), we should also set option UDP_ENCAP_ESPINUDP to enable udp_sk(sk)->encap_rcv. When the encap_rcv hook return 1 in udp_queue_rcv_one_skb(), udp_csum_pull_header() will try to pull udphdr, but the skb size has been segmented to gso size, which leads to this crash. Previous commit cf329aa42b66 (""udp: cope with UDP GRO packet misdirection"") introduces segmentation in UDP receive path only for GRO, which was never intended to be used for UFO, so drop UFO packets in udp_rcv_segment().",,"[{""url"":""https://git.kernel.org/stable/c/0c639c6479ec4480372901a5fc566f7588cf5522"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0d45954034f8edd6d4052e0190d3d6335c37e4de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c1022220b1b6fea802175e80444923a3bbf93a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/72f97d3cb791e26492236b2be7fd70d2c6222555"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/791f32c5eab33ca3a153f8f6f763aa0df1ddc320"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c0ec2e47f1e92d69b42b17a4a1e543256778393e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d46e51f1c78b9ab9323610feb14238d06d46d519"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/df6ad849d59256dcc0e2234844ef9f0daf885f5c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc45b3f9599b657d4a64bcf423d2a977b3e13a49"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38623,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:35.760,2025-08-28T15:15:56.320,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: PCI: pnv_php: Fix surprise plug detection and recovery The existing PowerNV hotplug code did not handle surprise plug events correctly, leading to a complete failure of the hotplug system after device removal and a required reboot to detect new devices. This comes down to two issues: 1) When a device is surprise removed, often the bridge upstream port will cause a PE freeze on the PHB. If this freeze is not cleared, the MSI interrupts from the bridge hotplug notification logic will not be received by the kernel, stalling all plug events on all slots associated with the PE. 2) When a device is removed from a slot, regardless of surprise or programmatic removal, the associated PHB/PE ls left frozen. If this freeze is not cleared via a fundamental reset, skiboot is unable to clear the freeze and cannot retrain / rescan the slot. This also requires a reboot to clear the freeze and redetect the device in the slot. Issue the appropriate unfreeze and rescan commands on hotplug events, and don't oops on hotplug if pci_bus_to_OF_node() returns NULL. [bhelgaas: tidy comments]",,"[{""url"":""https://git.kernel.org/stable/c/1d2f63680c5719a5da92639e981c6c9a87fcee08"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2ec8ec57bb8ebde3e2a015eff80e5d66e6634fe3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/473999ba937eac9776be791deed7c84a21d7880b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/48c6935a34981bb56f35be0774ec1f30c6e386f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6e7b24c71e530a6c1d656e73d8a30ee081656844"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6e7b5f922901585b8f11e0d6cda12bda5c59fc8a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/78d20b8c13075eae3d884c21db7a09a6bbdda5b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a2a2a6fc2469524caa713036297c542746d148dc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38624,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:35.910,2025-08-28T15:15:56.450,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: PCI: pnv_php: Clean up allocated IRQs on unplug When the root of a nested PCIe bridge configuration is unplugged, the pnv_php driver leaked the allocated IRQ resources for the child bridges' hotplug event notifications, resulting in a panic. Fix this by walking all child buses and deallocating all its IRQ resources before calling pci_hp_remove_devices(). Also modify the lifetime of the workqueue at struct pnv_php_slot::wq so that it is only destroyed in pnv_php_free_slot(), instead of pnv_php_disable_irq(). This is required since pnv_php_disable_irq() will now be called by workers triggered by hot unplug interrupts, so the workqueue needs to stay allocated. The abridged kernel panic that occurs without this patch is as follows: WARNING: CPU: 0 PID: 687 at kernel/irq/msi.c:292 msi_device_data_release+0x6c/0x9c CPU: 0 UID: 0 PID: 687 Comm: bash Not tainted 6.14.0-rc5+ #2 Call Trace: msi_device_data_release+0x34/0x9c (unreliable) release_nodes+0x64/0x13c devres_release_all+0xc0/0x140 device_del+0x2d4/0x46c pci_destroy_dev+0x5c/0x194 pci_hp_remove_devices+0x90/0x128 pci_hp_remove_devices+0x44/0x128 pnv_php_disable_slot+0x54/0xd4 power_write_file+0xf8/0x18c pci_slot_attr_store+0x40/0x5c sysfs_kf_write+0x64/0x78 kernfs_fop_write_iter+0x1b0/0x290 vfs_write+0x3bc/0x50c ksys_write+0x84/0x140 system_call_exception+0x124/0x230 system_call_vectored_common+0x15c/0x2ec [bhelgaas: tidy comments]",,"[{""url"":""https://git.kernel.org/stable/c/1773c19fa55e944cdd2634e2d9e552f87f2d38d5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/28aa3cfce12487614219e7667ec84424e1f43227"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/32173edf3fe2d447e14e5e3b299387c6f9602a88"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/398170b7fd0e0db2f8096df5206c75e5ff41415a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4668619092554e1b95c9a5ac2941ca47ba6d548a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c1ad4af160691e157d688ad9619ced2df556aac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/912e200240b6f9758f0b126e64a61c9227f4ad37"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bbd302c4b79df10197ffa7270ca3aa572eeca33c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38625,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:36.057,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: vfio/pds: Fix missing detach_ioas op When CONFIG_IOMMUFD is enabled and a device is bound to the pds_vfio_pci driver, the following WARN_ON() trace is seen and probe fails: WARNING: CPU: 0 PID: 5040 at drivers/vfio/vfio_main.c:317 __vfio_register_dev+0x130/0x140 [vfio] <...> pds_vfio_pci 0000:08:00.1: probe with driver pds_vfio_pci failed with error -22 This is because the driver's vfio_device_ops.detach_ioas isn't set. Fix this by using the generic vfio_iommufd_physical_detach_ioas function.",,"[{""url"":""https://git.kernel.org/stable/c/1df8150ab4cc422bddfbd312d6758c50b688a971"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7dbfae90c5a33f6b694e7068bc9522cc2655373d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/88b962fbd0ac30a65d2869c68d2f145be46ebe4d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b265dff9fcf047f660976a5c92c83e7c414a2d95"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe24d5bc635e103a517ec201c3cb571eeab8be2f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38626,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:36.193,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to trigger foreground gc during f2fs_map_blocks() in lfs mode w/ ""mode=lfs"" mount option, generic/299 will cause system panic as below: ------------[ cut here ]------------ kernel BUG at fs/f2fs/segment.c:2835! Call Trace: <TASK> f2fs_allocate_data_block+0x6f4/0xc50 f2fs_map_blocks+0x970/0x1550 f2fs_iomap_begin+0xb2/0x1e0 iomap_iter+0x1d6/0x430 __iomap_dio_rw+0x208/0x9a0 f2fs_file_write_iter+0x6b3/0xfa0 aio_write+0x15d/0x2e0 io_submit_one+0x55e/0xab0 __x64_sys_io_submit+0xa5/0x230 do_syscall_64+0x84/0x2f0 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0010:new_curseg+0x70f/0x720 The root cause of we run out-of-space is: in f2fs_map_blocks(), f2fs may trigger foreground gc only if it allocates any physical block, it will be a little bit later when there is multiple threads writing data w/ aio/dio/bufio method in parallel, since we always use OPU in lfs mode, so f2fs_map_blocks() does block allocations aggressively. In order to fix this issue, let's give a chance to trigger foreground gc in prior to block allocation in f2fs_map_blocks().",,"[{""url"":""https://git.kernel.org/stable/c/1005a3ca28e90c7a64fa43023f866b960a60f791"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/264ede8a52f18647ed5bb5f2bd9bf54f556ad8f5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/385e64a0744584397b4b52b27c96703516f39968"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/82765ce5c7a56f9309ee45328e763610eaf11253"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f289690f50a01c3e085d87853392d5b7436a4cee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38627,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:36.337,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: f2fs: compress: fix UAF of f2fs_inode_info in f2fs_free_dic The decompress_io_ctx may be released asynchronously after I/O completion. If this file is deleted immediately after read, and the kworker of processing post_read_wq has not been executed yet due to high workloads, It is possible that the inode(f2fs_inode_info) is evicted and freed before it is used f2fs_free_dic. The UAF case as below: Thread A Thread B - f2fs_decompress_end_io - f2fs_put_dic - queue_work add free_dic work to post_read_wq - do_unlink - iput - evict - call_rcu This file is deleted after read. Thread C kworker to process post_read_wq - rcu_do_batch - f2fs_free_inode - kmem_cache_free inode is freed by rcu - process_scheduled_works - f2fs_late_free_dic - f2fs_free_dic - f2fs_release_decomp_mem read (dic->inode)->i_compress_algorithm This patch store compress_algorithm and sbi in dic to avoid inode UAF. In addition, the previous solution is deprecated in [1] may cause system hang. [1] https://lore.kernel.org/all/c36ab955-c8db-4a8b-a9d0-f07b5f426c3f@kernel.org",,"[{""url"":""https://git.kernel.org/stable/c/39868685c2a94a70762bc6d77dc81d781d05bff5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8fae5b6addd5f6895e03797b56e3c7b9f9cd15c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38628,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:36.470,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: vdpa/mlx5: Fix release of uninitialized resources on error path The commit in the fixes tag made sure that mlx5_vdpa_free() is the single entrypoint for removing the vdpa device resources added in mlx5_vdpa_dev_add(), even in the cleanup path of mlx5_vdpa_dev_add(). This means that all functions from mlx5_vdpa_free() should be able to handle uninitialized resources. This was not the case though: mlx5_vdpa_destroy_mr_resources() and mlx5_cmd_cleanup_async_ctx() were not able to do so. This caused the splat below when adding a vdpa device without a MAC address. This patch fixes these remaining issues: - Makes mlx5_vdpa_destroy_mr_resources() return early if called on uninitialized resources. - Moves mlx5_cmd_init_async_ctx() early on during device addition because it can't fail. This means that mlx5_cmd_cleanup_async_ctx() also can't fail. To mirror this, move the call site of mlx5_cmd_cleanup_async_ctx() in mlx5_vdpa_free(). An additional comment was added in mlx5_vdpa_free() to document the expectations of functions called from this context. Splat: mlx5_core 0000:b5:03.2: mlx5_vdpa_dev_add:3950:(pid 2306) warning: No mac address provisioned? ------------[ cut here ]------------ WARNING: CPU: 13 PID: 2306 at kernel/workqueue.c:4207 __flush_work+0x9a/0xb0 [...] Call Trace: <TASK> ? __try_to_del_timer_sync+0x61/0x90 ? __timer_delete_sync+0x2b/0x40 mlx5_vdpa_destroy_mr_resources+0x1c/0x40 [mlx5_vdpa] mlx5_vdpa_free+0x45/0x160 [mlx5_vdpa] vdpa_release_dev+0x1e/0x50 [vdpa] device_release+0x31/0x90 kobject_cleanup+0x37/0x130 mlx5_vdpa_dev_add+0x327/0x890 [mlx5_vdpa] vdpa_nl_cmd_dev_add_set_doit+0x2c1/0x4d0 [vdpa] genl_family_rcv_msg_doit+0xd8/0x130 genl_family_rcv_msg+0x14b/0x220 ? __pfx_vdpa_nl_cmd_dev_add_set_doit+0x10/0x10 [vdpa] genl_rcv_msg+0x47/0xa0 ? __pfx_genl_rcv_msg+0x10/0x10 netlink_rcv_skb+0x53/0x100 genl_rcv+0x24/0x40 netlink_unicast+0x27b/0x3b0 netlink_sendmsg+0x1f7/0x430 __sys_sendto+0x1fa/0x210 ? ___pte_offset_map+0x17/0x160 ? next_uptodate_folio+0x85/0x2b0 ? percpu_counter_add_batch+0x51/0x90 ? filemap_map_pages+0x515/0x660 __x64_sys_sendto+0x20/0x30 do_syscall_64+0x7b/0x2c0 ? do_read_fault+0x108/0x220 ? do_pte_missing+0x14a/0x3e0 ? __handle_mm_fault+0x321/0x730 ? count_memcg_events+0x13f/0x180 ? handle_mm_fault+0x1fb/0x2d0 ? do_user_addr_fault+0x20c/0x700 ? syscall_exit_work+0x104/0x140 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7f0c25b0feca [...] ---[ end trace 0000000000000000 ]---",,"[{""url"":""https://git.kernel.org/stable/c/37f26b9013b46457b0a96633fc3a7dc977d8beb1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6de4ef950dd56a6a81daf92d8a1d864fc6a56971"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc51a66815999afb7e9cd845968de4fdf07567b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cf4fc23d0d3d5b89b36f0d79f2674510bb574d8e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38629,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:36.620,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ALSA: usb: scarlett2: Fix missing NULL check scarlett2_input_select_ctl_info() sets up the string arrays allocated via kasprintf(), but it misses NULL checks, which may lead to NULL dereference Oops. Let's add the proper NULL check.",,"[{""url"":""https://git.kernel.org/stable/c/2c735fcaee81ad8056960659dc9dc460891e76b0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d558db85920b124bac36f8a7ddc5de0aa7491bdd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/df485a4b2b3ee5b35c80f990beb554e38a8a5fb1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38630,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:36.750,2025-08-28T15:15:56.580,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fbdev: imxfb: Check fb_add_videomode to prevent null-ptr-deref fb_add_videomode() can fail with -ENOMEM when its internal kmalloc() cannot allocate a struct fb_modelist. If that happens, the modelist stays empty but the driver continues to register. Add a check for its return value to prevent poteintial null-ptr-deref, which is similar to the commit 17186f1f90d3 (""fbdev: Fix do_register_framebuffer to prevent null-ptr-deref in fb_videomode_to_var"").",,"[{""url"":""https://git.kernel.org/stable/c/40f0a51f6c54d46a94b9f1180339ede7ca7ee190"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/49377bac9e3bec1635065a033c9679214fe7593e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4b5d36cc3014986e6fac12eaa8433fe56801d4ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/69373502c2b5d364842c702c941d1171e4f35a7c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac16154cccda8be10ee3ae188f10a06f3890bc5d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cca8f5a3991916729b39d797d01499c335137319"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da11e6a30e0bb8e911288bdc443b3dc8f6a7cac7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f00c29e6755ead56baf2a9c1d3c4c0bb40af3612"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f060441c153495750804133555cf0a211a856892"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38631,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:36.893,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: clk: imx95-blk-ctl: Fix synchronous abort When enabling runtime PM for clock suppliers that also belong to a power domain, the following crash is thrown: error: synchronous external abort: 0000000096000010 [#1] PREEMPT SMP Workqueue: events_unbound deferred_probe_work_func pstate: 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : clk_mux_get_parent+0x60/0x90 lr : clk_core_reparent_orphans_nolock+0x58/0xd8 Call trace: clk_mux_get_parent+0x60/0x90 clk_core_reparent_orphans_nolock+0x58/0xd8 of_clk_add_hw_provider.part.0+0x90/0x100 of_clk_add_hw_provider+0x1c/0x38 imx95_bc_probe+0x2e0/0x3f0 platform_probe+0x70/0xd8 Enabling runtime PM without explicitly resuming the device caused the power domain cut off after clk_register() is called. As a result, a crash happens when the clock hardware provider is added and attempts to access the BLK_CTL register. Fix this by using devm_pm_runtime_enable() instead of pm_runtime_enable() and getting rid of the pm_runtime_disable() in the cleanup path.",,"[{""url"":""https://git.kernel.org/stable/c/533dc3cb375cabd8a2beba293d63ef2acd3d0005"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9f0ee0baf25b46bb82655c687718ebb0ae1def7b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b08217a257215ed9130fce93d35feba66b49bf0a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c1dead8bb303f86905ea6a09e5acda931165453b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38632,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:37.033,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: pinmux: fix race causing mux_owner NULL with active mux_usecount commit 5a3e85c3c397 (""pinmux: Use sequential access to access desc->pinmux data"") tried to address the issue when two client of the same gpio calls pinctrl_select_state() for the same functionality, was resulting in NULL pointer issue while accessing desc->mux_owner. However, issue was not completely fixed due to the way it was handled and it can still result in the same NULL pointer. The issue occurs due to the following interleaving: cpu0 (process A) cpu1 (process B) pin_request() { pin_free() { mutex_lock() desc->mux_usecount--; //becomes 0 .. mutex_unlock() mutex_lock(desc->mux) desc->mux_usecount++; // becomes 1 desc->mux_owner = owner; mutex_unlock(desc->mux) mutex_lock(desc->mux) desc->mux_owner = NULL; mutex_unlock(desc->mux) This sequence leads to a state where the pin appears to be in use (`mux_usecount == 1`) but has no owner (`mux_owner == NULL`), which can cause NULL pointer on next pin_request on the same pin. Ensure that updates to mux_usecount and mux_owner are performed atomically under the same lock. Only clear mux_owner when mux_usecount reaches zero and no new owner has been assigned.",,"[{""url"":""https://git.kernel.org/stable/c/0b075c011032f88d1cfde3b45d6dcf08b44140eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/22b585cbd67d14df3b91529d1b990661c300faa9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9b2a3e7189028aa7c4d53a84364f2ea9fb209787"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ea3f6b9a67be3476e331ce51cac316c2614a564"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b7bd6e3971eb7f0e34d2fdce1b18b08094e0c804"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38633,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:37.173,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: clk: spacemit: mark K1 pll1_d8 as critical The pll1_d8 clock is enabled by the boot loader, and is ultimately a parent for numerous clocks, including those used by APB and AXI buses. Guodong Xu discovered that this clock got disabled while responding to getting -EPROBE_DEFER when requesting a reset controller. The needed clock (CLK_DMA, along with its parents) had already been enabled. To respond to the probe deferral return, the CLK_DMA clock was disabled, and this led to parent clocks also reducing their enable count. When the enable count for pll1_d8 was decremented it became 0, which caused it to be disabled. This led to a system hang. Marking that clock critical resolves this by preventing it from being disabled. Define a new macro CCU_FACTOR_GATE_DEFINE() to allow clock flags to be supplied for a CCU_FACTOR_GATE clock.",,"[{""url"":""https://git.kernel.org/stable/c/10948c00e548e9ad2ce9d765baf26dce2d9b806b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7554729de27daf6d54bcf8689d863bbe267828bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38634,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:37.307,2025-08-28T15:15:56.707,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: power: supply: cpcap-charger: Fix null check for power_supply_get_by_name In the cpcap_usb_detect() function, the power_supply_get_by_name() function may return `NULL` instead of an error pointer. To prevent potential null pointer dereferences, Added a null check.",,"[{""url"":""https://git.kernel.org/stable/c/27001e4f146624c4b3389b029bdc0f8049819560"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4ebbb9106aaa2fd58e0359bc3a2490953db2ef0c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e9bdb563916287ba1b4258812434e0585ac6d00"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9784d832d7c103539cd9afb376534eaa35815d3d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a2436263144980cc99a9860c7b43335847afbe53"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d9fa3aae08f99493e67fb79413c0e95d30fca5e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f642500aa7ed93d2606e4f929244cce9c7467b3a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38635,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:37.450,2025-08-28T15:15:56.843,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: clk: davinci: Add NULL check in davinci_lpsc_clk_register() devm_kasprintf() returns NULL when memory allocation fails. Currently, davinci_lpsc_clk_register() does not check for this case, which results in a NULL pointer dereference. Add NULL check after devm_kasprintf() to prevent this issue and ensuring no resources are left allocated.",,"[{""url"":""https://git.kernel.org/stable/c/105e8115944a9f93e9412abe7bb07ed96725adf9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/13de464f445d42738fe18c9a28bab056ba3a290a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1d92608a29251278015f57f3572bc950db7519f0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/23f564326deaafacfd7adf6104755b15216d8320"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2adc945b70c4d97e9491a6c0c9f3b217a9eecfba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6fb19cdcf040e1dec052a9032acb66cc2ad1d43f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/77e9ad7a2d0e2a771c9e0be04b9d1639413b5f13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7843412e5927dafbb844782c56b6380564064109"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7943ed1f05f5cb7372dca2aa227f848747a98791"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38636,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:37.587,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: rv: Use strings in da monitors tracepoints Using DA monitors tracepoints with KASAN enabled triggers the following warning: BUG: KASAN: global-out-of-bounds in do_trace_event_raw_event_event_da_monitor+0xd6/0x1a0 Read of size 32 at addr ffffffffaada8980 by task ... Call Trace: <TASK> [...] do_trace_event_raw_event_event_da_monitor+0xd6/0x1a0 ? __pfx_do_trace_event_raw_event_event_da_monitor+0x10/0x10 ? trace_event_sncid+0x83/0x200 trace_event_sncid+0x163/0x200 [...] The buggy address belongs to the variable: automaton_snep+0x4e0/0x5e0 This is caused by the tracepoints reading 32 bytes __array instead of __string from the automata definition. Such strings are literals and reading 32 bytes ends up in out of bound memory accesses (e.g. the next automaton's data in this case). The error is harmless as, while printing the string, we stop at the null terminator, but it should still be fixed. Use the __string facilities while defining the tracepoints to avoid reading out of bound memory.",,"[{""url"":""https://git.kernel.org/stable/c/0ebc70d973ce7a81826b5c4f55f743e07f5864d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f904ff6e58d398c4336f3c19c42b338324451f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38637,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-04-18T07:15:43.823,2025-04-21T14:23:45.950,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net_sched: skbprio: Remove overly strict queue assertions In the current implementation, skbprio enqueue/dequeue contains an assertion that fails under certain conditions when SKBPRIO is used as a child qdisc under TBF with specific parameters. The failure occurs because TBF sometimes peeks at packets in the child qdisc without actually dequeuing them when tokens are unavailable. This peek operation creates a discrepancy between the parent and child qdisc queue length counters. When TBF later receives a high-priority packet, SKBPRIO's queue length may show a different value than what's reflected in its internal priority queue tracking, triggering the assertion. The fix removes this overly strict assertions in SKBPRIO, they are not necessary at all.",,"[{""url"":""https://git.kernel.org/stable/c/034b293bf17c124fec0f0e663f81203b00aa7a50"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1284733bab736e598341f1d3f3b94e2a322864a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1dcc144c322a8d526b791135604c0663f1af9d85"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2286770b07cb5268c03d11274b8efd43dff0d380"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2f35b7673a3aa3d09b3eb05811669622ebaa98ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/32ee79682315e6d3c99947b3f38b078a09a66919"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7abc8318ce0712182bf0783dcfdd9a6a8331160e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/864ca690ff135078d374bd565b9872f161c614bc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce8fe975fd99b49c29c42e50f2441ba53112b2e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38638,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:37.713,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ipv6: add a retry logic in net6_rt_notify() inet6_rt_notify() can be called under RCU protection only. This means the route could be changed concurrently and rt6_fill_node() could return -EMSGSIZE. Re-size the skb when this happens and retry, removing one WARN_ON() that syzbot was able to trigger: WARNING: CPU: 3 PID: 6291 at net/ipv6/route.c:6342 inet6_rt_notify+0x475/0x4b0 net/ipv6/route.c:6342 Modules linked in: CPU: 3 UID: 0 PID: 6291 Comm: syz.0.77 Not tainted 6.16.0-rc7-syzkaller #0 PREEMPT(full) Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 RIP: 0010:inet6_rt_notify+0x475/0x4b0 net/ipv6/route.c:6342 Code: fc ff ff e8 6d 52 ea f7 e9 47 fc ff ff 48 8b 7c 24 08 4c 89 04 24 e8 5a 52 ea f7 4c 8b 04 24 e9 94 fd ff ff e8 9c fe 84 f7 90 <0f> 0b 90 e9 bd fd ff ff e8 6e 52 ea f7 e9 bb fb ff ff 48 89 df e8 RSP: 0018:ffffc900035cf1d8 EFLAGS: 00010293 RAX: 0000000000000000 RBX: ffffc900035cf540 RCX: ffffffff8a36e790 RDX: ffff88802f7e8000 RSI: ffffffff8a36e9d4 RDI: 0000000000000005 RBP: ffff88803c230f00 R08: 0000000000000005 R09: 00000000ffffffa6 R10: 00000000ffffffa6 R11: 0000000000000001 R12: 00000000ffffffa6 R13: 0000000000000900 R14: ffff888032ea4100 R15: 0000000000000000 FS: 00007fac7b89a6c0(0000) GS:ffff8880d6a20000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007fac7b899f98 CR3: 0000000034b3f000 CR4: 0000000000352ef0 Call Trace: <TASK> ip6_route_mpath_notify+0xde/0x280 net/ipv6/route.c:5356 ip6_route_multipath_add+0x1181/0x1bd0 net/ipv6/route.c:5536 inet6_rtm_newroute+0xe4/0x1a0 net/ipv6/route.c:5647 rtnetlink_rcv_msg+0x95e/0xe90 net/core/rtnetlink.c:6944 netlink_rcv_skb+0x155/0x420 net/netlink/af_netlink.c:2552 netlink_unicast_kernel net/netlink/af_netlink.c:1320 [inline] netlink_unicast+0x58d/0x850 net/netlink/af_netlink.c:1346 netlink_sendmsg+0x8d1/0xdd0 net/netlink/af_netlink.c:1896 sock_sendmsg_nosec net/socket.c:712 [inline] __sock_sendmsg net/socket.c:727 [inline] ____sys_sendmsg+0xa95/0xc70 net/socket.c:2566 ___sys_sendmsg+0x134/0x1d0 net/socket.c:2620",,"[{""url"":""https://git.kernel.org/stable/c/0bdca3439a22c70eb8f404acd61bf7aca5d731b0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ea2f921db7a483a526058c5b5b8162edd88dabe5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38639,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:37.850,2025-08-28T15:15:56.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: xt_nfacct: don't assume acct name is null-terminated BUG: KASAN: slab-out-of-bounds in .. lib/vsprintf.c:721 Read of size 1 at addr ffff88801eac95c8 by task syz-executor183/5851 [..] string+0x231/0x2b0 lib/vsprintf.c:721 vsnprintf+0x739/0xf00 lib/vsprintf.c:2874 [..] nfacct_mt_checkentry+0xd2/0xe0 net/netfilter/xt_nfacct.c:41 xt_check_match+0x3d1/0xab0 net/netfilter/x_tables.c:523 nfnl_acct_find_get() handles non-null input, but the error printk relied on its presence.",,"[{""url"":""https://git.kernel.org/stable/c/58004aa21e79addaf41667bfe65e93ec51653f18"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/58007fc7b94fb2702000045ff401eb7f5bde7828"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/66d41268ede1e1b6e71ba28be923397ff0b2b9c3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c1ae471da69c09242834e956218ea6a42dd405a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b10cfa2de13d28ddd03210eb234422b7ec92725a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf58e667af7d96c8eb9411f926a0a0955f41ce21"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/df13c9c6ce1d55c31d1bd49db65a7fbbd86aab13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e021a1eee196887536a6630c5492c23a4c78d452"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e18939176e657a3a20bfbed357b8c55a9f82aba3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38640,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:38.007,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf: Disable migration in nf_hook_run_bpf(). syzbot reported that the netfilter bpf prog can be called without migration disabled in xmit path. Then the assertion in __bpf_prog_run() fails, triggering the splat below. [0] Let's use bpf_prog_run_pin_on_cpu() in nf_hook_run_bpf(). [0]: BUG: assuming non migratable context at ./include/linux/filter.h:703 in_atomic(): 0, irqs_disabled(): 0, migration_disabled() 0 pid: 5829, name: sshd-session 3 locks held by sshd-session/5829: #0: ffff88807b4e4218 (sk_lock-AF_INET){+.+.}-{0:0}, at: lock_sock include/net/sock.h:1667 [inline] #0: ffff88807b4e4218 (sk_lock-AF_INET){+.+.}-{0:0}, at: tcp_sendmsg+0x20/0x50 net/ipv4/tcp.c:1395 #1: ffffffff8e5c4e00 (rcu_read_lock){....}-{1:3}, at: rcu_lock_acquire include/linux/rcupdate.h:331 [inline] #1: ffffffff8e5c4e00 (rcu_read_lock){....}-{1:3}, at: rcu_read_lock include/linux/rcupdate.h:841 [inline] #1: ffffffff8e5c4e00 (rcu_read_lock){....}-{1:3}, at: __ip_queue_xmit+0x69/0x26c0 net/ipv4/ip_output.c:470 #2: ffffffff8e5c4e00 (rcu_read_lock){....}-{1:3}, at: rcu_lock_acquire include/linux/rcupdate.h:331 [inline] #2: ffffffff8e5c4e00 (rcu_read_lock){....}-{1:3}, at: rcu_read_lock include/linux/rcupdate.h:841 [inline] #2: ffffffff8e5c4e00 (rcu_read_lock){....}-{1:3}, at: nf_hook+0xb2/0x680 include/linux/netfilter.h:241 CPU: 0 UID: 0 PID: 5829 Comm: sshd-session Not tainted 6.16.0-rc6-syzkaller-00002-g155a3c003e55 #0 PREEMPT(full) Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x16c/0x1f0 lib/dump_stack.c:120 __cant_migrate kernel/sched/core.c:8860 [inline] __cant_migrate+0x1c7/0x250 kernel/sched/core.c:8834 __bpf_prog_run include/linux/filter.h:703 [inline] bpf_prog_run include/linux/filter.h:725 [inline] nf_hook_run_bpf+0x83/0x1e0 net/netfilter/nf_bpf_link.c:20 nf_hook_entry_hookfn include/linux/netfilter.h:157 [inline] nf_hook_slow+0xbb/0x200 net/netfilter/core.c:623 nf_hook+0x370/0x680 include/linux/netfilter.h:272 NF_HOOK_COND include/linux/netfilter.h:305 [inline] ip_output+0x1bc/0x2a0 net/ipv4/ip_output.c:433 dst_output include/net/dst.h:459 [inline] ip_local_out net/ipv4/ip_output.c:129 [inline] __ip_queue_xmit+0x1d7d/0x26c0 net/ipv4/ip_output.c:527 __tcp_transmit_skb+0x2686/0x3e90 net/ipv4/tcp_output.c:1479 tcp_transmit_skb net/ipv4/tcp_output.c:1497 [inline] tcp_write_xmit+0x1274/0x84e0 net/ipv4/tcp_output.c:2838 __tcp_push_pending_frames+0xaf/0x390 net/ipv4/tcp_output.c:3021 tcp_push+0x225/0x700 net/ipv4/tcp.c:759 tcp_sendmsg_locked+0x1870/0x42b0 net/ipv4/tcp.c:1359 tcp_sendmsg+0x2e/0x50 net/ipv4/tcp.c:1396 inet_sendmsg+0xb9/0x140 net/ipv4/af_inet.c:851 sock_sendmsg_nosec net/socket.c:712 [inline] __sock_sendmsg net/socket.c:727 [inline] sock_write_iter+0x4aa/0x5b0 net/socket.c:1131 new_sync_write fs/read_write.c:593 [inline] vfs_write+0x6c7/0x1150 fs/read_write.c:686 ksys_write+0x1f8/0x250 fs/read_write.c:738 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xcd/0x4c0 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7fe7d365d407 Code: 48 89 fa 4c 89 df e8 38 aa 00 00 8b 93 08 03 00 00 59 5e 48 83 f8 fc 74 1a 5b c3 0f 1f 84 00 00 00 00 00 48 8b 44 24 10 0f 05 <5b> c3 0f 1f 80 00 00 00 00 83 e2 39 83 fa 08 75 de e8 23 ff ff ff RSP:",,"[{""url"":""https://git.kernel.org/stable/c/0a356da16fb933abbeeb7aea038c351f3342cd3f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/17ce3e5949bc37557305ad46316f41c7875d6366"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/62f6175d145e00fc999fd2fcbffad3f59253c66a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0199c28167a8a4adec036005a8df268b2b68529"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee2502485702e4398cd74dbfb288bfa111d25e62"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38641,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:38.150,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: btusb: Fix potential NULL dereference on kmalloc failure Avoid potential NULL pointer dereference by checking the return value of kmalloc and handling allocation failure properly.",,"[{""url"":""https://git.kernel.org/stable/c/5029d80bfc30b60ff57c70ccb04e027acb404f6a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b505902c66a282dcb01bcdc015aa1fdfaaa075db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38642,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:38.283,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mac80211: fix WARN_ON for monitor mode on some devices On devices without WANT_MONITOR_VIF (and probably without channel context support) we get a WARN_ON for changing the per-link setting of a monitor interface. Since we already skip AP_VLAN interfaces and MONITOR with WANT_MONITOR_VIF and/or NO_VIRTUAL_MONITOR should update the settings, catch this in the link change code instead of the warning.",,"[{""url"":""https://git.kernel.org/stable/c/1e10ded6b0f9b0eeefaacbb6c6c6afff3f702812"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c57e5b9819dfd16d709bcd6cb633301ed0829a66"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff15498ebaa49c5429a74e70a1951dede60cd14c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38643,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:38.417,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: cfg80211: Add missing lock in cfg80211_check_and_end_cac() Callers of wdev_chandef() must hold the wiphy mutex. But the worker cfg80211_propagate_cac_done_wk() never takes the lock. Which triggers the warning below with the mesh_peer_connected_dfs test from hostapd and not (yet) released mac80211 code changes: WARNING: CPU: 0 PID: 495 at net/wireless/chan.c:1552 wdev_chandef+0x60/0x165 Modules linked in: CPU: 0 UID: 0 PID: 495 Comm: kworker/u4:2 Not tainted 6.14.0-rc5-wt-g03960e6f9d47 #33 13c287eeabfe1efea01c0bcc863723ab082e17cf Workqueue: cfg80211 cfg80211_propagate_cac_done_wk Stack: 00000000 00000001 ffffff00 6093267c 00000000 6002ec30 6d577c50 60037608 00000000 67e8d108 6063717b 00000000 Call Trace: [<6002ec30>] ? _printk+0x0/0x98 [<6003c2b3>] show_stack+0x10e/0x11a [<6002ec30>] ? _printk+0x0/0x98 [<60037608>] dump_stack_lvl+0x71/0xb8 [<6063717b>] ? wdev_chandef+0x60/0x165 [<6003766d>] dump_stack+0x1e/0x20 [<6005d1b7>] __warn+0x101/0x20f [<6005d3a8>] warn_slowpath_fmt+0xe3/0x15d [<600b0c5c>] ? mark_lock.part.0+0x0/0x4ec [<60751191>] ? __this_cpu_preempt_check+0x0/0x16 [<600b11a2>] ? mark_held_locks+0x5a/0x6e [<6005d2c5>] ? warn_slowpath_fmt+0x0/0x15d [<60052e53>] ? unblock_signals+0x3a/0xe7 [<60052f2d>] ? um_set_signals+0x2d/0x43 [<60751191>] ? __this_cpu_preempt_check+0x0/0x16 [<607508b2>] ? lock_is_held_type+0x207/0x21f [<6063717b>] wdev_chandef+0x60/0x165 [<605f89b4>] regulatory_propagate_dfs_state+0x247/0x43f [<60052f00>] ? um_set_signals+0x0/0x43 [<605e6bfd>] cfg80211_propagate_cac_done_wk+0x3a/0x4a [<6007e460>] process_scheduled_works+0x3bc/0x60e [<6007d0ec>] ? move_linked_works+0x4d/0x81 [<6007d120>] ? assign_work+0x0/0xaa [<6007f81f>] worker_thread+0x220/0x2dc [<600786ef>] ? set_pf_worker+0x0/0x57 [<60087c96>] ? to_kthread+0x0/0x43 [<6008ab3c>] kthread+0x2d3/0x2e2 [<6007f5ff>] ? worker_thread+0x0/0x2dc [<6006c05b>] ? calculate_sigpending+0x0/0x56 [<6003b37d>] new_thread_handler+0x4a/0x64 irq event stamp: 614611 hardirqs last enabled at (614621): [<00000000600bc96b>] __up_console_sem+0x82/0xaf hardirqs last disabled at (614630): [<00000000600bc92c>] __up_console_sem+0x43/0xaf softirqs last enabled at (614268): [<00000000606c55c6>] __ieee80211_wake_queue+0x933/0x985 softirqs last disabled at (614266): [<00000000606c52d6>] __ieee80211_wake_queue+0x643/0x985",,"[{""url"":""https://git.kernel.org/stable/c/2c5dee15239f3f3e31aa5c8808f18996c039e2c1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7022df2248c08c6f75a01714163ac902333bf3db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dbce810607726408f889d3358f4780fd1436861e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38644,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:38.567,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mac80211: reject TDLS operations when station is not associated syzbot triggered a WARN in ieee80211_tdls_oper() by sending NL80211_TDLS_ENABLE_LINK immediately after NL80211_CMD_CONNECT, before association completed and without prior TDLS setup. This left internal state like sdata->u.mgd.tdls_peer uninitialized, leading to a WARN_ON() in code paths that assumed it was valid. Reject the operation early if not in station mode or not associated.",,"[{""url"":""https://git.kernel.org/stable/c/0c84204cf0bbe89e454a5caccc6a908bc7db1542"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/16ecdab5446f15a61ec88eb0d23d25d009821db0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/31af06b574394530f68a4310c45ecbe2f68853c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/378ae9ccaea3f445838a087962a067b5cb2e8577"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4df663d4c1ca386dcab2f743dfc9f0cc07aef73c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/af72badd5ee423eb16f6ad7fe0a62f1b4252d848"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38645,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:38.727,2025-08-28T15:15:57.110,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/mlx5: Check device memory pointer before usage Add a NULL check before accessing device memory to prevent a crash if dev->dm allocation in mlx5_init_once() fails.",,"[{""url"":""https://git.kernel.org/stable/c/3046b011d368162b1b9ca9453eee0fea930e0a93"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4249f1307932f1b6bbb8b7eba60d82f0b7e44430"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/62d7cf455c887941ed6f105cd430ba04ee0b6c9f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/70f238c902b8c0461ae6fbb8d1a0bbddc4350eea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9053a69abfb5680c2a95292b96df5d204bc0776f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da899a1fd7c40e2e4302af1db7d0b8540fb22283"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eebb225fe6c9103293807b8edabcbad59f9589bc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38646,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:38.870,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: rtw89: avoid NULL dereference when RX problematic packet on unsupported 6 GHz band With a quite rare chance, RX report might be problematic to make SW think a packet is received on 6 GHz band even if the chip does not support 6 GHz band actually. Since SW won't initialize stuffs for unsupported bands, NULL dereference will happen then in the sequence, rtw89_vif_rx_stats_iter() -> rtw89_core_cancel_6ghz_probe_tx(). So, add a check to avoid it. The following is a crash log for this case. BUG: kernel NULL pointer dereference, address: 0000000000000032 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 0 P4D 0 Oops: 0000 [#1] PREEMPT SMP NOPTI CPU: 1 PID: 1907 Comm: irq/131-rtw89_p Tainted: G U 6.6.56-05896-g89f5fb0eb30b #1 (HASH:1400 4) Hardware name: Google Telith/Telith, BIOS Google_Telith.15217.747.0 11/12/2024 RIP: 0010:rtw89_vif_rx_stats_iter+0xd2/0x310 [rtw89_core] Code: 4c 89 7d c8 48 89 55 c0 49 8d 44 24 02 48 89 45 b8 45 31 ff eb 11 41 c6 45 3a 01 41 b7 01 4d 8b 6d 00 4d 39 f5 74 42 8b 43 10 <41> 33 45 32 0f b7 4b 14 66 41 33 4d 36 0f b7 c9 09 c1 74 d8 4d 85 RSP: 0018:ffff9f3080138ca0 EFLAGS: 00010246 RAX: 00000000b8bf5770 RBX: ffff91b5e8c639c0 RCX: 0000000000000011 RDX: ffff91b582de1be8 RSI: 0000000000000000 RDI: ffff91b5e8c639e6 RBP: ffff9f3080138d00 R08: 0000000000000000 R09: 0000000000000000 R10: ffff91b59de70000 R11: ffffffffc069be50 R12: ffff91b5e8c639e4 R13: 0000000000000000 R14: ffff91b5828020b8 R15: 0000000000000000 FS: 0000000000000000(0000) GS:ffff91b8efa40000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000032 CR3: 00000002bf838000 CR4: 0000000000750ee0 PKRU: 55555554 Call Trace: <IRQ> ? __die_body+0x68/0xb0 ? page_fault_oops+0x379/0x3e0 ? exc_page_fault+0x4f/0xa0 ? asm_exc_page_fault+0x22/0x30 ? __pfx_rtw89_vif_rx_stats_iter+0x10/0x10 [rtw89_core (HASH:1400 5)] ? rtw89_vif_rx_stats_iter+0xd2/0x310 [rtw89_core (HASH:1400 5)] __iterate_interfaces+0x59/0x110 [mac80211 (HASH:1400 6)] ? __pfx_rtw89_vif_rx_stats_iter+0x10/0x10 [rtw89_core (HASH:1400 5)] ? __pfx_rtw89_vif_rx_stats_iter+0x10/0x10 [rtw89_core (HASH:1400 5)] ieee80211_iterate_active_interfaces_atomic+0x36/0x50 [mac80211 (HASH:1400 6)] rtw89_core_rx_to_mac80211+0xfd/0x1b0 [rtw89_core (HASH:1400 5)] rtw89_core_rx+0x43a/0x980 [rtw89_core (HASH:1400 5)]",,"[{""url"":""https://git.kernel.org/stable/c/4b525630729082f026e7030eafccf89e3add7eae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/77a7a48f87d673a68664bebf044214821decbfda"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7e04f01bb94fe61c73cc59f0495c3b6c16a83231"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/892b29eab44b1803d2cad8e50f1bc2144ef478cb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f3527ac15a00916e68ecb495b74dbe6a6c62a06f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38647,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:39.337,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: rtw89: sar: drop lockdep assertion in rtw89_set_sar_from_acpi The following assertion is triggered on the rtw89 driver startup. It looks meaningless to hold wiphy lock on the early init stage so drop the assertion. WARNING: CPU: 7 PID: 629 at drivers/net/wireless/realtek/rtw89/sar.c:502 rtw89_set_sar_from_acpi+0x365/0x4d0 [rtw89_core] CPU: 7 UID: 0 PID: 629 Comm: (udev-worker) Not tainted 6.15.0+ #29 PREEMPT(lazy) Hardware name: LENOVO 21D0/LNVNB161216, BIOS J6CN50WW 09/27/2024 RIP: 0010:rtw89_set_sar_from_acpi+0x365/0x4d0 [rtw89_core] Call Trace: <TASK> rtw89_sar_init+0x68/0x2c0 [rtw89_core] rtw89_core_init+0x188e/0x1e50 [rtw89_core] rtw89_pci_probe+0x530/0xb50 [rtw89_pci] local_pci_probe+0xd9/0x190 pci_call_probe+0x183/0x540 pci_device_probe+0x171/0x2c0 really_probe+0x1e1/0x890 __driver_probe_device+0x18c/0x390 driver_probe_device+0x4a/0x120 __driver_attach+0x1a0/0x530 bus_for_each_dev+0x10b/0x190 bus_add_driver+0x2eb/0x540 driver_register+0x1a3/0x3a0 do_one_initcall+0xd5/0x450 do_init_module+0x2cc/0x8f0 init_module_from_file+0xe1/0x150 idempotent_init_module+0x226/0x760 __x64_sys_finit_module+0xcd/0x150 do_syscall_64+0x94/0x380 entry_SYSCALL_64_after_hwframe+0x76/0x7e Found by Linux Verification Center (linuxtesting.org).",,"[{""url"":""https://git.kernel.org/stable/c/6fe21445f7e801de5527d420f8e25e97b0cdd7e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f7ac6df92eee030151476078069dc3eb0002dfb0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38648,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:39.480,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: spi: stm32: Check for cfg availability in stm32_spi_probe The stm32_spi_probe function now includes a check to ensure that the pointer returned by of_device_get_match_data is not NULL before accessing its members. This resolves a warning where a potential NULL pointer dereference could occur when accessing cfg->has_device_mode. Before accessing the 'has_device_mode' member, we verify that 'cfg' is not NULL. If 'cfg' is NULL, an error message is logged. This change ensures that the driver does not attempt to access configuration data if it is not available, thus preventing a potential system crash due to a NULL pointer dereference.",,"[{""url"":""https://git.kernel.org/stable/c/21f1c800f6620e43f31dfd76709dbac8ebaa5a16"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3a571a8d52272cc26858ab1bc83d0f66e5dee938"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6031a54f4eac921efe6122a561d44df89b37f2d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a7645815edf4478f3258bb0db95a08986a77f5c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc063d23ad80ef7d201c41b2716b1bae7c662cf9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38649,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:39.617,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: arm64: dts: qcom: qcs615: fix a crash issue caused by infinite loop for Coresight An infinite loop has been created by the Coresight devices. When only a source device is enabled, the coresight_find_activated_sysfs_sink function is recursively invoked in an attempt to locate an active sink device, ultimately leading to a stack overflow and system crash. Therefore, disable the replicator1 to break the infinite loop and prevent a potential stack overflow. replicator1_out -> funnel_swao_in6 -> tmc_etf_swao_in -> tmc_etf_swao_out | | replicator1_in replicator_swao_in | | replicator0_out1 replicator_swao_out0 | | replicator0_in funnel_in1_in3 | | tmc_etf_out <- tmc_etf_in <- funnel_merg_out <- funnel_merg_in1 <- funnel_in1_out [call trace] dump_backtrace+0x9c/0x128 show_stack+0x20/0x38 dump_stack_lvl+0x48/0x60 dump_stack+0x18/0x28 panic+0x340/0x3b0 nmi_panic+0x94/0xa0 panic_bad_stack+0x114/0x138 handle_bad_stack+0x34/0xb8 __bad_stack+0x78/0x80 coresight_find_activated_sysfs_sink+0x28/0xa0 [coresight] coresight_find_activated_sysfs_sink+0x5c/0xa0 [coresight] coresight_find_activated_sysfs_sink+0x5c/0xa0 [coresight] coresight_find_activated_sysfs_sink+0x5c/0xa0 [coresight] coresight_find_activated_sysfs_sink+0x5c/0xa0 [coresight] ... coresight_find_activated_sysfs_sink+0x5c/0xa0 [coresight] coresight_enable_sysfs+0x80/0x2a0 [coresight] side effect after the change: Only trace data originating from AOSS can reach the ETF_SWAO and EUD sinks.",,"[{""url"":""https://git.kernel.org/stable/c/a9aaadcb0a6ce0c19616c46525112bc947c6f2b1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd4f35786d5f0798cc1f8c187a81a7c998e6c58f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fbe5be7893b8c7f58c999a26839cd30bc07654c6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38650,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:39.760,2025-08-28T15:15:57.237,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: hfsplus: remove mutex_lock check in hfsplus_free_extents Syzbot reported an issue in hfsplus filesystem: ------------[ cut here ]------------ WARNING: CPU: 0 PID: 4400 at fs/hfsplus/extents.c:346 hfsplus_free_extents+0x700/0xad0 Call Trace: <TASK> hfsplus_file_truncate+0x768/0xbb0 fs/hfsplus/extents.c:606 hfsplus_write_begin+0xc2/0xd0 fs/hfsplus/inode.c:56 cont_expand_zero fs/buffer.c:2383 [inline] cont_write_begin+0x2cf/0x860 fs/buffer.c:2446 hfsplus_write_begin+0x86/0xd0 fs/hfsplus/inode.c:52 generic_cont_expand_simple+0x151/0x250 fs/buffer.c:2347 hfsplus_setattr+0x168/0x280 fs/hfsplus/inode.c:263 notify_change+0xe38/0x10f0 fs/attr.c:420 do_truncate+0x1fb/0x2e0 fs/open.c:65 do_sys_ftruncate+0x2eb/0x380 fs/open.c:193 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd To avoid deadlock, Commit 31651c607151 (""hfsplus: avoid deadlock on file truncation"") unlock extree before hfsplus_free_extents(), and add check wheather extree is locked in hfsplus_free_extents(). However, when operations such as hfsplus_file_release, hfsplus_setattr, hfsplus_unlink, and hfsplus_get_block are executed concurrently in different files, it is very likely to trigger the WARN_ON, which will lead syzbot and xfstest to consider it as an abnormality. The comment above this warning also describes one of the easy triggering situations, which can easily trigger and cause xfstest&syzbot to report errors. [task A] [task B] ->hfsplus_file_release ->hfsplus_file_truncate ->hfs_find_init ->mutex_lock ->mutex_unlock ->hfsplus_write_begin ->hfsplus_get_block ->hfsplus_file_extend ->hfsplus_ext_read_extent ->hfs_find_init ->mutex_lock ->hfsplus_free_extents WARN_ON(mutex_is_locked) !!! Several threads could try to lock the shared extents tree. And warning can be triggered in one thread when another thread has locked the tree. This is the wrong behavior of the code and we need to remove the warning.",,"[{""url"":""https://git.kernel.org/stable/c/0807e4ac59a546f2346961c5e26a98901594b205"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/084933961ecda7561dedfb78c4676ccb90c91ada"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/14922f0cc92e010b160121679c0a6ca072f4e975"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/314310166ba1fdff7660dfd9d18ea42d7058f7ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5055b7db94110f228961dea6b74eed0a93a50b01"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9764b8bb9f5f94df105cd2ac43829dd0d2c82b9f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a19ce9230b22a0866313932e7964cf05557a6008"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fcb96956c921f1aae7e7b477f2435c56f77a31b4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fdd6aca652122d6e97787e88d7dd53ddc8b74e7e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38651,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:39.907,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: landlock: Fix warning from KUnit tests get_id_range() expects a positive value as first argument but get_random_u8() can return 0. Fix this by clamping it. Validated by running the test in a for loop for 1000 times. Note that MAX() is wrong as it is only supposed to be used for constants, but max() is good here. [..] ok 9 test_range2_rand1 [..] ok 10 test_range2_rand2 [..] ok 11 test_range2_rand15 [..] ------------[ cut here ]------------ [..] WARNING: CPU: 6 PID: 104 at security/landlock/id.c:99 test_range2_rand16 (security/landlock/id.c:99 (discriminator 1) security/landlock/id.c:234 (discriminator 1)) [..] Modules linked in: [..] CPU: 6 UID: 0 PID: 104 Comm: kunit_try_catch Tainted: G N 6.16.0-rc1-dev-00001-g314a2f98b65f #1 PREEMPT(undef) [..] Tainted: [N]=TEST [..] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 [..] RIP: 0010:test_range2_rand16 (security/landlock/id.c:99 (discriminator 1) security/landlock/id.c:234 (discriminator 1)) [..] Code: 49 c7 c0 10 70 30 82 4c 89 ff 48 c7 c6 a0 63 1e 83 49 c7 45 a0 e0 63 1e 83 e8 3f 95 17 00 e9 1f ff ff ff 0f 0b e9 df fd ff ff <0f> 0b ba 01 00 00 00 e9 68 fe ff ff 49 89 45 a8 49 8d 4d a0 45 31 [..] RSP: 0000:ffff888104eb7c78 EFLAGS: 00010246 [..] RAX: 0000000000000000 RBX: 000000000870822c RCX: 0000000000000000 ^^^^^^^^^^^^^^^^ [..] [..] Call Trace: [..] [..] ---[ end trace 0000000000000000 ]--- [..] ok 12 test_range2_rand16 [..] # landlock_id: pass:12 fail:0 skip:0 total:12 [..] # Totals: pass:12 fail:0 skip:0 total:12 [..] ok 1 landlock_id [mic: Minor cosmetic improvements]",,"[{""url"":""https://git.kernel.org/stable/c/127183361b69dbb7ac3246ad4726f93400481249"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d9ec2cfe12dd0d7c1a58213b9bef1bec66a3189"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0a69cf2c03e61bd8069becb97f66c173d0d1fa1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38652,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:40.057,2025-08-28T15:15:57.373,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to avoid out-of-boundary access in devs.path - touch /mnt/f2fs/012345678901234567890123456789012345678901234567890123 - truncate -s $((1024*1024*1024)) \ /mnt/f2fs/012345678901234567890123456789012345678901234567890123 - touch /mnt/f2fs/file - truncate -s $((1024*1024*1024)) /mnt/f2fs/file - mkfs.f2fs /mnt/f2fs/012345678901234567890123456789012345678901234567890123 \ -c /mnt/f2fs/file - mount /mnt/f2fs/012345678901234567890123456789012345678901234567890123 \ /mnt/f2fs/loop [16937.192225] F2FS-fs (loop0): Mount Device [ 0]: /mnt/f2fs/012345678901234567890123456789012345678901234567890123\xff\x01, 511, 0 - 3ffff [16937.192268] F2FS-fs (loop0): Failed to find devices If device path length equals to MAX_PATH_LEN, sbi->devs.path[] may not end up w/ null character due to path array is fully filled, So accidently, fields locate after path[] may be treated as part of device path, result in parsing wrong device path. struct f2fs_dev_info { ... char path[MAX_PATH_LEN]; ... }; Let's add one byte space for sbi->devs.path[] to store null character of device path string.",,"[{""url"":""https://git.kernel.org/stable/c/1b1efa5f0e878745e94a98022e8edc675a87d78e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1cf1ff15f262e8baf12201b270b6a79f9d119b2d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/345fc8d1838f3f8be7c8ed08d86a13dedef67136"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3466721f06edff834f99d9f49f23eabc6b2cb78e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5661998536af52848cc4d52a377e90368196edea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/666b7cf6ac9aa074b8319a2b68cba7f2c30023f0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/70849d33130a2cf1d6010069ed200669c8651fbd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/755427093e4294ac111c3f9e40d53f681a0fbdaa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc0172c74bd9edaee7bea2ebb35f3dbd37a8ae80"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38653,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:40.200,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: proc: use the same treatment to check proc_lseek as ones for proc_read_iter et.al Check pde->proc_ops->proc_lseek directly may cause UAF in rmmod scenario. It's a gap in proc_reg_open() after commit 654b33ada4ab(""proc: fix UAF in proc_get_inode()""). Followed by AI Viro's suggestion, fix it in same manner.",,"[{""url"":""https://git.kernel.org/stable/c/1fccbfbae1dd36198dc47feac696563244ad81d3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/33c778ea0bd0fa62ff590497e72562ff90f82b13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c35b0feb80b48720dfbbf4e33759c7be3faaebb6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d136502e04d8853a9aecb335d07bbefd7a1519a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc1072d934f687e1221d685cf1a49a5068318f34"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff7ec8dc1b646296f8d94c39339e8d3833d16c05"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38654,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:40.357,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: pinctrl: canaan: k230: Fix order of DT parse and pinctrl register Move DT parse before pinctrl register. This ensures that device tree parsing is done before calling devm_pinctrl_register() to prevent using uninitialized pin resources.",,"[{""url"":""https://git.kernel.org/stable/c/02c1deb1bff2b6d242e29a51e56107495979a2b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0ec03251d01494ef207089b5bd626becfd05fd86"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d94a32ac688f953dc9a9f12b5b4139ecad841bbb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38655,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:40.493,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: pinctrl: canaan: k230: add NULL check in DT parse Add a NULL check for the return value of of_get_property() when retrieving the ""pinmux"" property in the group parser. This avoids a potential NULL pointer dereference if the property is missing from the device tree node. Also fix a typo (""sintenel"") in the device ID match table comment, correcting it to ""sentinel"".",,"[{""url"":""https://git.kernel.org/stable/c/5d324b262c0ff256b8d603596574d66267b6394f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/65bd0be486390fc12a84eafaad78758c5e5a55e6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b5ae84aeff60b8819e8568ff0c57590caed9e6d3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38656,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:40.633,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: iwlwifi: Fix error code in iwl_op_mode_dvm_start() Preserve the error code if iwl_setup_deferred_work() fails. The current code returns ERR_PTR(0) (which is NULL) on this path. I believe the missing error code potentially leads to a use after free involving debugfs.",,"[{""url"":""https://git.kernel.org/stable/c/1d068272c21d886d06526454b68368100ba0a720"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/991e2066f6009d3cb898413058c62dbcc92bd6d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cf80c02a9fdb6c5bc8508beb6a0f6a1294fc32f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38657,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:40.777,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: rtw89: mcc: prevent shift wrapping in rtw89_core_mlsr_switch() The ""link_id"" value comes from the user via debugfs. If it's larger than BITS_PER_LONG then that would result in shift wrapping and potentially an out of bounds access later. In fact, we can limit it to IEEE80211_MLD_MAX_NUM_LINKS (15). Fortunately, only root can write to debugfs files so the security impact is minimal.",,"[{""url"":""https://git.kernel.org/stable/c/417cfa9cc44fbe6bceab786f9a4ee5a210f1288e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/53cf488927a0f79968f9c03c4d1e00d2a79731c3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38658,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:40.907,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nvmet: pci-epf: Do not complete commands twice if nvmet_req_init() fails Have nvmet_req_init() and req->execute() complete failed commands. Description of the problem: nvmet_req_init() calls __nvmet_req_complete() internally upon failure, e.g., unsupported opcode, which calls the ""queue_response"" callback, this results in nvmet_pci_epf_queue_response() being called, which will call nvmet_pci_epf_complete_iod() if data_len is 0 or if dma_dir is different from DMA_TO_DEVICE. This results in a double completion as nvmet_pci_epf_exec_iod_work() also calls nvmet_pci_epf_complete_iod() when nvmet_req_init() fails. Steps to reproduce: On the host send a command with an unsupported opcode with nvme-cli, For example the admin command ""security receive"" $ sudo nvme security-recv /dev/nvme0n1 -n1 -x4096 This triggers a double completion as nvmet_req_init() fails and nvmet_pci_epf_queue_response() is called, here iod->dma_dir is still in the default state of ""DMA_NONE"" as set by default in nvmet_pci_epf_alloc_iod(), so nvmet_pci_epf_complete_iod() is called. Because nvmet_req_init() failed nvmet_pci_epf_complete_iod() is also called in nvmet_pci_epf_exec_iod_work() leading to a double completion. This not only sends two completions to the host but also corrupts the state of the PCI NVMe target leading to kernel oops. This patch lets nvmet_req_init() and req->execute() complete all failed commands, and removes the double completion case in nvmet_pci_epf_exec_iod_work() therefore fixing the edge cases where double completions occurred.",,"[{""url"":""https://git.kernel.org/stable/c/746d0ac5a07d5da952ef258dd4d75f0b26c96476"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a535c0b10060bc8c174a7964b0f98064ee0c4774"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38659,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:41.053,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: gfs2: No more self recovery When a node withdraws and it turns out that it is the only node that has the filesystem mounted, gfs2 currently tries to replay the local journal to bring the filesystem back into a consistent state. Not only is that a very bad idea, it has also never worked because gfs2_recover_func() will refuse to do anything during a withdraw. However, before even getting to this point, gfs2_recover_func() dereferences sdp->sd_jdesc->jd_inode. This was a use-after-free before commit 04133b607a78 (""gfs2: Prevent double iput for journal on error"") and is a NULL pointer dereference since then. Simply get rid of self recovery to fix that.",,"[{""url"":""https://git.kernel.org/stable/c/1a91ba12abef628b43cada87478328274d988e88"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6784367b2f3cd7b89103de35764f37f152590dbd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/97c94c7dbddc34d353c83b541b3decabf98d04af"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/deb016c1669002e48c431d6fd32ea1c20ef41756"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f5426ffbec971a8f7346a57392d3a901bdee5a9b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38660,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:41.193,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: [ceph] parse_longname(): strrchr() expects NUL-terminated string ... and parse_longname() is not guaranteed that. That's the reason why it uses kmemdup_nul() to build the argument for kstrtou64(); the problem is, kstrtou64() is not the only thing that need it. Just get a NUL-terminated copy of the entire thing and be done with that...",,"[{""url"":""https://git.kernel.org/stable/c/101841c38346f4ca41dc1802c867da990ffb32eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3145b2b11492d61c512bbc59660bb823bc757f48"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/493479af8af3ab907f49e99323777d498a4fbd2b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bb80f7618832d26f7e395f52f82b1dac76223e5f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38661,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:41.330,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: platform/x86: alienware-wmi-wmax: Fix `dmi_system_id` array Add missing empty member to `awcc_dmi_table`.",,"[{""url"":""https://git.kernel.org/stable/c/660bcd9f1f94e623e1316b869b2172b36eb516d7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8346c6af27f1c1410eb314f4be5875fdf1579a10"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38662,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:41.450,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: mediatek: mt8365-dai-i2s: pass correct size to mt8365_dai_set_priv Given mt8365_dai_set_priv allocate priv_size space to copy priv_data which means we should pass mt8365_i2s_priv[i] or ""struct mtk_afe_i2s_priv"" instead of afe_priv which has the size of ""struct mt8365_afe_private"". Otherwise the KASAN complains about. [ 59.389765] BUG: KASAN: global-out-of-bounds in mt8365_dai_set_priv+0xc8/0x168 [snd_soc_mt8365_pcm] ... [ 59.394789] Call trace: [ 59.395167] dump_backtrace+0xa0/0x128 [ 59.395733] show_stack+0x20/0x38 [ 59.396238] dump_stack_lvl+0xe8/0x148 [ 59.396806] print_report+0x37c/0x5e0 [ 59.397358] kasan_report+0xac/0xf8 [ 59.397885] kasan_check_range+0xe8/0x190 [ 59.398485] asan_memcpy+0x3c/0x98 [ 59.399022] mt8365_dai_set_priv+0xc8/0x168 [snd_soc_mt8365_pcm] [ 59.399928] mt8365_dai_i2s_register+0x1e8/0x2b0 [snd_soc_mt8365_pcm] [ 59.400893] mt8365_afe_pcm_dev_probe+0x4d0/0xdf0 [snd_soc_mt8365_pcm] [ 59.401873] platform_probe+0xcc/0x228 [ 59.402442] really_probe+0x340/0x9e8 [ 59.402992] driver_probe_device+0x16c/0x3f8 [ 59.403638] driver_probe_device+0x64/0x1d8 [ 59.404256] driver_attach+0x1dc/0x4c8 [ 59.404840] bus_for_each_dev+0x100/0x190 [ 59.405442] driver_attach+0x44/0x68 [ 59.405980] bus_add_driver+0x23c/0x500 [ 59.406550] driver_register+0xf8/0x3d0 [ 59.407122] platform_driver_register+0x68/0x98 [ 59.407810] mt8365_afe_pcm_driver_init+0x2c/0xff8 [snd_soc_mt8365_pcm]",,"[{""url"":""https://git.kernel.org/stable/c/1dc0ed16cfbc3c28a07a89904071cfa802fdcee1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6bea85979d05470e6416a2bb504a9bcd9178304c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6e621dd99c57db916842865debaa65f20bbd6d8e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38663,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:41.590,2025-08-28T15:15:57.607,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nilfs2: reject invalid file types when reading inodes To prevent inodes with invalid file types from tripping through the vfs and causing malfunctions or assertion failures, add a missing sanity check when reading an inode from a block device. If the file type is not valid, treat it as a filesystem error.",,"[{""url"":""https://git.kernel.org/stable/c/1a5c204e175a78556b8ef1f7683249fa5197295a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2cf0c4130bf340be3935d097a3dcbfefdcf65815"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/42cd46b3a8b1497b9258dc7ac445dbd6beb73e2f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4aead50caf67e01020c8be1945c3201e8a972a27"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/79663a15a1c70ca84f86f2dbba07b423fe7d5d4f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/98872a934ea6a95985fb6a3655a78a5f0c114e82"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf585ee198bba4ff25b0d80a0891df4656cb0d08"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dd298c0b889acd3ecaf48b6e840c9ab91882e342"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38664,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:41.723,2025-08-28T15:15:57.740,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ice: Fix a null pointer dereference in ice_copy_and_init_pkg() Add check for the return value of devm_kmemdup() to prevent potential null pointer dereference.",,"[{""url"":""https://git.kernel.org/stable/c/0fde7dccbf4c8a6d7940ecaf4c3d80a12f405dd7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1c30093d58cd3d02d8358e2b1f4a06a0aae0bf5b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3028f2a4e746b499043bbb8ab816f975473a0535"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/35370d3b44efe194fd5ad55bac987e629597d782"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/435462f8ab2b9c5340a5414ce02f70117d0cfede"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4ff12d82dac119b4b99b5a78b5af3bf2474c0a36"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6d640a8ea62435a7f6f89869bee4fa99423d07ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c5a13c76dd37e9e4f8d48b87376a54f4399ce15"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38665,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:41.860,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: can: netlink: can_changelink(): fix NULL pointer deref of struct can_priv::do_set_mode Andrei Lalaev reported a NULL pointer deref when a CAN device is restarted from Bus Off and the driver does not implement the struct can_priv::do_set_mode callback. There are 2 code path that call struct can_priv::do_set_mode: - directly by a manual restart from the user space, via can_changelink() - delayed automatic restart after bus off (deactivated by default) To prevent the NULL pointer deference, refuse a manual restart or configure the automatic restart delay in can_changelink() and report the error via extack to user space. As an additional safety measure let can_restart() return an error if can_priv::do_set_mode is not set instead of dereferencing it unchecked.",,"[{""url"":""https://git.kernel.org/stable/c/0ca816a96fdcf32644c80cbe7a82c7b6ce6ddda5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6acceb46180f9e160d4f0c56fcaf39ba562822ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6bbcf37c5114926c99a1d1e6993a5b35689d2599"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c1f3f9797c1f44a762e6f5f72520b2e520537b52"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cf81a60a973358dea163f6b14062f17831ceb894"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38666,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:42.000,2025-08-28T15:15:57.877,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: appletalk: Fix use-after-free in AARP proxy probe The AARP proxyprobe routine (aarp_proxy_probe_network) sends a probe, releases the aarp_lock, sleeps, then re-acquires the lock. During that window an expire timer thread (__aarp_expire_timer) can remove and kfree() the same entry, leading to a use-after-free. race condition: cpu 0 | cpu 1 atalk_sendmsg() | atif_proxy_probe_device() aarp_send_ddp() | aarp_proxy_probe_network() mod_timer() | lock(aarp_lock) // LOCK!! timeout around 200ms | alloc(aarp_entry) and then call | proxies[hash] = aarp_entry aarp_expire_timeout() | aarp_send_probe() | unlock(aarp_lock) // UNLOCK!! lock(aarp_lock) // LOCK!! | msleep(100); __aarp_expire_timer(&proxies[ct]) | free(aarp_entry) | unlock(aarp_lock) // UNLOCK!! | | lock(aarp_lock) // LOCK!! | UAF aarp_entry !! ================================================================== BUG: KASAN: slab-use-after-free in aarp_proxy_probe_network+0x560/0x630 net/appletalk/aarp.c:493 Read of size 4 at addr ffff8880123aa360 by task repro/13278 CPU: 3 UID: 0 PID: 13278 Comm: repro Not tainted 6.15.2 #3 PREEMPT(full) Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x116/0x1b0 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:408 [inline] print_report+0xc1/0x630 mm/kasan/report.c:521 kasan_report+0xca/0x100 mm/kasan/report.c:634 aarp_proxy_probe_network+0x560/0x630 net/appletalk/aarp.c:493 atif_proxy_probe_device net/appletalk/ddp.c:332 [inline] atif_ioctl+0xb58/0x16c0 net/appletalk/ddp.c:857 atalk_ioctl+0x198/0x2f0 net/appletalk/ddp.c:1818 sock_do_ioctl+0xdc/0x260 net/socket.c:1190 sock_ioctl+0x239/0x6a0 net/socket.c:1311 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:906 [inline] __se_sys_ioctl fs/ioctl.c:892 [inline] __x64_sys_ioctl+0x194/0x200 fs/ioctl.c:892 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xcb/0x250 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f </TASK> Allocated: aarp_alloc net/appletalk/aarp.c:382 [inline] aarp_proxy_probe_network+0xd8/0x630 net/appletalk/aarp.c:468 atif_proxy_probe_device net/appletalk/ddp.c:332 [inline] atif_ioctl+0xb58/0x16c0 net/appletalk/ddp.c:857 atalk_ioctl+0x198/0x2f0 net/appletalk/ddp.c:1818 Freed: kfree+0x148/0x4d0 mm/slub.c:4841 __aarp_expire net/appletalk/aarp.c:90 [inline] __aarp_expire_timer net/appletalk/aarp.c:261 [inline] aarp_expire_timeout+0x480/0x6e0 net/appletalk/aarp.c:317 The buggy address belongs to the object at ffff8880123aa300 which belongs to the cache kmalloc-192 of size 192 The buggy address is located 96 bytes inside of freed 192-byte region [ffff8880123aa300, ffff8880123aa3c0) Memory state around the buggy address: ffff8880123aa200: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ffff8880123aa280: 00 00 00 00 fc fc fc fc fc fc fc fc fc fc fc fc >ffff8880123aa300: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ^ ffff8880123aa380: fb fb fb fb fb fb fb fb fc fc fc fc fc fc fc fc ffff8880123aa400: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ==================================================================",,"[{""url"":""https://git.kernel.org/stable/c/186942d19c0222617ef61f50e1dba91e269a5963"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2a6209e4649d45fd85d4193abc481911858ffc6f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5f02ea0f63dd38c41539ea290fcc1693c73aa8e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c4a92d07b0850342d3becf2e608f805e972467c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/82d19a70ced28b17a38ebf1b6978c6c7db894979"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b35694ffabb2af308a1f725d70f60fd8a47d1f3e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e4f1564c5b699eb89b3040688fd6b4e57922f1f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f90b6bb203f3f38bf2b3d976113d51571df9a482"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38667,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:42.150,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iio: fix potential out-of-bound write The buffer is set to 20 characters. If a caller write more characters, count is truncated to the max available space in ""simple_write_to_buffer"". To protect from OoB access, check that the input size fit into buffer and add a zero terminator after copy to the end of the copied data.",,"[{""url"":""https://git.kernel.org/stable/c/16285a0931869baa618b1f5d304e1e9d090470a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/81a635b6eccd6fc889f6d07ab9583b705f739ce1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38668,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:42.283,2025-08-28T15:15:58.020,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: regulator: core: fix NULL dereference on unbind due to stale coupling data Failing to reset coupling_desc.n_coupled after freeing coupled_rdevs can lead to NULL pointer dereference when regulators are accessed post-unbind. This can happen during runtime PM or other regulator operations that rely on coupling metadata. For example, on ridesx4, unbinding the 'reg-dummy' platform device triggers a panic in regulator_lock_recursive() due to stale coupling state. Ensure n_coupled is set to 0 to prevent access to invalid pointers.",,"[{""url"":""https://git.kernel.org/stable/c/233d3c54c9620e95193923859ea1d0b0f5d748ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5d4261dbb3335221fd9c6e69f909ba79ee6663a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c49eac796681e250e34156bafb643930310bd4a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7574892e259bbb16262ebfb4b65a2054a5e03a49"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/800a2cfb2df7f96b3fb48910fc595e0215f6b019"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca46946a482238b0cdea459fb82fc837fb36260e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca9bef9ba1a6be640c87bf802d2e9e696021576a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d7e59c5fd7a0f5e16e75a30a89ea2c4ab88612b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38669,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:42.423,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Revert ""drm/gem-shmem: Use dma_buf from GEM object instance"" This reverts commit 1a148af06000e545e714fe3210af3d77ff903c11. The dma_buf field in struct drm_gem_object is not stable over the object instance's lifetime. The field becomes NULL when user space releases the final GEM handle on the buffer object. This resulted in a NULL-pointer deref. Workarounds in commit 5307dce878d4 (""drm/gem: Acquire references on GEM handles for framebuffers"") and commit f6bfc9afc751 (""drm/framebuffer: Acquire internal references on GEM handles"") only solved the problem partially. They especially don't work for buffer objects without a DRM framebuffer associated. Hence, this revert to going back to using .import_attach->dmabuf. v3: - cc stable",,"[{""url"":""https://git.kernel.org/stable/c/291a77604858a8b47cf6640a12b76e97f99e00ed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6d496e9569983a0d7a05be6661126d0702cf94f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38670,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:42.547,2025-08-28T15:15:58.170,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: arm64/entry: Mask DAIF in cpu_switch_to(), call_on_irq_stack() `cpu_switch_to()` and `call_on_irq_stack()` manipulate SP to change to different stacks along with the Shadow Call Stack if it is enabled. Those two stack changes cannot be done atomically and both functions can be interrupted by SErrors or Debug Exceptions which, though unlikely, is very much broken : if interrupted, we can end up with mismatched stacks and Shadow Call Stack leading to clobbered stacks. In `cpu_switch_to()`, it can happen when SP_EL0 points to the new task, but x18 stills points to the old task's SCS. When the interrupt handler tries to save the task's SCS pointer, it will save the old task SCS pointer (x18) into the new task struct (pointed to by SP_EL0), clobbering it. In `call_on_irq_stack()`, it can happen when switching from the task stack to the IRQ stack and when switching back. In both cases, we can be interrupted when the SCS pointer points to the IRQ SCS, but SP points to the task stack. The nested interrupt handler pushes its return addresses on the IRQ SCS. It then detects that SP points to the task stack, calls `call_on_irq_stack()` and clobbers the task SCS pointer with the IRQ SCS pointer, which it will also use ! This leads to tasks returning to addresses on the wrong SCS, or even on the IRQ SCS, triggering kernel panics via CONFIG_VMAP_STACK or FPAC if enabled. This is possible on a default config, but unlikely. However, when enabling CONFIG_ARM64_PSEUDO_NMI, DAIF is unmasked and instead the GIC is responsible for filtering what interrupts the CPU should receive based on priority. Given the goal of emulating NMIs, pseudo-NMIs can be received by the CPU even in `cpu_switch_to()` and `call_on_irq_stack()`, possibly *very* frequently depending on the system configuration and workload, leading to unpredictable kernel panics. Completely mask DAIF in `cpu_switch_to()` and restore it when returning. Do the same in `call_on_irq_stack()`, but restore and mask around the branch. Mask DAIF even if CONFIG_SHADOW_CALL_STACK is not enabled for consistency of behaviour between all configurations. Introduce and use an assembly macro for saving and masking DAIF, as the existing one saves but only masks IF.",,"[{""url"":""https://git.kernel.org/stable/c/0f67015d72627bad72da3c2084352e0aa134416b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/407047893a64399f2d2390ff35cc6061107d805d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/708fd522b86d2a9544c34ec6a86fa3fc23336525"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9433a5f437b0948d6a2d8a02ad7a42ab7ca27a61"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6b0cb523eaa01efe8a3f76ced493ba60674c6e6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d42e6c20de6192f8e4ab4cf10be8c694ef27e8cb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38671,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:42.683,2025-08-28T15:15:58.300,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: i2c: qup: jump out of the loop in case of timeout Original logic only sets the return value but doesn't jump out of the loop if the bus is kept active by a client. This is not expected. A malicious or buggy i2c client can hang the kernel in this case and should be avoided. This is observed during a long time test with a PCA953x GPIO extender. Fix it by changing the logic to not only sets the return value, but also jumps out of the loop and return to the caller with -ETIMEDOUT.",,"[{""url"":""https://git.kernel.org/stable/c/0d33913fce67a93c1eb83396c3c9d6b411dcab33"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/42c4471b30fa203249f476dd42321cd7efb7f6a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/89459f168b78e5c801dc8b7ad037b62898bc4f57"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a7982a14b3012527a9583d12525cd0dc9f8d8934"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/acfa2948be630ad857535cb36153697f3cbf9ca9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c523bfba46c4b4d7676fb050909533a766698ecd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cbec4406998185e0311ae97dfacc649f9cd79b0b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d05ec13aa3eb868a60dc961b489053a643863ddc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38672,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:42.820,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Revert ""drm/gem-dma: Use dma_buf from GEM object instance"" This reverts commit e8afa1557f4f963c9a511bd2c6074a941c308685. The dma_buf field in struct drm_gem_object is not stable over the object instance's lifetime. The field becomes NULL when user space releases the final GEM handle on the buffer object. This resulted in a NULL-pointer deref. Workarounds in commit 5307dce878d4 (""drm/gem: Acquire references on GEM handles for framebuffers"") and commit f6bfc9afc751 (""drm/framebuffer: Acquire internal references on GEM handles"") only solved the problem partially. They especially don't work for buffer objects without a DRM framebuffer associated. Hence, this revert to going back to using .import_attach->dmabuf. v3: - cc stable",,"[{""url"":""https://git.kernel.org/stable/c/1918e79be908b8a2c8757640289bc196c14d928a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e7bdb3104a2f71ec1439d37f8e6e2f201dbcd7cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38673,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:42.953,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Revert ""drm/gem-framebuffer: Use dma_buf from GEM object instance"" This reverts commit cce16fcd7446dcff7480cd9d2b6417075ed81065. The dma_buf field in struct drm_gem_object is not stable over the object instance's lifetime. The field becomes NULL when user space releases the final GEM handle on the buffer object. This resulted in a NULL-pointer deref. Workarounds in commit 5307dce878d4 (""drm/gem: Acquire references on GEM handles for framebuffers"") and commit f6bfc9afc751 (""drm/framebuffer: Acquire internal references on GEM handles"") only solved the problem partially. They especially don't work for buffer objects without a DRM framebuffer associated. Hence, this revert to going back to using .import_attach->dmabuf. v3: - cc stable",,"[{""url"":""https://git.kernel.org/stable/c/2712ca878b688682ac2ce02aefc413fc76019cd9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e31f5a1c2cd38bf977736cdfa79444e19d4005ec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38674,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:43.090,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Revert ""drm/prime: Use dma_buf from GEM object instance"" This reverts commit f83a9b8c7fd0557b0c50784bfdc1bbe9140c9bf8. The dma_buf field in struct drm_gem_object is not stable over the object instance's lifetime. The field becomes NULL when user space releases the final GEM handle on the buffer object. This resulted in a NULL-pointer deref. Workarounds in commit 5307dce878d4 (""drm/gem: Acquire references on GEM handles for framebuffers"") and commit f6bfc9afc751 (""drm/framebuffer: Acquire internal references on GEM handles"") only solved the problem partially. They especially don't work for buffer objects without a DRM framebuffer associated. Hence, this revert to going back to using .import_attach->dmabuf. v3: - cc stable",,"[{""url"":""https://git.kernel.org/stable/c/5f05d83ce689a8930a70dfa73f879604aef8cc03"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fb4ef4a52b79a22ad382bfe77332642d02aef773"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38675,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-22T16:15:43.217,2025-08-22T18:08:51.663,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: xfrm: state: initialize state_ptrs earlier in xfrm_state_find In case of preemption, xfrm_state_look_at will find a different pcpu_id and look up states for that other CPU. If we matched a state for CPU2 in the state_cache while the lookup started on CPU1, we will jump to ""found"", but the ""best"" state that we got will be ignored and we will enter the ""acquire"" block. This block uses state_ptrs, which isn't initialized at this point. Let's initialize state_ptrs just after taking rcu_read_lock. This will also prevent a possible misuse in the future, if someone adjusts this function.",,"[{""url"":""https://git.kernel.org/stable/c/463562f9591742be62ddde3b426a0533ed496955"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6bf2daafc51bcb9272c0fdff2afd38217337d0d3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/94d077c331730510d5611b438640a292097341f0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38676,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-26T13:15:32.147,2025-08-28T15:15:58.427,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iommu/amd: Avoid stack buffer overflow from kernel cmdline While the kernel command line is considered trusted in most environments, avoid writing 1 byte past the end of ""acpiid"" if the ""str"" argument is maximum length.",,"[{""url"":""https://git.kernel.org/stable/c/0ad8509b468fa1058f4f400a1829f29e4ccc4de8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4bdb0f78bddbfa77d3ab458a21dd9cec495d317a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/736db11c86f03e717fc4bf771d05efdf10d23acb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8503d0fcb1086a7cfe26df67ca4bd9bd9e99bdec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8f80c633cba144f721d38d9380f23d23ab7db10e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ff52d3af0ef286535749e14e3fe9eceb39a8349"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a732502bf3bbe859613b6d7b2b0313b11f0474ac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38677,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-30T10:15:36.260,2025-09-02T15:55:35.520,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to avoid out-of-boundary access in dnode page As Jiaming Zhang reported: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x1c1/0x2a0 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0x17e/0x800 mm/kasan/report.c:480 kasan_report+0x147/0x180 mm/kasan/report.c:593 data_blkaddr fs/f2fs/f2fs.h:3053 [inline] f2fs_data_blkaddr fs/f2fs/f2fs.h:3058 [inline] f2fs_get_dnode_of_data+0x1a09/0x1c40 fs/f2fs/node.c:855 f2fs_reserve_block+0x53/0x310 fs/f2fs/data.c:1195 prepare_write_begin fs/f2fs/data.c:3395 [inline] f2fs_write_begin+0xf39/0x2190 fs/f2fs/data.c:3594 generic_perform_write+0x2c7/0x910 mm/filemap.c:4112 f2fs_buffered_write_iter fs/f2fs/file.c:4988 [inline] f2fs_file_write_iter+0x1ec8/0x2410 fs/f2fs/file.c:5216 new_sync_write fs/read_write.c:593 [inline] vfs_write+0x546/0xa90 fs/read_write.c:686 ksys_write+0x149/0x250 fs/read_write.c:738 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xf3/0x3d0 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f The root cause is in the corrupted image, there is a dnode has the same node id w/ its inode, so during f2fs_get_dnode_of_data(), it tries to access block address in dnode at offset 934, however it parses the dnode as inode node, so that get_dnode_addr() returns 360, then it tries to access page address from 360 + 934 * 4 = 4096 w/ 4 bytes. To fix this issue, let's add sanity check for node id of all direct nodes during f2fs_get_dnode_of_data().",,"[{""url"":""https://git.kernel.org/stable/c/6b7784ea07e6aa044f74b39d6b5af5e28746fc81"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/77de19b6867f2740cdcb6c9c7e50d522b47847a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/888aa660144bcb6ec07839da756ee46bfcf7fc53"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/901f62efd6e855f93d8b1175540f29f4dc45ba55"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/92ef491b506a0f4dd971a3a76f86f2d8f5370180"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a650654365c57407413e9b1f6ff4d539bf2e99ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee4d13f5407cbdf1216cc258f45492075713889a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1d5093d9fe9f3c74c123741c88666cc853b79c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38678,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-03T13:15:48.897,2025-09-04T15:36:56.447,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: nf_tables: reject duplicate device on updates A chain/flowtable update with duplicated devices in the same batch is possible. Unfortunately, netdev event path only removes the first device that is found, leaving unregistered the hook of the duplicated device. Check if a duplicated device exists in the transaction batch, bail out with EEXIST in such case. WARNING is hit when unregistering the hook: [49042.221275] WARNING: CPU: 4 PID: 8425 at net/netfilter/core.c:340 nf_hook_entry_head+0xaa/0x150 [49042.221375] CPU: 4 UID: 0 PID: 8425 Comm: nft Tainted: G S 6.16.0+ #170 PREEMPT(full) [...] [49042.221382] RIP: 0010:nf_hook_entry_head+0xaa/0x150",,"[{""url"":""https://git.kernel.org/stable/c/cf5fb87fcdaaaafec55dcc0dc5a9e15ead343973"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d7615bde541f16517d6790412da6ec46fa8a4c1f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38679,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:35.387,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: venus: Fix OOB read due to missing payload bound check Currently, The event_seq_changed() handler processes a variable number of properties sent by the firmware. The number of properties is indicated by the firmware and used to iterate over the payload. However, the payload size is not being validated against the actual message length. This can lead to out-of-bounds memory access if the firmware provides a property count that exceeds the data available in the payload. Such a condition can result in kernel crashes or potential information leaks if memory beyond the buffer is accessed. Fix this by properly validating the remaining size of the payload before each property access and updating bounds accordingly as properties are parsed. This ensures that property parsing is safely bounded within the received message buffer and protects against malformed or malicious firmware behavior.",,"[{""url"":""https://git.kernel.org/stable/c/06d6770ff0d8cc8dfd392329a8cc03e2a83e7289"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6f08bfb5805637419902f3d70069fe17a404545b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8f274e2b05fdae7a53cee83979202b5ecb49035c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a3eef5847603cd8a4110587907988c3f93c9605a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bed4921055dd7bb4d2eea2729852ae18cf97a2c6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c956c3758510b448b3d4d10d1da8230e8c9bf668"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38680,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:35.553,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: uvcvideo: Fix 1-byte out-of-bounds read in uvc_parse_format() The buffer length check before calling uvc_parse_format() only ensured that the buffer has at least 3 bytes (buflen > 2), buf the function accesses buffer[3], requiring at least 4 bytes. This can lead to an out-of-bounds read if the buffer has exactly 3 bytes. Fix it by checking that the buffer has at least 4 bytes in uvc_parse_format().",,"[{""url"":""https://git.kernel.org/stable/c/1e269581b3aa5962fdc52757ab40da286168c087"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/424980d33b3f816485513e538610168b03fab9f1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6d4a7c0b296162354b6fc759a1475b9d57ddfaa6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/782b6a718651eda3478b1824b37a8b3185d2740c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8343f3fe0b755925f83d60b05e92bf4396879758"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ad554217c9b945031c73df4e8176a475e2dea57"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a97e062e4ff3dab84a2f1eb811e9eddc6699e2a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cac702a439050df65272c49184aef7975fe3eff2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ffdd82182953df643aa63d999b6f1653d0c93778"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38681,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:35.747,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm/ptdump: take the memory hotplug lock inside ptdump_walk_pgd() Memory hot remove unmaps and tears down various kernel page table regions as required. The ptdump code can race with concurrent modifications of the kernel page tables. When leaf entries are modified concurrently, the dump code may log stale or inconsistent information for a VA range, but this is otherwise not harmful. But when intermediate levels of kernel page table are freed, the dump code will continue to use memory that has been freed and potentially reallocated for another purpose. In such cases, the ptdump code may dereference bogus addresses, leading to a number of potential problems. To avoid the above mentioned race condition, platforms such as arm64, riscv and s390 take memory hotplug lock, while dumping kernel page table via the sysfs interface /sys/kernel/debug/kernel_page_tables. Similar race condition exists while checking for pages that might have been marked W+X via /sys/kernel/debug/kernel_page_tables/check_wx_pages which in turn calls ptdump_check_wx(). Instead of solving this race condition again, let's just move the memory hotplug lock inside generic ptdump_check_wx() which will benefit both the scenarios. Drop get_online_mems() and put_online_mems() combination from all existing platform ptdump code paths.",,"[{""url"":""https://git.kernel.org/stable/c/1636b5e9c3543b87d673e32a47e7c18698882425"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ee9a8c27bfd72c3f465004fa8455785d61be5e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/59305202c67fea50378dcad0cc199dbc13a0e99a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/67995d4244694928ce701928e530b5b4adeb17b4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/69bea84b06b5e779627e7afdbf4b60a7d231c76f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac25ec5fa2bf6e606dc7954488e4dded272fa9cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca8c414499f2e5337a95a76be0d21b728ee31c6b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff40839e018b82c4d756d035f34a63aa2d93be83"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38682,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:35.910,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: i2c: core: Fix double-free of fwnode in i2c_unregister_device() Before commit df6d7277e552 (""i2c: core: Do not dereference fwnode in struct device""), i2c_unregister_device() only called fwnode_handle_put() on of_node-s in the form of calling of_node_put(client->dev.of_node). But after this commit the i2c_client's fwnode now unconditionally gets fwnode_handle_put() on it. When the i2c_client has no primary (ACPI / OF) fwnode but it does have a software fwnode, the software-node will be the primary node and fwnode_handle_put() will put() it. But for the software fwnode device_remove_software_node() will also put() it leading to a double free: [ 82.665598] ------------[ cut here ]------------ [ 82.665609] refcount_t: underflow; use-after-free. [ 82.665808] WARNING: CPU: 3 PID: 1502 at lib/refcount.c:28 refcount_warn_saturate+0xba/0x11 ... [ 82.666830] RIP: 0010:refcount_warn_saturate+0xba/0x110 ... [ 82.666962] <TASK> [ 82.666971] i2c_unregister_device+0x60/0x90 Fix this by not calling fwnode_handle_put() when the primary fwnode is a software-node.",,"[{""url"":""https://git.kernel.org/stable/c/1c24e5fc0c7096e00c202a6a3e0c342c1afb47c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ffe02f7c4e36090154646612e67d331832f92037"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38683,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:36.047,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: hv_netvsc: Fix panic during namespace deletion with VF The existing code move the VF NIC to new namespace when NETDEV_REGISTER is received on netvsc NIC. During deletion of the namespace, default_device_exit_batch() >> default_device_exit_net() is called. When netvsc NIC is moved back and registered to the default namespace, it automatically brings VF NIC back to the default namespace. This will cause the default_device_exit_net() >> for_each_netdev_safe loop unable to detect the list end, and hit NULL ptr: [ 231.449420] mana 7870:00:00.0 enP30832s1: Moved VF to namespace with: eth0 [ 231.449656] BUG: kernel NULL pointer dereference, address: 0000000000000010 [ 231.450246] #PF: supervisor read access in kernel mode [ 231.450579] #PF: error_code(0x0000) - not-present page [ 231.450916] PGD 17b8a8067 P4D 0 [ 231.451163] Oops: Oops: 0000 [#1] SMP NOPTI [ 231.451450] CPU: 82 UID: 0 PID: 1394 Comm: kworker/u768:1 Not tainted 6.16.0-rc4+ #3 VOLUNTARY [ 231.452042] Hardware name: Microsoft Corporation Virtual Machine/Virtual Machine, BIOS Hyper-V UEFI Release v4.1 11/21/2024 [ 231.452692] Workqueue: netns cleanup_net [ 231.452947] RIP: 0010:default_device_exit_batch+0x16c/0x3f0 [ 231.453326] Code: c0 0c f5 b3 e8 d5 db fe ff 48 85 c0 74 15 48 c7 c2 f8 fd ca b2 be 10 00 00 00 48 8d 7d c0 e8 7b 77 25 00 49 8b 86 28 01 00 00 <48> 8b 50 10 4c 8b 2a 4c 8d 62 f0 49 83 ed 10 4c 39 e0 0f 84 d6 00 [ 231.454294] RSP: 0018:ff75fc7c9bf9fd00 EFLAGS: 00010246 [ 231.454610] RAX: 0000000000000000 RBX: 0000000000000002 RCX: 61c8864680b583eb [ 231.455094] RDX: ff1fa9f71462d800 RSI: ff75fc7c9bf9fd38 RDI: 0000000030766564 [ 231.455686] RBP: ff75fc7c9bf9fd78 R08: 0000000000000000 R09: 0000000000000000 [ 231.456126] R10: 0000000000000001 R11: 0000000000000004 R12: ff1fa9f70088e340 [ 231.456621] R13: ff1fa9f70088e340 R14: ffffffffb3f50c20 R15: ff1fa9f7103e6340 [ 231.457161] FS: 0000000000000000(0000) GS:ff1faa6783a08000(0000) knlGS:0000000000000000 [ 231.457707] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 231.458031] CR2: 0000000000000010 CR3: 0000000179ab2006 CR4: 0000000000b73ef0 [ 231.458434] Call Trace: [ 231.458600] <TASK> [ 231.458777] ops_undo_list+0x100/0x220 [ 231.459015] cleanup_net+0x1b8/0x300 [ 231.459285] process_one_work+0x184/0x340 To fix it, move the ns change to a workqueue, and take rtnl_lock to avoid changing the netdev list when default_device_exit_net() is using it.",,"[{""url"":""https://git.kernel.org/stable/c/2a70cbd1aef8b8be39992ab7b776ce1390091774"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/33caa208dba6fa639e8a92fd0c8320b652e5550c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3467c4ebb334658c6fcf3eabb64a6e8b2135e010"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ca41ab55d23a0aa71661a5a56a8f06c11db90dc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4293f6c5ccf735b26afeb6825def14d830e0367b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4eff1e57a8ef98d70451b94e8437e458b27dd234"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5276896e6923ebe8c68573779d784aaf7d987cce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d036104947176d030bec64792d54e1b4f4c7f318"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38684,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:36.210,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/sched: ets: use old 'nbands' while purging unused classes Shuang reported sch_ets test-case [1] crashing in ets_class_qlen_notify() after recent changes from Lion [2]. The problem is: in ets_qdisc_change() we purge unused DWRR queues; the value of 'q->nbands' is the new one, and the cleanup should be done with the old one. The problem is here since my first attempts to fix ets_qdisc_change(), but it surfaced again after the recent qdisc len accounting fixes. Fix it purging idle DWRR queues before assigning a new value of 'q->nbands', so that all purge operations find a consistent configuration: - old 'q->nbands' because it's needed by ets_class_find() - old 'q->nstrict' because it's needed by ets_class_is_strict() BUG: kernel NULL pointer dereference, address: 0000000000000000 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 0 P4D 0 Oops: Oops: 0000 [#1] SMP NOPTI CPU: 62 UID: 0 PID: 39457 Comm: tc Kdump: loaded Not tainted 6.12.0-116.el10.x86_64 #1 PREEMPT(voluntary) Hardware name: Dell Inc. PowerEdge R640/06DKY5, BIOS 2.12.2 07/09/2021 RIP: 0010:__list_del_entry_valid_or_report+0x4/0x80 Code: ff 4c 39 c7 0f 84 39 19 8e ff b8 01 00 00 00 c3 cc cc cc cc 66 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa <48> 8b 17 48 8b 4f 08 48 85 d2 0f 84 56 19 8e ff 48 85 c9 0f 84 ab RSP: 0018:ffffba186009f400 EFLAGS: 00010202 RAX: 00000000000000d6 RBX: 0000000000000000 RCX: 0000000000000004 RDX: ffff9f0fa29b69c0 RSI: 0000000000000000 RDI: 0000000000000000 RBP: ffffffffc12c2400 R08: 0000000000000008 R09: 0000000000000004 R10: ffffffffffffffff R11: 0000000000000004 R12: 0000000000000000 R13: ffff9f0f8cfe0000 R14: 0000000000100005 R15: 0000000000000000 FS: 00007f2154f37480(0000) GS:ffff9f269c1c0000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000000 CR3: 00000001530be001 CR4: 00000000007726f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 PKRU: 55555554 Call Trace: <TASK> ets_class_qlen_notify+0x65/0x90 [sch_ets] qdisc_tree_reduce_backlog+0x74/0x110 ets_qdisc_change+0x630/0xa40 [sch_ets] __tc_modify_qdisc.constprop.0+0x216/0x7f0 tc_modify_qdisc+0x7c/0x120 rtnetlink_rcv_msg+0x145/0x3f0 netlink_rcv_skb+0x53/0x100 netlink_unicast+0x245/0x390 netlink_sendmsg+0x21b/0x470 ____sys_sendmsg+0x39d/0x3d0 ___sys_sendmsg+0x9a/0xe0 __sys_sendmsg+0x7a/0xd0 do_syscall_64+0x7d/0x160 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7f2155114084 Code: 89 02 b8 ff ff ff ff eb bb 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 f3 0f 1e fa 80 3d 25 f0 0c 00 00 74 13 b8 2e 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 54 c3 0f 1f 00 48 83 ec 28 89 54 24 1c 48 89 RSP: 002b:00007fff1fd7a988 EFLAGS: 00000202 ORIG_RAX: 000000000000002e RAX: ffffffffffffffda RBX: 0000560ec063e5e0 RCX: 00007f2155114084 RDX: 0000000000000000 RSI: 00007fff1fd7a9f0 RDI: 0000000000000003 RBP: 00007fff1fd7aa60 R08: 0000000000000010 R09: 000000000000003f R10: 0000560ee9b3a010 R11: 0000000000000202 R12: 00007fff1fd7aae0 R13: 000000006891ccde R14: 0000560ec063e5e0 R15: 00007fff1fd7aad0 </TASK> [1] https://lore.kernel.org/netdev/e08c7f4a6882f260011909a868311c6e9b54f3e4.1639153474.git.dcaratti@redhat.com/ [2] https://lore.kernel.org/netdev/d912cbd7-193b-4269-9857-525bee8bbb6a@gmail.com/",,"[{""url"":""https://git.kernel.org/stable/c/5b3b346bc4c2aa2c428735438a11989d251f32f1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/84a24fb446ee07b22b64aae6f0e3f4a38266310a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/87c6efc5ce9c126ae4a781bc04504b83780e3650"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/970c1c731c4ede46d05f5b0355724d1e400cfbca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/97ec167cd2e8a81a2d87331a2ed92daf007542c8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bdfddcde86e8b9245d9c0c2efe2b6fe8dcf6bf41"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be9692dafdfb36d9c43afd9d4e1d9d9ba8e7b51b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d69f4a258cd91b3bcef7089eb0401005aae2aed5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38685,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:36.397,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fbdev: Fix vmalloc out-of-bounds write in fast_imageblit This issue triggers when a userspace program does an ioctl FBIOPUT_CON2FBMAP by passing console number and frame buffer number. Ideally this maps console to frame buffer and updates the screen if console is visible. As part of mapping it has to do resize of console according to frame buffer info. if this resize fails and returns from vc_do_resize() and continues further. At this point console and new frame buffer are mapped and sets display vars. Despite failure still it continue to proceed updating the screen at later stages where vc_data is related to previous frame buffer and frame buffer info and display vars are mapped to new frame buffer and eventully leading to out-of-bounds write in fast_imageblit(). This bheviour is excepted only when fg_console is equal to requested console which is a visible console and updates screen with invalid struct references in fbcon_putcs().",,"[{""url"":""https://git.kernel.org/stable/c/078e62bffca4b7e72e8f3550eb063ab981c36c7a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/27b118aebdd84161c8ff5ce49d9d536f2af10754"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c4d7ddaf1d43780b106bedc692679f965dc5a3a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/56701bf9eeb63219e378cb7fcbd066ea4eaeeb50"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/af0db3c1f898144846d4c172531a199bb3ca375d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cfec17721265e72e50cc69c6004fe3475cd38df2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ed9b8e5016230868c8d813d9179523f729fec8c6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38686,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:36.557,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: userfaultfd: fix a crash in UFFDIO_MOVE when PMD is a migration entry When UFFDIO_MOVE encounters a migration PMD entry, it proceeds with obtaining a folio and accessing it even though the entry is swp_entry_t. Add the missing check and let split_huge_pmd() handle migration entries. While at it also remove unnecessary folio check. [surenb@google.com: remove extra folio check, per David]",,"[{""url"":""https://git.kernel.org/stable/c/1202abad7a7ccd28c426d2844771a387b07629a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f1101a0a181243ad587ececdffc4845f035549f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aba6faec0103ed8f169be8dce2ead41fcb689446"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bb81c18dbd42650c844e160cafa7cbb20243a96a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38687,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:36.700,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: comedi: fix race between polling and detaching syzbot reports a use-after-free in comedi in the below link, which is due to comedi gladly removing the allocated async area even though poll requests are still active on the wait_queue_head inside of it. This can cause a use-after-free when the poll entries are later triggered or removed, as the memory for the wait_queue_head has been freed. We need to check there are no tasks queued on any of the subdevices' wait queues before allowing the device to be detached by the `COMEDI_DEVCONFIG` ioctl. Tasks will read-lock `dev->attach_lock` before adding themselves to the subdevice wait queue, so fix the problem in the `COMEDI_DEVCONFIG` ioctl handler by write-locking `dev->attach_lock` before checking that all of the subdevices are safe to be deleted. This includes testing for any sleepers on the subdevices' wait queues. It remains locked until the device has been detached. This requires the `comedi_device_detach()` function to be refactored slightly, moving the bulk of it into new function `comedi_device_detach_locked()`. Note that the refactor of `comedi_device_detach()` results in `comedi_device_cancel_all()` now being called while `dev->attach_lock` is write-locked, which wasn't the case previously, but that does not matter. Thanks to Jens Axboe for diagnosing the problem and co-developing this patch.",,"[{""url"":""https://git.kernel.org/stable/c/017198079551a2a5cf61eae966af3c4b145e1f3b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0f989f9d05492028afd2bded4b42023c57d8a76e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/35b6fc51c666fc96355be5cd633ed0fe4ccf68b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5724e82df4f9a4be62908362c97d522d25de75dd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5c4a2ffcbd052c69bbf4680677d4c4eaa5a252d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/71ca60d2e631cf9c63bcbc7017961c61ff04e419"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd4286123d6948ff638ea9cd5818ae4796d5d252"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d85fac8729c9acfd72368faff1d576ec585e5c8f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe67122ba781df44a1a9716eb1dfd751321ab512"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38688,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:36.863,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iommufd: Prevent ALIGN() overflow When allocating IOVA the candidate range gets aligned to the target alignment. If the range is close to ULONG_MAX then the ALIGN() can wrap resulting in a corrupted iova. Open code the ALIGN() using get_add_overflow() to prevent this. This simplifies the checks as we don't need to check for length earlier either. Consolidate the two copies of this code under a single helper. This bug would allow userspace to create a mapping that overlaps with some other mapping or a reserved range.",,"[{""url"":""https://git.kernel.org/stable/c/79fad1917802c28de51a479318a056a6fbe3e2f2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b42497e3c0e74db061eafad41c0cd7243c46436b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d19b817540c0abe84854a64ee9ee34cecc3bbeef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e42a046bb41dcdde4f766a17d8211842007ed537"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ebb6021560b94649bec6b8faba6fe0dca2218e81"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38689,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:37.013,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: x86/fpu: Fix NULL dereference in avx512_status() Problem ------- With CONFIG_X86_DEBUG_FPU enabled, reading /proc/[kthread]/arch_status causes a warning and a NULL pointer dereference. This is because the AVX-512 timestamp code uses x86_task_fpu() but doesn't check it for NULL. CONFIG_X86_DEBUG_FPU addles that function for kernel threads (PF_KTHREAD specifically), making it return NULL. The point of the warning was to ensure that kernel threads only access task->fpu after going through kernel_fpu_begin()/_end(). Note: all kernel tasks exposed in /proc have a valid task->fpu. Solution -------- One option is to silence the warning and check for NULL from x86_task_fpu(). However, that warning is fairly fresh and seems like a defense against misuse of the FPU state in kernel threads. Instead, stop outputting AVX-512_elapsed_ms for kernel threads altogether. The data was garbage anyway because avx512_timestamp is only updated for user threads, not kernel threads. If anyone ever wants to track kernel thread AVX-512 use, they can come back later and do it properly, separate from this bug fix. [ dhansen: mostly rewrite changelog ]",,"[{""url"":""https://git.kernel.org/stable/c/2ca887e81095b99d890a8878841f36f4920181e6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/31cd31c9e17ece125aad27259501a2af69ccb020"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38690,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:37.153,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/xe/migrate: prevent infinite recursion If the buf + offset is not aligned to XE_CAHELINE_BYTES we fallback to using a bounce buffer. However the bounce buffer here is allocated on the stack, and the only alignment requirement here is that it's naturally aligned to u8, and not XE_CACHELINE_BYTES. If the bounce buffer is also misaligned we then recurse back into the function again, however the new bounce buffer might also not be aligned, and might never be until we eventually blow through the stack, as we keep recursing. Instead of using the stack use kmalloc, which should respect the power-of-two alignment request here. Fixes a kernel panic when triggering this path through eudebug. v2 (Stuart): - Add build bug check for power-of-two restriction - s/EINVAL/ENOMEM/ (cherry picked from commit 38b34e928a08ba594c4bbf7118aa3aadacd62fff)",,"[{""url"":""https://git.kernel.org/stable/c/89f511c024879c5812cc0c010a6663b5e49950f3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d7a1cbebbb691891671def57407ba2f8ee914e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38691,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:37.297,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: pNFS: Fix uninited ptr deref in block/scsi layout The error occurs on the third attempt to encode extents. When function ext_tree_prepare_commit() reallocates a larger buffer to retry encoding extents, the ""layoutupdate_pages"" page array is initialized only after the retry loop. But ext_tree_free_commitdata() is called on every iteration and tries to put pages in the array, thus dereferencing uninitialized pointers. An additional problem is that there is no limit on the maximum possible buffer_size. When there are too many extents, the client may create a layoutcommit that is larger than the maximum possible RPC size accepted by the server. During testing, we observed two typical scenarios. First, one memory page for extents is enough when we work with small files, append data to the end of the file, or preallocate extents before writing. But when we fill a new large file without preallocating, the number of extents can be huge, and counting the number of written extents in ext_tree_encode_commit() does not help much. Since this number increases even more between unlocking and locking of ext_tree, the reallocated buffer may not be large enough again and again.",,"[{""url"":""https://git.kernel.org/stable/c/24334f3cf8a294f253071b5bf22d754dbb6d0f2d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2896f101110076ac6bf99d7aaf463d61e26f89dd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/37c3443a2685528f972d910a6fb87716b96fef46"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4f783333cbfa2ee7d4aa8e47f6bd1b3f77534fcf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/579b85f893d9885162e1cabf99a4a088916e143e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/94ec6d939031a616474376dadbf4a8d0ef8b0bcc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9768797c219326699778fba9cd3b607b2f1e7950"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9be5c04beca3202d0a5f09fb4b2ecb644caa0bc5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f0b2eee3fbba9b7e3746ef698424ef5e4a197776"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38692,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:37.447,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: exfat: add cluster chain loop check for dir An infinite loop may occur if the following conditions occur due to file system corruption. (1) Condition for exfat_count_dir_entries() to loop infinitely. - The cluster chain includes a loop. - There is no UNUSED entry in the cluster chain. (2) Condition for exfat_create_upcase_table() to loop infinitely. - The cluster chain of the root directory includes a loop. - There are no UNUSED entry and up-case table entry in the cluster chain of the root directory. (3) Condition for exfat_load_bitmap() to loop infinitely. - The cluster chain of the root directory includes a loop. - There are no UNUSED entry and bitmap entry in the cluster chain of the root directory. (4) Condition for exfat_find_dir_entry() to loop infinitely. - The cluster chain includes a loop. - The unused directory entries were exhausted by some operation. (5) Condition for exfat_check_dir_empty() to loop infinitely. - The cluster chain includes a loop. - The unused directory entries were exhausted by some operation. - All files and sub-directories under the directory are deleted. This commit adds checks to break the above infinite loop.",,"[{""url"":""https://git.kernel.org/stable/c/4c3cda20c4cf1871e27868d08fda06b79bc7d568"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/868f23286c1a13162330fa6c614fe350f78e3f82"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/99f9a97dce39ad413c39b92c90393bbd6778f3fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa8fe7b7b73d4c9a41bb96cb3fb3092f794ecb33"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e2066ca3ef49a30920d8536fa366b2a183a808ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38693,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:37.593,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: dvb-frontends: w7090p: fix null-ptr-deref in w7090p_tuner_write_serpar and w7090p_tuner_read_serpar In w7090p_tuner_write_serpar, msg is controlled by user. When msg[0].buf is null and msg[0].len is zero, former checks on msg[0].buf would be passed. If accessing msg[0].buf[2] without sanity check, null pointer deref would happen. We add check on msg[0].len to prevent crash. Similar commit: commit 0ed554fd769a (""media: dvb-usb: az6027: fix null-ptr-deref in az6027_i2c_xfer()"")",,"[{""url"":""https://git.kernel.org/stable/c/17b30e5ded062bd74f8ca6f317e1d415a8680665"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/39b06b93f24dff923c4183d564ed28c039150554"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/454a443eaa792c8865c861a282fe6d4f596abc3a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6bbaec6a036940e22318f0454b50b8000845ab59"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7a41ecfc3415ebe3b4c44f96b3337691dcf431a3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/99690a494d91a0dc86cebd628da4c62c40552bcb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3d77a3fc71c084575d3df4ec6544b3fb6ce587d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ed0234c8458b3149f15e496b48a1c9874dd24a1b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f98132a59ccc59a8b97987363bc99c8968934756"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38694,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:37.750,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: dvb-frontends: dib7090p: fix null-ptr-deref in dib7090p_rw_on_apb() In dib7090p_rw_on_apb, msg is controlled by user. When msg[0].buf is null and msg[0].len is zero, former checks on msg[0].buf would be passed. If accessing msg[0].buf[2] without sanity check, null pointer deref would happen. We add check on msg[0].len to prevent crash. Similar issue occurs when access msg[1].buf[0] and msg[1].buf[1]. Similar commit: commit 0ed554fd769a (""media: dvb-usb: az6027: fix null-ptr-deref in az6027_i2c_xfer()"")",,"[{""url"":""https://git.kernel.org/stable/c/09906650484a09b3a4d4b3d3065395856810becd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0bb32863426afe0badac25c28d59021f211d0f48"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/19eb5d8e6aa1169d368a4d69aae5572950deb89d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/529fd5593b721e6f4370c591f5086649ed149ff6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a0f744d6cdde81d7382e183f77a4080a39b206cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bc07cae4f36bb18d5b6a9ed835c1278ca44ec82e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c33280d6bd668dbdc5a5f07887cc63a52ab4789c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce5cac69b2edac3e3246fee03e8f4c2a1075238b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce8b7c711b9c4f040b5419729d0972db8e374324"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38695,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:37.903,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: lpfc: Check for hdwq null ptr when cleaning up lpfc_vport structure If a call to lpfc_sli4_read_rev() from lpfc_sli4_hba_setup() fails, the resultant cleanup routine lpfc_sli4_vport_delete_fcp_xri_aborted() may occur before sli4_hba.hdwqs are allocated. This may result in a null pointer dereference when attempting to take the abts_io_buf_list_lock for the first hardware queue. Fix by adding a null ptr check on phba->sli4_hba.hdwq and early return because this situation means there must have been an error during port initialization.",,"[{""url"":""https://git.kernel.org/stable/c/46a0602c24d7d425dd8e00c749cd64a934aac7ec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/571617f171f723b05f02d154a2e549a17eab4935"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e25ee1ecec91c61a8acf938ad338399cad464de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6698796282e828733cde3329c887b4ae9e5545e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6711ce7e9de4eb1a541ef30638df1294ea4267f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74bdf54a847dab209d2a8f65852f59b7fa156175"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7925dd68807cc8fd755b04ca99e7e6f1c04392e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/add68606a01dcccf18837a53e85b85caf0693b4b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3f55f46bb37a8ec73bfe3cfe36e3ecfa2945dfa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38696,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:38.060,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: MIPS: Don't crash in stack_top() for tasks without ABI or vDSO Not all tasks have an ABI associated or vDSO mapped, for example kthreads never do. If such a task ever ends up calling stack_top(), it will derefence the NULL ABI pointer and crash. This can for example happen when using kunit: mips_stack_top+0x28/0xc0 arch_pick_mmap_layout+0x190/0x220 kunit_vm_mmap_init+0xf8/0x138 __kunit_add_resource+0x40/0xa8 kunit_vm_mmap+0x88/0xd8 usercopy_test_init+0xb8/0x240 kunit_try_run_case+0x5c/0x1a8 kunit_generic_run_threadfn_adapter+0x28/0x50 kthread+0x118/0x240 ret_from_kernel_thread+0x14/0x1c Only dereference the ABI point if it is set. The GIC page is also included as it is specific to the vDSO. Also move the randomization adjustment into the same conditional.",,"[{""url"":""https://git.kernel.org/stable/c/24d098b6f69b0aa806ffcb3e18259bee31650b28"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5b6839b572b503609b9b58bc6c04a816eefa0794"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/82d140f6aab5e89a9d3972697a0dbe1498752d9b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ab18e48a503230d675e824a0d68a108bdff42503"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd90dbd196831f5c2620736dc221db2634cf1e8e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cddf47d20b0325dc8a4e57b833fe96e8f36c42a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e78033e59444d257d095b73ce5d20625294f6ec2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e9f4a6b3421e936c3ee9d74710243897d74dbaa2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f22de2027b206ddfb8a075800bb5d0dacf2da4b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38697,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:38.210,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: jfs: upper bound check of tree index in dbAllocAG When computing the tree index in dbAllocAG, we never check if we are out of bounds realative to the size of the stree. This could happen in a scenario where the filesystem metadata are corrupted.",,"[{""url"":""https://git.kernel.org/stable/c/1467a75819e41341cd5ebd16faa2af1ca3c8f4fe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/173cfd741ad7073640bfb7e2344c2a0ee005e769"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2dd05f09cc323018136a7ecdb3d1007be9ede27f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/30e19a884c0b11f33821aacda7e72e914bec26ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/49ea46d9025aa1914b24ea957636cbe4367a7311"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5bdb9553fb134fd52ec208a8b378120670f6e784"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a4f199203f79ca9cd7355799ccb26800174ff093"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c214006856ff52a8ff17ed8da52d50601d54f9ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c8ca21a2836993d7cb816668458e05e598574e55"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38698,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:38.370,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: jfs: Regular file corruption check The reproducer builds a corrupted file on disk with a negative i_size value. Add a check when opening this file to avoid subsequent operation failures.",,"[{""url"":""https://git.kernel.org/stable/c/00462be586b33076f8b8023e7ba697deedc131db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/02edcfda419168d9405bffe55f18ea9c1bf92366"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2d04df8116426b6c7b9f8b9b371250f666a2a2fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6bc86f1d7d5419d5b19483ba203ca0b760c41c51"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/78989af5bbf55a0cf1165b0fa73921bc02f1543b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9605cb2ea38ba014d0e704cba0dbbb00593fa9fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ad054cd2c4ca8c371e555748832aa217c41fc65"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9f896c3d0192241d6438be6963682ace8203f502"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd9454b7710b28060faa49b041f8283c435721a3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38699,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:38.527,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: bfa: Double-free fix When the bfad_im_probe() function fails during initialization, the memory pointed to by bfad->im is freed without setting bfad->im to NULL. Subsequently, during driver uninstallation, when the state machine enters the bfad_sm_stopping state and calls the bfad_im_probe_undo() function, it attempts to free the memory pointed to by bfad->im again, thereby triggering a double-free vulnerability. Set bfad->im to NULL if probing fails.",,"[{""url"":""https://git.kernel.org/stable/c/13f613228cf3c96a038424cd97aa4d6aadc66294"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/39cfe2c83146aad956318f866d0ee471b7a61fa5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/50d9bd48321038bd6e15af5a454bbcd180cf6f80"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/684c92bb08a25ed3c0356bc7eb532ed5b19588dd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8456f862cb95bcc3a831e1ba87c0c17068be0f3f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e03dd9fadf76db5b9799583074a1a2a54f787f1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9337c2affbaebe00b75fdf84ea0e2fcf93c140af"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/add4c4850363d7c1b72e8fce9ccb21fdd2cf5dc9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba024d92564580bb90ec367248ace8efe16ce815"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38700,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:38.680,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: libiscsi: Initialize iscsi_conn->dd_data only if memory is allocated In case of an ib_fast_reg_mr allocation failure during iSER setup, the machine hits a panic because iscsi_conn->dd_data is initialized unconditionally, even when no memory is allocated (dd_size == 0). This leads invalid pointer dereference during connection teardown. Fix by setting iscsi_conn->dd_data only if memory is actually allocated. Panic trace: ------------ iser: iser_create_fastreg_desc: Failed to allocate ib_fast_reg_mr err=-12 iser: iser_alloc_rx_descriptors: failed allocating rx descriptors / data buffers BUG: unable to handle page fault for address: fffffffffffffff8 RIP: 0010:swake_up_locked.part.5+0xa/0x40 Call Trace: complete+0x31/0x40 iscsi_iser_conn_stop+0x88/0xb0 [ib_iser] iscsi_stop_conn+0x66/0xc0 [scsi_transport_iscsi] iscsi_if_stop_conn+0x14a/0x150 [scsi_transport_iscsi] iscsi_if_rx+0x1135/0x1834 [scsi_transport_iscsi] ? netlink_lookup+0x12f/0x1b0 ? netlink_deliver_tap+0x2c/0x200 netlink_unicast+0x1ab/0x280 netlink_sendmsg+0x257/0x4f0 ? _copy_from_user+0x29/0x60 sock_sendmsg+0x5f/0x70",,"[{""url"":""https://git.kernel.org/stable/c/2b242ea14386a510010eabfbfc3ce81a101f3802"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/35782c32528d82aa21f84cb5ceb2abd3526a8159"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ea3a256ed81f95ab0f3281a0e234b01a9cae605"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/66a373f50b4249d57f5a88c7be9676f9d5884865"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ea6d961566c7d762ed0204b06db05756fdda3b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a145c269dc5380c063a20a0db7e6df2995962e9d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a33d42b7fc24fe03f239fbb0880dd5b4b4b97c19"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f53af99f441ee79599d8df6113a7144d74cf9153"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd5aad080edb501ab5c84b7623d612d0e3033403"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38701,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:38.833,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: do not BUG when INLINE_DATA_FL lacks system.data xattr A syzbot fuzzed image triggered a BUG_ON in ext4_update_inline_data() when an inode had the INLINE_DATA_FL flag set but was missing the system.data extended attribute. Since this can happen due to a maiciouly fuzzed file system, we shouldn't BUG, but rather, report it as a corrupted file system. Add similar replacements of BUG_ON with EXT4_ERROR_INODE() ii ext4_create_inline_data() and ext4_inline_data_truncate().",,"[{""url"":""https://git.kernel.org/stable/c/099b847ccc6c1ad2f805d13cfbcc83f5b6d4bc42"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1199a6399895f4767f0b9a68a6ff47c3f799b7c7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/279c87ef7b9da34f65c2e4db586e730b667a6fb9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2817ac83cb4732597bf36853fe13ca616f4ee4e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f322c12df7aeed1755acd3c6fab48c7807795fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8085a7324d8ec448c4a764af7853e19bbd64e17a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/81e7e2e7ba07e7c8cdce43ccad2f91adbc5a919c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8a6f89d42e61788605722dd9faf98797c958a7e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d960f4b793912f35e9d72bd9d1e90553063fcbf1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38702,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:38.990,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fbdev: fix potential buffer overflow in do_register_framebuffer() The current implementation may lead to buffer overflow when: 1. Unregistration creates NULL gaps in registered_fb[] 2. All array slots become occupied despite num_registered_fb < FB_MAX 3. The registration loop exceeds array bounds Add boundary check to prevent registered_fb[FB_MAX] access.",,"[{""url"":""https://git.kernel.org/stable/c/248b2aab9b2af5ecf89d9d7955a2ff20c4b4a399"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2828a433c7d7a05b6f27c8148502095101dd0b09"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/523b84dc7ccea9c4d79126d6ed1cf9033cf83b05"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5c3f5a25c62230b7965804ce7a2e9305c3ca3961"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/806f85bdd3a60187c21437fc51baace11f659f35"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cbe740de32bb0fb7a5213731ff5f26ea6718fca3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38703,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:39.130,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/xe: Make dma-fences compliant with the safe access rules Xe can free some of the data pointed to by the dma-fences it exports. Most notably the timeline name can get freed if userspace closes the associated submit queue. At the same time the fence could have been exported to a third party (for example a sync_fence fd) which will then cause an use- after-free on subsequent access. To make this safe we need to make the driver compliant with the newly documented dma-fence rules. Driver has to ensure a RCU grace period between signalling a fence and freeing any data pointed to by said fence. For the timeline name we simply make the queue be freed via kfree_rcu and for the shared lock associated with multiple queues we add a RCU grace period before freeing the per GT structure holding the lock.",,"[{""url"":""https://git.kernel.org/stable/c/683b0e397dad9f26a42dcacf6f7f545a77ce6c06"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6bd90e700b4285e6a7541e00f969cab0d696adde"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b17fcce70733c211cb5dabf54f4f9491920b1d92"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba37807d08bae67de6139346a85650cab5f6145a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38704,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:39.263,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: rcu/nocb: Fix possible invalid rdp's->nocb_cb_kthread pointer access In the preparation stage of CPU online, if the corresponding the rdp's->nocb_cb_kthread does not exist, will be created, there is a situation where the rdp's rcuop kthreads creation fails, and then de-offload this CPU's rdp, does not assign this CPU's rdp->nocb_cb_kthread pointer, but this rdp's->nocb_gp_rdp and rdp's->rdp_gp->nocb_gp_kthread is still valid. This will cause the subsequent re-offload operation of this offline CPU, which will pass the conditional check and the kthread_unpark() will access invalid rdp's->nocb_cb_kthread pointer. This commit therefore use rdp's->nocb_gp_kthread instead of rdp_gp's->nocb_gp_kthread for safety check.",,"[{""url"":""https://git.kernel.org/stable/c/1bba3900ca18bdae28d1b9fa10f16a8f8cb2ada1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1c951683a720b17c9ecaad1932bc95b29044611f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9b5ec8e6b31755288a07b3abeeab8cd38e9d3c9d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cce3d027227c69e85896af9fbc6fa9af5c68f067"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38705,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:39.403,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/pm: fix null pointer access Writing a string without delimiters (' ', '\n', '\0') to the under gpu_od/fan_ctrl sysfs or pp_power_profile_mode for the CUSTOM profile will result in a null pointer dereference.",,"[{""url"":""https://git.kernel.org/stable/c/5d8cc029e5595760c7d18c64632e8e40a86a9b2e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a83ffafd02a7af59848755c109d544e3894af737"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cef79c18538e9ce2ca6e5b3fa95c38ec41dcd07a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d524d40e3a6152a3ea1125af729f8cd8ca65efde"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38706,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:39.550,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: core: Check for rtd == NULL in snd_soc_remove_pcm_runtime() snd_soc_remove_pcm_runtime() might be called with rtd == NULL which will leads to null pointer dereference. This was reproduced with topology loading and marking a link as ignore due to missing hardware component on the system. On module removal the soc_tplg_remove_link() would call snd_soc_remove_pcm_runtime() with rtd == NULL since the link was ignored, no runtime was created.",,"[{""url"":""https://git.kernel.org/stable/c/2d91cb261cac6d885954b8f5da28b5c176c18131"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2fce20decc6a83f16dd73744150c4e7ea6c97c21"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/41f53afe53a57a7c50323f99424b598190acf192"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ce0a7255ce97ed7c54afae83fdbce712a1f0c9e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f8fc03712194fd4e2df28af7f7f7a38205934ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/82ba7b8cf9f6e3bf392a9f08ba3d1c0b200ccb94"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8b465bedc2b417fd27c1d1ab7122882b4b60b1a0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cecc65827ef3df9754e097582d89569139e6cd1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38707,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:39.697,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: Add sanity check for file name The length of the file name should be smaller than the directory entry size.",,"[{""url"":""https://git.kernel.org/stable/c/27ee9a42b245efe6529e28b03453291a775cb3e4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2ac47f738ddfc1957a33be163bc97ee8f78e85a6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3572737a768dadea904ebc4eb34b6ed575bb72d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b51642fc52d1c7243a9361555d5c4b24d7569d7e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bde58c1539f3ffddffc94d64007de16964e6b8eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e841ecb139339602bc1853f5f09daa5d1ea920a2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f99eb9a641f4ef927d8724f4966dcfd1f0e9f835"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38708,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:39.847,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drbd: add missing kref_get in handle_write_conflicts With `two-primaries` enabled, DRBD tries to detect ""concurrent"" writes and handle write conflicts, so that even if you write to the same sector simultaneously on both nodes, they end up with the identical data once the writes are completed. In handling ""superseeded"" writes, we forgot a kref_get, resulting in a premature drbd_destroy_device and use after free, and further to kernel crashes with symptoms. Relevance: No one should use DRBD as a random data generator, and apparently all users of ""two-primaries"" handle concurrent writes correctly on layer up. That is cluster file systems use some distributed lock manager, and live migration in virtualization environments stops writes on one node before starting writes on the other node. Which means that other than for ""test cases"", this code path is never taken in real life. FYI, in DRBD 9, things are handled differently nowadays. We still detect ""write conflicts"", but no longer try to be smart about them. We decided to disconnect hard instead: upper layers must not submit concurrent writes. If they do, that's their fault.",,"[{""url"":""https://git.kernel.org/stable/c/00c9c9628b49e368d140cfa61d7df9b8922ec2a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0336bfe9c237476bd7c45605a36ca79c2bca62e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3a896498f6f577e57bf26aaa93b48c22b6d20c20"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/46e3763dcae0ffcf8fcfaff4fc10a90a92ffdd89"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/57418de35420cedab035aa1da8a26c0499b7f575"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d483ad300fc0a06f69b019dda8f74970714baf8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/810cd546a29bfac90ed1328ea01d693d4bd11cb1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/84ef8dd3238330d1795745ece83b19f0295751bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9f53b2433ad248cd3342cc345f56f5c7904bd8c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38709,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:39.997,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: loop: Avoid updating block size under exclusive owner Syzbot came up with a reproducer where a loop device block size is changed underneath a mounted filesystem. This causes a mismatch between the block device block size and the block size stored in the superblock causing confusion in various places such as fs/buffer.c. The particular issue triggered by syzbot was a warning in __getblk_slow() due to requested buffer size not matching block device block size. Fix the problem by getting exclusive hold of the loop device to change its block size. This fails if somebody (such as filesystem) has already an exclusive ownership of the block device and thus prevents modifying the loop device under some exclusive owner which doesn't expect it.",,"[{""url"":""https://git.kernel.org/stable/c/139a000d20f2f38ce34296feddd641d730fe1c08"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5d67b30aefeb7a949040bbb1b4e3b84c5d29a624"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7e49538288e523427beedd26993d446afef1a6fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b928438cc87c0bf7ae078e4b7b6e14261e84c5c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce8da5d13d8c2a7b30b2fb376a22e8eb1a70b8bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38710,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:40.137,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: gfs2: Validate i_depth for exhash directories A fuzzer test introduced corruption that ends up with a depth of 0 in dir_e_read(), causing an undefined shift by 32 at: index = hash >> (32 - dip->i_depth); As calculated in an open-coded way in dir_make_exhash(), the minimum depth for an exhash directory is ilog2(sdp->sd_hash_ptrs) and 0 is invalid as sdp->sd_hash_ptrs is fixed as sdp->bsize / 16 at mount time. So we can avoid the undefined behaviour by checking for depth values lower than the minimum in gfs2_dinode_in(). Values greater than the maximum are already being checked for there. Also switch the calculation in dir_make_exhash() to use ilog2() to clarify how the depth is calculated. Tested with the syzkaller repro.c and xfstests '-g quick'.",,"[{""url"":""https://git.kernel.org/stable/c/53a0249d68a210c16e961b83adfa82f94ee0a53d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/557c024ca7250bb65ae60f16c02074106c2f197b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9680c58675b82348ab84d387e4fa727f7587e1a0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b5f46951e62377b6e406fadc18bc3c5bdf1632a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38711,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:40.280,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: smb/server: avoid deadlock when linking with ReplaceIfExists If smb2_create_link() is called with ReplaceIfExists set and the name does exist then a deadlock will happen. ksmbd_vfs_kern_path_locked() will return with success and the parent directory will be locked. ksmbd_vfs_remove_file() will then remove the file. ksmbd_vfs_link() will then be called while the parent is still locked. It will try to lock the same parent and will deadlock. This patch moves the ksmbd_vfs_kern_path_unlock() call to *before* ksmbd_vfs_link() and then simplifies the code, removing the file_present flag variable.",,"[{""url"":""https://git.kernel.org/stable/c/1e858a7a51c7b8b009d8f246de7ceb7743b44a71"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/814cfdb6358d9b84fcbec9918c8f938cc096a43a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d5012ffe14120f978ee34aef4df3d6cb026b7c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a726fef6d7d4cfc365d3434e3916dbfe78991a33"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a7dddd62578c2eb6cb28b8835556a121b5157323"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac98d54630d5b52e3f684d872f0d82c06c418ea9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d5fc1400a34b4ea5e8f2ce296ea12bf8c8421694"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38712,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:40.437,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: hfsplus: don't use BUG_ON() in hfsplus_create_attributes_file() When the volume header contains erroneous values that do not reflect the actual state of the filesystem, hfsplus_fill_super() assumes that the attributes file is not yet created, which later results in hitting BUG_ON() when hfsplus_create_attributes_file() is called. Replace this BUG_ON() with -EIO error with a message to suggest running fsck tool.",,"[{""url"":""https://git.kernel.org/stable/c/03cd1db1494cf930e2fa042c9c13e32bffdb4eba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1bb8da27ff15e346d4bc9e248e819c9a88ebf9d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9046566fa692f88954dac8c510f37ee17a15fdb7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3359392b75395a31af739a761f48f4041148226"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bb0eea8e375677f586ad11c12e2525ed3fc698c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c7c6363ca186747ebc2df10c8a1a51e66e0e32d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce5e387f396cbb5c061d9837abcac731e9e06f4d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d768e3ed430e89a699bf89d3214dcbbf4648c939"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dee5c668ad71ddbcb4b48d95e8a4f371314ad41d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38713,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:40.657,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: hfsplus: fix slab-out-of-bounds read in hfsplus_uni2asc() The hfsplus_readdir() method is capable to crash by calling hfsplus_uni2asc(): [ 667.121659][ T9805] ================================================================== [ 667.122651][ T9805] BUG: KASAN: slab-out-of-bounds in hfsplus_uni2asc+0x902/0xa10 [ 667.123627][ T9805] Read of size 2 at addr ffff88802592f40c by task repro/9805 [ 667.124578][ T9805] [ 667.124876][ T9805] CPU: 3 UID: 0 PID: 9805 Comm: repro Not tainted 6.16.0-rc3 #1 PREEMPT(full) [ 667.124886][ T9805] Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 [ 667.124890][ T9805] Call Trace: [ 667.124893][ T9805] <TASK> [ 667.124896][ T9805] dump_stack_lvl+0x10e/0x1f0 [ 667.124911][ T9805] print_report+0xd0/0x660 [ 667.124920][ T9805] ? __virt_addr_valid+0x81/0x610 [ 667.124928][ T9805] ? __phys_addr+0xe8/0x180 [ 667.124934][ T9805] ? hfsplus_uni2asc+0x902/0xa10 [ 667.124942][ T9805] kasan_report+0xc6/0x100 [ 667.124950][ T9805] ? hfsplus_uni2asc+0x902/0xa10 [ 667.124959][ T9805] hfsplus_uni2asc+0x902/0xa10 [ 667.124966][ T9805] ? hfsplus_bnode_read+0x14b/0x360 [ 667.124974][ T9805] hfsplus_readdir+0x845/0xfc0 [ 667.124984][ T9805] ? __pfx_hfsplus_readdir+0x10/0x10 [ 667.124994][ T9805] ? stack_trace_save+0x8e/0xc0 [ 667.125008][ T9805] ? iterate_dir+0x18b/0xb20 [ 667.125015][ T9805] ? trace_lock_acquire+0x85/0xd0 [ 667.125022][ T9805] ? lock_acquire+0x30/0x80 [ 667.125029][ T9805] ? iterate_dir+0x18b/0xb20 [ 667.125037][ T9805] ? down_read_killable+0x1ed/0x4c0 [ 667.125044][ T9805] ? putname+0x154/0x1a0 [ 667.125051][ T9805] ? __pfx_down_read_killable+0x10/0x10 [ 667.125058][ T9805] ? apparmor_file_permission+0x239/0x3e0 [ 667.125069][ T9805] iterate_dir+0x296/0xb20 [ 667.125076][ T9805] __x64_sys_getdents64+0x13c/0x2c0 [ 667.125084][ T9805] ? __pfx___x64_sys_getdents64+0x10/0x10 [ 667.125091][ T9805] ? __x64_sys_openat+0x141/0x200 [ 667.125126][ T9805] ? __pfx_filldir64+0x10/0x10 [ 667.125134][ T9805] ? do_user_addr_fault+0x7fe/0x12f0 [ 667.125143][ T9805] do_syscall_64+0xc9/0x480 [ 667.125151][ T9805] entry_SYSCALL_64_after_hwframe+0x77/0x7f [ 667.125158][ T9805] RIP: 0033:0x7fa8753b2fc9 [ 667.125164][ T9805] Code: 00 c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 48 [ 667.125172][ T9805] RSP: 002b:00007ffe96f8e0f8 EFLAGS: 00000217 ORIG_RAX: 00000000000000d9 [ 667.125181][ T9805] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fa8753b2fc9 [ 667.125185][ T9805] RDX: 0000000000000400 RSI: 00002000000063c0 RDI: 0000000000000004 [ 667.125190][ T9805] RBP: 00007ffe96f8e110 R08: 00007ffe96f8e110 R09: 00007ffe96f8e110 [ 667.125195][ T9805] R10: 0000000000000000 R11: 0000000000000217 R12: 0000556b1e3b4260 [ 667.125199][ T9805] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000 [ 667.125207][ T9805] </TASK> [ 667.125210][ T9805] [ 667.145632][ T9805] Allocated by task 9805: [ 667.145991][ T9805] kasan_save_stack+0x20/0x40 [ 667.146352][ T9805] kasan_save_track+0x14/0x30 [ 667.146717][ T9805] __kasan_kmalloc+0xaa/0xb0 [ 667.147065][ T9805] __kmalloc_noprof+0x205/0x550 [ 667.147448][ T9805] hfsplus_find_init+0x95/0x1f0 [ 667.147813][ T9805] hfsplus_readdir+0x220/0xfc0 [ 667.148174][ T9805] iterate_dir+0x296/0xb20 [ 667.148549][ T9805] __x64_sys_getdents64+0x13c/0x2c0 [ 667.148937][ T9805] do_syscall_64+0xc9/0x480 [ 667.149291][ T9805] entry_SYSCALL_64_after_hwframe+0x77/0x7f [ 667.149809][ T9805] [ 667.150030][ T9805] The buggy address belongs to the object at ffff88802592f000 [ 667.150030][ T9805] which belongs to the cache kmalloc-2k of size 2048 [ 667.151282][ T9805] The buggy address is located 0 bytes to the right of [ 667.151282][ T9805] allocated 1036-byte region [ffff88802592f000, ffff88802592f40c) [ 667.1 ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/13604b1d7e7b125fb428cddbec6b8d92baad25d5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1ca69007e52a73bd8b84b988b61b319816ca8b01"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/291bb5d931c6f3cd7227b913302a17be21cf53b0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6f93694bcbc2c2ab3e01cd8fba2f296faf34e6b9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73f7da507d787b489761a0fa280716f84fa32b2f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/76a4c6636a69d69409aa253b049b1be717a539c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/94458781aee6045bd3d0ad4b80b02886b9e2219b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ccf0ad56a779e6704c0b27f555dec847f50c7557"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f7534cbfac0a9ffa4fa17cacc6e8b6446dae24ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38714,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:40.820,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: hfsplus: fix slab-out-of-bounds in hfsplus_bnode_read() The hfsplus_bnode_read() method can trigger the issue: [ 174.852007][ T9784] ================================================================== [ 174.852709][ T9784] BUG: KASAN: slab-out-of-bounds in hfsplus_bnode_read+0x2f4/0x360 [ 174.853412][ T9784] Read of size 8 at addr ffff88810b5fc6c0 by task repro/9784 [ 174.854059][ T9784] [ 174.854272][ T9784] CPU: 1 UID: 0 PID: 9784 Comm: repro Not tainted 6.16.0-rc3 #7 PREEMPT(full) [ 174.854281][ T9784] Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 [ 174.854286][ T9784] Call Trace: [ 174.854289][ T9784] <TASK> [ 174.854292][ T9784] dump_stack_lvl+0x10e/0x1f0 [ 174.854305][ T9784] print_report+0xd0/0x660 [ 174.854315][ T9784] ? __virt_addr_valid+0x81/0x610 [ 174.854323][ T9784] ? __phys_addr+0xe8/0x180 [ 174.854330][ T9784] ? hfsplus_bnode_read+0x2f4/0x360 [ 174.854337][ T9784] kasan_report+0xc6/0x100 [ 174.854346][ T9784] ? hfsplus_bnode_read+0x2f4/0x360 [ 174.854354][ T9784] hfsplus_bnode_read+0x2f4/0x360 [ 174.854362][ T9784] hfsplus_bnode_dump+0x2ec/0x380 [ 174.854370][ T9784] ? __pfx_hfsplus_bnode_dump+0x10/0x10 [ 174.854377][ T9784] ? hfsplus_bnode_write_u16+0x83/0xb0 [ 174.854385][ T9784] ? srcu_gp_start+0xd0/0x310 [ 174.854393][ T9784] ? __mark_inode_dirty+0x29e/0xe40 [ 174.854402][ T9784] hfsplus_brec_remove+0x3d2/0x4e0 [ 174.854411][ T9784] __hfsplus_delete_attr+0x290/0x3a0 [ 174.854419][ T9784] ? __pfx_hfs_find_1st_rec_by_cnid+0x10/0x10 [ 174.854427][ T9784] ? __pfx___hfsplus_delete_attr+0x10/0x10 [ 174.854436][ T9784] ? __asan_memset+0x23/0x50 [ 174.854450][ T9784] hfsplus_delete_all_attrs+0x262/0x320 [ 174.854459][ T9784] ? __pfx_hfsplus_delete_all_attrs+0x10/0x10 [ 174.854469][ T9784] ? rcu_is_watching+0x12/0xc0 [ 174.854476][ T9784] ? __mark_inode_dirty+0x29e/0xe40 [ 174.854483][ T9784] hfsplus_delete_cat+0x845/0xde0 [ 174.854493][ T9784] ? __pfx_hfsplus_delete_cat+0x10/0x10 [ 174.854507][ T9784] hfsplus_unlink+0x1ca/0x7c0 [ 174.854516][ T9784] ? __pfx_hfsplus_unlink+0x10/0x10 [ 174.854525][ T9784] ? down_write+0x148/0x200 [ 174.854532][ T9784] ? __pfx_down_write+0x10/0x10 [ 174.854540][ T9784] vfs_unlink+0x2fe/0x9b0 [ 174.854549][ T9784] do_unlinkat+0x490/0x670 [ 174.854557][ T9784] ? __pfx_do_unlinkat+0x10/0x10 [ 174.854565][ T9784] ? __might_fault+0xbc/0x130 [ 174.854576][ T9784] ? getname_flags.part.0+0x1c5/0x550 [ 174.854584][ T9784] __x64_sys_unlink+0xc5/0x110 [ 174.854592][ T9784] do_syscall_64+0xc9/0x480 [ 174.854600][ T9784] entry_SYSCALL_64_after_hwframe+0x77/0x7f [ 174.854608][ T9784] RIP: 0033:0x7f6fdf4c3167 [ 174.854614][ T9784] Code: f0 ff ff 73 01 c3 48 8b 0d 26 0d 0e 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 08 [ 174.854622][ T9784] RSP: 002b:00007ffcb948bca8 EFLAGS: 00000206 ORIG_RAX: 0000000000000057 [ 174.854630][ T9784] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f6fdf4c3167 [ 174.854636][ T9784] RDX: 00007ffcb948bcc0 RSI: 00007ffcb948bcc0 RDI: 00007ffcb948bd50 [ 174.854641][ T9784] RBP: 00007ffcb948cd90 R08: 0000000000000001 R09: 00007ffcb948bb40 [ 174.854645][ T9784] R10: 00007f6fdf564fc0 R11: 0000000000000206 R12: 0000561e1bc9c2d0 [ 174.854650][ T9784] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000 [ 174.854658][ T9784] </TASK> [ 174.854661][ T9784] [ 174.879281][ T9784] Allocated by task 9784: [ 174.879664][ T9784] kasan_save_stack+0x20/0x40 [ 174.880082][ T9784] kasan_save_track+0x14/0x30 [ 174.880500][ T9784] __kasan_kmalloc+0xaa/0xb0 [ 174.880908][ T9784] __kmalloc_noprof+0x205/0x550 [ 174.881337][ T9784] __hfs_bnode_create+0x107/0x890 [ 174.881779][ T9784] hfsplus_bnode_find+0x2d0/0xd10 [ 174.882222][ T9784] hfsplus_brec_find+0x2b0/0x520 [ 174.882659][ T9784] hfsplus_delete_all_attrs+0x23b/0x3 ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/032f7ed6717a4cd3714f9801be39fdfc7f1c7644"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/291b7f2538920aa229500dbdd6c5f0927a51bc8b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/475d770c19929082aab43337e6c077d0e2043df3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5ab59229bef6063edf3a6fc2e3e3fd7cd2181b29"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7fa4cef8ea13b37811287ef60674c5fd1dd02ee6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8583d067ae22b7f32ce5277ca5543ac8bf86a3e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a2abd574d2fe22b8464cf6df5abb6f24d809eac0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c80aa2aaaa5e69d5219c6af8ef7e754114bd08d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ffee8a7bed0fbfe29da239a922b59c5db897c613"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38715,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:40.970,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: hfs: fix slab-out-of-bounds in hfs_bnode_read() This patch introduces is_bnode_offset_valid() method that checks the requested offset value. Also, it introduces check_and_correct_requested_length() method that checks and correct the requested length (if it is necessary). These methods are used in hfs_bnode_read(), hfs_bnode_write(), hfs_bnode_clear(), hfs_bnode_copy(), and hfs_bnode_move() with the goal to prevent the access out of allocated memory and triggering the crash.",,"[{""url"":""https://git.kernel.org/stable/c/384a66b89f9540a9a8cb0f48807697dfabaece4c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/67ecc81f6492275c9c54280532f558483c99c90e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a1a60e79502279f996e55052f50cc14919020475"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a431930c9bac518bf99d6b1da526a7f37ddee8d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e7d2dc2421e821e4045775e6dc226378328de6f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eec522fd0d28106b14a59ab2d658605febe4a3bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/efc095b35b23297e419c2ab4fc1ed1a8f0781a29"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc7f732984ec91f30be3e574e0644066d07f2b78"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe2891a9c43ab87d1a210d61e6438ca6936e2f62"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38716,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:41.120,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: hfs: fix general protection fault in hfs_find_init() The hfs_find_init() method can trigger the crash if tree pointer is NULL: [ 45.746290][ T9787] Oops: general protection fault, probably for non-canonical address 0xdffffc0000000008: 0000 [#1] SMP KAI [ 45.747287][ T9787] KASAN: null-ptr-deref in range [0x0000000000000040-0x0000000000000047] [ 45.748716][ T9787] CPU: 2 UID: 0 PID: 9787 Comm: repro Not tainted 6.16.0-rc3 #10 PREEMPT(full) [ 45.750250][ T9787] Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 [ 45.751983][ T9787] RIP: 0010:hfs_find_init+0x86/0x230 [ 45.752834][ T9787] Code: c1 ea 03 80 3c 02 00 0f 85 9a 01 00 00 4c 8d 6b 40 48 c7 45 18 00 00 00 00 48 b8 00 00 00 00 00 fc [ 45.755574][ T9787] RSP: 0018:ffffc90015157668 EFLAGS: 00010202 [ 45.756432][ T9787] RAX: dffffc0000000000 RBX: 0000000000000000 RCX: ffffffff819a4d09 [ 45.757457][ T9787] RDX: 0000000000000008 RSI: ffffffff819acd3a RDI: ffffc900151576e8 [ 45.758282][ T9787] RBP: ffffc900151576d0 R08: 0000000000000005 R09: 0000000000000000 [ 45.758943][ T9787] R10: 0000000080000000 R11: 0000000000000001 R12: 0000000000000004 [ 45.759619][ T9787] R13: 0000000000000040 R14: ffff88802c50814a R15: 0000000000000000 [ 45.760293][ T9787] FS: 00007ffb72734540(0000) GS:ffff8880cec64000(0000) knlGS:0000000000000000 [ 45.761050][ T9787] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 45.761606][ T9787] CR2: 00007f9bd8225000 CR3: 000000010979a000 CR4: 00000000000006f0 [ 45.762286][ T9787] Call Trace: [ 45.762570][ T9787] <TASK> [ 45.762824][ T9787] hfs_ext_read_extent+0x190/0x9d0 [ 45.763269][ T9787] ? submit_bio_noacct_nocheck+0x2dd/0xce0 [ 45.763766][ T9787] ? __pfx_hfs_ext_read_extent+0x10/0x10 [ 45.764250][ T9787] hfs_get_block+0x55f/0x830 [ 45.764646][ T9787] block_read_full_folio+0x36d/0x850 [ 45.765105][ T9787] ? __pfx_hfs_get_block+0x10/0x10 [ 45.765541][ T9787] ? const_folio_flags+0x5b/0x100 [ 45.765972][ T9787] ? __pfx_hfs_read_folio+0x10/0x10 [ 45.766415][ T9787] filemap_read_folio+0xbe/0x290 [ 45.766840][ T9787] ? __pfx_filemap_read_folio+0x10/0x10 [ 45.767325][ T9787] ? __filemap_get_folio+0x32b/0xbf0 [ 45.767780][ T9787] do_read_cache_folio+0x263/0x5c0 [ 45.768223][ T9787] ? __pfx_hfs_read_folio+0x10/0x10 [ 45.768666][ T9787] read_cache_page+0x5b/0x160 [ 45.769070][ T9787] hfs_btree_open+0x491/0x1740 [ 45.769481][ T9787] hfs_mdb_get+0x15e2/0x1fb0 [ 45.769877][ T9787] ? __pfx_hfs_mdb_get+0x10/0x10 [ 45.770316][ T9787] ? find_held_lock+0x2b/0x80 [ 45.770731][ T9787] ? lockdep_init_map_type+0x5c/0x280 [ 45.771200][ T9787] ? lockdep_init_map_type+0x5c/0x280 [ 45.771674][ T9787] hfs_fill_super+0x38e/0x720 [ 45.772092][ T9787] ? __pfx_hfs_fill_super+0x10/0x10 [ 45.772549][ T9787] ? snprintf+0xbe/0x100 [ 45.772931][ T9787] ? __pfx_snprintf+0x10/0x10 [ 45.773350][ T9787] ? do_raw_spin_lock+0x129/0x2b0 [ 45.773796][ T9787] ? find_held_lock+0x2b/0x80 [ 45.774215][ T9787] ? set_blocksize+0x40a/0x510 [ 45.774636][ T9787] ? sb_set_blocksize+0x176/0x1d0 [ 45.775087][ T9787] ? setup_bdev_super+0x369/0x730 [ 45.775533][ T9787] get_tree_bdev_flags+0x384/0x620 [ 45.775985][ T9787] ? __pfx_hfs_fill_super+0x10/0x10 [ 45.776453][ T9787] ? __pfx_get_tree_bdev_flags+0x10/0x10 [ 45.776950][ T9787] ? bpf_lsm_capable+0x9/0x10 [ 45.777365][ T9787] ? security_capable+0x80/0x260 [ 45.777803][ T9787] vfs_get_tree+0x8e/0x340 [ 45.778203][ T9787] path_mount+0x13de/0x2010 [ 45.778604][ T9787] ? kmem_cache_free+0x2b0/0x4c0 [ 45.779052][ T9787] ? __pfx_path_mount+0x10/0x10 [ 45.779480][ T9787] ? getname_flags.part.0+0x1c5/0x550 [ 45.779954][ T9787] ? putname+0x154/0x1a0 [ 45.780335][ T9787] __x64_sys_mount+0x27b/0x300 [ 45.780758][ T9787] ? __pfx___x64_sys_mount+0x10/0x10 [ 45.781232][ T9787] ---truncated---",,"[{""url"":""https://git.kernel.org/stable/c/4f032979b63ad52e08aadf0faeac34ed35133ec0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5d8b249527362e0ccafcaf76b3bec2a0d2aa1498"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6e20e10064fdc43231636fca519c15c013a8e3d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/736a0516a16268995f4898eded49bfef077af709"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b918c17a1934ac6309b0083f41d4e9d8fb3bb46c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38717,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:41.257,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: kcm: Fix race condition in kcm_unattach() syzbot found a race condition when kcm_unattach(psock) and kcm_release(kcm) are executed at the same time. kcm_unattach() is missing a check of the flag kcm->tx_stopped before calling queue_work(). If the kcm has a reserved psock, kcm_unattach() might get executed between cancel_work_sync() and unreserve_psock() in kcm_release(), requeuing kcm->tx_work right before kcm gets freed in kcm_done(). Remove kcm->tx_stopped and replace it by the less error-prone disable_work_sync().",,"[{""url"":""https://git.kernel.org/stable/c/52565a935213cd6a8662ddb8efe5b4219343a25d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7275dc3bb8f91b23125ff3f47b6529935cf46152"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/798733ee5d5788b12e8a52db1519abc17e826f69"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c0bffbc92a1ca3960fb9cdb8e9f75a68468eb308"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38718,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:41.413,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: sctp: linearize cloned gso packets in sctp_rcv A cloned head skb still shares these frag skbs in fraglist with the original head skb. It's not safe to access these frag skbs. syzbot reported two use-of-uninitialized-memory bugs caused by this: BUG: KMSAN: uninit-value in sctp_inq_pop+0x15b7/0x1920 net/sctp/inqueue.c:211 sctp_inq_pop+0x15b7/0x1920 net/sctp/inqueue.c:211 sctp_assoc_bh_rcv+0x1a7/0xc50 net/sctp/associola.c:998 sctp_inq_push+0x2ef/0x380 net/sctp/inqueue.c:88 sctp_backlog_rcv+0x397/0xdb0 net/sctp/input.c:331 sk_backlog_rcv+0x13b/0x420 include/net/sock.h:1122 __release_sock+0x1da/0x330 net/core/sock.c:3106 release_sock+0x6b/0x250 net/core/sock.c:3660 sctp_wait_for_connect+0x487/0x820 net/sctp/socket.c:9360 sctp_sendmsg_to_asoc+0x1ec1/0x1f00 net/sctp/socket.c:1885 sctp_sendmsg+0x32b9/0x4a80 net/sctp/socket.c:2031 inet_sendmsg+0x25a/0x280 net/ipv4/af_inet.c:851 sock_sendmsg_nosec net/socket.c:718 [inline] and BUG: KMSAN: uninit-value in sctp_assoc_bh_rcv+0x34e/0xbc0 net/sctp/associola.c:987 sctp_assoc_bh_rcv+0x34e/0xbc0 net/sctp/associola.c:987 sctp_inq_push+0x2a3/0x350 net/sctp/inqueue.c:88 sctp_backlog_rcv+0x3c7/0xda0 net/sctp/input.c:331 sk_backlog_rcv+0x142/0x420 include/net/sock.h:1148 __release_sock+0x1d3/0x330 net/core/sock.c:3213 release_sock+0x6b/0x270 net/core/sock.c:3767 sctp_wait_for_connect+0x458/0x820 net/sctp/socket.c:9367 sctp_sendmsg_to_asoc+0x223a/0x2260 net/sctp/socket.c:1886 sctp_sendmsg+0x3910/0x49f0 net/sctp/socket.c:2032 inet_sendmsg+0x269/0x2a0 net/ipv4/af_inet.c:851 sock_sendmsg_nosec net/socket.c:712 [inline] This patch fixes it by linearizing cloned gso packets in sctp_rcv().",,"[{""url"":""https://git.kernel.org/stable/c/03d0cc6889e02420125510b5444b570f4bbf53d5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1bd5214ea681584c5886fea3ba03e49f93a43c0e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d757f17bc2ef2727994ffa6d5d6e4bc4789a770"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd0e92bb2b7542fb96397ffac639b4f5b099d0cb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d0194e391bb493aa6cec56d177b14df6b29188d5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ea094f38d387d1b0ded5dee4a3e5720aa4ce0139"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc66772607101bd2030a4332b3bd0ea3b3605250"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd60d8a086191fe33c2d719732d2482052fa6805"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38719,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:41.577,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: hibmcge: fix the division by zero issue When the network port is down, the queue is released, and ring->len is 0. In debugfs, hbg_get_queue_used_num() will be called, which may lead to a division by zero issue. This patch adds a check, if ring->len is 0, hbg_get_queue_used_num() directly returns 0.",,"[{""url"":""https://git.kernel.org/stable/c/475e06113c615dafd44262d6d6bd37786f7f4206"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7004b26f0b64331143eb0b312e77a357a11427ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c945e1ad4f3b77166a3215dabc0c6c980d4a9c73"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38720,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:41.710,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: hibmcge: fix rtnl deadlock issue Currently, the hibmcge netdev acquires the rtnl_lock in pci_error_handlers.reset_prepare() and releases it in pci_error_handlers.reset_done(). However, in the PCI framework: pci_reset_bus - __pci_reset_slot - pci_slot_save_and_disable_locked - pci_dev_save_and_disable - err_handler->reset_prepare(dev); In pci_slot_save_and_disable_locked(): list_for_each_entry(dev, &slot->bus->devices, bus_list) { if (!dev->slot || dev->slot!= slot) continue; pci_dev_save_and_disable(dev); if (dev->subordinate) pci_bus_save_and_disable_locked(dev->subordinate); } This will iterate through all devices under the current bus and execute err_handler->reset_prepare(), causing two devices of the hibmcge driver to sequentially request the rtnl_lock, leading to a deadlock. Since the driver now executes netif_device_detach() before the reset process, it will not concurrently with other netdev APIs, so there is no need to hold the rtnl_lock now. Therefore, this patch removes the rtnl_lock during the reset process and adjusts the position of HBG_NIC_STATE_RESETTING to ensure that multiple resets are not executed concurrently.",,"[{""url"":""https://git.kernel.org/stable/c/1343a8994ca7dba78f5dd818e89d68331c21c35d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c875503a9b9082928d7d3fc60b5400d16fbfae4e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d85a6346fd6f595c4914205762d0cdf35c004a5e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38721,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:41.843,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: ctnetlink: fix refcount leak on table dump There is a reference count leak in ctnetlink_dump_table(): if (res < 0) { nf_conntrack_get(&ct->ct_general); // HERE cb->args[1] = (unsigned long)ct; ... While its very unlikely, its possible that ct == last. If this happens, then the refcount of ct was already incremented. This 2nd increment is never undone. This prevents the conntrack object from being released, which in turn keeps prevents cnet->count from dropping back to 0. This will then block the netns dismantle (or conntrack rmmod) as nf_conntrack_cleanup_net_list() will wait forever. This can be reproduced by running conntrack_resize.sh selftest in a loop. It takes ~20 minutes for me on a preemptible kernel on average before I see a runaway kworker spinning in nf_conntrack_cleanup_net_list. One fix would to change this to: if (res < 0) { if (ct != last) nf_conntrack_get(&ct->ct_general); But this reference counting isn't needed in the first place. We can just store a cookie value instead. A followup patch will do the same for ctnetlink_exp_dump_table, it looks to me as if this has the same problem and like ctnetlink_dump_table, we only need a 'skip hint', not the actual object so we can apply the same cookie strategy there as well.",,"[{""url"":""https://git.kernel.org/stable/c/19b909a4b1452fb97e477d2f08b97f8d04095619"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/30cf811058552b8cd0e98dff677ef3f89d6d34ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/41462f4cfc583513833f87f9ee55d12da651a7e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/586892e341fbf698e7cbaca293e1353957db725a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/962518c6ca9f9a13df099cafa429f72f68ad61f0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a2cb4df7872de069f809de2f076ec8e54d649fe3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a62d6aa3f31f216b637a4c71b7a8bfc7c57f049b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de788b2e6227462b6dcd0e07474e72c089008f74"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e14f72aa66c029db106921d621edcedef68e065b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38722,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:41.993,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: habanalabs: fix UAF in export_dmabuf() As soon as we'd inserted a file reference into descriptor table, another thread could close it. That's fine for the case when all we are doing is returning that descriptor to userland (it's a race, but it's a userland race and there's nothing the kernel can do about it). However, if we follow fd_install() with any kind of access to objects that would be destroyed on close (be it the struct file itself or anything destroyed by its ->release()), we have a UAF. dma_buf_fd() is a combination of reserving a descriptor and fd_install(). habanalabs export_dmabuf() calls it and then proceeds to access the objects destroyed on close. In particular, it grabs an extra reference to another struct file that will be dropped as part of ->release() for ours; that ""will be"" is actually ""might have already been"". Fix that by reserving descriptor before anything else and do fd_install() only when everything had been set up. As a side benefit, we no longer have the failure exit with file already created, but reference to underlying file (as well as ->dmabuf_export_cnt, etc.) not grabbed yet; unlike dma_buf_fd(), fd_install() can't fail.",,"[{""url"":""https://git.kernel.org/stable/c/33927f3d0ecdcff06326d6e4edb6166aed42811c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/40deceb38f9db759772d1c289c28fd2a543f57fc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/55c232d7e0241f1d5120b595e7a9de24c75ed3d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c07886761fd6251db6938d4e747002e3d150d231"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38723,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:42.130,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: LoongArch: BPF: Fix jump offset calculation in tailcall The extra pass of bpf_int_jit_compile() skips JIT context initialization which essentially skips offset calculation leaving out_offset = -1, so the jmp_offset in emit_bpf_tail_call is calculated by ""#define jmp_offset (out_offset - (cur_offset))"" is a negative number, which is wrong. The final generated assembly are as follow. 54: bgeu $a2, $t1, -8 # 0x0000004c 58: addi.d $a6, $s5, -1 5c: bltz $a6, -16 # 0x0000004c 60: alsl.d $t2, $a2, $a1, 0x3 64: ld.d $t2, $t2, 264 68: beq $t2, $zero, -28 # 0x0000004c Before apply this patch, the follow test case will reveal soft lock issues. cd tools/testing/selftests/bpf/ ./test_progs --allow=tailcalls/tailcall_bpf2bpf_1 dmesg: watchdog: BUG: soft lockup - CPU#2 stuck for 26s! [test_progs:25056]",,"[{""url"":""https://git.kernel.org/stable/c/17c010fe45def335fe03a0718935416b04c7f349"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1a782fa32e644aa9fbae6c8488f3e61221ac96e1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9262e3e04621558e875eb5afb5e726b648cd5949"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd39d9e6b7e4c58fa77783e7aedf7ada51d02ea3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f2b5e50cc04d7a049b385bc1c93b9cbf5f10c94f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f83d469e16bb1f75991ca67c56786fb2aaa42bea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38724,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:42.273,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nfsd: handle get_client_locked() failure in nfsd4_setclientid_confirm() Lei Lu recently reported that nfsd4_setclientid_confirm() did not check the return value from get_client_locked(). a SETCLIENTID_CONFIRM could race with a confirmed client expiring and fail to get a reference. That could later lead to a UAF. Fix this by getting a reference early in the case where there is an extant confirmed client. If that fails then treat it as if there were no confirmed client found at all. In the case where the unconfirmed client is expiring, just fail and return the result from get_client_locked().",,"[{""url"":""https://git.kernel.org/stable/c/22f45cedf281e6171817c8a3432c44d788c550e1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/36e83eda90e0e4ac52f259f775b40b2841f8a0a3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f252a73e81aa01660cb426735eab932e6182e8d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/571a5e46c71490285d2d8c06f6b5a7cbf6c7edd1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74ad36ed60df561a303a19ecef400c7096b20306"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/908e4ead7f757504d8b345452730636e298cbf68"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d35ac850410966010e92f401f4e21868a9ea4d8b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d71abd1ae4e0413707cd42b10c24a11d1aa71772"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f3aac6cf390d8b80e1d82975faf4ac61175519c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38725,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:42.420,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: usb: asix_devices: add phy_mask for ax88772 mdio bus Without setting phy_mask for ax88772 mdio bus, current driver may create at most 32 mdio phy devices with phy address range from 0x00 ~ 0x1f. DLink DUB-E100 H/W Ver B1 is such a device. However, only one main phy device will bind to net phy driver. This is creating issue during system suspend/resume since phy_polling_mode() in phy_state_machine() will directly deference member of phydev->drv for non-main phy devices. Then NULL pointer dereference issue will occur. Due to only external phy or internal phy is necessary, add phy_mask for ax88772 mdio bus to workarnoud the issue.",,"[{""url"":""https://git.kernel.org/stable/c/4faff70959d51078f9ee8372f8cff0d7045e4114"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/59ed6fbdb1bc03316e09493ffde7066f031c7524"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/75947d3200de98a9ded9ad8972e02f1a177097fe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a754ab53993b1585132e871c5d811167ad3c52ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad1f8313aeec0115f9978bd2d002ef4a8d96c773"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ccef5ee4adf56472aa26bdd1f821a6d0cd06089a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee2cd40b0bb46056949a2319084a729d95389386"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38726,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:42.570,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: ftgmac100: fix potential NULL pointer access in ftgmac100_phy_disconnect After the call to phy_disconnect() netdev->phydev is reset to NULL. So fixed_phy_unregister() would be called with a NULL pointer as argument. Therefore cache the phy_device before this call.",,"[{""url"":""https://git.kernel.org/stable/c/44bcd397ad9cd1a6b25fabb7f5edbee4fb0cfc2e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ad90dd34b4e8e5be1e45a4559f4de0f14e53af2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ae59ec969c07c73f0610f8bd7e648f01e798d222"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e88fbc30dda1cb7438515303704ceddb3ade4ecd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38727,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:42.713,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netlink: avoid infinite retry looping in netlink_unicast() netlink_attachskb() checks for the socket's read memory allocation constraints. Firstly, it has: rmem < READ_ONCE(sk->sk_rcvbuf) to check if the just increased rmem value fits into the socket's receive buffer. If not, it proceeds and tries to wait for the memory under: rmem + skb->truesize > READ_ONCE(sk->sk_rcvbuf) The checks don't cover the case when skb->truesize + sk->sk_rmem_alloc is equal to sk->sk_rcvbuf. Thus the function neither successfully accepts these conditions, nor manages to reschedule the task - and is called in retry loop for indefinite time which is caught as: rcu: INFO: rcu_sched self-detected stall on CPU rcu: 0-....: (25999 ticks this GP) idle=ef2/1/0x4000000000000000 softirq=262269/262269 fqs=6212 (t=26000 jiffies g=230833 q=259957) NMI backtrace for cpu 0 CPU: 0 PID: 22 Comm: kauditd Not tainted 5.10.240 #68 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.17.0-4.fc42 04/01/2014 Call Trace: <IRQ> dump_stack lib/dump_stack.c:120 nmi_cpu_backtrace.cold lib/nmi_backtrace.c:105 nmi_trigger_cpumask_backtrace lib/nmi_backtrace.c:62 rcu_dump_cpu_stacks kernel/rcu/tree_stall.h:335 rcu_sched_clock_irq.cold kernel/rcu/tree.c:2590 update_process_times kernel/time/timer.c:1953 tick_sched_handle kernel/time/tick-sched.c:227 tick_sched_timer kernel/time/tick-sched.c:1399 __hrtimer_run_queues kernel/time/hrtimer.c:1652 hrtimer_interrupt kernel/time/hrtimer.c:1717 __sysvec_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1113 asm_call_irq_on_stack arch/x86/entry/entry_64.S:808 </IRQ> netlink_attachskb net/netlink/af_netlink.c:1234 netlink_unicast net/netlink/af_netlink.c:1349 kauditd_send_queue kernel/audit.c:776 kauditd_thread kernel/audit.c:897 kthread kernel/kthread.c:328 ret_from_fork arch/x86/entry/entry_64.S:304 Restore the original behavior of the check which commit in Fixes accidentally missed when restructuring the code. Found by Linux Verification Center (linuxtesting.org).",,"[{""url"":""https://git.kernel.org/stable/c/346c820ef5135cf062fa3473da955ef8c5fb6929"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/44ddd7b1ae0b7edb2c832eb16798c827a05e58f0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/47d49fd07f86d1f55ea1083287303d237e9e0922"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6bee383ff83352a693d03efdf27cdd80742f71b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/759dfc7d04bab1b0b86113f1164dc1fec192b859"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/78fcd69d55c5f11d7694c547eca767a1cfd38ec4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d42b71a34f6b8a2d5c53df81169b03b8d8b5cf4e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e8edc7de688791a337c068693f22e8d8b869df71"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f324959ad47e62e3cadaffa65d3cff790fb48529"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38728,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:42.867,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: smb3: fix for slab out of bounds on mount to ksmbd With KASAN enabled, it is possible to get a slab out of bounds during mount to ksmbd due to missing check in parse_server_interfaces() (see below): BUG: KASAN: slab-out-of-bounds in parse_server_interfaces+0x14ee/0x1880 [cifs] Read of size 4 at addr ffff8881433dba98 by task mount/9827 CPU: 5 UID: 0 PID: 9827 Comm: mount Tainted: G OE 6.16.0-rc2-kasan #2 PREEMPT(voluntary) Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE Hardware name: Dell Inc. Precision Tower 3620/0MWYPT, BIOS 2.13.1 06/14/2019 Call Trace: <TASK> dump_stack_lvl+0x9f/0xf0 print_report+0xd1/0x670 __virt_addr_valid+0x22c/0x430 ? parse_server_interfaces+0x14ee/0x1880 [cifs] ? kasan_complete_mode_report_info+0x2a/0x1f0 ? parse_server_interfaces+0x14ee/0x1880 [cifs] kasan_report+0xd6/0x110 parse_server_interfaces+0x14ee/0x1880 [cifs] __asan_report_load_n_noabort+0x13/0x20 parse_server_interfaces+0x14ee/0x1880 [cifs] ? __pfx_parse_server_interfaces+0x10/0x10 [cifs] ? trace_hardirqs_on+0x51/0x60 SMB3_request_interfaces+0x1ad/0x3f0 [cifs] ? __pfx_SMB3_request_interfaces+0x10/0x10 [cifs] ? SMB2_tcon+0x23c/0x15d0 [cifs] smb3_qfs_tcon+0x173/0x2b0 [cifs] ? __pfx_smb3_qfs_tcon+0x10/0x10 [cifs] ? cifs_get_tcon+0x105d/0x2120 [cifs] ? do_raw_spin_unlock+0x5d/0x200 ? cifs_get_tcon+0x105d/0x2120 [cifs] ? __pfx_smb3_qfs_tcon+0x10/0x10 [cifs] cifs_mount_get_tcon+0x369/0xb90 [cifs] ? dfs_cache_find+0xe7/0x150 [cifs] dfs_mount_share+0x985/0x2970 [cifs] ? check_path.constprop.0+0x28/0x50 ? save_trace+0x54/0x370 ? __pfx_dfs_mount_share+0x10/0x10 [cifs] ? __lock_acquire+0xb82/0x2ba0 ? __kasan_check_write+0x18/0x20 cifs_mount+0xbc/0x9e0 [cifs] ? __pfx_cifs_mount+0x10/0x10 [cifs] ? do_raw_spin_unlock+0x5d/0x200 ? cifs_setup_cifs_sb+0x29d/0x810 [cifs] cifs_smb3_do_mount+0x263/0x1990 [cifs]",,"[{""url"":""https://git.kernel.org/stable/c/7d34ec36abb84fdfb6632a0f2cbda90379ae21fc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8de33d4d72e8fae3502ec3850bd7b14e7c7328b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9bdb8e98a0073c73ab3e6c631ec78877ceb64565"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a0620e1525663edd8c4594f49fb75fe5be4724b0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a542f93a123555d09c3ce8bc947f7b56ad8e6463"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f6eda5b0e8f8123564c5b34f5801d63243032eac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38729,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:43.013,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ALSA: usb-audio: Validate UAC3 power domain descriptors, too UAC3 power domain descriptors need to be verified with its variable bLength for avoiding the unexpected OOB accesses by malicious firmware, too.",,"[{""url"":""https://git.kernel.org/stable/c/07c8d78dbb5e0ff8b23f7fd69cd1d4e2ba22b3dc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1666207ba0a5973735ef010812536adde6174e81"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/29b415ec09f5b9d1dfa2423b826725a8c8796b9a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/40714daf4d0448e1692c78563faf0ed0f9d9b5c7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/452ad54f432675982cc0d6eb6c40a6c86ac61dbd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd08d390d15b204cac1d3174f5f149a20c52e61a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d832ccbc301fbd9e5a1d691bdcf461cdb514595f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ebc9e06b6ea978a20abf9b87d41afc51b2d745ac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f03418bb9d542f44df78eec2eff4ac83c0a8ac0d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38730,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-04T16:15:43.167,2025-09-05T17:47:24.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: io_uring/net: commit partial buffers on retry Ring provided buffers are potentially only valid within the single execution context in which they were acquired. io_uring deals with this and invalidates them on retry. But on the networking side, if MSG_WAITALL is set, or if the socket is of the streaming type and too little was processed, then it will hang on to the buffer rather than recycle or commit it. This is problematic for two reasons: 1) If someone unregisters the provided buffer ring before a later retry, then the req->buf_list will no longer be valid. 2) If multiple sockers are using the same buffer group, then multiple receives can consume the same memory. This can cause data corruption in the application, as either receive could land in the same userspace buffer. Fix this by disallowing partial retries from pinning a provided buffer across multiple executions, if ring provided buffers are used.",,"[{""url"":""https://git.kernel.org/stable/c/21a4ddb0f5e933f372808c10b9ac704505751bb1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2eb7937b5fc7fcd90eab7bebb0181214b61b9283"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3b53dc1c641f2884d4750fc25aaf6c36b90db606"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/41b70df5b38bc80967d2e0ed55cc3c3896bba781"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe9da1812f8697a38f7e30991d568ec199e16059"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38731,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-05T18:15:42.277,2025-09-08T16:25:59.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/xe: Fix vm_bind_ioctl double free bug If the argument check during an array bind fails, the bind_ops are freed twice as seen below. Fix this by setting bind_ops to NULL after freeing. ================================================================== BUG: KASAN: double-free in xe_vm_bind_ioctl+0x1b2/0x21f0 [xe] Free of addr ffff88813bb9b800 by task xe_vm/14198 CPU: 5 UID: 0 PID: 14198 Comm: xe_vm Not tainted 6.16.0-xe-eudebug-cmanszew+ #520 PREEMPT(full) Hardware name: Intel Corporation Alder Lake Client Platform/AlderLake-P DDR5 RVP, BIOS ADLPFWI1.R00.2411.A02.2110081023 10/08/2021 Call Trace: <TASK> dump_stack_lvl+0x82/0xd0 print_report+0xcb/0x610 ? __virt_addr_valid+0x19a/0x300 ? xe_vm_bind_ioctl+0x1b2/0x21f0 [xe] kasan_report_invalid_free+0xc8/0xf0 ? xe_vm_bind_ioctl+0x1b2/0x21f0 [xe] ? xe_vm_bind_ioctl+0x1b2/0x21f0 [xe] check_slab_allocation+0x102/0x130 kfree+0x10d/0x440 ? should_fail_ex+0x57/0x2f0 ? xe_vm_bind_ioctl+0x1b2/0x21f0 [xe] xe_vm_bind_ioctl+0x1b2/0x21f0 [xe] ? __pfx_xe_vm_bind_ioctl+0x10/0x10 [xe] ? __lock_acquire+0xab9/0x27f0 ? lock_acquire+0x165/0x300 ? drm_dev_enter+0x53/0xe0 [drm] ? find_held_lock+0x2b/0x80 ? drm_dev_exit+0x30/0x50 [drm] ? drm_ioctl_kernel+0x128/0x1c0 [drm] drm_ioctl_kernel+0x128/0x1c0 [drm] ? __pfx_xe_vm_bind_ioctl+0x10/0x10 [xe] ? find_held_lock+0x2b/0x80 ? __pfx_drm_ioctl_kernel+0x10/0x10 [drm] ? should_fail_ex+0x57/0x2f0 ? __pfx_xe_vm_bind_ioctl+0x10/0x10 [xe] drm_ioctl+0x352/0x620 [drm] ? __pfx_drm_ioctl+0x10/0x10 [drm] ? __pfx_rpm_resume+0x10/0x10 ? do_raw_spin_lock+0x11a/0x1b0 ? find_held_lock+0x2b/0x80 ? __pm_runtime_resume+0x61/0xc0 ? rcu_is_watching+0x20/0x50 ? trace_irq_enable.constprop.0+0xac/0xe0 xe_drm_ioctl+0x91/0xc0 [xe] __x64_sys_ioctl+0xb2/0x100 ? rcu_is_watching+0x20/0x50 do_syscall_64+0x68/0x2e0 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7fa9acb24ded (cherry picked from commit a01b704527c28a2fd43a17a85f8996b75ec8492a)",,"[{""url"":""https://git.kernel.org/stable/c/111fb43a557726079a67ce3ab51f602ddbf7097e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/77a946bf1af0e8110ef6e243394217a17f9b7e33"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38732,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-05T18:15:42.407,2025-09-08T16:25:59.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: nf_reject: don't leak dst refcount for loopback packets recent patches to add a WARN() when replacing skb dst entry found an old bug: WARNING: include/linux/skbuff.h:1165 skb_dst_check_unset include/linux/skbuff.h:1164 [inline] WARNING: include/linux/skbuff.h:1165 skb_dst_set include/linux/skbuff.h:1210 [inline] WARNING: include/linux/skbuff.h:1165 nf_reject_fill_skb_dst+0x2a4/0x330 net/ipv4/netfilter/nf_reject_ipv4.c:234 [..] Call Trace: nf_send_unreach+0x17b/0x6e0 net/ipv4/netfilter/nf_reject_ipv4.c:325 nft_reject_inet_eval+0x4bc/0x690 net/netfilter/nft_reject_inet.c:27 expr_call_ops_eval net/netfilter/nf_tables_core.c:237 [inline] .. This is because blamed commit forgot about loopback packets. Such packets already have a dst_entry attached, even at PRE_ROUTING stage. Instead of checking hook just check if the skb already has a route attached to it.",,"[{""url"":""https://git.kernel.org/stable/c/51e8531371f90bee742c63775c9a568e5d6bf3c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7b8b503c06274ef3c6c1a107743f1ec0d0a53ef8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/82ef97abf22790182f7d433c74960dfd61b99c33"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/91a79b792204313153e1bdbbe5acbfc28903b3a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a0a3ace2a57887dac1e7c9a724846040c3e31868"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b32e1590a8d22cf7d7f965e46d5576051acf8e42"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b7a885ba25960c91db237c3f83b4285156789bce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38733,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-05T18:15:42.550,2025-09-08T16:25:59.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: s390/mm: Do not map lowcore with identity mapping Since the identity mapping is pinned to address zero the lowcore is always also mapped to address zero, this happens regardless of the relocate_lowcore command line option. If the option is specified the lowcore is mapped twice, instead of only once. This means that NULL pointer accesses will succeed instead of causing an exception (low address protection still applies, but covers only parts). To fix this never map the first two pages of physical memory with the identity mapping.",,"[{""url"":""https://git.kernel.org/stable/c/1d7864acd497cb468a998d44631f84896f885e85"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/30bf5728bb217a6d1ba73f44094c9b9c6bc9a567"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/93f616ff870a1fb7e84d472cad0af651b18f9f87"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38734,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-05T18:15:42.677,2025-09-08T16:25:59.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/smc: fix UAF on smcsk after smc_listen_out() BPF CI testing report a UAF issue: [ 16.446633] BUG: kernel NULL pointer dereference, address: 000000000000003 0 [ 16.447134] #PF: supervisor read access in kernel mod e [ 16.447516] #PF: error_code(0x0000) - not-present pag e [ 16.447878] PGD 0 P4D 0 [ 16.448063] Oops: Oops: 0000 [#1] PREEMPT SMP NOPT I [ 16.448409] CPU: 0 UID: 0 PID: 9 Comm: kworker/0:1 Tainted: G OE 6.13.0-rc3-g89e8a75fda73-dirty #4 2 [ 16.449124] Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODUL E [ 16.449502] Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/201 4 [ 16.450201] Workqueue: smc_hs_wq smc_listen_wor k [ 16.450531] RIP: 0010:smc_listen_work+0xc02/0x159 0 [ 16.452158] RSP: 0018:ffffb5ab40053d98 EFLAGS: 0001024 6 [ 16.452526] RAX: 0000000000000001 RBX: 0000000000000002 RCX: 000000000000030 0 [ 16.452994] RDX: 0000000000000280 RSI: 00003513840053f0 RDI: 000000000000000 0 [ 16.453492] RBP: ffffa097808e3800 R08: ffffa09782dba1e0 R09: 000000000000000 5 [ 16.453987] R10: 0000000000000000 R11: 0000000000000000 R12: ffffa0978274640 0 [ 16.454497] R13: 0000000000000000 R14: 0000000000000000 R15: ffffa09782d4092 0 [ 16.454996] FS: 0000000000000000(0000) GS:ffffa097bbc00000(0000) knlGS:000000000000000 0 [ 16.455557] CS: 0010 DS: 0000 ES: 0000 CR0: 000000008005003 3 [ 16.455961] CR2: 0000000000000030 CR3: 0000000102788004 CR4: 0000000000770ef 0 [ 16.456459] PKRU: 5555555 4 [ 16.456654] Call Trace : [ 16.456832] <TASK > [ 16.456989] ? __die+0x23/0x7 0 [ 16.457215] ? page_fault_oops+0x180/0x4c 0 [ 16.457508] ? __lock_acquire+0x3e6/0x249 0 [ 16.457801] ? exc_page_fault+0x68/0x20 0 [ 16.458080] ? asm_exc_page_fault+0x26/0x3 0 [ 16.458389] ? smc_listen_work+0xc02/0x159 0 [ 16.458689] ? smc_listen_work+0xc02/0x159 0 [ 16.458987] ? lock_is_held_type+0x8f/0x10 0 [ 16.459284] process_one_work+0x1ea/0x6d 0 [ 16.459570] worker_thread+0x1c3/0x38 0 [ 16.459839] ? __pfx_worker_thread+0x10/0x1 0 [ 16.460144] kthread+0xe0/0x11 0 [ 16.460372] ? __pfx_kthread+0x10/0x1 0 [ 16.460640] ret_from_fork+0x31/0x5 0 [ 16.460896] ? __pfx_kthread+0x10/0x1 0 [ 16.461166] ret_from_fork_asm+0x1a/0x3 0 [ 16.461453] </TASK > [ 16.461616] Modules linked in: bpf_testmod(OE) [last unloaded: bpf_testmod(OE) ] [ 16.462134] CR2: 000000000000003 0 [ 16.462380] ---[ end trace 0000000000000000 ]--- [ 16.462710] RIP: 0010:smc_listen_work+0xc02/0x1590 The direct cause of this issue is that after smc_listen_out_connected(), newclcsock->sk may be NULL since it will releases the smcsk. Therefore, if the application closes the socket immediately after accept, newclcsock->sk can be NULL. A possible execution order could be as follows: smc_listen_work | userspace ----------------------------------------------------------------- lock_sock(sk) | smc_listen_out_connected() | | \- smc_listen_out | | | \- release_sock | | |- sk->sk_data_ready() | | fd = accept(); | close(fd); | \- socket->sk = NULL; /* newclcsock->sk is NULL now */ SMC_STAT_SERV_SUCC_INC(sock_net(newclcsock->sk)) Since smc_listen_out_connected() will not fail, simply swapping the order of the code can easily fix this issue.",,"[{""url"":""https://git.kernel.org/stable/c/070b4af44c4b6e4c35fb1ca7001a6a88fd2d318f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2e765ba0ee0eae35688b443e97108308a716773e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/85545f1525f9fa9bf44fec77ba011024f15da342"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d9cef55ed49117bd63695446fb84b4b91815c0b4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38735,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-05T18:15:42.817,2025-09-08T16:25:59.157,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: gve: prevent ethtool ops after shutdown A crash can occur if an ethtool operation is invoked after shutdown() is called. shutdown() is invoked during system shutdown to stop DMA operations without performing expensive deallocations. It is discouraged to unregister the netdev in this path, so the device may still be visible to userspace and kernel helpers. In gve, shutdown() tears down most internal data structures. If an ethtool operation is dispatched after shutdown(), it will dereference freed or NULL pointers, leading to a kernel panic. While graceful shutdown normally quiesces userspace before invoking the reboot syscall, forced shutdowns (as observed on GCP VMs) can still trigger this path. Fix by calling netif_device_detach() in shutdown(). This marks the device as detached so the ethtool ioctl handler will skip dispatching operations to the driver.",,"[{""url"":""https://git.kernel.org/stable/c/48a4e89d50e8ea52e800bc7865970b92fcf4647c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/75a9a46d67f46d608205888f9b34e315c1786345"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d8a41e9a4ff83ff666de811e7f012167cdc00e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a7efffeecb881b4649fdc30de020ef910f35d646"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba51d73408edf815cbaeab148625576c2dd90192"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38736,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-05T18:15:42.953,2025-09-08T16:25:38.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: usb: asix_devices: Fix PHY address mask in MDIO bus initialization Syzbot reported shift-out-of-bounds exception on MDIO bus initialization. The PHY address should be masked to 5 bits (0-31). Without this mask, invalid PHY addresses could be used, potentially causing issues with MDIO bus operations. Fix this by masking the PHY address with 0x1f (31 decimal) to ensure it stays within the valid range.",,"[{""url"":""https://git.kernel.org/stable/c/22042ffedd8c2c6db08ccdd6d4273068eddd3c5c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/24ef2f53c07f273bad99173e27ee88d44d135b1c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/523eab02fce458fa6d3c51de5bb055800986953e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/748da80831221ae24b4bc8d7ffb22acd5712a341"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8f141f2a4f2ef8ca865d5921574c3d6535e00a49"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fcb4ce9f729c1d08e53abf9d449340e24c3edee6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38737,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-05T18:15:43.090,2025-09-08T16:25:38.810,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: cifs: Fix oops due to uninitialised variable Fix smb3_init_transform_rq() to initialise buffer to NULL before calling netfs_alloc_folioq_buffer() as netfs assumes it can append to the buffer it is given. Setting it to NULL means it should start a fresh buffer, but the value is currently undefined.",,"[{""url"":""https://git.kernel.org/stable/c/453a6d2a68e54a483d67233c6e1e24c4095ee4be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4931fe2dbe1cc0e7d350a4b51b0b330e43971d98"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6adaa9fae36f848afa7278945d725e197e33c496"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,,
CVE-2025-38738,security_alert@emc.com,2025-08-14T15:15:33.943,2025-08-18T18:07:59.757,Analyzed,[],"SupportAssist for Home PCs Installer exe version(s) 4.8.2.29006 and prior, contain(s) an Incorrect Privilege Assignment vulnerability in the Installer. A low privileged attacker with local access could potentially exploit this vulnerability, leading to elevation of privileges.","[{""source"":""security_alert@emc.com"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-266""}]}]","[{""url"":""https://www.dell.com/support/kbdoc/en-us/000356690/dsa-2025-296-security-update-for-dell-supportassist-for-home-pcs-and-dell-supportassist-for-business-pcs-vulnerabilities"",""source"":""security_alert@emc.com"",""tags"":[""Vendor Advisory""]}]","[{""source"":""security_alert@emc.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:H/PR:L/UI:R/S:U/C:H/I:H/A:H"",""baseScore"":6.7,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""HIGH"",""privilegesRequired"":""LOW"",""userInteraction"":""REQUIRED"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":0.8,""impactScore"":5.9},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":7.8,""baseSeverity"":""HIGH"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":5.9}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:dell:supportassist_for_home_pcs:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""4.8.2.38851"",""matchCriteriaId"":""94968545-1DF2-4F0E-A5FE-6E9C2C85D08E""}]}]}]",,,,,,,,
CVE-2025-38739,security_alert@emc.com,2025-08-04T16:15:33.080,2025-08-18T15:41:06.843,Analyzed,[],"Dell Digital Delivery, versions prior to 5.6.1.0, contains an Insufficiently Protected Credentials vulnerability. A remote unauthenticated attacker could potentially exploit this vulnerability, leading to Information Disclosure.","[{""source"":""security_alert@emc.com"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-522""}]}]","[{""url"":""https://www.dell.com/support/kbdoc/en-us/000349489/dsa-2025-302"",""source"":""security_alert@emc.com"",""tags"":[""Vendor Advisory""]}]","[{""source"":""security_alert@emc.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:N/A:L"",""baseScore"":7.2,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""CHANGED"",""confidentialityImpact"":""LOW"",""integrityImpact"":""NONE"",""availabilityImpact"":""LOW""},""exploitabilityScore"":3.9,""impactScore"":2.7},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N"",""baseScore"":5.3,""baseSeverity"":""MEDIUM"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""LOW"",""integrityImpact"":""NONE"",""availabilityImpact"":""NONE""},""exploitabilityScore"":3.9,""impactScore"":1.4}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:dell:digital_delivery:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""5.6.1.0"",""matchCriteriaId"":""1F56C831-AE6F-48AF-97DA-A0EAD8B0E893""}]}]}]",,,,,,,,
CVE-2025-38741,security_alert@emc.com,2025-08-04T19:15:31.117,2025-08-05T14:34:17.327,Awaiting Analysis,[],"Dell Enterprise SONiC OS, version 4.5.0, contains a cryptographic key vulnerability in SSH. An unauthenticated remote attacker could potentially exploit this vulnerability, leading to unauthorized access to communication.","[{""source"":""security_alert@emc.com"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-321""}]}]","[{""url"":""https://www.dell.com/support/kbdoc/en-us/000340083/dsa-2025-275-security-update-for-dell-enterprise-sonic-distribution-vulnerabilities"",""source"":""security_alert@emc.com""}]","[{""source"":""security_alert@emc.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N"",""baseScore"":7.5,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""NONE"",""availabilityImpact"":""NONE""},""exploitabilityScore"":3.9,""impactScore"":3.6}]",,,,,,,,,
CVE-2025-38742,security_alert@emc.com,2025-08-21T19:15:40.737,2025-09-10T15:56:11.980,Analyzed,[],"Dell iDRAC Service Module (iSM), versions prior to 6.0.3.0, contains an Incorrect Permission Assignment for Critical Resource vulnerability. A low privileged attacker with local access could potentially exploit this vulnerability, leading to Code execution.","[{""source"":""security_alert@emc.com"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-732""}]}]","[{""url"":""https://www.dell.com/support/kbdoc/en-us/000359617/dsa-2025-311-security-update-for-dell-idrac-service-module-vulnerabilities"",""source"":""security_alert@emc.com"",""tags"":[""Vendor Advisory""]}]","[{""source"":""security_alert@emc.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L"",""baseScore"":5.3,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""LOW"",""integrityImpact"":""LOW"",""availabilityImpact"":""LOW""},""exploitabilityScore"":1.8,""impactScore"":3.4}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:dell:emc_idrac_service_module:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""6.0.3.0"",""matchCriteriaId"":""F70CB45B-6463-4BF1-8DC6-83CE46568C65""}]}]}]",,,,,,,,
CVE-2025-38743,security_alert@emc.com,2025-08-21T19:15:42.140,2025-09-03T16:22:35.137,Analyzed,[],"Dell iDRAC Service Module (iSM), versions prior to 6.0.3.0, contains a Buffer Access with Incorrect Length Value vulnerability. A low privileged attacker with local access could potentially exploit this vulnerability, leading to Code execution and Elevation of privileges.","[{""source"":""security_alert@emc.com"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-805""}]}]","[{""url"":""https://www.dell.com/support/kbdoc/en-us/000359617/dsa-2025-311-security-update-for-dell-idrac-service-module-vulnerabilities"",""source"":""security_alert@emc.com"",""tags"":[""Vendor Advisory""]}]","[{""source"":""security_alert@emc.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":7.8,""baseSeverity"":""HIGH"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":5.9}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:dell:emc_idrac_service_module:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""6.0.3.0"",""matchCriteriaId"":""F70CB45B-6463-4BF1-8DC6-83CE46568C65""}]}]}]",,,,,,,,
CVE-2025-38745,security_alert@emc.com,2025-08-14T15:15:34.123,2025-08-19T19:12:14.850,Analyzed,[],"Dell OpenManage Enterprise, versions 3.10, 4.0, 4.1, and 4.2, contains an Insertion of Sensitive Information into Log File vulnerability in the Backup and Restore. A low privileged attacker with remote access could potentially exploit this vulnerability, leading to Information exposure.","[{""source"":""security_alert@emc.com"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-532""}]}]","[{""url"":""https://www.dell.com/support/kbdoc/en-us/000356351/dsa-2025-314-security-update-for-dell-openmanage-enterprise-vulnerability"",""source"":""security_alert@emc.com"",""tags"":[""Vendor Advisory""]}]","[{""source"":""security_alert@emc.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:H/I:N/A:N"",""baseScore"":4.8,""baseSeverity"":""MEDIUM"",""attackVector"":""NETWORK"",""attackComplexity"":""HIGH"",""privilegesRequired"":""LOW"",""userInteraction"":""REQUIRED"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""NONE"",""availabilityImpact"":""NONE""},""exploitabilityScore"":1.2,""impactScore"":3.6},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"",""baseScore"":6.5,""baseSeverity"":""MEDIUM"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""NONE"",""availabilityImpact"":""NONE""},""exploitabilityScore"":2.8,""impactScore"":3.6}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:dell:openmanage_enterprise:3.10:*:*:*:*:*:*:*"",""matchCriteriaId"":""894202A9-C16D-4573-A9F1-2A3E022F76AC""},{""vulnerable"":true,""criteria"":""cpe:2.3:a:dell:openmanage_enterprise:4.0:*:*:*:*:*:*:*"",""matchCriteriaId"":""AE32FB11-B8CB-4224-A280-1E24F99EFA8E""},{""vulnerable"":true,""criteria"":""cpe:2.3:a:dell:openmanage_enterprise:4.1.0:*:*:*:*:*:*:*"",""matchCriteriaId"":""BCA1091B-581E-4A42-96CE-77F2593FE7FD""},{""vulnerable"":true,""criteria"":""cpe:2.3:a:dell:openmanage_enterprise:4.2.0:*:*:*:*:*:*:*"",""matchCriteriaId"":""52ADF58A-9359-46FF-BB28-73A1628629E7""}]}]}]",,,,,,,,
CVE-2025-38746,security_alert@emc.com,2025-08-06T20:15:27.940,2025-08-18T15:38:10.493,Analyzed,[],"Dell SupportAssist OS Recovery, versions prior to 5.5.14.0, contains an Exposure of Sensitive Information to an Unauthorized Actor vulnerability. An unauthenticated attacker with physical access could potentially exploit this vulnerability, leading to Information Disclosure.","[{""source"":""security_alert@emc.com"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-200""}]}]","[{""url"":""https://www.dell.com/support/kbdoc/en-us/000353093/dsa-2025-315"",""source"":""security_alert@emc.com"",""tags"":[""Vendor Advisory""]}]","[{""source"":""security_alert@emc.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N"",""baseScore"":3.5,""baseSeverity"":""LOW"",""attackVector"":""PHYSICAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""LOW"",""integrityImpact"":""LOW"",""availabilityImpact"":""NONE""},""exploitabilityScore"":0.9,""impactScore"":2.5},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N"",""baseScore"":2.4,""baseSeverity"":""LOW"",""attackVector"":""PHYSICAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""LOW"",""integrityImpact"":""NONE"",""availabilityImpact"":""NONE""},""exploitabilityScore"":0.9,""impactScore"":1.4}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:dell:supportassist_os_recovery:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""5.5.14.0"",""matchCriteriaId"":""23BD8270-8E44-4B09-9C58-34B1C76D1AB8""}]}]}]",,,,,,,,
CVE-2025-38747,security_alert@emc.com,2025-08-06T20:15:28.197,2025-08-18T15:36:36.020,Analyzed,[],"Dell SupportAssist OS Recovery, versions prior to 5.5.14.0, contain a Creation of Temporary File With Insecure Permissions vulnerability. A local authenticated attacker could potentially exploit this vulnerability, leading to Elevation of Privileges.","[{""source"":""security_alert@emc.com"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-378""}]}]","[{""url"":""https://www.dell.com/support/kbdoc/en-us/000353093/dsa-2025-315"",""source"":""security_alert@emc.com"",""tags"":[""Vendor Advisory""]}]","[{""source"":""security_alert@emc.com"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":7.8,""baseSeverity"":""HIGH"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":5.9}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:dell:supportassist_os_recovery:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""5.5.14.0"",""matchCriteriaId"":""23BD8270-8E44-4B09-9C58-34B1C76D1AB8""}]}]}]",,,,,,,,
