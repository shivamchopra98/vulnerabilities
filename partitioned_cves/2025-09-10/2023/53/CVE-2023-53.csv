id,sourceIdentifier,published,lastModified,vulnStatus,cveTags,descriptions,weaknesses,configurations,references,metrics_cvssMetricV31,metrics_cvssMetricV2,metrics_cvssMetricV30,cisaExploitAdd,cisaActionDue,cisaRequiredAction,cisaVulnerabilityName,evaluatorComment,metrics_cvssMetricV40
CVE-2023-53000,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:48.810,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netlink: prevent potential spectre v1 gadgets Most netlink attributes are parsed and validated from __nla_validate_parse() or validate_nla() u16 type = nla_type(nla); if (type == 0 || type > maxtype) { /* error or continue */ } @type is then used as an array index and can be used as a Spectre v1 gadget. array_index_nospec() can be used to prevent leaking content of kernel memory to malicious users. This should take care of vast majority of netlink uses, but an audit is needed to take care of others where validation is not yet centralized in core netlink functions.",,,"[{""url"":""https://git.kernel.org/stable/c/3e5082b1c66c7783fbcd79b5b178573230e528ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/41b74e95f297ac360ca7ed6bf200100717cb6c45"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/539ca5dcbc91134bbe2c45677811c31d8b030d2d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/992e4ff7116a77968039277b5d6aaa535c2f2184"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f0950402e8c76e7dcb08563f1b4e8000fbc62455"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53001,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:48.927,2025-07-15T16:15:24.997,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53002,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:49.050,2025-04-14T20:52:28.503,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: drm/i915: Fix a memory leak with reused mmap_offset drm_vma_node_allow() and drm_vma_node_revoke() should be called in balanced pairs. We call drm_vma_node_allow() once per-file everytime a user calls mmap_offset, but only call drm_vma_node_revoke once per-file on each mmap_offset. As the mmap_offset is reused by the client, the per-file vm_count may remain non-zero and the rbtree leaked. Call drm_vma_node_allow_once() instead to prevent that memory leak.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-401""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.7"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""C989BC04-67C6-4C21-BD03-48657AD16FFC""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc5:*:*:*:*:*:*"",""matchCriteriaId"":""D34127CC-68F5-4703-A5F6-5006F803E4AE""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/0220e4fe178c3390eb0291cdb34912d66972db8a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/0bdc4b4ba7206c452ee81c82fa66e39d0e1780fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53003,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:49.170,2025-04-01T15:39:21.640,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: EDAC/qcom: Do not pass llcc_driv_data as edac_device_ctl_info's pvt_info The memory for llcc_driv_data is allocated by the LLCC driver. But when it is passed as the private driver info to the EDAC core, it will get freed during the qcom_edac driver release. So when the qcom_edac driver gets probed again, it will try to use the freed data leading to the use-after-free bug. Hence, do not pass llcc_driv_data as pvt_info but rather reference it using the platform_data pointer in the qcom_edac driver.","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-416""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""4.20"",""versionEndExcluding"":""5.4.231"",""matchCriteriaId"":""79CA608C-BC5E-4BB5-9250-771AEC44F412""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.5"",""versionEndExcluding"":""5.10.166"",""matchCriteriaId"":""A44D9D24-661C-40D4-8735-4CEB1C7C02F2""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.11"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""91C2E92D-CC25-4FBD-8824-56A148119D7E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc5:*:*:*:*:*:*"",""matchCriteriaId"":""D34127CC-68F5-4703-A5F6-5006F803E4AE""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/66e10d5f399629ef7877304d9ba2b35d0474e7eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/6f0351d0c311951b8b3064db91e61841e85b2b96"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/76d9ebb7f0bc10fbc78b6d576751552edf743968"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/977c6ba624f24ae20cf0faee871257a39348d4a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/bff5243bd32661cf9ce66f6d9210fc8f89bda145"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":7.8,""baseSeverity"":""HIGH"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":5.9}]",,,,,,,,
CVE-2023-53004,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:49.307,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ovl: fix tmpfile leak Missed an error cleanup.",,,"[{""url"":""https://git.kernel.org/stable/c/baabaa505563362b71f2637aedd7b807d270656c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/caa0ea92503f8afa1941f6ac899e5c4e3f6ec8bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53005,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:49.420,2025-04-14T20:52:39.980,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: trace_events_hist: add check for return value of 'create_hist_field' Function 'create_hist_field' is called recursively at trace_events_hist.c:1954 and can return NULL-value that's why we have to check it to avoid null pointer dereference. Found by Linux Verification Center (linuxtesting.org) with SVACE.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-476""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""4.17"",""versionEndExcluding"":""4.19.272"",""matchCriteriaId"":""9A3B50DB-7519-417C-A0FE-0909D04EC68D""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""4.20"",""versionEndExcluding"":""5.4.231"",""matchCriteriaId"":""79CA608C-BC5E-4BB5-9250-771AEC44F412""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.5"",""versionEndExcluding"":""5.10.166"",""matchCriteriaId"":""A44D9D24-661C-40D4-8735-4CEB1C7C02F2""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.11"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""91C2E92D-CC25-4FBD-8824-56A148119D7E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc5:*:*:*:*:*:*"",""matchCriteriaId"":""D34127CC-68F5-4703-A5F6-5006F803E4AE""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/31b2414abeaa6de0490e85164badc6dcb1bb8ec9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/592ba7116fa620425725ff0972691f352ba3caf6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/886aa449235f478e262bbd5dcdee6ed6bc202949"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/8b152e9150d07a885f95e1fd401fc81af202d9a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/b4e7e81b4fdfcf457daee6b7a61769f62198d840"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/d2d1ada58e7cc100b8d7d6b082d19321ba4a700a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53006,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:49.543,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: cifs: Fix oops due to uncleared server->smbd_conn in reconnect In smbd_destroy(), clear the server->smbd_conn pointer after freeing the smbd_connection struct that it points to so that reconnection doesn't get confused.",,,"[{""url"":""https://git.kernel.org/stable/c/4b83bc6f87eedab4599b0123e572a422689444be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5109607a4ece7cd8536172bf7549eb4dce1f3576"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/91be54849d5392050f5b847b42bd5e6221551ac8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9640c0b268405f2540e8203a545e930ea88bb7d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b7ab9161cf5ddc42a288edf9d1a61f3bdffe17c7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e037baee16e0b9ace7e730888fcae9cec11daff2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53007,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:49.670,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tracing: Make sure trace_printk() can output as soon as it can be used Currently trace_printk() can be used as soon as early_trace_init() is called from start_kernel(). But if a crash happens, and ""ftrace_dump_on_oops"" is set on the kernel command line, all you get will be: [ 0.456075] <idle>-0 0dN.2. 347519us : Unknown type 6 [ 0.456075] <idle>-0 0dN.2. 353141us : Unknown type 6 [ 0.456075] <idle>-0 0dN.2. 358684us : Unknown type 6 This is because the trace_printk() event (type 6) hasn't been registered yet. That gets done via an early_initcall(), which may be early, but not early enough. Instead of registering the trace_printk() event (and other ftrace events, which are not trace events) via an early_initcall(), have them registered at the same time that trace_printk() can be used. This way, if there is a crash before early_initcall(), then the trace_printk()s will actually be useful.",,,"[{""url"":""https://git.kernel.org/stable/c/198c83963f6335ca6d690cff067679560f2a3a22"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3bb06eb6e9acf7c4a3e1b5bc87aed398ff8e2253"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/76b2390fdc80c0a8300e5da5b6b62d201b6fe9ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b0af180514edea6c83dc9a299d9f383009c99f25"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b94d7c7654356860dd7719120c7d15ba38b6162a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de3930a4883ddad2244efd6d349013294c62c75c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f97eb0ab066133483a65c93eb894748de2f6b598"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53008,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:49.797,2025-04-14T20:52:51.587,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: cifs: fix potential memory leaks in session setup Make sure to free cifs_ses::auth_key.response before allocating it as we might end up leaking memory in reconnect or mounting.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-401""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""B217F2F3-06C6-4332-8EE1-0360743FEF08""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/2fe58d977ee05da5bb89ef5dc4f5bf2dc15db46f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/893d45394dbe4b5cbf3723c19e2ccc8b93a6ac9b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53009,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:49.920,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdkfd: Add sync after creating vram bo There will be data corruption on vram allocated by svm if the initialization is not complete and application is writting on the memory. Adding sync to wait for the initialization completion is to resolve this issue.",,,"[{""url"":""https://git.kernel.org/stable/c/92af2d3b57a1afdfdcafb1c6a07ffd89cf3e98fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba029e9991d9be90a28b6a0ceb25e9a6fb348829"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53010,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:50.030,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bnxt: Do not read past the end of test names Test names were being concatenated based on a offset beyond the end of the first name, which tripped the buffer overflow detection logic: detected buffer overflow in strnlen [...] Call Trace: bnxt_ethtool_init.cold+0x18/0x18 Refactor struct hwrm_selftest_qlist_output to use an actual array, and adjust the concatenation to use snprintf() rather than a series of strncat() calls.",,,"[{""url"":""https://git.kernel.org/stable/c/cefa85480ac99c0bef5a09daadb48d65fc28e279"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3e599c090fc6977331150c5f0a69ab8ce87da21"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53011,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:50.157,2025-04-14T20:51:37.577,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: net: stmmac: enable all safety features by default In the original implementation of dwmac5 commit 8bf993a5877e (""net: stmmac: Add support for DWMAC5 and implement Safety Features"") all safety features were enabled by default. Later it seems some implementations didn't have support for all the features, so in commit 5ac712dcdfef (""net: stmmac: enable platform specific safety features"") the safety_feat_cfg structure was added to the callback and defined for some platforms to selectively enable these safety features. The problem is that only certain platforms were given that software support. If the automotive safety package bit is set in the hardware features register the safety feature callback is called for the platform, and for platforms that didn't get a safety_feat_cfg defined this results in the following NULL pointer dereference: [ 7.933303] Call trace: [ 7.935812] dwmac5_safety_feat_config+0x20/0x170 [stmmac] [ 7.941455] __stmmac_open+0x16c/0x474 [stmmac] [ 7.946117] stmmac_open+0x38/0x70 [stmmac] [ 7.950414] __dev_open+0x100/0x1dc [ 7.954006] __dev_change_flags+0x18c/0x204 [ 7.958297] dev_change_flags+0x24/0x6c [ 7.962237] do_setlink+0x2b8/0xfa4 [ 7.965827] __rtnl_newlink+0x4ec/0x840 [ 7.969766] rtnl_newlink+0x50/0x80 [ 7.973353] rtnetlink_rcv_msg+0x12c/0x374 [ 7.977557] netlink_rcv_skb+0x5c/0x130 [ 7.981500] rtnetlink_rcv+0x18/0x2c [ 7.985172] netlink_unicast+0x2e8/0x340 [ 7.989197] netlink_sendmsg+0x1a8/0x420 [ 7.993222] ____sys_sendmsg+0x218/0x280 [ 7.997249] ___sys_sendmsg+0xac/0x100 [ 8.001103] __sys_sendmsg+0x84/0xe0 [ 8.004776] __arm64_sys_sendmsg+0x24/0x30 [ 8.008983] invoke_syscall+0x48/0x114 [ 8.012840] el0_svc_common.constprop.0+0xcc/0xec [ 8.017665] do_el0_svc+0x38/0xb0 [ 8.021071] el0_svc+0x2c/0x84 [ 8.024212] el0t_64_sync_handler+0xf4/0x120 [ 8.028598] el0t_64_sync+0x190/0x194 Go back to the original behavior, if the automotive safety package is found to be supported in hardware enable all the features unless safety_feat_cfg is passed in saying this particular platform only supports a subset of the features.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-476""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.14"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""D7106030-745D-4E41-92EA-B14D4942EE1E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/120b8e527e07c65de7f2b9018dcd9d17e66f2427"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/aebf7e62708ba706ee7bf484c9023b15c214e92a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/fdfc76a116b5e9d3e98e6c96fe83b42d011d21d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53012,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:50.290,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: thermal: core: call put_device() only after device_register() fails put_device() shouldn't be called before a prior call to device_register(). __thermal_cooling_device_register() doesn't follow that properly and needs fixing. Also thermal_cooling_device_destroy_sysfs() is getting called unnecessarily on few error paths. Fix all this by placing the calls at the right place. Based on initial work done by Caleb Connolly.",,,"[{""url"":""https://git.kernel.org/stable/c/2846a7412f6246fd5171f51011bf76dfebcec0ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c54b7bc8a31ce0f7cc7f8deef05067df414f1d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a7d736cc3c6cb0d7498bbfb56515d414e35e9510"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53013,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:50.423,2025-04-14T20:51:49.353,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: ptdma: pt_core_execute_cmd() should use spinlock The interrupt handler (pt_core_irq_handler()) of the ptdma driver can be called from interrupt context. The code flow in this function can lead down to pt_core_execute_cmd() which will attempt to grab a mutex, which is not appropriate in interrupt context and ultimately leads to a kernel panic. The fix here changes this mutex to a spinlock, which has been verified to resolve the issue.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-667""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.15"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""21EEE3D1-0886-406D-BF6E-28331027E3AB""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/13ba563c2c8055ba8a637c9f70bb833b43cb4207"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/95e5fda3b5f9ed8239b145da3fa01e641cf5d53c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/ed0d8f731e0bf1bb12a7a37698ac613db20e2794"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53014,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:50.540,2025-04-15T19:40:48.390,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: dmaengine: tegra: Fix memory leak in terminate_all() Terminate vdesc when terminating an ongoing transfer. This will ensure that the vdesc is present in the desc_terminated list The descriptor will be freed later in desc_free_list(). This fixes the memory leaks which can happen when terminating an ongoing transfer.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-401""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.19"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""A98C4733-A1A4-4186-8224-8DEC21754170""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/567128076d554e41609c61b7d447089094ff72c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/a7a7ee6f5a019ad72852c001abbce50d35e992f2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53015,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:50.757,2025-04-15T19:41:18.383,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: HID: betop: check shape of output reports betopff_init() only checks the total sum of the report counts for each report field to be at least 4, but hid_betopff_play() expects 4 report fields. A device advertising an output report with one field and 4 report counts would pass the check but crash the kernel with a NULL pointer dereference in hid_betopff_play().","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-476""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""4.0"",""versionEndExcluding"":""4.14.305"",""matchCriteriaId"":""C1DBED98-CE57-4144-9FE0-CD02221FF86E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""4.15"",""versionEndExcluding"":""4.19.272"",""matchCriteriaId"":""83C4B95C-BD08-4683-A26E-2A65333F2D15""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""4.20"",""versionEndExcluding"":""5.4.231"",""matchCriteriaId"":""79CA608C-BC5E-4BB5-9250-771AEC44F412""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.5"",""versionEndExcluding"":""5.10.166"",""matchCriteriaId"":""A44D9D24-661C-40D4-8735-4CEB1C7C02F2""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.11"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""91C2E92D-CC25-4FBD-8824-56A148119D7E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/07bc32e53c7bd5c91472cc485231ef6274db9b76"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/1a2a47b85cab50a3c146731bfeaf2d860f5344ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/28fc6095da22dc88433d79578ae1c495ebe8ca43"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/3782c0d6edf658b71354a64d60aa7a296188fc90"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/7317326f685824c7c29bd80841fd18041af6bb73"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/d3065cc56221d1a5eda237e94eaf2a627b88ab79"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/dbab4dba400d6ea9a9697fbbd287adbf7db1dac4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53016,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:50.983,2025-04-15T19:41:27.160,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: Fix possible deadlock in rfcomm_sk_state_change syzbot reports a possible deadlock in rfcomm_sk_state_change [1]. While rfcomm_sock_connect acquires the sk lock and waits for the rfcomm lock, rfcomm_sock_release could have the rfcomm lock and hit a deadlock for acquiring the sk lock. Here's a simplified flow: rfcomm_sock_connect: lock_sock(sk) rfcomm_dlc_open: rfcomm_lock() rfcomm_sock_release: rfcomm_sock_shutdown: rfcomm_lock() __rfcomm_dlc_close: rfcomm_k_state_change: lock_sock(sk) This patch drops the sk lock before calling rfcomm_dlc_open to avoid the possible deadlock and holds sk's reference count to prevent use-after-free after rfcomm_dlc_open completes.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-416""},{""lang"":""en"",""value"":""CWE-667""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.15"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""21EEE3D1-0886-406D-BF6E-28331027E3AB""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/17511bd84871f4a6106cb335616e086880313f3f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/1d80d57ffcb55488f0ec0b77928d4f82d16b6a90"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/98aec50ff7f60cc6f2d6a4396b475c547e58b04d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53017,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:51.103,2025-04-15T19:41:36.207,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: hci_sync: fix memory leak in hci_update_adv_data() When hci_cmd_sync_queue() failed in hci_update_adv_data(), inst_ptr is not freed, which will cause memory leak, convert to use ERR_PTR/PTR_ERR to pass the instance to callback so no memory needs to be allocated.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-401""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.0"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""B9B6FA18-3858-4D81-93A1-B1A601BBAE6E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/1ed8b37cbaf14574c779064ef1372af62e8ba6aa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/8ac6043bd3e5b58d30f50737aedc2e58e8087ad5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53018,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:51.223,2025-04-15T19:41:43.143,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: hci_conn: Fix memory leaks When hci_cmd_sync_queue() failed in hci_le_terminate_big() or hci_le_big_terminate(), the memory pointed by variable d is not freed, which will cause memory leak. Add release process to error path.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-401""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.0"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""B9B6FA18-3858-4D81-93A1-B1A601BBAE6E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/3aa21311f36d8a2730c7ccef37235e951f23927b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/f51a825b9f730a782aa768454906b4468e67b667"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53019,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:51.330,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: mdio: validate parameter addr in mdiobus_get_phy() The caller may pass any value as addr, what may result in an out-of-bounds access to array mdio_map. One existing case is stmmac_init_phy() that may pass -1 as addr. Therefore validate addr before using it.",,,"[{""url"":""https://git.kernel.org/stable/c/1d80c259dfbadefa61b7ea334dfce5cb57f8c72f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4bc5f1f6bc94e695dfd912122af96e7115a0ddb8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7879626296e6ffd838ae0f2af1ab49ee46354973"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/867dbe784c5010a466f00a7d1467c1c5ea569c75"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8a7b9560a3a8eb8724888c426e05926752f73aa0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad67de330d83e8078372b52af18ffe8d39e26c85"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c431a3d642593bbdb99e8a9e3eed608b730db6f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53020,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:51.457,2025-04-15T19:41:50.600,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: l2tp: close all race conditions in l2tp_tunnel_register() The code in l2tp_tunnel_register() is racy in several ways: 1. It modifies the tunnel socket _after_ publishing it. 2. It calls setup_udp_tunnel_sock() on an existing socket without locking. 3. It changes sock lock class on fly, which triggers many syzbot reports. This patch amends all of them by moving socket initialization code before publishing and under sock lock. As suggested by Jakub, the l2tp lockdep class is not necessary as we can just switch to bh_lock_sock_nested().","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-362""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""3.6"",""versionEndExcluding"":""5.10.166"",""matchCriteriaId"":""F62E4A98-1B6C-4EA7-A272-DC5FBC68C570""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.11"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""91C2E92D-CC25-4FBD-8824-56A148119D7E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/0b2c59720e65885a394a017d0cf9cab118914682"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/2d77e5c0ad79004b5ef901895437e9cce6dfcc7e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/77e8ed776cdb1a24b2aab8fe7c6f1f154235e1ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/cef0845b6dcfa2f6c2c832e7f9622551456c741d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":4.7,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""HIGH"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.0,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53021,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:51.580,2025-04-01T15:40:10.120,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: net/sched: sch_taprio: fix possible use-after-free syzbot reported a nasty crash [1] in net_tx_action() which made little sense until we got a repro. This repro installs a taprio qdisc, but providing an invalid TCA_RATE attribute. qdisc_create() has to destroy the just initialized taprio qdisc, and taprio_destroy() is called. However, the hrtimer used by taprio had already fired, therefore advance_sched() called __netif_schedule(). Then net_tx_action was trying to use a destroyed qdisc. We can not undo the __netif_schedule(), so we must wait until one cpu serviced the qdisc before we can proceed. Many thanks to Alexander Potapenko for his help. [1] BUG: KMSAN: uninit-value in queued_spin_trylock include/asm-generic/qspinlock.h:94 [inline] BUG: KMSAN: uninit-value in do_raw_spin_trylock include/linux/spinlock.h:191 [inline] BUG: KMSAN: uninit-value in __raw_spin_trylock include/linux/spinlock_api_smp.h:89 [inline] BUG: KMSAN: uninit-value in _raw_spin_trylock+0x92/0xa0 kernel/locking/spinlock.c:138 queued_spin_trylock include/asm-generic/qspinlock.h:94 [inline] do_raw_spin_trylock include/linux/spinlock.h:191 [inline] __raw_spin_trylock include/linux/spinlock_api_smp.h:89 [inline] _raw_spin_trylock+0x92/0xa0 kernel/locking/spinlock.c:138 spin_trylock include/linux/spinlock.h:359 [inline] qdisc_run_begin include/net/sch_generic.h:187 [inline] qdisc_run+0xee/0x540 include/net/pkt_sched.h:125 net_tx_action+0x77c/0x9a0 net/core/dev.c:5086 __do_softirq+0x1cc/0x7fb kernel/softirq.c:571 run_ksoftirqd+0x2c/0x50 kernel/softirq.c:934 smpboot_thread_fn+0x554/0x9f0 kernel/smpboot.c:164 kthread+0x31b/0x430 kernel/kthread.c:376 ret_from_fork+0x1f/0x30 Uninit was created at: slab_post_alloc_hook mm/slab.h:732 [inline] slab_alloc_node mm/slub.c:3258 [inline] __kmalloc_node_track_caller+0x814/0x1250 mm/slub.c:4970 kmalloc_reserve net/core/skbuff.c:358 [inline] __alloc_skb+0x346/0xcf0 net/core/skbuff.c:430 alloc_skb include/linux/skbuff.h:1257 [inline] nlmsg_new include/net/netlink.h:953 [inline] netlink_ack+0x5f3/0x12b0 net/netlink/af_netlink.c:2436 netlink_rcv_skb+0x55d/0x6c0 net/netlink/af_netlink.c:2507 rtnetlink_rcv+0x30/0x40 net/core/rtnetlink.c:6108 netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline] netlink_unicast+0xf3b/0x1270 net/netlink/af_netlink.c:1345 netlink_sendmsg+0x1288/0x1440 net/netlink/af_netlink.c:1921 sock_sendmsg_nosec net/socket.c:714 [inline] sock_sendmsg net/socket.c:734 [inline] ____sys_sendmsg+0xabc/0xe90 net/socket.c:2482 ___sys_sendmsg+0x2a1/0x3f0 net/socket.c:2536 __sys_sendmsg net/socket.c:2565 [inline] __do_sys_sendmsg net/socket.c:2574 [inline] __se_sys_sendmsg net/socket.c:2572 [inline] __x64_sys_sendmsg+0x367/0x540 net/socket.c:2572 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd CPU: 0 PID: 13 Comm: ksoftirqd/0 Not tainted 6.0.0-rc2-syzkaller-47461-gac3859c02d7f #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 07/22/2022","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-416""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""4.20"",""versionEndExcluding"":""5.4.231"",""matchCriteriaId"":""79CA608C-BC5E-4BB5-9250-771AEC44F412""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.5"",""versionEndExcluding"":""5.10.166"",""matchCriteriaId"":""A44D9D24-661C-40D4-8735-4CEB1C7C02F2""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.11"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""91C2E92D-CC25-4FBD-8824-56A148119D7E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/1200388a0b1c3c6fda48d4d2143db8f7e4ef5348"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/3a415d59c1dbec9d772dbfab2d2520d98360caae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/c53acbf2facfdfabdc6e6984a1a38f5d38b606a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/c60fe70078d6e515f424cb868d07e00411b27fbc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/d3b2d2820a005e43855fa71b80c4a4b194201c60"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":7.8,""baseSeverity"":""HIGH"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":5.9}]",,,,,,,,
CVE-2023-53022,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:51.710,2025-04-15T19:41:54.910,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: net: enetc: avoid deadlock in enetc_tx_onestep_tstamp() This lockdep splat says it better than I could: ================================ WARNING: inconsistent lock state 6.2.0-rc2-07010-ga9b9500ffaac-dirty #967 Not tainted -------------------------------- inconsistent {IN-SOFTIRQ-W} -> {SOFTIRQ-ON-W} usage. kworker/1:3/179 [HC0[0]:SC0[0]:HE1:SE1] takes: ffff3ec4036ce098 (_xmit_ETHER#2){+.?.}-{3:3}, at: netif_freeze_queues+0x5c/0xc0 {IN-SOFTIRQ-W} state was registered at: _raw_spin_lock+0x5c/0xc0 sch_direct_xmit+0x148/0x37c __dev_queue_xmit+0x528/0x111c ip6_finish_output2+0x5ec/0xb7c ip6_finish_output+0x240/0x3f0 ip6_output+0x78/0x360 ndisc_send_skb+0x33c/0x85c ndisc_send_rs+0x54/0x12c addrconf_rs_timer+0x154/0x260 call_timer_fn+0xb8/0x3a0 __run_timers.part.0+0x214/0x26c run_timer_softirq+0x3c/0x74 __do_softirq+0x14c/0x5d8 ____do_softirq+0x10/0x20 call_on_irq_stack+0x2c/0x5c do_softirq_own_stack+0x1c/0x30 __irq_exit_rcu+0x168/0x1a0 irq_exit_rcu+0x10/0x40 el1_interrupt+0x38/0x64 irq event stamp: 7825 hardirqs last enabled at (7825): [<ffffdf1f7200cae4>] exit_to_kernel_mode+0x34/0x130 hardirqs last disabled at (7823): [<ffffdf1f708105f0>] __do_softirq+0x550/0x5d8 softirqs last enabled at (7824): [<ffffdf1f7081050c>] __do_softirq+0x46c/0x5d8 softirqs last disabled at (7811): [<ffffdf1f708166e0>] ____do_softirq+0x10/0x20 other info that might help us debug this: Possible unsafe locking scenario: CPU0 ---- lock(_xmit_ETHER#2); <Interrupt> lock(_xmit_ETHER#2); *** DEADLOCK *** 3 locks held by kworker/1:3/179: #0: ffff3ec400004748 ((wq_completion)events){+.+.}-{0:0}, at: process_one_work+0x1f4/0x6c0 #1: ffff80000a0bbdc8 ((work_completion)(&priv->tx_onestep_tstamp)){+.+.}-{0:0}, at: process_one_work+0x1f4/0x6c0 #2: ffff3ec4036cd438 (&dev->tx_global_lock){+.+.}-{3:3}, at: netif_tx_lock+0x1c/0x34 Workqueue: events enetc_tx_onestep_tstamp Call trace: print_usage_bug.part.0+0x208/0x22c mark_lock+0x7f0/0x8b0 __lock_acquire+0x7c4/0x1ce0 lock_acquire.part.0+0xe0/0x220 lock_acquire+0x68/0x84 _raw_spin_lock+0x5c/0xc0 netif_freeze_queues+0x5c/0xc0 netif_tx_lock+0x24/0x34 enetc_tx_onestep_tstamp+0x20/0x100 process_one_work+0x28c/0x6c0 worker_thread+0x74/0x450 kthread+0x118/0x11c but I'll say it anyway: the enetc_tx_onestep_tstamp() work item runs in process context, therefore with softirqs enabled (i.o.w., it can be interrupted by a softirq). If we hold the netif_tx_lock() when there is an interrupt, and the NET_TX softirq then gets scheduled, this will take the netif_tx_lock() a second time and deadlock the kernel. To solve this, use netif_tx_lock_bh(), which blocks softirqs from running.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-667""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.13"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""450804D3-1879-4858-A68D-9C0BCBF13142""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/3c463721a73bdb57a913e0d3124677a3758886fc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/8232e5a84d25a84a5cbda0f241a00793fb6eb608"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/e893dced1a18e77b1262f5c10169413f0ece0da7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53023,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:51.847,2025-04-01T15:39:10.740,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: net: nfc: Fix use-after-free in local_cleanup() Fix a use-after-free that occurs in kfree_skb() called from local_cleanup(). This could happen when killing nfc daemon (e.g. neard) after detaching an nfc device. When detaching an nfc device, local_cleanup() called from nfc_llcp_unregister_device() frees local->rx_pending and decreases local->ref by kref_put() in nfc_llcp_local_put(). In the terminating process, nfc daemon releases all sockets and it leads to decreasing local->ref. After the last release of local->ref, local_cleanup() called from local_release() frees local->rx_pending again, which leads to the bug. Setting local->rx_pending to NULL in local_cleanup() could prevent use-after-free when local_cleanup() is called twice. Found by a modified version of syzkaller. BUG: KASAN: use-after-free in kfree_skb() Call Trace: dump_stack_lvl (lib/dump_stack.c:106) print_address_description.constprop.0.cold (mm/kasan/report.c:306) kasan_check_range (mm/kasan/generic.c:189) kfree_skb (net/core/skbuff.c:955) local_cleanup (net/nfc/llcp_core.c:159) nfc_llcp_local_put.part.0 (net/nfc/llcp_core.c:172) nfc_llcp_local_put (net/nfc/llcp_core.c:181) llcp_sock_destruct (net/nfc/llcp_sock.c:959) __sk_destruct (net/core/sock.c:2133) sk_destruct (net/core/sock.c:2181) __sk_free (net/core/sock.c:2192) sk_free (net/core/sock.c:2203) llcp_sock_release (net/nfc/llcp_sock.c:646) __sock_release (net/socket.c:650) sock_close (net/socket.c:1365) __fput (fs/file_table.c:306) task_work_run (kernel/task_work.c:179) ptrace_notify (kernel/signal.c:2354) syscall_exit_to_user_mode_prepare (kernel/entry/common.c:278) syscall_exit_to_user_mode (kernel/entry/common.c:296) do_syscall_64 (arch/x86/entry/common.c:86) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:106) Allocated by task 4719: kasan_save_stack (mm/kasan/common.c:45) __kasan_slab_alloc (mm/kasan/common.c:325) slab_post_alloc_hook (mm/slab.h:766) kmem_cache_alloc_node (mm/slub.c:3497) __alloc_skb (net/core/skbuff.c:552) pn533_recv_response (drivers/nfc/pn533/usb.c:65) __usb_hcd_giveback_urb (drivers/usb/core/hcd.c:1671) usb_giveback_urb_bh (drivers/usb/core/hcd.c:1704) tasklet_action_common.isra.0 (kernel/softirq.c:797) __do_softirq (kernel/softirq.c:571) Freed by task 1901: kasan_save_stack (mm/kasan/common.c:45) kasan_set_track (mm/kasan/common.c:52) kasan_save_free_info (mm/kasan/genericdd.c:518) __kasan_slab_free (mm/kasan/common.c:236) kmem_cache_free (mm/slub.c:3809) kfree_skbmem (net/core/skbuff.c:874) kfree_skb (net/core/skbuff.c:931) local_cleanup (net/nfc/llcp_core.c:159) nfc_llcp_unregister_device (net/nfc/llcp_core.c:1617) nfc_unregister_device (net/nfc/core.c:1179) pn53x_unregister_nfc (drivers/nfc/pn533/pn533.c:2846) pn533_usb_disconnect (drivers/nfc/pn533/usb.c:579) usb_unbind_interface (drivers/usb/core/driver.c:458) device_release_driver_internal (drivers/base/dd.c:1279) bus_remove_device (drivers/base/bus.c:529) device_del (drivers/base/core.c:3665) usb_disable_device (drivers/usb/core/message.c:1420) usb_disconnect (drivers/usb/core.c:2261) hub_event (drivers/usb/core/hub.c:5833) process_one_work (arch/x86/include/asm/jump_label.h:27 include/linux/jump_label.h:212 include/trace/events/workqueue.h:108 kernel/workqueue.c:2281) worker_thread (include/linux/list.h:282 kernel/workqueue.c:2423) kthread (kernel/kthread.c:319) ret_from_fork (arch/x86/entry/entry_64.S:301)","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-416""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""3.9"",""versionEndExcluding"":""4.14.305"",""matchCriteriaId"":""10C5A938-FF24-4A9E-9F50-02013C0919F8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""4.15"",""versionEndExcluding"":""4.19.272"",""matchCriteriaId"":""83C4B95C-BD08-4683-A26E-2A65333F2D15""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""4.20"",""versionEndExcluding"":""5.4.231"",""matchCriteriaId"":""79CA608C-BC5E-4BB5-9250-771AEC44F412""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.5"",""versionEndExcluding"":""5.10.166"",""matchCriteriaId"":""A44D9D24-661C-40D4-8735-4CEB1C7C02F2""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.11"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""91C2E92D-CC25-4FBD-8824-56A148119D7E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/4bb4db7f3187c6e3de6b229ffc87cdb30a2d22b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/54f7be61584b8ec4c6df405f479495b9397bae4a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/7f129927feaf7c10b1c38bbce630172e9a08c834"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/a59cdbda3714e11aa3ab579132864c4c8c6d54f9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/ad1baab3a5c03692d22ce446f38596a126377f6a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/b09ae26f08aaf2d85f96ea7f90ddd3387f62216f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/d3605282ec3502ec8847915eb2cf1f340493ff79"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":7.8,""baseSeverity"":""HIGH"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":5.9}]",,,,,,,,
CVE-2023-53024,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:51.980,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf: Fix pointer-leak due to insufficient speculative store bypass mitigation To mitigate Spectre v4, 2039f26f3aca (""bpf: Fix leakage due to insufficient speculative store bypass mitigation"") inserts lfence instructions after 1) initializing a stack slot and 2) spilling a pointer to the stack. However, this does not cover cases where a stack slot is first initialized with a pointer (subject to sanitization) but then overwritten with a scalar (not subject to sanitization because the slot was already initialized). In this case, the second write may be subject to speculative store bypass (SSB) creating a speculative pointer-as-scalar type confusion. This allows the program to subsequently leak the numerical pointer value using, for example, a branch-based cache side channel. To fix this, also sanitize scalars if they write a stack slot that previously contained a pointer. Assuming that pointer-spills are only generated by LLVM on register-pressure, the performance impact on most real-world BPF programs should be small. The following unprivileged BPF bytecode drafts a minimal exploit and the mitigation: [...] // r6 = 0 or 1 (skalar, unknown user input) // r7 = accessible ptr for side channel // r10 = frame pointer (fp), to be leaked // r9 = r10 # fp alias to encourage ssb *(u64 *)(r9 - 8) = r10 // fp[-8] = ptr, to be leaked // lfence added here because of pointer spill to stack. // // Ommitted: Dummy bpf_ringbuf_output() here to train alias predictor // for no r9-r10 dependency. // *(u64 *)(r10 - 8) = r6 // fp[-8] = scalar, overwrites ptr // 2039f26f3aca: no lfence added because stack slot was not STACK_INVALID, // store may be subject to SSB // // fix: also add an lfence when the slot contained a ptr // r8 = *(u64 *)(r9 - 8) // r8 = architecturally a scalar, speculatively a ptr // // leak ptr using branch-based cache side channel: r8 &= 1 // choose bit to leak if r8 == 0 goto SLOW // no mispredict // architecturally dead code if input r6 is 0, // only executes speculatively iff ptr bit is 1 r8 = *(u64 *)(r7 + 0) # encode bit in cache (0: slow, 1: fast) SLOW: [...] After running this, the program can time the access to *(r7 + 0) to determine whether the chosen pointer bit was 0 or 1. Repeat this 64 times to recover the whole address on amd64. In summary, sanitization can only be skipped if one scalar is overwritten with another scalar. Scalar-confusion due to speculative store bypass can not lead to invalid accesses because the pointer bounds deducted during verification are enforced using branchless logic. See 979d63d50c0c (""bpf: prevent out of bounds speculation on pointer arithmetic"") for details. Do not make the mitigation depend on !env->allow_{uninit_stack,ptr_leaks} because speculative leaks are likely unexpected if these were enabled. For example, leaking the address to a protected log file may be acceptable while disabling the mitigation might unintentionally leak the address into the cached-state of a map that is accessible to unprivileged processes.",,,"[{""url"":""https://git.kernel.org/stable/c/01bdcc73dbe7be3ad4d4ee9a59b71e42f461a528"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/81b3374944d201872cfcf82730a7860f8e7c31dd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aae109414a57ab4164218f36e2e4a17f027fcaaa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b0c89ef025562161242a7c19b213bd6b272e93df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da75dec7c6617bddad418159ffebcb133f008262"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e4f4db47794c9f474b184ee1418f42e6a07412b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53025,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:52.117,2025-06-05T15:15:24.170,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53026,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:52.250,2025-04-15T19:42:05.810,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/core: Fix ib block iterator counter overflow When registering a new DMA MR after selecting the best aligned page size for it, we iterate over the given sglist to split each entry to smaller, aligned to the selected page size, DMA blocks. In given circumstances where the sg entry and page size fit certain sizes and the sg entry is not aligned to the selected page size, the total size of the aligned pages we need to cover the sg entry is >= 4GB. Under this circumstances, while iterating page aligned blocks, the counter responsible for counting how much we advanced from the start of the sg entry is overflowed because its type is u32 and we pass 4GB in size. This can lead to an infinite loop inside the iterator function because the overflow prevents the counter to be larger than the size of the sg entry. Fix the presented problem by changing the advancement condition to eliminate overflow. Backtrace: [ 192.374329] efa_reg_user_mr_dmabuf [ 192.376783] efa_register_mr [ 192.382579] pgsz_bitmap 0xfffff000 rounddown 0x80000000 [ 192.386423] pg_sz [0x80000000] umem_length[0xc0000000] [ 192.392657] start 0x0 length 0xc0000000 params.page_shift 31 params.page_num 3 [ 192.399559] hp_cnt[3], pages_in_hp[524288] [ 192.403690] umem->sgt_append.sgt.nents[1] [ 192.407905] number entries: [1], pg_bit: [31] [ 192.411397] biter->__sg_nents [1] biter->__sg [0000000008b0c5d8] [ 192.415601] biter->__sg_advance [665837568] sg_dma_len[3221225472] [ 192.419823] biter->__sg_nents [1] biter->__sg [0000000008b0c5d8] [ 192.423976] biter->__sg_advance [2813321216] sg_dma_len[3221225472] [ 192.428243] biter->__sg_nents [1] biter->__sg [0000000008b0c5d8] [ 192.432397] biter->__sg_advance [665837568] sg_dma_len[3221225472]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-835""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.2"",""versionEndExcluding"":""5.4.231"",""matchCriteriaId"":""CE5CA7CE-9223-4A0E-9EC7-CD255B30BD3B""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.5"",""versionEndExcluding"":""5.10.166"",""matchCriteriaId"":""A44D9D24-661C-40D4-8735-4CEB1C7C02F2""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.11"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""91C2E92D-CC25-4FBD-8824-56A148119D7E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/0afec5e9cea732cb47014655685a2a47fb180c31"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/362c9489720b31b6aa7491423ba65a4e98aa9838"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/43811d07ea64366af8ec9e168c558ec51440c39e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/902063a9fea5f8252df392ade746bc9cfd07a5ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/d66c1d4178c219b6e7d7a6f714e3e3656faccc36"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53027,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:52.387,2025-03-28T07:15:37.860,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53028,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:52.507,2025-04-15T19:42:15.790,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: Revert ""wifi: mac80211: fix memory leak in ieee80211_if_add()"" This reverts commit 13e5afd3d773c6fc6ca2b89027befaaaa1ea7293. ieee80211_if_free() is already called from free_netdev(ndev) because ndev->priv_destructor == ieee80211_if_free syzbot reported: general protection fault, probably for non-canonical address 0xdffffc0000000004: 0000 [#1] PREEMPT SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000020-0x0000000000000027] CPU: 0 PID: 10041 Comm: syz-executor.0 Not tainted 6.2.0-rc2-syzkaller-00388-g55b98837e37d #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022 RIP: 0010:pcpu_get_page_chunk mm/percpu.c:262 [inline] RIP: 0010:pcpu_chunk_addr_search mm/percpu.c:1619 [inline] RIP: 0010:free_percpu mm/percpu.c:2271 [inline] RIP: 0010:free_percpu+0x186/0x10f0 mm/percpu.c:2254 Code: 80 3c 02 00 0f 85 f5 0e 00 00 48 8b 3b 48 01 ef e8 cf b3 0b 00 48 ba 00 00 00 00 00 fc ff df 48 8d 78 20 48 89 f9 48 c1 e9 03 <80> 3c 11 00 0f 85 3b 0e 00 00 48 8b 58 20 48 b8 00 00 00 00 00 fc RSP: 0018:ffffc90004ba7068 EFLAGS: 00010002 RAX: 0000000000000000 RBX: ffff88823ffe2b80 RCX: 0000000000000004 RDX: dffffc0000000000 RSI: ffffffff81c1f4e7 RDI: 0000000000000020 RBP: ffffe8fffe8fc220 R08: 0000000000000005 R09: 0000000000000000 R10: 0000000000000000 R11: 1ffffffff2179ab2 R12: ffff8880b983d000 R13: 0000000000000003 R14: 0000607f450fc220 R15: ffff88823ffe2988 FS: 00007fcb349de700(0000) GS:ffff8880b9800000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000001b32220000 CR3: 000000004914f000 CR4: 00000000003506f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> netdev_run_todo+0x6bf/0x1100 net/core/dev.c:10352 ieee80211_register_hw+0x2663/0x4040 net/mac80211/main.c:1411 mac80211_hwsim_new_radio+0x2537/0x4d80 drivers/net/wireless/mac80211_hwsim.c:4583 hwsim_new_radio_nl+0xa09/0x10f0 drivers/net/wireless/mac80211_hwsim.c:5176 genl_family_rcv_msg_doit.isra.0+0x1e6/0x2d0 net/netlink/genetlink.c:968 genl_family_rcv_msg net/netlink/genetlink.c:1048 [inline] genl_rcv_msg+0x4ff/0x7e0 net/netlink/genetlink.c:1065 netlink_rcv_skb+0x165/0x440 net/netlink/af_netlink.c:2564 genl_rcv+0x28/0x40 net/netlink/genetlink.c:1076 netlink_unicast_kernel net/netlink/af_netlink.c:1330 [inline] netlink_unicast+0x547/0x7f0 net/netlink/af_netlink.c:1356 netlink_sendmsg+0x91b/0xe10 net/netlink/af_netlink.c:1932 sock_sendmsg_nosec net/socket.c:714 [inline] sock_sendmsg+0xd3/0x120 net/socket.c:734 ____sys_sendmsg+0x712/0x8c0 net/socket.c:2476 ___sys_sendmsg+0x110/0x1b0 net/socket.c:2530 __sys_sendmsg+0xf7/0x1c0 net/socket.c:2559 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-401""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.10.163"",""versionEndExcluding"":""5.10.165"",""matchCriteriaId"":""5D344DEB-2525-4247-81EE-3559A1C4D911""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.15.86"",""versionEndExcluding"":""5.15.90"",""matchCriteriaId"":""8FE25AE0-3216-4628-B2DD-2E3F12C5C9F7""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.0.16"",""versionEndExcluding"":""6.1"",""matchCriteriaId"":""6C7522E3-150F-436D-BBD7-96C7B4B795ED""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.1.2"",""versionEndExcluding"":""6.1.8"",""matchCriteriaId"":""91C42ED4-1CA5-4338-9DA6-715E64021DFB""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/71e5cd1018d345e649e63f74a56c1897f99db7e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/80f8a66dede0a4b4e9e846765a97809c6fe49ce5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/982c8b1e95c088f5d8f65967ec25be66e961401c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/effecd8d116d3d3a28b4f628e61bba8d318fdfcf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53029,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:52.627,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: octeontx2-pf: Fix the use of GFP_KERNEL in atomic context on rt The commit 4af1b64f80fb (""octeontx2-pf: Fix lmtst ID used in aura free"") uses the get/put_cpu() to protect the usage of percpu pointer in ->aura_freeptr() callback, but it also unnecessarily disable the preemption for the blockable memory allocation. The commit 87b93b678e95 (""octeontx2-pf: Avoid use of GFP_KERNEL in atomic context"") tried to fix these sleep inside atomic warnings. But it only fix the one for the non-rt kernel. For the rt kernel, we still get the similar warnings like below. BUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:46 in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 1, name: swapper/0 preempt_count: 1, expected: 0 RCU nest depth: 0, expected: 0 3 locks held by swapper/0/1: #0: ffff800009fc5fe8 (rtnl_mutex){+.+.}-{3:3}, at: rtnl_lock+0x24/0x30 #1: ffff000100c276c0 (&mbox->lock){+.+.}-{3:3}, at: otx2_init_hw_resources+0x8c/0x3a4 #2: ffffffbfef6537e0 (&cpu_rcache->lock){+.+.}-{2:2}, at: alloc_iova_fast+0x1ac/0x2ac Preemption disabled at: [<ffff800008b1908c>] otx2_rq_aura_pool_init+0x14c/0x284 CPU: 20 PID: 1 Comm: swapper/0 Tainted: G W 6.2.0-rc3-rt1-yocto-preempt-rt #1 Hardware name: Marvell OcteonTX CN96XX board (DT) Call trace: dump_backtrace.part.0+0xe8/0xf4 show_stack+0x20/0x30 dump_stack_lvl+0x9c/0xd8 dump_stack+0x18/0x34 __might_resched+0x188/0x224 rt_spin_lock+0x64/0x110 alloc_iova_fast+0x1ac/0x2ac iommu_dma_alloc_iova+0xd4/0x110 __iommu_dma_map+0x80/0x144 iommu_dma_map_page+0xe8/0x260 dma_map_page_attrs+0xb4/0xc0 __otx2_alloc_rbuf+0x90/0x150 otx2_rq_aura_pool_init+0x1c8/0x284 otx2_init_hw_resources+0xe4/0x3a4 otx2_open+0xf0/0x610 __dev_open+0x104/0x224 __dev_change_flags+0x1e4/0x274 dev_change_flags+0x2c/0x7c ic_open_devs+0x124/0x2f8 ip_auto_config+0x180/0x42c do_one_initcall+0x90/0x4dc do_basic_setup+0x10c/0x14c kernel_init_freeable+0x10c/0x13c kernel_init+0x2c/0x140 ret_from_fork+0x10/0x20 Of course, we can shuffle the get/put_cpu() to only wrap the invocation of ->aura_freeptr() as what commit 87b93b678e95 does. But there are only two ->aura_freeptr() callbacks, otx2_aura_freeptr() and cn10k_aura_freeptr(). There is no usage of perpcu variable in the otx2_aura_freeptr() at all, so the get/put_cpu() seems redundant to it. We can move the get/put_cpu() into the corresponding callback which really has the percpu variable usage and avoid the sprinkling of get/put_cpu() in several places.",,,"[{""url"":""https://git.kernel.org/stable/c/29e9c67bf3271067735c188e95cf3631ecd64d58"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/55ba18dc62deff5910c0fa64486dea1ff20832ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/659518e013d6bd562bb0f1d2d9f99d0ac54720e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53030,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:52.750,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: octeontx2-pf: Avoid use of GFP_KERNEL in atomic context Using GFP_KERNEL in preemption disable context, causing below warning when CONFIG_DEBUG_ATOMIC_SLEEP is enabled. [ 32.542271] BUG: sleeping function called from invalid context at include/linux/sched/mm.h:274 [ 32.550883] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 1, name: swapper/0 [ 32.558707] preempt_count: 1, expected: 0 [ 32.562710] RCU nest depth: 0, expected: 0 [ 32.566800] CPU: 3 PID: 1 Comm: swapper/0 Tainted: G W 6.2.0-rc2-00269-gae9dcb91c606 #7 [ 32.576188] Hardware name: Marvell CN106XX board (DT) [ 32.581232] Call trace: [ 32.583670] dump_backtrace.part.0+0xe0/0xf0 [ 32.587937] show_stack+0x18/0x30 [ 32.591245] dump_stack_lvl+0x68/0x84 [ 32.594900] dump_stack+0x18/0x34 [ 32.598206] __might_resched+0x12c/0x160 [ 32.602122] __might_sleep+0x48/0xa0 [ 32.605689] __kmem_cache_alloc_node+0x2b8/0x2e0 [ 32.610301] __kmalloc+0x58/0x190 [ 32.613610] otx2_sq_aura_pool_init+0x1a8/0x314 [ 32.618134] otx2_open+0x1d4/0x9d0 To avoid use of GFP_ATOMIC for memory allocation, disable preemption after all memory allocation is done.",,,"[{""url"":""https://git.kernel.org/stable/c/1eb57b87f106c90cee6b2a56a10f2e29c7a25f3e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2827c4eb429db64befdca11362e2b1c5f524f6ba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/87b93b678e95c7d93fe6a55b0e0fbda26d8c7760"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53031,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:52.870,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: powerpc/imc-pmu: Fix use of mutex in IRQs disabled section Current imc-pmu code triggers a WARNING with CONFIG_DEBUG_ATOMIC_SLEEP and CONFIG_PROVE_LOCKING enabled, while running a thread_imc event. Command to trigger the warning: # perf stat -e thread_imc/CPM_CS_FROM_L4_MEM_X_DPTEG/ sleep 5 Performance counter stats for 'sleep 5': 0 thread_imc/CPM_CS_FROM_L4_MEM_X_DPTEG/ 5.002117947 seconds time elapsed 0.000131000 seconds user 0.001063000 seconds sys Below is snippet of the warning in dmesg: BUG: sleeping function called from invalid context at kernel/locking/mutex.c:580 in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 2869, name: perf-exec preempt_count: 2, expected: 0 4 locks held by perf-exec/2869: #0: c00000004325c540 (&sig->cred_guard_mutex){+.+.}-{3:3}, at: bprm_execve+0x64/0xa90 #1: c00000004325c5d8 (&sig->exec_update_lock){++++}-{3:3}, at: begin_new_exec+0x460/0xef0 #2: c0000003fa99d4e0 (&cpuctx_lock){-...}-{2:2}, at: perf_event_exec+0x290/0x510 #3: c000000017ab8418 (&ctx->lock){....}-{2:2}, at: perf_event_exec+0x29c/0x510 irq event stamp: 4806 hardirqs last enabled at (4805): [<c000000000f65b94>] _raw_spin_unlock_irqrestore+0x94/0xd0 hardirqs last disabled at (4806): [<c0000000003fae44>] perf_event_exec+0x394/0x510 softirqs last enabled at (0): [<c00000000013c404>] copy_process+0xc34/0x1ff0 softirqs last disabled at (0): [<0000000000000000>] 0x0 CPU: 36 PID: 2869 Comm: perf-exec Not tainted 6.2.0-rc2-00011-g1247637727f2 #61 Hardware name: 8375-42A POWER9 0x4e1202 opal:v7.0-16-g9b85f7d961 PowerNV Call Trace: dump_stack_lvl+0x98/0xe0 (unreliable) __might_resched+0x2f8/0x310 __mutex_lock+0x6c/0x13f0 thread_imc_event_add+0xf4/0x1b0 event_sched_in+0xe0/0x210 merge_sched_in+0x1f0/0x600 visit_groups_merge.isra.92.constprop.166+0x2bc/0x6c0 ctx_flexible_sched_in+0xcc/0x140 ctx_sched_in+0x20c/0x2a0 ctx_resched+0x104/0x1c0 perf_event_exec+0x340/0x510 begin_new_exec+0x730/0xef0 load_elf_binary+0x3f8/0x1e10 ... do not call blocking ops when !TASK_RUNNING; state=2001 set at [<00000000fd63e7cf>] do_nanosleep+0x60/0x1a0 WARNING: CPU: 36 PID: 2869 at kernel/sched/core.c:9912 __might_sleep+0x9c/0xb0 CPU: 36 PID: 2869 Comm: sleep Tainted: G W 6.2.0-rc2-00011-g1247637727f2 #61 Hardware name: 8375-42A POWER9 0x4e1202 opal:v7.0-16-g9b85f7d961 PowerNV NIP: c000000000194a1c LR: c000000000194a18 CTR: c000000000a78670 REGS: c00000004d2134e0 TRAP: 0700 Tainted: G W (6.2.0-rc2-00011-g1247637727f2) MSR: 9000000000021033 <SF,HV,ME,IR,DR,RI,LE> CR: 48002824 XER: 00000000 CFAR: c00000000013fb64 IRQMASK: 1 The above warning triggered because the current imc-pmu code uses mutex lock in interrupt disabled sections. The function mutex_lock() internally calls __might_resched(), which will check if IRQs are disabled and in case IRQs are disabled, it will trigger the warning. Fix the issue by changing the mutex lock to spinlock. [mpe: Fix comments, trim oops in change log, add reported-by tags]",,,"[{""url"":""https://git.kernel.org/stable/c/424bcb570cb320d1d15238cd4c933522b90f78fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/76d588dddc459fefa1da96e0a081a397c5c8e216"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8cbeb60320ac45a8240b561c8ef466b86c34dedc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a90d339f1f66be4a946769b565668e2bd0686dfa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d0c6d2a31026102d4738b47a610bed4401b9834f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53032,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:52.997,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: ipset: Fix overflow before widen in the bitmap_ip_create() function. When first_ip is 0, last_ip is 0xFFFFFFFF, and netmask is 31, the value of an arithmetic expression 2 << (netmask - mask_bits - 1) is subject to overflow due to a failure casting operands to a larger data type before performing the arithmetic. Note that it's harmless since the value will be checked at the next step. Found by InfoTeCS on behalf of Linux Verification Center (linuxtesting.org) with SVACE.",,,"[{""url"":""https://git.kernel.org/stable/c/4e6a70fd840400e3a2e784a6673968a3eb2431c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/511cf17b2447fc41cfef8d71936e1fa53e395c1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ea4b476cea1b7d461d16dda25ca3c7e616e2d15"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dfd834ccc1b88bbbab81b9046a3a539dd0c2d14f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e137d9bb26bd85ce07323a38e38ceb0b160db841"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e88865876d47c790be0d5e23973499d75d034364"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/feefb33eefa166fc3e0fd17547b0bc0cb3baced9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53033,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:53.120,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: nft_payload: incorrect arithmetics when fetching VLAN header bits If the offset + length goes over the ethernet + vlan header, then the length is adjusted to copy the bytes that are within the boundaries of the vlan_ethhdr scratchpad area. The remaining bytes beyond ethernet + vlan header are copied directly from the skbuff data area. Fix incorrect arithmetic operator: subtract, not add, the size of the vlan header in case of double-tagged packets to adjust the length accordingly to address CVE-2023-0179.",,,"[{""url"":""https://git.kernel.org/stable/c/550efeff989b041f3746118c0ddd863c39ddc1aa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/696e1a48b1a1b01edad542a1ef293665864a4dd0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/76ef74d4a379faa451003621a84e3498044e7aa3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a8acfe2c6fb99f9375a9325807a179cd8c32e6e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53034,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-04-16T15:15:52.717,2025-04-17T20:22:16.240,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ntb_hw_switchtec: Fix shift-out-of-bounds in switchtec_ntb_mw_set_trans There is a kernel API ntb_mw_clear_trans() would pass 0 to both addr and size. This would make xlate_pos negative. [ 23.734156] switchtec switchtec0: MW 0: part 0 addr 0x0000000000000000 size 0x0000000000000000 [ 23.734158] ================================================================================ [ 23.734172] UBSAN: shift-out-of-bounds in drivers/ntb/hw/mscc/ntb_hw_switchtec.c:293:7 [ 23.734418] shift exponent -1 is negative Ensuring xlate_pos is a positive or zero before BIT.",,,"[{""url"":""https://git.kernel.org/stable/c/0df2e03e4620548b41891b4e0d1bd9d2e0d8a39a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2429bdf26a0f3950fdd996861e9c1a3873af1dbe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/36d32cfb00d42e865396424bb5d340fc0a28870d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5b6857bb3bfb0dae17fab1e42c1e82c204a508b1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ed22f8d8be26225a78cf5e85b2036421a6bf2d5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c61a3f2df162ba424be0141649a9ef5f28eaccc1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cb153bdc1812a3375639ed6ca5f147eaefb65349"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de203da734fae00e75be50220ba5391e7beecdf9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f56951f211f181410a383d305e8d370993e45294"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53035,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:22.627,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nilfs2: fix kernel-infoleak in nilfs_ioctl_wrap_copy() The ioctl helper function nilfs_ioctl_wrap_copy(), which exchanges a metadata array to/from user space, may copy uninitialized buffer regions to user space memory for read-only ioctl commands NILFS_IOCTL_GET_SUINFO and NILFS_IOCTL_GET_CPINFO. This can occur when the element size of the user space metadata given by the v_size member of the argument nilfs_argv structure is larger than the size of the metadata element (nilfs_suinfo structure or nilfs_cpinfo structure) on the file system side. KMSAN-enabled kernels detect this issue as follows: BUG: KMSAN: kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:121 [inline] BUG: KMSAN: kernel-infoleak in _copy_to_user+0xc0/0x100 lib/usercopy.c:33 instrument_copy_to_user include/linux/instrumented.h:121 [inline] _copy_to_user+0xc0/0x100 lib/usercopy.c:33 copy_to_user include/linux/uaccess.h:169 [inline] nilfs_ioctl_wrap_copy+0x6fa/0xc10 fs/nilfs2/ioctl.c:99 nilfs_ioctl_get_info fs/nilfs2/ioctl.c:1173 [inline] nilfs_ioctl+0x2402/0x4450 fs/nilfs2/ioctl.c:1290 nilfs_compat_ioctl+0x1b8/0x200 fs/nilfs2/ioctl.c:1343 __do_compat_sys_ioctl fs/ioctl.c:968 [inline] __se_compat_sys_ioctl+0x7dd/0x1000 fs/ioctl.c:910 __ia32_compat_sys_ioctl+0x93/0xd0 fs/ioctl.c:910 do_syscall_32_irqs_on arch/x86/entry/common.c:112 [inline] __do_fast_syscall_32+0xa2/0x100 arch/x86/entry/common.c:178 do_fast_syscall_32+0x37/0x80 arch/x86/entry/common.c:203 do_SYSENTER_32+0x1f/0x30 arch/x86/entry/common.c:246 entry_SYSENTER_compat_after_hwframe+0x70/0x82 Uninit was created at: __alloc_pages+0x9f6/0xe90 mm/page_alloc.c:5572 alloc_pages+0xab0/0xd80 mm/mempolicy.c:2287 __get_free_pages+0x34/0xc0 mm/page_alloc.c:5599 nilfs_ioctl_wrap_copy+0x223/0xc10 fs/nilfs2/ioctl.c:74 nilfs_ioctl_get_info fs/nilfs2/ioctl.c:1173 [inline] nilfs_ioctl+0x2402/0x4450 fs/nilfs2/ioctl.c:1290 nilfs_compat_ioctl+0x1b8/0x200 fs/nilfs2/ioctl.c:1343 __do_compat_sys_ioctl fs/ioctl.c:968 [inline] __se_compat_sys_ioctl+0x7dd/0x1000 fs/ioctl.c:910 __ia32_compat_sys_ioctl+0x93/0xd0 fs/ioctl.c:910 do_syscall_32_irqs_on arch/x86/entry/common.c:112 [inline] __do_fast_syscall_32+0xa2/0x100 arch/x86/entry/common.c:178 do_fast_syscall_32+0x37/0x80 arch/x86/entry/common.c:203 do_SYSENTER_32+0x1f/0x30 arch/x86/entry/common.c:246 entry_SYSENTER_compat_after_hwframe+0x70/0x82 Bytes 16-127 of 3968 are uninitialized ... This eliminates the leak issue by initializing the page allocated as buffer using get_zeroed_page().",,,"[{""url"":""https://git.kernel.org/stable/c/003587000276f81d0114b5ce773d80c119d8cb30"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5bb105cc72beb9d51bf12f5c657336d2d35bdc5d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5f33b042f74fc9662eba17f4cd19b07d84bbc6c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8a6550b365c0ce2e65905de57dcbfe1f7d629726"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8f5cbf6a8c0e19b062b829c5b7aca01468bb57f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9c5034e9a0e03db8d5e9eabb176340259b5b97e4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a94932381e8dae4117e9129b3c1282e18aa97b05"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d18db946cc6a394291539e030df32324285648f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53036,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:22.733,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Fix call trace warning and hang when removing amdgpu device On GPUs with RAS enabled, below call trace and hang are observed when shutting down device. v2: use DRM device unplugged flag instead of shutdown flag as the check to prevent memory wipe in shutdown stage. [ +0.000000] RIP: 0010:amdgpu_vram_mgr_fini+0x18d/0x1c0 [amdgpu] [ +0.000001] PKRU: 55555554 [ +0.000001] Call Trace: [ +0.000001] <TASK> [ +0.000002] amdgpu_ttm_fini+0x140/0x1c0 [amdgpu] [ +0.000183] amdgpu_bo_fini+0x27/0xa0 [amdgpu] [ +0.000184] gmc_v11_0_sw_fini+0x2b/0x40 [amdgpu] [ +0.000163] amdgpu_device_fini_sw+0xb6/0x510 [amdgpu] [ +0.000152] amdgpu_driver_release_kms+0x16/0x30 [amdgpu] [ +0.000090] drm_dev_release+0x28/0x50 [drm] [ +0.000016] devm_drm_dev_init_release+0x38/0x60 [drm] [ +0.000011] devm_action_release+0x15/0x20 [ +0.000003] release_nodes+0x40/0xc0 [ +0.000001] devres_release_all+0x9e/0xe0 [ +0.000001] device_unbind_cleanup+0x12/0x80 [ +0.000003] device_release_driver_internal+0xff/0x160 [ +0.000001] driver_detach+0x4a/0x90 [ +0.000001] bus_remove_driver+0x6c/0xf0 [ +0.000001] driver_unregister+0x31/0x50 [ +0.000001] pci_unregister_driver+0x40/0x90 [ +0.000003] amdgpu_exit+0x15/0x120 [amdgpu]",,,"[{""url"":""https://git.kernel.org/stable/c/93bb18d2a873d2fa9625c8ea927723660a868b95"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9a02dae3bbfe2df8e1c81e61a08695709e9588f9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f06b902511ea05526f405ee64da54a8313d91831"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53037,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:22.827,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: mpi3mr: Bad drive in topology results kernel crash When the SAS Transport Layer support is enabled and a device exposed to the OS by the driver fails INQUIRY commands, the driver frees up the memory allocated for an internal HBA port data structure. However, in some places, the reference to the freed memory is not cleared. When the firmware sends the Device Info change event for the same device again, the freed memory is accessed and that leads to memory corruption and OS crash.",,,"[{""url"":""https://git.kernel.org/stable/c/1f822ae8fb2a20fffa71e9bfa9b203c03d72d3ba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e45183978d64699df639e795235433a60f35047"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa11e4b6cdb403b9fdef6939550f6b36dd61624d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53038,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:22.920,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: lpfc: Check kzalloc() in lpfc_sli4_cgn_params_read() If kzalloc() fails in lpfc_sli4_cgn_params_read(), then we rely on lpfc_read_object()'s routine to NULL check pdata. Currently, an early return error is thrown from lpfc_read_object() to protect us from NULL ptr dereference, but the errno code is -ENODEV. Change the errno code to a more appropriate -ENOMEM.",,,"[{""url"":""https://git.kernel.org/stable/c/312320b0e0ec21249a17645683fe5304d796aec1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4829a1e1171536978b240a1438789c2e4d5c9715"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/67b8343998b84418bc5b5206aa01fe9b461a80ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/908dd9a0853a88155a5a36018c7e2b32ccf20379"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53039,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.017,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: HID: intel-ish-hid: ipc: Fix potential use-after-free in work function When a reset notify IPC message is received, the ISR schedules a work function and passes the ISHTP device to it via a global pointer ishtp_dev. If ish_probe() fails, the devm-managed device resources including ishtp_dev are freed, but the work is not cancelled, causing a use-after-free when the work function tries to access ishtp_dev. Use devm_work_autocancel() instead, so that the work is automatically cancelled if probe fails.",,,"[{""url"":""https://git.kernel.org/stable/c/0a594cb490ca6232671fc09e2dc1a0fc7ccbb0b5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ae2f2b0a28416ed2f6d8478ac8b9f7862f36785"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c1d378b8c224fd50247625255f09fc01dcc5836"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3ce3afd9f791dd1b7daedfcf8c396b60af5dec0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53040,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.113,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ca8210: fix mac_len negative array access This patch fixes a buffer overflow access of skb->data if ieee802154_hdr_peek_addrs() fails.",,,"[{""url"":""https://git.kernel.org/stable/c/55d836f75778d2e2cafe37e023f9c106400bad4b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5da4469a7aa011de614c3e2ae383c35a353a382e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c993779ea1d0cccdb3a5d7d45446dd229e610a3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7df72bedbdd1d02bb216e1f6eca0a16900238c4e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/918944526a386f186dd818ea6b0bcbed75d8c16b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d143e327c97241599c958d1ba9fbaa88c37db721"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d2b3bd0d4cadfdb7f3454d2aef9d5d9e8b48aae4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd176a18db96d574d8c4763708abcec4444a08b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53041,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.220,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: qla2xxx: Perform lockless command completion in abort path While adding and removing the controller, the following call trace was observed: WARNING: CPU: 3 PID: 623596 at kernel/dma/mapping.c:532 dma_free_attrs+0x33/0x50 CPU: 3 PID: 623596 Comm: sh Kdump: loaded Not tainted 5.14.0-96.el9.x86_64 #1 RIP: 0010:dma_free_attrs+0x33/0x50 Call Trace: qla2x00_async_sns_sp_done+0x107/0x1b0 [qla2xxx] qla2x00_abort_srb+0x8e/0x250 [qla2xxx] ? ql_dbg+0x70/0x100 [qla2xxx] __qla2x00_abort_all_cmds+0x108/0x190 [qla2xxx] qla2x00_abort_all_cmds+0x24/0x70 [qla2xxx] qla2x00_abort_isp_cleanup+0x305/0x3e0 [qla2xxx] qla2x00_remove_one+0x364/0x400 [qla2xxx] pci_device_remove+0x36/0xa0 __device_release_driver+0x17a/0x230 device_release_driver+0x24/0x30 pci_stop_bus_device+0x68/0x90 pci_stop_and_remove_bus_device_locked+0x16/0x30 remove_store+0x75/0x90 kernfs_fop_write_iter+0x11c/0x1b0 new_sync_write+0x11f/0x1b0 vfs_write+0x1eb/0x280 ksys_write+0x5f/0xe0 do_syscall_64+0x5c/0x80 ? do_user_addr_fault+0x1d8/0x680 ? do_syscall_64+0x69/0x80 ? exc_page_fault+0x62/0x140 ? asm_exc_page_fault+0x8/0x30 entry_SYSCALL_64_after_hwframe+0x44/0xae The command was completed in the abort path during driver unload with a lock held, causing the warning in abort path. Hence complete the command without any lock held.",,,"[{""url"":""https://git.kernel.org/stable/c/0367076b0817d5c75dfb83001ce7ce5c64d803a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/231cfa78ec5badd84a1a2b09465bfad1a926aba1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/415d614344a4f1bbddf55d724fc7eb9ef4b39aad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9189f20b4c5307c0998682bb522e481b4567a8b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd0a1804ac5bab2545ac700c8d0fe9ae9284c567"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d6f7377528d2abf338e504126e44439541be8f7d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53042,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.320,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Do not set DRR on pipe Commit [WHY] Writing to DRR registers such as OTG_V_TOTAL_MIN on the same frame as a pipe commit can cause underflow.",,,"[{""url"":""https://git.kernel.org/stable/c/3c20a098b507020936e02a98f4fbb924deeef44b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/56574f89dbd84004c3fd6485bcaafb5aa9b8be14"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8080f1e300e7abcc03025ec8b5bab69ae98daaa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53043,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.400,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: arm64: dts: qcom: sc7280: Mark PCIe controller as cache coherent If the controller is not marked as cache coherent, then kernel will try to ensure coherency during dma-ops and that may cause data corruption. So, mark the PCIe node as dma-coherent as the devices on PCIe bus are cache coherent.",,,"[{""url"":""https://git.kernel.org/stable/c/267b899375bf38944d915c9654d6eb434edad0ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8a63441e83724fee1ef3fd37b237d40d90780766"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e43bba938e2c9104bb4f8bc417ac4d7bb29755e1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53044,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.490,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dm stats: check for and propagate alloc_percpu failure Check alloc_precpu()'s return value and return an error from dm_stats_init() if it fails. Update alloc_dev() to fail if dm_stats_init() does. Otherwise, a NULL pointer dereference will occur in dm_stats_cleanup() even if dm-stats isn't being actively used.",,,"[{""url"":""https://git.kernel.org/stable/c/0d96bd507ed7e7d565b6d53ebd3874686f123b2e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2287d7b721471a3d58bcd829250336e3cdf1635e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/443c9d522397511a4328dc2ec3c9c63c73049756"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4a32a9a818a895671bd43e0c40351e60e4e9140b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5b66e36a3efd24041b7374432bfa4dec2ff01e95"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a42180dd361584816bfe15c137b665699b994d90"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c68f08cc745675a17894e1b4a5b5b9700ace6da4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3aa3e060c4a80827eb801fc448debc9daa7c46b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53045,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.590,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: gadget: u_audio: don't let userspace block driver unbind In the unbind callback for f_uac1 and f_uac2, a call to snd_card_free() via g_audio_cleanup() will disconnect the card and then wait for all resources to be released, which happens when the refcount falls to zero. Since userspace can keep the refcount incremented by not closing the relevant file descriptor, the call to unbind may block indefinitely. This can cause a deadlock during reboot, as evidenced by the following blocked task observed on my machine: task:reboot state:D stack:0 pid:2827 ppid:569 flags:0x0000000c Call trace: __switch_to+0xc8/0x140 __schedule+0x2f0/0x7c0 schedule+0x60/0xd0 schedule_timeout+0x180/0x1d4 wait_for_completion+0x78/0x180 snd_card_free+0x90/0xa0 g_audio_cleanup+0x2c/0x64 afunc_unbind+0x28/0x60 ... kernel_restart+0x4c/0xac __do_sys_reboot+0xcc/0x1ec __arm64_sys_reboot+0x28/0x30 invoke_syscall+0x4c/0x110 ... The issue can also be observed by opening the card with arecord and then stopping the process through the shell before unbinding: # arecord -D hw:UAC2Gadget -f S32_LE -c 2 -r 48000 /dev/null Recording WAVE '/dev/null' : Signed 32 bit Little Endian, Rate 48000 Hz, Stereo ^Z[1]+ Stopped arecord -D hw:UAC2Gadget -f S32_LE -c 2 -r 48000 /dev/null # echo gadget.0 > /sys/bus/gadget/drivers/configfs-gadget/unbind (observe that the unbind command never finishes) Fix the problem by using snd_card_free_when_closed() instead, which will still disconnect the card as desired, but defer the task of freeing the resources to the core once userspace closes its file descriptor.",,,"[{""url"":""https://git.kernel.org/stable/c/0eda2004f38d95ef5715d62be884cd344260535b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3256e152b645fc1e788ba44c2d8ced690113e3e6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/33f341c1fc60e172a3515c51bdabee11e83d1ee9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3bc7324e4911351e39c54a62e6ca46321cb10faf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3e016ef2e72da93a2ea7afbb45de1b481b44d761"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/43ca70753dfffd517d2af126da28690f8f615605"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c67ed9ad9b83e453e808f9b31a931a20a25629b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b131989797f7287d7fdadb2bababc05a15d44750"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53046,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.697,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: Fix race condition in hci_cmd_sync_clear There is a potential race condition in hci_cmd_sync_work and hci_cmd_sync_clear, and could lead to use-after-free. For instance, hci_cmd_sync_work is added to the 'req_workqueue' after cancel_work_sync The entry of 'cmd_sync_work_list' may be freed in hci_cmd_sync_clear, and causing kernel panic when it is used in 'hci_cmd_sync_work'. Here's the call trace: dump_stack_lvl+0x49/0x63 print_report.cold+0x5e/0x5d3 ? hci_cmd_sync_work+0x282/0x320 kasan_report+0xaa/0x120 ? hci_cmd_sync_work+0x282/0x320 __asan_report_load8_noabort+0x14/0x20 hci_cmd_sync_work+0x282/0x320 process_one_work+0x77b/0x11c0 ? _raw_spin_lock_irq+0x8e/0xf0 worker_thread+0x544/0x1180 ? poll_idle+0x1e0/0x1e0 kthread+0x285/0x320 ? process_one_work+0x11c0/0x11c0 ? kthread_complete_and_exit+0x30/0x30 ret_from_fork+0x22/0x30 </TASK> Allocated by task 266: kasan_save_stack+0x26/0x50 __kasan_kmalloc+0xae/0xe0 kmem_cache_alloc_trace+0x191/0x350 hci_cmd_sync_queue+0x97/0x2b0 hci_update_passive_scan+0x176/0x1d0 le_conn_complete_evt+0x1b5/0x1a00 hci_le_conn_complete_evt+0x234/0x340 hci_le_meta_evt+0x231/0x4e0 hci_event_packet+0x4c5/0xf00 hci_rx_work+0x37d/0x880 process_one_work+0x77b/0x11c0 worker_thread+0x544/0x1180 kthread+0x285/0x320 ret_from_fork+0x22/0x30 Freed by task 269: kasan_save_stack+0x26/0x50 kasan_set_track+0x25/0x40 kasan_set_free_info+0x24/0x40 ____kasan_slab_free+0x176/0x1c0 __kasan_slab_free+0x12/0x20 slab_free_freelist_hook+0x95/0x1a0 kfree+0xba/0x2f0 hci_cmd_sync_clear+0x14c/0x210 hci_unregister_dev+0xff/0x440 vhci_release+0x7b/0xf0 __fput+0x1f3/0x970 ____fput+0xe/0x20 task_work_run+0xd4/0x160 do_exit+0x8b0/0x22a0 do_group_exit+0xba/0x2a0 get_signal+0x1e4a/0x25b0 arch_do_signal_or_restart+0x93/0x1f80 exit_to_user_mode_prepare+0xf5/0x1a0 syscall_exit_to_user_mode+0x26/0x50 ret_from_fork+0x15/0x30",,,"[{""url"":""https://git.kernel.org/stable/c/1c66bee492a5fe00ae3fe890bb693bfc99f994c6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/608901a77c945ac15dea23f6098c9882ef19d9f0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be586211a3ab40a4f4ca60450e0d31606afc55ec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53047,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.790,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tee: amdtee: fix race condition in amdtee_open_session There is a potential race condition in amdtee_open_session that may lead to use-after-free. For instance, in amdtee_open_session() after sess->sess_mask is set, and before setting: sess->session_info[i] = session_info; if amdtee_close_session() closes this same session, then 'sess' data structure will be released, causing kernel panic when 'sess' is accessed within amdtee_open_session(). The solution is to set the bit sess->sess_mask as the last step in amdtee_open_session().",,,"[{""url"":""https://git.kernel.org/stable/c/02b296978a2137d7128151c542e84dc96400bc00"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a63cce9393e4e7dbc5af82dc87e68cb321cb1a78"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3ef9e6fe09f1a132af28c623edcf4d4f39d9f35"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f632a90f8e39db39b322107b9a8d438b826a7f4f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8502fba45bd30e1a6a354d9d898bc99d1a11e6d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53048,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.897,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: typec: tcpm: fix warning when handle discover_identity message Since both source and sink device can send discover_identity message in PD3, kernel may dump below warning: ------------[ cut here ]------------ WARNING: CPU: 0 PID: 169 at drivers/usb/typec/tcpm/tcpm.c:1446 tcpm_queue_vdm+0xe0/0xf0 Modules linked in: CPU: 0 PID: 169 Comm: 1-0050 Not tainted 6.1.1-00038-g6a3c36cf1da2-dirty #567 Hardware name: NXP i.MX8MPlus EVK board (DT) pstate: 20000005 (nzCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : tcpm_queue_vdm+0xe0/0xf0 lr : tcpm_queue_vdm+0x2c/0xf0 sp : ffff80000c19bcd0 x29: ffff80000c19bcd0 x28: 0000000000000001 x27: ffff0000d11c8ab8 x26: ffff0000d11cc000 x25: 0000000000000000 x24: 00000000ff008081 x23: 0000000000000001 x22: 00000000ff00a081 x21: ffff80000c19bdbc x20: 0000000000000000 x19: ffff0000d11c8080 x18: ffffffffffffffff x17: 0000000000000000 x16: 0000000000000000 x15: ffff0000d716f580 x14: 0000000000000001 x13: ffff0000d716f507 x12: 0000000000000001 x11: 0000000000000000 x10: 0000000000000020 x9 : 00000000000ee098 x8 : 00000000ffffffff x7 : 000000000000001c x6 : ffff0000d716f580 x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000 x2 : ffff80000c19bdbc x1 : 00000000ff00a081 x0 : 0000000000000004 Call trace: tcpm_queue_vdm+0xe0/0xf0 tcpm_pd_rx_handler+0x340/0x1ab0 kthread_worker_fn+0xcc/0x18c kthread+0x10c/0x110 ret_from_fork+0x10/0x20 ---[ end trace 0000000000000000 ]--- Below sequences may trigger this warning: tcpm_send_discover_work(work) tcpm_send_vdm(port, USB_SID_PD, CMD_DISCOVER_IDENT, NULL, 0); tcpm_queue_vdm(port, header, data, count); port->vdm_state = VDM_STATE_READY; vdm_state_machine_work(work); <-- received discover_identity from partner vdm_run_state_machine(port); port->vdm_state = VDM_STATE_SEND_MESSAGE; mod_vdm_delayed_work(port, x); tcpm_pd_rx_handler(work); tcpm_pd_data_request(port, msg); tcpm_handle_vdm_request(port, msg->payload, cnt); tcpm_queue_vdm(port, response[0], &response[1], rlen - 1); --> WARN_ON(port->vdm_state > VDM_STATE_DONE); For this case, the state machine could still send out discover identity message later if we skip current discover_identity message. So we should handle the received message firstly and override the pending discover_identity message without warning in this case. Then, a delayed send_discover work will send discover_identity message again.",,,"[{""url"":""https://git.kernel.org/stable/c/abfc4fa28f0160df61c7149567da4f6494dfb488"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bb579b3f75c60bf488a7c36e092e8be583407d53"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d55ca2d2ea1a7ec553213986993fba8c0257381c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e37d2c489d71e94ed4a39529bc9520a7fd983d42"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53049,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.990,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: ucsi: Fix NULL pointer deref in ucsi_connector_change() When ucsi_init() fails, ucsi->connector is NULL, yet in case of ucsi_acpi we may still get events which cause the ucs_acpi code to call ucsi_connector_change(), which then derefs the NULL ucsi->connector pointer. Fix this by not setting ucsi->ntfy inside ucsi_init() until ucsi_init() has succeeded, so that ucsi_connector_change() ignores the events because UCSI_ENABLE_NTFY_CONNECTOR_CHANGE is not set in the ntfy mask.",,,"[{""url"":""https://git.kernel.org/stable/c/1c5abcb13491da8c049f20462189c12c753ba978"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7dd27aed9c456670b3882877ef17a48195f21693"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ef0423e43f877a328454059d46763043ce3da44"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6adfe9bbd6ac11e398b54ccd99a0f8eea09f3c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f87fb985452ab2083967103ac00bfd68fb182764"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53050,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:24.093,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: thunderbolt: Fix memory leak in margining Memory for the usb4->margining needs to be relased for the upstream port of the router as well, even though the debugfs directory gets released with the router device removal. Fix this.",,,"[{""url"":""https://git.kernel.org/stable/c/0b357b360e671688f9bf38ff94300515b68bc247"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/acec726473822bc6b585961f4ca2a11fa7f28341"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f390095bbd131ec2dfb29792d9f6fd0f0656bfc0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53051,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:24.180,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dm crypt: add cond_resched() to dmcrypt_write() The loop in dmcrypt_write may be running for unbounded amount of time, thus we need cond_resched() in it. This commit fixes the following warning: [ 3391.153255][ C12] watchdog: BUG: soft lockup - CPU#12 stuck for 23s! [dmcrypt_write/2:2897] ... [ 3391.387210][ C12] Call trace: [ 3391.390338][ C12] blk_attempt_bio_merge.part.6+0x38/0x158 [ 3391.395970][ C12] blk_attempt_plug_merge+0xc0/0x1b0 [ 3391.401085][ C12] blk_mq_submit_bio+0x398/0x550 [ 3391.405856][ C12] submit_bio_noacct+0x308/0x380 [ 3391.410630][ C12] dmcrypt_write+0x1e4/0x208 [dm_crypt] [ 3391.416005][ C12] kthread+0x130/0x138 [ 3391.419911][ C12] ret_from_fork+0x10/0x18",,,"[{""url"":""https://git.kernel.org/stable/c/2c743db1193bf0e76c73d71ede08bd9b96e6c31d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/66ff37993dd7e9954b6446237fe2453b380ce40d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7b9f8efb5fc888dd938d2964e705b8e00f1dc0f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/885c28ceae7dab2b18c2cc0eb95f1f82b1f629d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e87cd83f70504f1cd2e428966f353c007d6d2d7f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb485b7404a281d974bd445ddc5b0b8d5958f371"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f0eb61b493dbbc32529fbd0d2e945b71b0e47306"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fb294b1c0ba982144ca467a75e7d01ff26304e2b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53052,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:24.283,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: cifs: fix use-after-free bug in refresh_cache_worker() The UAF bug occurred because we were putting DFS root sessions in cifs_umount() while DFS cache refresher was being executed. Make DFS root sessions have same lifetime as DFS tcons so we can avoid the use-after-free bug is DFS cache refresher and other places that require IPCs to get new DFS referrals on. Also, get rid of mount group handling in DFS cache as we no longer need it. This fixes below use-after-free bug catched by KASAN [ 379.946955] BUG: KASAN: use-after-free in __refresh_tcon.isra.0+0x10b/0xc10 [cifs] [ 379.947642] Read of size 8 at addr ffff888018f57030 by task kworker/u4:3/56 [ 379.948096] [ 379.948208] CPU: 0 PID: 56 Comm: kworker/u4:3 Not tainted 6.2.0-rc7-lku #23 [ 379.948661] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.0-0-gd239552-rebuilt.opensuse.org 04/01/2014 [ 379.949368] Workqueue: cifs-dfscache refresh_cache_worker [cifs] [ 379.949942] Call Trace: [ 379.950113] <TASK> [ 379.950260] dump_stack_lvl+0x50/0x67 [ 379.950510] print_report+0x16a/0x48e [ 379.950759] ? __virt_addr_valid+0xd8/0x160 [ 379.951040] ? __phys_addr+0x41/0x80 [ 379.951285] kasan_report+0xdb/0x110 [ 379.951533] ? __refresh_tcon.isra.0+0x10b/0xc10 [cifs] [ 379.952056] ? __refresh_tcon.isra.0+0x10b/0xc10 [cifs] [ 379.952585] __refresh_tcon.isra.0+0x10b/0xc10 [cifs] [ 379.953096] ? __pfx___refresh_tcon.isra.0+0x10/0x10 [cifs] [ 379.953637] ? __pfx___mutex_lock+0x10/0x10 [ 379.953915] ? lock_release+0xb6/0x720 [ 379.954167] ? __pfx_lock_acquire+0x10/0x10 [ 379.954443] ? refresh_cache_worker+0x34e/0x6d0 [cifs] [ 379.954960] ? __pfx_wb_workfn+0x10/0x10 [ 379.955239] refresh_cache_worker+0x4ad/0x6d0 [cifs] [ 379.955755] ? __pfx_refresh_cache_worker+0x10/0x10 [cifs] [ 379.956323] ? __pfx_lock_acquired+0x10/0x10 [ 379.956615] ? read_word_at_a_time+0xe/0x20 [ 379.956898] ? lockdep_hardirqs_on_prepare+0x12/0x220 [ 379.957235] process_one_work+0x535/0x990 [ 379.957509] ? __pfx_process_one_work+0x10/0x10 [ 379.957812] ? lock_acquired+0xb7/0x5f0 [ 379.958069] ? __list_add_valid+0x37/0xd0 [ 379.958341] ? __list_add_valid+0x37/0xd0 [ 379.958611] worker_thread+0x8e/0x630 [ 379.958861] ? __pfx_worker_thread+0x10/0x10 [ 379.959148] kthread+0x17d/0x1b0 [ 379.959369] ? __pfx_kthread+0x10/0x10 [ 379.959630] ret_from_fork+0x2c/0x50 [ 379.959879] </TASK>",,,"[{""url"":""https://git.kernel.org/stable/c/396935de145589c8bfe552fa03a5e38604071829"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a89d81c1a3c152837ea204fd29572228e54ce0b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53053,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:24.373,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: erspan: do not use skb_mac_header() in ndo_start_xmit() Drivers should not assume skb_mac_header(skb) == skb->data in their ndo_start_xmit(). Use skb_network_offset() and skb_transport_offset() which better describe what is needed in erspan_fb_xmit() and ip6erspan_tunnel_xmit() syzbot reported: WARNING: CPU: 0 PID: 5083 at include/linux/skbuff.h:2873 skb_mac_header include/linux/skbuff.h:2873 [inline] WARNING: CPU: 0 PID: 5083 at include/linux/skbuff.h:2873 ip6erspan_tunnel_xmit+0x1d9c/0x2d90 net/ipv6/ip6_gre.c:962 Modules linked in: CPU: 0 PID: 5083 Comm: syz-executor406 Not tainted 6.3.0-rc2-syzkaller-00866-gd4671cb96fa3 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/02/2023 RIP: 0010:skb_mac_header include/linux/skbuff.h:2873 [inline] RIP: 0010:ip6erspan_tunnel_xmit+0x1d9c/0x2d90 net/ipv6/ip6_gre.c:962 Code: 04 02 41 01 de 84 c0 74 08 3c 03 0f 8e 1c 0a 00 00 45 89 b4 24 c8 00 00 00 c6 85 77 fe ff ff 01 e9 33 e7 ff ff e8 b4 27 a1 f8 <0f> 0b e9 b6 e7 ff ff e8 a8 27 a1 f8 49 8d bf f0 0c 00 00 48 b8 00 RSP: 0018:ffffc90003b2f830 EFLAGS: 00010293 RAX: 0000000000000000 RBX: 000000000000ffff RCX: 0000000000000000 RDX: ffff888021273a80 RSI: ffffffff88e1bd4c RDI: 0000000000000003 RBP: ffffc90003b2f9d8 R08: 0000000000000003 R09: 000000000000ffff R10: 000000000000ffff R11: 0000000000000000 R12: ffff88802b28da00 R13: 00000000000000d0 R14: ffff88807e25b6d0 R15: ffff888023408000 FS: 0000555556a61300(0000) GS:ffff8880b9800000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000055e5b11eb6e8 CR3: 0000000027c1b000 CR4: 00000000003506f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> __netdev_start_xmit include/linux/netdevice.h:4900 [inline] netdev_start_xmit include/linux/netdevice.h:4914 [inline] __dev_direct_xmit+0x504/0x730 net/core/dev.c:4300 dev_direct_xmit include/linux/netdevice.h:3088 [inline] packet_xmit+0x20a/0x390 net/packet/af_packet.c:285 packet_snd net/packet/af_packet.c:3075 [inline] packet_sendmsg+0x31a0/0x5150 net/packet/af_packet.c:3107 sock_sendmsg_nosec net/socket.c:724 [inline] sock_sendmsg+0xde/0x190 net/socket.c:747 __sys_sendto+0x23a/0x340 net/socket.c:2142 __do_sys_sendto net/socket.c:2154 [inline] __se_sys_sendto net/socket.c:2150 [inline] __x64_sys_sendto+0xe1/0x1b0 net/socket.c:2150 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7f123aaa1039 Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 b1 14 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007ffc15d12058 EFLAGS: 00000246 ORIG_RAX: 000000000000002c RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f123aaa1039 RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000003 RBP: 0000000000000000 R08: 0000000020000040 R09: 0000000000000014 R10: 0000000000000000 R11: 0000000000000246 R12: 00007f123aa648c0 R13: 431bde82d7b634db R14: 0000000000000000 R15: 0000000000000000",,,"[{""url"":""https://git.kernel.org/stable/c/5d4172732f0ee1639a361a6cc5c3114bbb397386"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e50ed774554f93d55426039b27b1e38d7fa64d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9c7d6803689c99d55bbb862260d0ba486ff23c0b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b41f37dbd9cdb60000e3b0dfad6df787591c2265"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b72f453e886af532bde1fd049a2d2421999630d3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da149daf821a3c05cd04f7c60776c86c5ee9685c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8cec30541f5c5cc218e9a32138d45d227727f2f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53054,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:24.483,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: dwc2: fix a devres leak in hw_enable upon suspend resume Each time the platform goes to low power, PM suspend / resume routines call: __dwc2_lowlevel_hw_enable -> devm_add_action_or_reset(). This adds a new devres each time. This may also happen at runtime, as dwc2_lowlevel_hw_enable() can be called from udc_start(). This can be seen with tracing: - echo 1 > /sys/kernel/debug/tracing/events/dev/devres_log/enable - go to low power - cat /sys/kernel/debug/tracing/trace A new ""ADD"" entry is found upon each low power cycle: ... devres_log: 49000000.usb-otg ADD 82a13bba devm_action_release (8 bytes) ... devres_log: 49000000.usb-otg ADD 49889daf devm_action_release (8 bytes) ... A second issue is addressed here: - regulator_bulk_enable() is called upon each PM cycle (suspend/resume). - regulator_bulk_disable() never gets called. So the reference count for these regulators constantly increase, by one upon each low power cycle, due to missing regulator_bulk_disable() call in __dwc2_lowlevel_hw_disable(). The original fix that introduced the devm_add_action_or_reset() call, fixed an issue during probe, that happens due to other errors in dwc2_driver_probe() -> dwc2_core_reset(). Then the probe fails without disabling regulators, when dr_mode == USB_DR_MODE_PERIPHERAL. Rather fix the error path: disable all the low level hardware in the error path, by using the ""hsotg->ll_hw_enabled"" flag. Checking dr_mode has been introduced to avoid a dual call to dwc2_lowlevel_hw_disable(). ""ll_hw_enabled"" should achieve the same (and is used currently in the remove() routine).",,,"[{""url"":""https://git.kernel.org/stable/c/1f01027c51eb16145e8e07fafea3ca07ef102d06"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6485fc381b6528b6f547ee1ff10bdbcbe31a6e4c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cba76e1fb896b573f09f51aa299223276a77bc90"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f747313249b74f323ddf841a9c8db14d989f296a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ffb8ab6f87bd28d700ab5c20d9d3a7e75067630d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53055,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:24.590,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fscrypt: destroy keyring after security_sb_delete() fscrypt_destroy_keyring() must be called after all potentially-encrypted inodes were evicted; otherwise it cannot safely destroy the keyring. Since inodes that are in-use by the Landlock LSM don't get evicted until security_sb_delete(), this means that fscrypt_destroy_keyring() must be called *after* security_sb_delete(). This fixes a WARN_ON followed by a NULL dereference, only possible if Landlock was being used on encrypted files.",,,"[{""url"":""https://git.kernel.org/stable/c/497ab5d9c7852dfedab2c9de75e41b60e54b7c5d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/992a3f3e8a0c92151dfdf65fc85567c865fd558a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ccb820dc7d2236b1af0d54ae038a27b5b6d5ae5a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d77531fac6a1fd9f1db0195438ba5419d72b96c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53056,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:24.680,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: qla2xxx: Synchronize the IOCB count to be in order A system hang was observed with the following call trace: BUG: kernel NULL pointer dereference, address: 0000000000000000 PGD 0 P4D 0 Oops: 0000 [#1] PREEMPT SMP NOPTI CPU: 15 PID: 86747 Comm: nvme Kdump: loaded Not tainted 6.2.0+ #1 Hardware name: Dell Inc. PowerEdge R6515/04F3CJ, BIOS 2.7.3 03/31/2022 RIP: 0010:__wake_up_common+0x55/0x190 Code: 41 f6 01 04 0f 85 b2 00 00 00 48 8b 43 08 4c 8d 40 e8 48 8d 43 08 48 89 04 24 48 89 c6\ 49 8d 40 18 48 39 c6 0f 84 e9 00 00 00 <49> 8b 40 18 89 6c 24 14 31 ed 4c 8d 60 e8 41 8b 18 f6 c3 04 75 5d RSP: 0018:ffffb05a82afbba0 EFLAGS: 00010082 RAX: 0000000000000000 RBX: ffff8f9b83a00018 RCX: 0000000000000000 RDX: 0000000000000001 RSI: ffff8f9b83a00020 RDI: ffff8f9b83a00018 RBP: 0000000000000001 R08: ffffffffffffffe8 R09: ffffb05a82afbbf8 R10: 70735f7472617473 R11: 5f30307832616c71 R12: 0000000000000001 R13: 0000000000000003 R14: 0000000000000000 R15: 0000000000000000 FS: 00007f815cf4c740(0000) GS:ffff8f9eeed80000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000000 CR3: 000000010633a000 CR4: 0000000000350ee0 Call Trace: <TASK> __wake_up_common_lock+0x83/0xd0 qla_nvme_ls_req+0x21b/0x2b0 [qla2xxx] __nvme_fc_send_ls_req+0x1b5/0x350 [nvme_fc] nvme_fc_xmt_disconnect_assoc+0xca/0x110 [nvme_fc] nvme_fc_delete_association+0x1bf/0x220 [nvme_fc] ? nvme_remove_namespaces+0x9f/0x140 [nvme_core] nvme_do_delete_ctrl+0x5b/0xa0 [nvme_core] nvme_sysfs_delete+0x5f/0x70 [nvme_core] kernfs_fop_write_iter+0x12b/0x1c0 vfs_write+0x2a3/0x3b0 ksys_write+0x5f/0xe0 do_syscall_64+0x5c/0x90 ? syscall_exit_work+0x103/0x130 ? syscall_exit_to_user_mode+0x12/0x30 ? do_syscall_64+0x69/0x90 ? exit_to_user_mode_loop+0xd0/0x130 ? exit_to_user_mode_prepare+0xec/0x100 ? syscall_exit_to_user_mode+0x12/0x30 ? do_syscall_64+0x69/0x90 ? syscall_exit_to_user_mode+0x12/0x30 ? do_syscall_64+0x69/0x90 entry_SYSCALL_64_after_hwframe+0x72/0xdc RIP: 0033:0x7f815cd3eb97 The IOCB counts are out of order and that would block any commands from going out and subsequently hang the system. Synchronize the IOCB count to be in correct order.",,,"[{""url"":""https://git.kernel.org/stable/c/6295b3ec64a3623fa96869ffb7cf17d0b3c92035"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6d57b77d7369ed73836c82b25f785b34923eef84"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3affdeb400f3adc925bd996f3839481f5291839"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ffd7831841d3c56c655531fc8c5acafaaf20e1bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53057,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:24.773,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: HCI: Fix global-out-of-bounds To loop a variable-length array, hci_init_stage_sync(stage) considers that stage[i] is valid as long as stage[i-1].func is valid. Thus, the last element of stage[].func should be intentionally invalid as hci_init0[], le_init2[], and others did. However, amp_init1[] and amp_init2[] have no invalid element, letting hci_init_stage_sync() keep accessing amp_init1[] over its valid range. This patch fixes this by adding {} in the last of amp_init1[] and amp_init2[]. ================================================================== BUG: KASAN: global-out-of-bounds in hci_dev_open_sync ( /v6.2-bzimage/net/bluetooth/hci_sync.c:3154 /v6.2-bzimage/net/bluetooth/hci_sync.c:3343 /v6.2-bzimage/net/bluetooth/hci_sync.c:4418 /v6.2-bzimage/net/bluetooth/hci_sync.c:4609 /v6.2-bzimage/net/bluetooth/hci_sync.c:4689) Read of size 8 at addr ffffffffaed1ab70 by task kworker/u5:0/1032 CPU: 0 PID: 1032 Comm: kworker/u5:0 Not tainted 6.2.0 #3 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04 Workqueue: hci1 hci_power_on Call Trace: <TASK> dump_stack_lvl (/v6.2-bzimage/lib/dump_stack.c:107 (discriminator 1)) print_report (/v6.2-bzimage/mm/kasan/report.c:307 /v6.2-bzimage/mm/kasan/report.c:417) ? hci_dev_open_sync (/v6.2-bzimage/net/bluetooth/hci_sync.c:3154 /v6.2-bzimage/net/bluetooth/hci_sync.c:3343 /v6.2-bzimage/net/bluetooth/hci_sync.c:4418 /v6.2-bzimage/net/bluetooth/hci_sync.c:4609 /v6.2-bzimage/net/bluetooth/hci_sync.c:4689) kasan_report (/v6.2-bzimage/mm/kasan/report.c:184 /v6.2-bzimage/mm/kasan/report.c:519) ? hci_dev_open_sync (/v6.2-bzimage/net/bluetooth/hci_sync.c:3154 /v6.2-bzimage/net/bluetooth/hci_sync.c:3343 /v6.2-bzimage/net/bluetooth/hci_sync.c:4418 /v6.2-bzimage/net/bluetooth/hci_sync.c:4609 /v6.2-bzimage/net/bluetooth/hci_sync.c:4689) hci_dev_open_sync (/v6.2-bzimage/net/bluetooth/hci_sync.c:3154 /v6.2-bzimage/net/bluetooth/hci_sync.c:3343 /v6.2-bzimage/net/bluetooth/hci_sync.c:4418 /v6.2-bzimage/net/bluetooth/hci_sync.c:4609 /v6.2-bzimage/net/bluetooth/hci_sync.c:4689) ? __pfx_hci_dev_open_sync (/v6.2-bzimage/net/bluetooth/hci_sync.c:4635) ? mutex_lock (/v6.2-bzimage/./arch/x86/include/asm/atomic64_64.h:190 /v6.2-bzimage/./include/linux/atomic/atomic-long.h:443 /v6.2-bzimage/./include/linux/atomic/atomic-instrumented.h:1781 /v6.2-bzimage/kernel/locking/mutex.c:171 /v6.2-bzimage/kernel/locking/mutex.c:285) ? __pfx_mutex_lock (/v6.2-bzimage/kernel/locking/mutex.c:282) hci_power_on (/v6.2-bzimage/net/bluetooth/hci_core.c:485 /v6.2-bzimage/net/bluetooth/hci_core.c:984) ? __pfx_hci_power_on (/v6.2-bzimage/net/bluetooth/hci_core.c:969) ? read_word_at_a_time (/v6.2-bzimage/./include/asm-generic/rwonce.h:85) ? strscpy (/v6.2-bzimage/./arch/x86/include/asm/word-at-a-time.h:62 /v6.2-bzimage/lib/string.c:161) process_one_work (/v6.2-bzimage/kernel/workqueue.c:2294) worker_thread (/v6.2-bzimage/./include/linux/list.h:292 /v6.2-bzimage/kernel/workqueue.c:2437) ? __pfx_worker_thread (/v6.2-bzimage/kernel/workqueue.c:2379) kthread (/v6.2-bzimage/kernel/kthread.c:376) ? __pfx_kthread (/v6.2-bzimage/kernel/kthread.c:331) ret_from_fork (/v6.2-bzimage/arch/x86/entry/entry_64.S:314) </TASK> The buggy address belongs to the variable: amp_init1+0x30/0x60 The buggy address belongs to the physical page: page:000000003a157ec6 refcount:1 mapcount:0 mapping:0000000000000000 ia flags: 0x200000000001000(reserved|node=0|zone=2) raw: 0200000000001000 ffffea0005054688 ffffea0005054688 000000000000000 raw: 0000000000000000 0000000000000000 00000001ffffffff 000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffffffffaed1aa00: f9 f9 f9 f9 00 00 00 00 f9 f9 f9 f9 00 00 00 00 ffffffffaed1aa80: 00 00 00 00 f9 f9 f9 f9 00 00 00 00 00 00 00 00 >ffffffffaed1ab00: 00 f9 f9 f9 f9 f9 f9 f9 00 00 00 00 00 00 f9 f9 ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/8497222b22b591c6b2d106e0e3c1672ffe4e10e0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3168abd24245aa0775c5a387dcf94d36ca7e738"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bce56405201111807cc8e4f47c6de3e10b17c1ac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53058,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:24.867,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/mlx5: E-Switch, Fix an Oops in error handling code The error handling dereferences ""vport"". There is nothing we can do if it is an error pointer except returning the error code.",,,"[{""url"":""https://git.kernel.org/stable/c/1a9853a7437a22fd849347008fb3c85087906b56"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/388188fb58bef9e7f3ca4f8970f03d493b66909f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5eadc80328298ef7beaaf0cd96791667d3b485ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/640fcdbcf27fc62de9223f958ceb4e897a00e791"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c4c977935b2fc60084b3735737d17a06e7ba1bd0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53059,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:24.963,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: platform/chrome: cros_ec_chardev: fix kernel data leak from ioctl It is possible to peep kernel page's data by providing larger `insize` in struct cros_ec_command[1] when invoking EC host commands. Fix it by using zeroed memory. [1]: https://elixir.bootlin.com/linux/v6.2/source/include/linux/platform_data/cros_ec_proto.h#L74",,,"[{""url"":""https://git.kernel.org/stable/c/13493ad6a220cb3f6f3552a16b4f2753a118b633"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a0d8644784f73fa39f57f72f374eefaba2bf48a0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b20cf3f89c56b5f6a38b7f76a8128bf9f291bbd3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eab28bfafcd1245a3510df9aa9eb940589956ea6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ebea2e16504f40d2c2bac42ad5c5a3de5ce034b4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f86ff88a1548ccf5a13960c0e7625ca787ea0993"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53060,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:25.060,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: igb: revert rtnl_lock() that causes deadlock The commit 6faee3d4ee8b (""igb: Add lock to avoid data race"") adds rtnl_lock to eliminate a false data race shown below (FREE from device detaching) | (USE from netdev core) igb_remove | igb_ndo_get_vf_config igb_disable_sriov | vf >= adapter->vfs_allocated_count? kfree(adapter->vf_data) | adapter->vfs_allocated_count = 0 | | memcpy(... adapter->vf_data[vf] The above race will never happen and the extra rtnl_lock causes deadlock below [ 141.420169] <TASK> [ 141.420672] __schedule+0x2dd/0x840 [ 141.421427] schedule+0x50/0xc0 [ 141.422041] schedule_preempt_disabled+0x11/0x20 [ 141.422678] __mutex_lock.isra.13+0x431/0x6b0 [ 141.423324] unregister_netdev+0xe/0x20 [ 141.423578] igbvf_remove+0x45/0xe0 [igbvf] [ 141.423791] pci_device_remove+0x36/0xb0 [ 141.423990] device_release_driver_internal+0xc1/0x160 [ 141.424270] pci_stop_bus_device+0x6d/0x90 [ 141.424507] pci_stop_and_remove_bus_device+0xe/0x20 [ 141.424789] pci_iov_remove_virtfn+0xba/0x120 [ 141.425452] sriov_disable+0x2f/0xf0 [ 141.425679] igb_disable_sriov+0x4e/0x100 [igb] [ 141.426353] igb_remove+0xa0/0x130 [igb] [ 141.426599] pci_device_remove+0x36/0xb0 [ 141.426796] device_release_driver_internal+0xc1/0x160 [ 141.427060] driver_detach+0x44/0x90 [ 141.427253] bus_remove_driver+0x55/0xe0 [ 141.427477] pci_unregister_driver+0x2a/0xa0 [ 141.428296] __x64_sys_delete_module+0x141/0x2b0 [ 141.429126] ? mntput_no_expire+0x4a/0x240 [ 141.429363] ? syscall_trace_enter.isra.19+0x126/0x1a0 [ 141.429653] do_syscall_64+0x5b/0x80 [ 141.429847] ? exit_to_user_mode_prepare+0x14d/0x1c0 [ 141.430109] ? syscall_exit_to_user_mode+0x12/0x30 [ 141.430849] ? do_syscall_64+0x67/0x80 [ 141.431083] ? syscall_exit_to_user_mode_prepare+0x183/0x1b0 [ 141.431770] ? syscall_exit_to_user_mode+0x12/0x30 [ 141.432482] ? do_syscall_64+0x67/0x80 [ 141.432714] ? exc_page_fault+0x64/0x140 [ 141.432911] entry_SYSCALL_64_after_hwframe+0x72/0xdc Since the igb_disable_sriov() will call pci_disable_sriov() before releasing any resources, the netdev core will synchronize the cleanup to avoid any races. This patch removes the useless rtnl_(un)lock to guarantee correctness.",,,"[{""url"":""https://git.kernel.org/stable/c/0dabb72b923e17cb3b4ac99ea1adc9ef35116930"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4d2626e10709ff8474ffd1a9db3cf4647569e89c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/62a64645749926f9d75af82a96440941f22b046f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/65f69851e44d71248b952a687e44759a7abb5016"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/66e5577cabc3d463eea540332727929d0ace41c6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d845e9a485f287181ff81567c3900a8e7ad1e28"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd1e320ac0958298c2774605ad050483f33a21f2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de91528d8ba274c614a2265077d695c61e31fd43"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53061,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:25.163,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix possible refcount leak in smb2_open() Reference count of acls will leak when memory allocation fails. Fix this by adding the missing posix_acl_release().",,,"[{""url"":""https://git.kernel.org/stable/c/2624b445544ffc1472ccabfb6ec867c199d4c95c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/303f8e58cc3ace744801dcdcabfc06ffc72ed62d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a22c49a05e5e7aa2c414fbc42c49c4c01a5c9a78"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c33344b7972225b232966f95d31f6312dcc6273d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53062,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:25.257,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: usb: smsc95xx: Limit packet length to skb->len Packet length retrieved from descriptor may be larger than the actual socket buffer length. In such case the cloned skb passed up the network stack will leak kernel memory contents.",,,"[{""url"":""https://git.kernel.org/stable/c/33d1603a38e05886c538129ddfe00bd52d347e7b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/70eb25c6a6cde149affe8a587371a3a8ad295ba0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/733580e268a53db1cd01f2251419da91866378f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba6c40227108f8ee428e42eb0337b48ed3001e65"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3c145a4d24b752c9a1314d5a595014d51471418"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e041bef1adee02999cf24f9a2e15ed452bc363fe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f2111c791d885211714db85f9a06188571c57dd0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff821092cf02a70c2bccd2d19269f01e29aa52cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53063,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:25.377,2025-05-10T15:15:58.530,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53064,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:25.480,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iavf: fix hang on reboot with ice When a system with E810 with existing VFs gets rebooted the following hang may be observed. Pid 1 is hung in iavf_remove(), part of a network driver: PID: 1 TASK: ffff965400e5a340 CPU: 24 COMMAND: ""systemd-shutdow"" #0 [ffffaad04005fa50] __schedule at ffffffff8b3239cb #1 [ffffaad04005fae8] schedule at ffffffff8b323e2d #2 [ffffaad04005fb00] schedule_hrtimeout_range_clock at ffffffff8b32cebc #3 [ffffaad04005fb80] usleep_range_state at ffffffff8b32c930 #4 [ffffaad04005fbb0] iavf_remove at ffffffffc12b9b4c [iavf] #5 [ffffaad04005fbf0] pci_device_remove at ffffffff8add7513 #6 [ffffaad04005fc10] device_release_driver_internal at ffffffff8af08baa #7 [ffffaad04005fc40] pci_stop_bus_device at ffffffff8adcc5fc #8 [ffffaad04005fc60] pci_stop_and_remove_bus_device at ffffffff8adcc81e #9 [ffffaad04005fc70] pci_iov_remove_virtfn at ffffffff8adf9429 #10 [ffffaad04005fca8] sriov_disable at ffffffff8adf98e4 #11 [ffffaad04005fcc8] ice_free_vfs at ffffffffc04bb2c8 [ice] #12 [ffffaad04005fd10] ice_remove at ffffffffc04778fe [ice] #13 [ffffaad04005fd38] ice_shutdown at ffffffffc0477946 [ice] #14 [ffffaad04005fd50] pci_device_shutdown at ffffffff8add58f1 #15 [ffffaad04005fd70] device_shutdown at ffffffff8af05386 #16 [ffffaad04005fd98] kernel_restart at ffffffff8a92a870 #17 [ffffaad04005fda8] __do_sys_reboot at ffffffff8a92abd6 #18 [ffffaad04005fee0] do_syscall_64 at ffffffff8b317159 #19 [ffffaad04005ff08] __context_tracking_enter at ffffffff8b31b6fc #20 [ffffaad04005ff18] syscall_exit_to_user_mode at ffffffff8b31b50d #21 [ffffaad04005ff28] do_syscall_64 at ffffffff8b317169 #22 [ffffaad04005ff50] entry_SYSCALL_64_after_hwframe at ffffffff8b40009b RIP: 00007f1baa5c13d7 RSP: 00007fffbcc55a98 RFLAGS: 00000202 RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f1baa5c13d7 RDX: 0000000001234567 RSI: 0000000028121969 RDI: 00000000fee1dead RBP: 00007fffbcc55ca0 R8: 0000000000000000 R9: 00007fffbcc54e90 R10: 00007fffbcc55050 R11: 0000000000000202 R12: 0000000000000005 R13: 0000000000000000 R14: 00007fffbcc55af0 R15: 0000000000000000 ORIG_RAX: 00000000000000a9 CS: 0033 SS: 002b During reboot all drivers PM shutdown callbacks are invoked. In iavf_shutdown() the adapter state is changed to __IAVF_REMOVE. In ice_shutdown() the call chain above is executed, which at some point calls iavf_remove(). However iavf_remove() expects the VF to be in one of the states __IAVF_RUNNING, __IAVF_DOWN or __IAVF_INIT_FAILED. If that's not the case it sleeps forever. So if iavf_shutdown() gets invoked before iavf_remove() the system will hang indefinitely because the adapter is already in state __IAVF_REMOVE. Fix this by returning from iavf_remove() if the state is __IAVF_REMOVE, as we already went through iavf_shutdown().",,,"[{""url"":""https://git.kernel.org/stable/c/4e264be98b88a6d6f476c11087fe865696e8bef5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/502b898235f06130750c91512c86dd0e9efe28e6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7a29799fc141ba9e6cf921fc8e958e3398ad1a4f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f752ace58867de3c063512b21e0f1694fc27f043"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53065,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:25.580,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: perf/core: Fix perf_output_begin parameter is incorrectly invoked in perf_event_bpf_output syzkaller reportes a KASAN issue with stack-out-of-bounds. The call trace is as follows: dump_stack+0x9c/0xd3 print_address_description.constprop.0+0x19/0x170 __kasan_report.cold+0x6c/0x84 kasan_report+0x3a/0x50 __perf_event_header__init_id+0x34/0x290 perf_event_header__init_id+0x48/0x60 perf_output_begin+0x4a4/0x560 perf_event_bpf_output+0x161/0x1e0 perf_iterate_sb_cpu+0x29e/0x340 perf_iterate_sb+0x4c/0xc0 perf_event_bpf_event+0x194/0x2c0 __bpf_prog_put.constprop.0+0x55/0xf0 __cls_bpf_delete_prog+0xea/0x120 [cls_bpf] cls_bpf_delete_prog_work+0x1c/0x30 [cls_bpf] process_one_work+0x3c2/0x730 worker_thread+0x93/0x650 kthread+0x1b8/0x210 ret_from_fork+0x1f/0x30 commit 267fb27352b6 (""perf: Reduce stack usage of perf_output_begin()"") use on-stack struct perf_sample_data of the caller function. However, perf_event_bpf_output uses incorrect parameter to convert small-sized data (struct perf_bpf_event) into large-sized data (struct perf_sample_data), which causes memory overwriting occurs in __perf_event_header__init_id.",,,"[{""url"":""https://git.kernel.org/stable/c/3a776fddb4e5598c8bfcd4ad094fba34f9856fc9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac5f88642cb211152041f84a985309e9af4baf59"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ddcf8320003638a06eb1e46412e045d0c5701575"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb81a2ed4f52be831c9fb879752d89645a312c13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff8137727a2af4ad5f6e6c8b9f7ec5e8db9da86c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53066,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:25.673,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: qed/qed_sriov: guard against NULL derefs from qed_iov_get_vf_info We have to make sure that the info returned by the helper is valid before using it. Found by Linux Verification Center (linuxtesting.org) with the SVACE static analysis tool.",,,"[{""url"":""https://git.kernel.org/stable/c/25143b6a01d0cc5319edd3de22ffa2578b045550"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/39c3b9dd481c3afce9439b29bafe00444cb4406b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/42d72c6d1edc9dc09a5d6f6695d257fa9e9cc270"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7742c08e012eb65405e8304d100641638c5ff882"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7bd0037822fd04da13721f77a42ee5a077d4c5fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/97ea704f39b5ded96f071e98701aa543f6f89683"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b224b0cab3a66e93d414825065a2e667a1d28c32"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e42d3bde4ec03c863259878dddaef5c351cca7ad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53067,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:25.777,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: LoongArch: Only call get_timer_irq() once in constant_clockevent_init() Under CONFIG_DEBUG_ATOMIC_SLEEP=y and CONFIG_DEBUG_PREEMPT=y, we can see the following messages on LoongArch, this is because using might_sleep() in preemption disable context. [ 0.001127] smp: Bringing up secondary CPUs ... [ 0.001222] Booting CPU#1... [ 0.001244] 64-bit Loongson Processor probed (LA464 Core) [ 0.001247] CPU1 revision is: 0014c012 (Loongson-64bit) [ 0.001250] FPU1 revision is: 00000000 [ 0.001252] BUG: sleeping function called from invalid context at kernel/locking/mutex.c:283 [ 0.001255] in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 0, name: swapper/1 [ 0.001257] preempt_count: 1, expected: 0 [ 0.001258] RCU nest depth: 0, expected: 0 [ 0.001259] Preemption disabled at: [ 0.001261] [<9000000000223800>] arch_dup_task_struct+0x20/0x110 [ 0.001272] CPU: 1 PID: 0 Comm: swapper/1 Not tainted 6.2.0-rc7+ #43 [ 0.001275] Hardware name: Loongson Loongson-3A5000-7A1000-1w-A2101/Loongson-LS3A5000-7A1000-1w-A2101, BIOS vUDK2018-LoongArch-V4.0.05132-beta10 12/13/202 [ 0.001277] Stack : 0072617764726148 0000000000000000 9000000000222f1c 90000001001e0000 [ 0.001286] 90000001001e3be0 90000001001e3be8 0000000000000000 0000000000000000 [ 0.001292] 90000001001e3be8 0000000000000040 90000001001e3cb8 90000001001e3a50 [ 0.001297] 9000000001642000 90000001001e3be8 be694d10ce4139dd 9000000100174500 [ 0.001303] 0000000000000001 0000000000000001 00000000ffffe0a2 0000000000000020 [ 0.001309] 000000000000002f 9000000001354116 00000000056b0000 ffffffffffffffff [ 0.001314] 0000000000000000 0000000000000000 90000000014f6e90 9000000001642000 [ 0.001320] 900000000022b69c 0000000000000001 0000000000000000 9000000001736a90 [ 0.001325] 9000000100038000 0000000000000000 9000000000222f34 0000000000000000 [ 0.001331] 00000000000000b0 0000000000000004 0000000000000000 0000000000070000 [ 0.001337] ... [ 0.001339] Call Trace: [ 0.001342] [<9000000000222f34>] show_stack+0x5c/0x180 [ 0.001346] [<90000000010bdd80>] dump_stack_lvl+0x60/0x88 [ 0.001352] [<9000000000266418>] __might_resched+0x180/0x1cc [ 0.001356] [<90000000010c742c>] mutex_lock+0x20/0x64 [ 0.001359] [<90000000002a8ccc>] irq_find_matching_fwspec+0x48/0x124 [ 0.001364] [<90000000002259c4>] constant_clockevent_init+0x68/0x204 [ 0.001368] [<900000000022acf4>] start_secondary+0x40/0xa8 [ 0.001371] [<90000000010c0124>] smpboot_entry+0x60/0x64 Here are the complete call chains: smpboot_entry() start_secondary() constant_clockevent_init() get_timer_irq() irq_find_matching_fwnode() irq_find_matching_fwspec() mutex_lock() might_sleep() __might_sleep() __might_resched() In order to avoid the above issue, we should break the call chains, using timer_irq_installed variable as check condition to only call get_timer_irq() once in constant_clockevent_init() is a simple and proper way.",,,"[{""url"":""https://git.kernel.org/stable/c/acadbd058fa12b510fbecca11eae22bd6f654250"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b9c379e1d7e141b102f41858c9b8f6f36e7c89a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bb7a78e343468873bf00b2b181fcfd3c02d8cb56"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53068,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:25.870,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: usb: lan78xx: Limit packet length to skb->len Packet length retrieved from descriptor may be larger than the actual socket buffer length. In such case the cloned skb passed up the network stack will leak kernel memory contents. Additionally prevent integer underflow when size is less than ETH_FCS_LEN.",,,"[{""url"":""https://git.kernel.org/stable/c/44b9ed73369fc5ec85dd2ee487e986301792a82d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f247f5a2c18b3f21206cdd51193df4f38e1b9f5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/83de34967473ed31d276381373713cc2869a42e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53069,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:25.960,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: octeontx2-vf: Add missing free for alloc_percpu Add the free_percpu for the allocated ""vf->hw.lmt_info"" in order to avoid memory leak, same as the ""pf->hw.lmt_info"" in `drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c`.",,,"[{""url"":""https://git.kernel.org/stable/c/813b590840771890c738ce6dbfd0c5938a1bafb9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/840631bcf21f58c0a3f01378a54d79e9ce86b226"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90874b76e5f82eaa3309714d72ff2cd8bb8d1b02"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f038f3917baf04835ba2b7bcf2a04ac93fbf8a9c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53070,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:26.050,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ACPI: PPTT: Fix to avoid sleep in the atomic context when PPTT is absent Commit 0c80f9e165f8 (""ACPI: PPTT: Leave the table mapped for the runtime usage"") enabled to map PPTT once on the first invocation of acpi_get_pptt() and never unmapped the same allowing it to be used at runtime with out the hassle of mapping and unmapping the table. This was needed to fetch LLC information from the PPTT in the cpuhotplug path which is executed in the atomic context as the acpi_get_table() might sleep waiting for a mutex. However it missed to handle the case when there is no PPTT on the system which results in acpi_get_pptt() being called from all the secondary CPUs attempting to fetch the LLC information in the atomic context without knowing the absence of PPTT resulting in the splat like below: | BUG: sleeping function called from invalid context at kernel/locking/semaphore.c:164 | in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 0, name: swapper/1 | preempt_count: 1, expected: 0 | RCU nest depth: 0, expected: 0 | no locks held by swapper/1/0. | irq event stamp: 0 | hardirqs last enabled at (0): 0x0 | hardirqs last disabled at (0): copy_process+0x61c/0x1b40 | softirqs last enabled at (0): copy_process+0x61c/0x1b40 | softirqs last disabled at (0): 0x0 | CPU: 1 PID: 0 Comm: swapper/1 Not tainted 6.3.0-rc1 #1 | Call trace: | dump_backtrace+0xac/0x138 | show_stack+0x30/0x48 | dump_stack_lvl+0x60/0xb0 | dump_stack+0x18/0x28 | __might_resched+0x160/0x270 | __might_sleep+0x58/0xb0 | down_timeout+0x34/0x98 | acpi_os_wait_semaphore+0x7c/0xc0 | acpi_ut_acquire_mutex+0x58/0x108 | acpi_get_table+0x40/0xe8 | acpi_get_pptt+0x48/0xa0 | acpi_get_cache_info+0x38/0x140 | init_cache_level+0xf4/0x118 | detect_cache_attributes+0x2e4/0x640 | update_siblings_masks+0x3c/0x330 | store_cpu_topology+0x88/0xf0 | secondary_start_kernel+0xd0/0x168 | __secondary_switched+0xb8/0xc0 Update acpi_get_pptt() to consider the fact that PPTT is once checked and is not available on the system and return NULL avoiding any attempts to fetch PPTT and thereby avoiding any possible sleep waiting for a mutex in the atomic context.",,,"[{""url"":""https://git.kernel.org/stable/c/1318a07706bb2f8c65f88f39a16c2b5260bcdcd4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/91d7b60a65d9f71230ea09b86d2058a884a3c2af"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0c1106d51b9abc8eae03c5522b20649b6a55f6e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53071,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:26.140,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: do not run mt76_unregister_device() on unregistered hw Trying to probe a mt7921e pci card without firmware results in a successful probe where ieee80211_register_hw hasn't been called. When removing the driver, ieee802111_unregister_hw is called unconditionally leading to a kernel NULL pointer dereference. Fix the issue running mt76_unregister_device routine just for registered hw.",,,"[{""url"":""https://git.kernel.org/stable/c/2d34f27714c97a9786a30b3bb54944d6d8ed612f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/41130c32f3a18fcc930316da17f3a5f3bc326aa1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dffe86df26aee01a5fc56a175b7a7f157961e370"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53072,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:26.237,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mptcp: use the workqueue to destroy unaccepted sockets Christoph reported a UaF at token lookup time after having refactored the passive socket initialization part: BUG: KASAN: use-after-free in __token_bucket_busy+0x253/0x260 Read of size 4 at addr ffff88810698d5b0 by task syz-executor653/3198 CPU: 1 PID: 3198 Comm: syz-executor653 Not tainted 6.2.0-rc59af4eaa31c1f6c00c8f1e448ed99a45c66340dd5 #6 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x6e/0x91 print_report+0x16a/0x46f kasan_report+0xad/0x130 __token_bucket_busy+0x253/0x260 mptcp_token_new_connect+0x13d/0x490 mptcp_connect+0x4ed/0x860 __inet_stream_connect+0x80e/0xd90 tcp_sendmsg_fastopen+0x3ce/0x710 mptcp_sendmsg+0xff1/0x1a20 inet_sendmsg+0x11d/0x140 __sys_sendto+0x405/0x490 __x64_sys_sendto+0xdc/0x1b0 do_syscall_64+0x3b/0x90 entry_SYSCALL_64_after_hwframe+0x72/0xdc We need to properly clean-up all the paired MPTCP-level resources and be sure to release the msk last, even when the unaccepted subflow is destroyed by the TCP internals via inet_child_forget(). We can re-use the existing MPTCP_WORK_CLOSE_SUBFLOW infra, explicitly checking that for the critical scenario: the closed subflow is the MPC one, the msk is not accepted and eventually going through full cleanup. With such change, __mptcp_destroy_sock() is always called on msk sockets, even on accepted ones. We don't need anymore to transiently drop one sk reference at msk clone time. Please note this commit depends on the parent one: mptcp: refactor passive socket initialization",,,"[{""url"":""https://git.kernel.org/stable/c/2827f099b3fb9a59263c997400e9182f5d423e84"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/804cf487fb0031f3c74755b78d8663333f0ba636"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b6985b9b82954caa53f862d6059d06c0526254f0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53073,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:26.330,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: perf/x86/amd/core: Always clear status for idx The variable 'status' (which contains the unhandled overflow bits) is not being properly masked in some cases, displaying the following warning: WARNING: CPU: 156 PID: 475601 at arch/x86/events/amd/core.c:972 amd_pmu_v2_handle_irq+0x216/0x270 This seems to be happening because the loop is being continued before the status bit being unset, in case x86_perf_event_set_period() returns 0. This is also causing an inconsistency because the ""handled"" counter is incremented, but the status bit is not cleaned. Move the bit cleaning together above, together when the ""handled"" counter is incremented.",,,"[{""url"":""https://git.kernel.org/stable/c/263f5ecaf7080513efc248ec739b6d9e00f4129f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d4c7b1f12e101d6d6253092588b127416ddfb6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ab33a8f7649b0324639a336e1081aaea51a4523e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53074,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:26.420,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: fix ttm_bo calltrace warning in psp_hw_fini The call trace occurs when the amdgpu is removed after the mode1 reset. During mode1 reset, from suspend to resume, there is no need to reinitialize the ta firmware buffer which caused the bo pin_count increase redundantly. [ 489.885525] Call Trace: [ 489.885525] <TASK> [ 489.885526] amdttm_bo_put+0x34/0x50 [amdttm] [ 489.885529] amdgpu_bo_free_kernel+0xe8/0x130 [amdgpu] [ 489.885620] psp_free_shared_bufs+0xb7/0x150 [amdgpu] [ 489.885720] psp_hw_fini+0xce/0x170 [amdgpu] [ 489.885815] amdgpu_device_fini_hw+0x2ff/0x413 [amdgpu] [ 489.885960] ? blocking_notifier_chain_unregister+0x56/0xb0 [ 489.885962] amdgpu_driver_unload_kms+0x51/0x60 [amdgpu] [ 489.886049] amdgpu_pci_remove+0x5a/0x140 [amdgpu] [ 489.886132] ? __pm_runtime_resume+0x60/0x90 [ 489.886134] pci_device_remove+0x3e/0xb0 [ 489.886135] __device_release_driver+0x1ab/0x2a0 [ 489.886137] driver_detach+0xf3/0x140 [ 489.886138] bus_remove_driver+0x6c/0xf0 [ 489.886140] driver_unregister+0x31/0x60 [ 489.886141] pci_unregister_driver+0x40/0x90 [ 489.886142] amdgpu_exit+0x15/0x451 [amdgpu]",,,"[{""url"":""https://git.kernel.org/stable/c/23f4a2d29ba57bf88095f817de5809d427fcbe7e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/55a7c647ebf6e376c45d8322568dd6eb71937139"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7be9a2f8c5179520a7d5570e648e0c97d09e4fae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53075,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:26.510,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ftrace: Fix invalid address access in lookup_rec() when index is 0 KASAN reported follow problem: BUG: KASAN: use-after-free in lookup_rec Read of size 8 at addr ffff000199270ff0 by task modprobe CPU: 2 Comm: modprobe Call trace: kasan_report __asan_load8 lookup_rec ftrace_location arch_check_ftrace_location check_kprobe_address_safe register_kprobe When checking pg->records[pg->index - 1].ip in lookup_rec(), it can get a pg which is newly added to ftrace_pages_start in ftrace_process_locs(). Before the first pg->index++, index is 0 and accessing pg->records[-1].ip will cause this problem. Don't check the ip when pg->index is 0.",,,"[{""url"":""https://git.kernel.org/stable/c/2a0d71fabfeb349216d33f001a6421b1768bd3a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2de28e5ce34b22b73b833a21e2c45ae3aade3964"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4f84f31f63416b0f02fc146ffdc4ab32723eb7e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7569ee04b0e3b32df79f64db3a7138573edad9bc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/83c3b2f4e7c61367c7b24551f4c6eb94bbdda283"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac58b88ccbbb8e9fb83e137cee04a856b1ea6635"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee92fa443358f4fc0017c1d0d325c27b37802504"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1bd8b7fd890d87d0dc4dedc6287ea34dd07c0b4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53076,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:26.610,2025-05-05T15:15:53.393,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53077,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:26.720,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: fix shift-out-of-bounds in CalculateVMAndRowBytes [WHY] When PTEBufferSizeInRequests is zero, UBSAN reports the following warning because dml_log2 returns an unexpected negative value: shift exponent 4294966273 is too large for 32-bit type 'int' [HOW] In the case PTEBufferSizeInRequests is zero, skip the dml_log2() and assign the result directly.",,,"[{""url"":""https://git.kernel.org/stable/c/031f196d1b1b6d5dfcb0533b431e3ab1750e6189"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7257070be70e19a9138f39009c1a26c83a8a7cfa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a16394b5d661afec9a264fecac3abd87aea439ea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bec1bea2fa974e63f6059c33edde669c7894d0bc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e12b95680821b9880cd9992c0f3555389363604f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53078,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:26.820,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: scsi_dh_alua: Fix memleak for 'qdata' in alua_activate() If alua_rtpg_queue() failed from alua_activate(), then 'qdata' is not freed, which will cause following memleak: unreferenced object 0xffff88810b2c6980 (size 32): comm ""kworker/u16:2"", pid 635322, jiffies 4355801099 (age 1216426.076s) hex dump (first 32 bytes): 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 40 39 24 c1 ff ff ff ff 00 f8 ea 0a 81 88 ff ff @9$............. backtrace: [<0000000098f3a26d>] alua_activate+0xb0/0x320 [<000000003b529641>] scsi_dh_activate+0xb2/0x140 [<000000007b296db3>] activate_path_work+0xc6/0xe0 [dm_multipath] [<000000007adc9ace>] process_one_work+0x3c5/0x730 [<00000000c457a985>] worker_thread+0x93/0x650 [<00000000cb80e628>] kthread+0x1ba/0x210 [<00000000a1e61077>] ret_from_fork+0x22/0x30 Fix the problem by freeing 'qdata' in error path.",,,"[{""url"":""https://git.kernel.org/stable/c/0d89254a4320eb7de0970c478172f764125c6355"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/123483df146492ca22b503ae6dacc2ce7c3a3974"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1c55982beb80c7d3c30278fc6cfda8496a31dbe6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5c4d71424df34fc23dc5336d09394ce68c849542"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9311e7a554dffd3823499e309a8b86a5cd1540e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a13faca032acbf2699293587085293bdfaafc8ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c09cdf6eb815ee35e55d6c50ac7f63db58bd20b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c110051d335ef7f62ad33474b0c23997fee5bfb5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53079,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:26.923,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/mlx5: Fix steering rules cleanup vport's mc, uc and multicast rules are not deleted in teardown path when EEH happens. Since the vport's promisc settings(uc, mc and all) in firmware are reset after EEH, mlx5 driver will try to delete the above rules in the initialization path. This cause kernel crash because these software rules are no longer valid. Fix by nullifying these rules right after delete to avoid accessing any dangling pointers. Call Trace: __list_del_entry_valid+0xcc/0x100 (unreliable) tree_put_node+0xf4/0x1b0 [mlx5_core] tree_remove_node+0x30/0x70 [mlx5_core] mlx5_del_flow_rules+0x14c/0x1f0 [mlx5_core] esw_apply_vport_rx_mode+0x10c/0x200 [mlx5_core] esw_update_vport_rx_mode+0xb4/0x180 [mlx5_core] esw_vport_change_handle_locked+0x1ec/0x230 [mlx5_core] esw_enable_vport+0x130/0x260 [mlx5_core] mlx5_eswitch_enable_sriov+0x2a0/0x2f0 [mlx5_core] mlx5_device_enable_sriov+0x74/0x440 [mlx5_core] mlx5_load_one+0x114c/0x1550 [mlx5_core] mlx5_pci_resume+0x68/0xf0 [mlx5_core] eeh_report_resume+0x1a4/0x230 eeh_pe_dev_traverse+0x98/0x170 eeh_handle_normal_event+0x3e4/0x640 eeh_handle_event+0x4c/0x370 eeh_event_handler+0x14c/0x210 kthread+0x168/0x1b0 ret_from_kernel_thread+0x5c/0x84",,,"[{""url"":""https://git.kernel.org/stable/c/18cead61e437f4c7898acca0a5f3df12f801d97f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4df1f2d36bdc9a368650bf14b9097c555e95f71d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/63546395a0e6ac264f78f65218086ce6014b4494"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6f5780536181d1d0d09a11a1bc92f22e143447e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/922f56e9a795d6f3dd72d3428ebdd7ee040fa855"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53080,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.020,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: xsk: Add missing overflow check in xdp_umem_reg The number of chunks can overflow u32. Make sure to return -EINVAL on overflow. Also remove a redundant u32 cast assigning umem->npgs.",,,"[{""url"":""https://git.kernel.org/stable/c/3cfc3564411acf96bf2fb791f706a1aa4f872c1d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/580634b03a55f04a3c1968bcbd97736c079c6601"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a069909acc4435eeb41d05ccc03baa447cc01b7e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bb2e3bfb2a79db0c2057c6f701b782954394c67f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c7df4813b149362248d6ef7be41a311e27bf75fe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53081,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.117,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ocfs2: fix data corruption after failed write When buffered write fails to copy data into underlying page cache page, ocfs2_write_end_nolock() just zeroes out and dirties the page. This can leave dirty page beyond EOF and if page writeback tries to write this page before write succeeds and expands i_size, page gets into inconsistent state where page dirty bit is clear but buffer dirty bits stay set resulting in page data never getting written and so data copied to the page is lost. Fix the problem by invalidating page beyond EOF after failed write.",,,"[{""url"":""https://git.kernel.org/stable/c/1629f6f522b2d058019710466a84b240683bbee3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/205759c6c18f54659b0b5976b14a52d1b3eb9f57"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/47eb055ad3588fc96d34e9e1dd87b210ce62906b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c24eb49ab44351424ac8fe8567f91ea48a06089"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90410bcf873cf05f54a32183afff0161f44f9715"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/91d7a4bd5656552d6259e2d0f8859f9e8cc5ef68"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9e53869cb43c96d6d851c491fd4e26430ab6ba6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c26f3ff4c0be590c1250f945ac2e4fc5fcdc5f45"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53082,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.220,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: vp_vdpa: fix the crash in hot unplug with vp_vdpa While unplugging the vp_vdpa device, it triggers a kernel panic The root cause is: vdpa_mgmtdev_unregister() will accesses modern devices which will cause a use after free. So need to change the sequence in vp_vdpa_remove [ 195.003359] BUG: unable to handle page fault for address: ff4e8beb80199014 [ 195.004012] #PF: supervisor read access in kernel mode [ 195.004486] #PF: error_code(0x0000) - not-present page [ 195.004960] PGD 100000067 P4D 1001b6067 PUD 1001b7067 PMD 1001b8067 PTE 0 [ 195.005578] Oops: 0000 1 PREEMPT SMP PTI [ 195.005968] CPU: 13 PID: 164 Comm: kworker/u56:10 Kdump: loaded Not tainted 5.14.0-252.el9.x86_64 #1 [ 195.006792] Hardware name: Red Hat KVM/RHEL, BIOS edk2-20221207gitfff6d81270b5-2.el9 unknown [ 195.007556] Workqueue: kacpi_hotplug acpi_hotplug_work_fn [ 195.008059] RIP: 0010:ioread8+0x31/0x80 [ 195.008418] Code: 77 28 48 81 ff 00 00 01 00 76 0b 89 fa ec 0f b6 c0 c3 cc cc cc cc 8b 15 ad 72 93 01 b8 ff 00 00 00 85 d2 75 0f c3 cc cc cc cc <8a> 07 0f b6 c0 c3 cc cc cc cc 83 ea 01 48 83 ec 08 48 89 fe 48 c7 [ 195.010104] RSP: 0018:ff4e8beb8067bab8 EFLAGS: 00010292 [ 195.010584] RAX: ffffffffc05834a0 RBX: ffffffffc05843c0 RCX: ff4e8beb8067bae0 [ 195.011233] RDX: ff1bcbd580f88000 RSI: 0000000000000246 RDI: ff4e8beb80199014 [ 195.011881] RBP: ff1bcbd587e39000 R08: ffffffff916fa2d0 R09: ff4e8beb8067ba68 [ 195.012527] R10: 000000000000001c R11: 0000000000000000 R12: ff1bcbd5a3de9120 [ 195.013179] R13: ffffffffc062d000 R14: 0000000000000080 R15: ff1bcbe402bc7805 [ 195.013826] FS: 0000000000000000(0000) GS:ff1bcbe402740000(0000) knlGS:0000000000000000 [ 195.014564] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 195.015093] CR2: ff4e8beb80199014 CR3: 0000000107dea002 CR4: 0000000000771ee0 [ 195.015741] PKRU: 55555554 [ 195.016001] Call Trace: [ 195.016233] <TASK> [ 195.016434] vp_modern_get_status+0x12/0x20 [ 195.016823] vp_vdpa_reset+0x1b/0x50 [vp_vdpa] [ 195.017238] virtio_vdpa_reset+0x3c/0x48 [virtio_vdpa] [ 195.017709] remove_vq_common+0x1f/0x3a0 [virtio_net] [ 195.018178] virtnet_remove+0x5d/0x70 [virtio_net] [ 195.018618] virtio_dev_remove+0x3d/0x90 [ 195.018986] device_release_driver_internal+0x1aa/0x230 [ 195.019466] bus_remove_device+0xd8/0x150 [ 195.019841] device_del+0x18b/0x3f0 [ 195.020167] ? kernfs_find_ns+0x35/0xd0 [ 195.020526] device_unregister+0x13/0x60 [ 195.020894] unregister_virtio_device+0x11/0x20 [ 195.021311] device_release_driver_internal+0x1aa/0x230 [ 195.021790] bus_remove_device+0xd8/0x150 [ 195.022162] device_del+0x18b/0x3f0 [ 195.022487] device_unregister+0x13/0x60 [ 195.022852] ? vdpa_dev_remove+0x30/0x30 [vdpa] [ 195.023270] vp_vdpa_dev_del+0x12/0x20 [vp_vdpa] [ 195.023694] vdpa_match_remove+0x2b/0x40 [vdpa] [ 195.024115] bus_for_each_dev+0x78/0xc0 [ 195.024471] vdpa_mgmtdev_unregister+0x65/0x80 [vdpa] [ 195.024937] vp_vdpa_remove+0x23/0x40 [vp_vdpa] [ 195.025353] pci_device_remove+0x36/0xa0 [ 195.025719] device_release_driver_internal+0x1aa/0x230 [ 195.026201] pci_stop_bus_device+0x6c/0x90 [ 195.026580] pci_stop_and_remove_bus_device+0xe/0x20 [ 195.027039] disable_slot+0x49/0x90 [ 195.027366] acpiphp_disable_and_eject_slot+0x15/0x90 [ 195.027832] hotplug_event+0xea/0x210 [ 195.028171] ? hotplug_event+0x210/0x210 [ 195.028535] acpiphp_hotplug_notify+0x22/0x80 [ 195.028942] ? hotplug_event+0x210/0x210 [ 195.029303] acpi_device_hotplug+0x8a/0x1d0 [ 195.029690] acpi_hotplug_work_fn+0x1a/0x30 [ 195.030077] process_one_work+0x1e8/0x3c0 [ 195.030451] worker_thread+0x50/0x3b0 [ 195.030791] ? rescuer_thread+0x3a0/0x3a0 [ 195.031165] kthread+0xd9/0x100 [ 195.031459] ? kthread_complete_and_exit+0x20/0x20 [ 195.031899] ret_from_fork+0x22/0x30 [ 195.032233] </TASK>",,,"[{""url"":""https://git.kernel.org/stable/c/aed8efddd39b3434c96718d39009285c52b1cafc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/baafa2960731211837d8fc04ff3873ecb7440464"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa1f327f93c9a7310cce9d2fcda28b7af91f7437"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53083,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.310,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nfsd: don't replace page in rq_pages if it's a continuation of last page The splice read calls nfsd_splice_actor to put the pages containing file data into the svc_rqst->rq_pages array. It's possible however to get a splice result that only has a partial page at the end, if (e.g.) the filesystem hands back a short read that doesn't cover the whole page. nfsd_splice_actor will plop the partial page into its rq_pages array and return. Then later, when nfsd_splice_actor is called again, the remainder of the page may end up being filled out. At this point, nfsd_splice_actor will put the page into the array _again_ corrupting the reply. If this is done enough times, rq_next_page will overrun the array and corrupt the trailing fields -- the rq_respages and rq_next_page pointers themselves. If we've already added the page to the array in the last pass, don't add it to the array a second time when dealing with a splice continuation. This was originally handled properly in nfsd_splice_actor, but commit 91e23b1c3982 (""NFSD: Clean up nfsd_splice_actor()"") removed the check for it.",,,"[{""url"":""https://git.kernel.org/stable/c/0101067f376eb7b9afd00279270f25d5111a091d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/12eca509234acb6b666802edf77408bb70d7bfca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/27c934dd8832dd40fd34776f916dc201e18b319b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/51ddb84baff6f09ad62b5999ece3ec172e4e3568"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8235cd619db6e67f1d7d26c55f1f3e4e575c947d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53084,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.403,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/shmem-helper: Remove another errant put in error path drm_gem_shmem_mmap() doesn't own reference in error code path, resulting in the dma-buf shmem GEM object getting prematurely freed leading to a later use-after-free.",,,"[{""url"":""https://git.kernel.org/stable/c/5cfb617967b05f8f27e862c97db1fabd8485f4db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/684c7372bbd6447c2e86a2a84e97a1478604d21f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/77d26c824aa5a7e0681ef1d5b75fe538d746addc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dede8c14a37a7ac458f9add56154a074ed78e7cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee9adb7a45516cfa536ca92253d7ae59d56db9e4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53085,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.493,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/edid: fix info leak when failing to get panel id Make sure to clear the transfer buffer before fetching the EDID to avoid leaking slab data to the logs on errors that leave the buffer unchanged.",,,"[{""url"":""https://git.kernel.org/stable/c/4d8457fe0eb9c80ff7795cf8a30962128b71d853"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/598c42c78919117dc0d235ae22d17ad642377483"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53086,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.580,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: connac: do not check WED status for non-mmio devices WED is supported just for mmio devices, so do not check it for usb or sdio devices. This patch fixes the crash reported below: [ 21.946627] wlp0s3u1i3: authenticate with c4:41:1e:f5:2b:1d [ 22.525298] wlp0s3u1i3: send auth to c4:41:1e:f5:2b:1d (try 1/3) [ 22.548274] wlp0s3u1i3: authenticate with c4:41:1e:f5:2b:1d [ 22.557694] wlp0s3u1i3: send auth to c4:41:1e:f5:2b:1d (try 1/3) [ 22.565885] wlp0s3u1i3: authenticated [ 22.569502] wlp0s3u1i3: associate with c4:41:1e:f5:2b:1d (try 1/3) [ 22.578966] wlp0s3u1i3: RX AssocResp from c4:41:1e:f5:2b:1d (capab=0x11 status=30 aid=3) [ 22.579113] wlp0s3u1i3: c4:41:1e:f5:2b:1d rejected association temporarily; comeback duration 1000 TU (1024 ms) [ 23.649518] wlp0s3u1i3: associate with c4:41:1e:f5:2b:1d (try 2/3) [ 23.752528] wlp0s3u1i3: RX AssocResp from c4:41:1e:f5:2b:1d (capab=0x11 status=0 aid=3) [ 23.797450] wlp0s3u1i3: associated [ 24.959527] kernel tried to execute NX-protected page - exploit attempt? (uid: 0) [ 24.959640] BUG: unable to handle page fault for address: ffff88800c223200 [ 24.959706] #PF: supervisor instruction fetch in kernel mode [ 24.959788] #PF: error_code(0x0011) - permissions violation [ 24.959846] PGD 2c01067 P4D 2c01067 PUD 2c02067 PMD c2a8063 PTE 800000000c223163 [ 24.959957] Oops: 0011 [#1] PREEMPT SMP [ 24.960009] CPU: 0 PID: 391 Comm: wpa_supplicant Not tainted 6.2.0-kvm #18 [ 24.960089] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.1-2.fc37 04/01/2014 [ 24.960191] RIP: 0010:0xffff88800c223200 [ 24.960446] RSP: 0018:ffffc90000ff7698 EFLAGS: 00010282 [ 24.960513] RAX: ffff888028397010 RBX: ffff88800c26e630 RCX: 0000000000000058 [ 24.960598] RDX: ffff88800c26f844 RSI: 0000000000000006 RDI: ffff888028397010 [ 24.960682] RBP: ffff88800ea72f00 R08: 18b873fbab2b964c R09: be06b38235f3c63c [ 24.960766] R10: 18b873fbab2b964c R11: be06b38235f3c63c R12: 0000000000000001 [ 24.960853] R13: ffff88800c26f84c R14: ffff8880063f0ff8 R15: ffff88800c26e644 [ 24.960950] FS: 00007effcea327c0(0000) GS:ffff88807dc00000(0000) knlGS:0000000000000000 [ 24.961036] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 24.961106] CR2: ffff88800c223200 CR3: 000000000eaa2000 CR4: 00000000000006b0 [ 24.961190] Call Trace: [ 24.961219] <TASK> [ 24.961245] ? mt76_connac_mcu_add_key+0x2cf/0x310 [ 24.961313] ? mt7921_set_key+0x150/0x200 [ 24.961365] ? drv_set_key+0xa9/0x1b0 [ 24.961418] ? ieee80211_key_enable_hw_accel+0xd9/0x240 [ 24.961485] ? ieee80211_key_replace+0x3f3/0x730 [ 24.961541] ? crypto_shash_setkey+0x89/0xd0 [ 24.961597] ? ieee80211_key_link+0x2d7/0x3a0 [ 24.961664] ? crypto_aead_setauthsize+0x31/0x50 [ 24.961730] ? sta_info_hash_lookup+0xa6/0xf0 [ 24.961785] ? ieee80211_add_key+0x1fc/0x250 [ 24.961842] ? rdev_add_key+0x41/0x140 [ 24.961882] ? nl80211_parse_key+0x6c/0x2f0 [ 24.961940] ? nl80211_new_key+0x24a/0x290 [ 24.961984] ? genl_rcv_msg+0x36c/0x3a0 [ 24.962036] ? rdev_mod_link_station+0xe0/0xe0 [ 24.962102] ? nl80211_set_key+0x410/0x410 [ 24.962143] ? nl80211_pre_doit+0x200/0x200 [ 24.962187] ? genl_bind+0xc0/0xc0 [ 24.962217] ? netlink_rcv_skb+0xaa/0xd0 [ 24.962259] ? genl_rcv+0x24/0x40 [ 24.962300] ? netlink_unicast+0x224/0x2f0 [ 24.962345] ? netlink_sendmsg+0x30b/0x3d0 [ 24.962388] ? ____sys_sendmsg+0x109/0x1b0 [ 24.962388] ? ____sys_sendmsg+0x109/0x1b0 [ 24.962440] ? __import_iovec+0x2e/0x110 [ 24.962482] ? ___sys_sendmsg+0xbe/0xe0 [ 24.962525] ? mod_objcg_state+0x25c/0x330 [ 24.962576] ? __dentry_kill+0x19e/0x1d0 [ 24.962618] ? call_rcu+0x18f/0x270 [ 24.962660] ? __dentry_kill+0x19e/0x1d0 [ 24.962702] ? __x64_sys_sendmsg+0x70/0x90 [ 24.962744] ? do_syscall_64+0x3d/0x80 [ 24.962796] ? exit_to_user_mode_prepare+0x1b/0x70 [ 24.962852] ? entry_SYSCA ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/53edfda851dd1ce41ac049ce2f195dc41dd27cc1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5683e1488aa9b0805a9403d215e48fed29d6d923"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53087,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.667,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/i915/active: Fix misuse of non-idle barriers as fence trackers Users reported oopses on list corruptions when using i915 perf with a number of concurrently running graphics applications. Root cause analysis pointed at an issue in barrier processing code -- a race among perf open / close replacing active barriers with perf requests on kernel context and concurrent barrier preallocate / acquire operations performed during user context first pin / last unpin. When adding a request to a composite tracker, we try to reuse an existing fence tracker, already allocated and registered with that composite. The tracker we obtain may already track another fence, may be an idle barrier, or an active barrier. If the tracker we get occurs a non-idle barrier then we try to delete that barrier from a list of barrier tasks it belongs to. However, while doing that we don't respect return value from a function that performs the barrier deletion. Should the deletion ever fail, we would end up reusing the tracker still registered as a barrier task. Since the same structure field is reused with both fence callback lists and barrier tasks list, list corruptions would likely occur. Barriers are now deleted from a barrier tasks list by temporarily removing the list content, traversing that content with skip over the node to be deleted, then populating the list back with the modified content. Should that intentionally racy concurrent deletion attempts be not serialized, one or more of those may fail because of the list being temporary empty. Related code that ignores the results of barrier deletion was initially introduced in v5.4 by commit d8af05ff38ae (""drm/i915: Allow sharing the idle-barrier from other kernel requests""). However, all users of the barrier deletion routine were apparently serialized at that time, then the issue didn't exhibit itself. Results of git bisect with help of a newly developed igt@gem_barrier_race@remote-request IGT test indicate that list corruptions might start to appear after commit 311770173fac (""drm/i915/gt: Schedule request retirement when timeline idles""), introduced in v5.5. Respect results of barrier deletion attempts -- mark the barrier as idle only if successfully deleted from the list. Then, before proceeding with setting our fence as the one currently tracked, make sure that the tracker we've got is not a non-idle barrier. If that check fails then don't use that tracker but go back and try to acquire a new, usable one. v3: use unlikely() to document what outcome we expect (Andi), - fix bad grammar in commit description. v2: no code changes, - blame commit 311770173fac (""drm/i915/gt: Schedule request retirement when timeline idles""), v5.5, not commit d8af05ff38ae (""drm/i915: Allow sharing the idle-barrier from other kernel requests""), v5.4, - reword commit description. (cherry picked from commit 506006055769b10d1b2b4e22f636f3b45e0e9fc7)",,,"[{""url"":""https://git.kernel.org/stable/c/5c7591b8574c52c56b3994c2fbef1a3a311b5715"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e784a7d07af42057c0576fb647b482f4cb0dc2c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6ab7d33617559cced63d467928f478ea5c459021"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9159db27fb19bbf1c91b5c9d5285e66cc96cc5ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0e6b416b25ee14716f3549e0cbec1011b193809"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53088,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.760,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mptcp: fix UaF in listener shutdown As reported by Christoph after having refactored the passive socket initialization, the mptcp listener shutdown path is prone to an UaF issue. BUG: KASAN: use-after-free in _raw_spin_lock_bh+0x73/0xe0 Write of size 4 at addr ffff88810cb23098 by task syz-executor731/1266 CPU: 1 PID: 1266 Comm: syz-executor731 Not tainted 6.2.0-rc59af4eaa31c1f6c00c8f1e448ed99a45c66340dd5 #6 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x6e/0x91 print_report+0x16a/0x46f kasan_report+0xad/0x130 kasan_check_range+0x14a/0x1a0 _raw_spin_lock_bh+0x73/0xe0 subflow_error_report+0x6d/0x110 sk_error_report+0x3b/0x190 tcp_disconnect+0x138c/0x1aa0 inet_child_forget+0x6f/0x2e0 inet_csk_listen_stop+0x209/0x1060 __mptcp_close_ssk+0x52d/0x610 mptcp_destroy_common+0x165/0x640 mptcp_destroy+0x13/0x80 __mptcp_destroy_sock+0xe7/0x270 __mptcp_close+0x70e/0x9b0 mptcp_close+0x2b/0x150 inet_release+0xe9/0x1f0 __sock_release+0xd2/0x280 sock_close+0x15/0x20 __fput+0x252/0xa20 task_work_run+0x169/0x250 exit_to_user_mode_prepare+0x113/0x120 syscall_exit_to_user_mode+0x1d/0x40 do_syscall_64+0x48/0x90 entry_SYSCALL_64_after_hwframe+0x72/0xdc The msk grace period can legitly expire in between the last reference count dropped in mptcp_subflow_queue_clean() and the later eventual access in inet_csk_listen_stop() After the previous patch we don't need anymore special-casing msk listener socket cleanup: the mptcp worker will process each of the unaccepted msk sockets. Just drop the now unnecessary code. Please note this commit depends on the two parent ones: mptcp: refactor passive socket initialization mptcp: use the workqueue to destroy unaccepted sockets",,,"[{""url"":""https://git.kernel.org/stable/c/0a3f4f1f9c27215e4ddcd312558342e57b93e518"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0f4f4cf5d32f10543deb946a37111e714579511e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5564be74a22a61855f8b8c100d8c4abb003bb792"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53089,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.853,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: fix task hung in ext4_xattr_delete_inode Syzbot reported a hung task problem: ================================================================== INFO: task syz-executor232:5073 blocked for more than 143 seconds. Not tainted 6.2.0-rc2-syzkaller-00024-g512dee0c00ad #0 ""echo 0 > /proc/sys/kernel/hung_task_timeout_secs"" disables this message. task:syz-exec232 state:D stack:21024 pid:5073 ppid:5072 flags:0x00004004 Call Trace: <TASK> context_switch kernel/sched/core.c:5244 [inline] __schedule+0x995/0xe20 kernel/sched/core.c:6555 schedule+0xcb/0x190 kernel/sched/core.c:6631 __wait_on_freeing_inode fs/inode.c:2196 [inline] find_inode_fast+0x35a/0x4c0 fs/inode.c:950 iget_locked+0xb1/0x830 fs/inode.c:1273 __ext4_iget+0x22e/0x3ed0 fs/ext4/inode.c:4861 ext4_xattr_inode_iget+0x68/0x4e0 fs/ext4/xattr.c:389 ext4_xattr_inode_dec_ref_all+0x1a7/0xe50 fs/ext4/xattr.c:1148 ext4_xattr_delete_inode+0xb04/0xcd0 fs/ext4/xattr.c:2880 ext4_evict_inode+0xd7c/0x10b0 fs/ext4/inode.c:296 evict+0x2a4/0x620 fs/inode.c:664 ext4_orphan_cleanup+0xb60/0x1340 fs/ext4/orphan.c:474 __ext4_fill_super fs/ext4/super.c:5516 [inline] ext4_fill_super+0x81cd/0x8700 fs/ext4/super.c:5644 get_tree_bdev+0x400/0x620 fs/super.c:1282 vfs_get_tree+0x88/0x270 fs/super.c:1489 do_new_mount+0x289/0xad0 fs/namespace.c:3145 do_mount fs/namespace.c:3488 [inline] __do_sys_mount fs/namespace.c:3697 [inline] __se_sys_mount+0x2d3/0x3c0 fs/namespace.c:3674 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7fa5406fd5ea RSP: 002b:00007ffc7232f968 EFLAGS: 00000202 ORIG_RAX: 00000000000000a5 RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007fa5406fd5ea RDX: 0000000020000440 RSI: 0000000020000000 RDI: 00007ffc7232f970 RBP: 00007ffc7232f970 R08: 00007ffc7232f9b0 R09: 0000000000000432 R10: 0000000000804a03 R11: 0000000000000202 R12: 0000000000000004 R13: 0000555556a7a2c0 R14: 00007ffc7232f9b0 R15: 0000000000000000 </TASK> ================================================================== The problem is that the inode contains an xattr entry with ea_inum of 15 when cleaning up an orphan inode <15>. When evict inode <15>, the reference counting of the corresponding EA inode is decreased. When EA inode <15> is found by find_inode_fast() in __ext4_iget(), it is found that the EA inode holds the I_FREEING flag and waits for the EA inode to complete deletion. As a result, when inode <15> is being deleted, we wait for inode <15> to complete the deletion, resulting in an infinite loop and triggering Hung Task. To solve this problem, we only need to check whether the ino of EA inode and parent is the same before getting EA inode.",,,"[{""url"":""https://git.kernel.org/stable/c/0f7bfd6f8164be32dbbdf36aa1e5d00485c53cd7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1aec41c98cce61d19ce89650895e51b9f3cdef13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2c96c52aeaa6fd9163cfacdd98778b4a0398ef18"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/64b72f5e7574020dea62ab733d88a54d903c42a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73f7987fe1b82596f1a380e85cd0097ebaae7e01"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/94fd091576b12540924f6316ebc0678e84cb2800"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a98160d8f3e6242ca9b7f443f26e7ef3a61ba684"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/efddc7e106fdf8d1f62d45e79de78f63b7c04fba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53090,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.957,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdkfd: Fix an illegal memory access In the kfd_wait_on_events() function, the kfd_event_waiter structure is allocated by alloc_event_waiters(), but the event field of the waiter structure is not initialized; When copy_from_user() fails in the kfd_wait_on_events() function, it will enter exception handling to release the previously allocated memory of the waiter structure; Due to the event field of the waiters structure being accessed in the free_waiters() function, this results in illegal memory access and system crash, here is the crash log: localhost kernel: RIP: 0010:native_queued_spin_lock_slowpath+0x185/0x1e0 localhost kernel: RSP: 0018:ffffaa53c362bd60 EFLAGS: 00010082 localhost kernel: RAX: ff3d3d6bff4007cb RBX: 0000000000000282 RCX: 00000000002c0000 localhost kernel: RDX: ffff9e855eeacb80 RSI: 000000000000279c RDI: ffffe7088f6a21d0 localhost kernel: RBP: ffffe7088f6a21d0 R08: 00000000002c0000 R09: ffffaa53c362be64 localhost kernel: R10: ffffaa53c362bbd8 R11: 0000000000000001 R12: 0000000000000002 localhost kernel: R13: ffff9e7ead15d600 R14: 0000000000000000 R15: ffff9e7ead15d698 localhost kernel: FS: 0000152a3d111700(0000) GS:ffff9e855ee80000(0000) knlGS:0000000000000000 localhost kernel: CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 localhost kernel: CR2: 0000152938000010 CR3: 000000044d7a4000 CR4: 00000000003506e0 localhost kernel: Call Trace: localhost kernel: _raw_spin_lock_irqsave+0x30/0x40 localhost kernel: remove_wait_queue+0x12/0x50 localhost kernel: kfd_wait_on_events+0x1b6/0x490 [hydcu] localhost kernel: ? ftrace_graph_caller+0xa0/0xa0 localhost kernel: kfd_ioctl+0x38c/0x4a0 [hydcu] localhost kernel: ? kfd_ioctl_set_trap_handler+0x70/0x70 [hydcu] localhost kernel: ? kfd_ioctl_create_queue+0x5a0/0x5a0 [hydcu] localhost kernel: ? ftrace_graph_caller+0xa0/0xa0 localhost kernel: __x64_sys_ioctl+0x8e/0xd0 localhost kernel: ? syscall_trace_enter.isra.18+0x143/0x1b0 localhost kernel: do_syscall_64+0x33/0x80 localhost kernel: entry_SYSCALL_64_after_hwframe+0x44/0xa9 localhost kernel: RIP: 0033:0x152a4dff68d7 Allocate the structure with kcalloc, and remove redundant 0-initialization and a redundant loop condition check.",,,"[{""url"":""https://git.kernel.org/stable/c/2fece63b55c5d74cd6f5de51159e2cde37e10555"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4fc8fff378b2f2039f2a666d9f8c570f4e58352c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a3fb3b745af0ce46ec2e0c8e507bae45b937334"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/61f306f8df0d5559659c5578cf6d95236bcdcb25"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6936525142a015e854d0a23e9ad9ea0a28b3843d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bbf5eada4334a96e3a204b2307ff5b14dc380b0b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d9923e7214a870b312bf61f6a89c7554d0966985"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53091,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:28.073,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: update s_journal_inum if it changes after journal replay When mounting a crafted ext4 image, s_journal_inum may change after journal replay, which is obviously unreasonable because we have successfully loaded and replayed the journal through the old s_journal_inum. And the new s_journal_inum bypasses some of the checks in ext4_get_journal(), which may trigger a null pointer dereference problem. So if s_journal_inum changes after the journal replay, we ignore the change, and rewrite the current journal_inum to the superblock.",,,"[{""url"":""https://git.kernel.org/stable/c/3039d8b8692408438a618fac2776b629852663c3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/499fef2030fb754c68b1c7cb3a799a3bc1d0d925"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/70e66bdeae4d0f7c8e87762f425b68aedd5e8955"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee0c5277d4fab920bd31345c49e193ecede9ecef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53092,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:28.180,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: interconnect: exynos: fix node leak in probe PM QoS error path Make sure to add the newly allocated interconnect node to the provider before adding the PM QoS request so that the node is freed on errors.",,,"[{""url"":""https://git.kernel.org/stable/c/3aab264875bf3c915ea2517fae1eec213e0b4987"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b71dd43bd49bd68186c1d19dbeedee219e003149"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c479e4ac4a3d1485a48599e66ce46547c1367828"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd4738ae1a0c216d25360a98e835967b06d6a253"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53093,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:28.270,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tracing: Do not let histogram values have some modifiers Histogram values can not be strings, stacktraces, graphs, symbols, syscalls, or grouped in buckets or log. Give an error if a value is set to do so. Note, the histogram code was not prepared to handle these modifiers for histograms and caused a bug. Mark Rutland reported: # echo 'p:copy_to_user __arch_copy_to_user n=$arg2' >> /sys/kernel/tracing/kprobe_events # echo 'hist:keys=n:vals=hitcount.buckets=8:sort=hitcount' > /sys/kernel/tracing/events/kprobes/copy_to_user/trigger # cat /sys/kernel/tracing/events/kprobes/copy_to_user/hist [ 143.694628] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000 [ 143.695190] Mem abort info: [ 143.695362] ESR = 0x0000000096000004 [ 143.695604] EC = 0x25: DABT (current EL), IL = 32 bits [ 143.695889] SET = 0, FnV = 0 [ 143.696077] EA = 0, S1PTW = 0 [ 143.696302] FSC = 0x04: level 0 translation fault [ 143.702381] Data abort info: [ 143.702614] ISV = 0, ISS = 0x00000004 [ 143.702832] CM = 0, WnR = 0 [ 143.703087] user pgtable: 4k pages, 48-bit VAs, pgdp=00000000448f9000 [ 143.703407] [0000000000000000] pgd=0000000000000000, p4d=0000000000000000 [ 143.704137] Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP [ 143.704714] Modules linked in: [ 143.705273] CPU: 0 PID: 133 Comm: cat Not tainted 6.2.0-00003-g6fc512c10a7c #3 [ 143.706138] Hardware name: linux,dummy-virt (DT) [ 143.706723] pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 143.707120] pc : hist_field_name.part.0+0x14/0x140 [ 143.707504] lr : hist_field_name.part.0+0x104/0x140 [ 143.707774] sp : ffff800008333a30 [ 143.707952] x29: ffff800008333a30 x28: 0000000000000001 x27: 0000000000400cc0 [ 143.708429] x26: ffffd7a653b20260 x25: 0000000000000000 x24: ffff10d303ee5800 [ 143.708776] x23: ffffd7a6539b27b0 x22: ffff10d303fb8c00 x21: 0000000000000001 [ 143.709127] x20: ffff10d303ec2000 x19: 0000000000000000 x18: 0000000000000000 [ 143.709478] x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000 [ 143.709824] x14: 0000000000000000 x13: 203a6f666e692072 x12: 6567676972742023 [ 143.710179] x11: 0a230a6d6172676f x10: 000000000000002c x9 : ffffd7a6521e018c [ 143.710584] x8 : 000000000000002c x7 : 7f7f7f7f7f7f7f7f x6 : 000000000000002c [ 143.710915] x5 : ffff10d303b0103e x4 : ffffd7a653b20261 x3 : 000000000000003d [ 143.711239] x2 : 0000000000020001 x1 : 0000000000000001 x0 : 0000000000000000 [ 143.711746] Call trace: [ 143.712115] hist_field_name.part.0+0x14/0x140 [ 143.712642] hist_field_name.part.0+0x104/0x140 [ 143.712925] hist_field_print+0x28/0x140 [ 143.713125] event_hist_trigger_print+0x174/0x4d0 [ 143.713348] hist_show+0xf8/0x980 [ 143.713521] seq_read_iter+0x1bc/0x4b0 [ 143.713711] seq_read+0x8c/0xc4 [ 143.713876] vfs_read+0xc8/0x2a4 [ 143.714043] ksys_read+0x70/0xfc [ 143.714218] __arm64_sys_read+0x24/0x30 [ 143.714400] invoke_syscall+0x50/0x120 [ 143.714587] el0_svc_common.constprop.0+0x4c/0x100 [ 143.714807] do_el0_svc+0x44/0xd0 [ 143.714970] el0_svc+0x2c/0x84 [ 143.715134] el0t_64_sync_handler+0xbc/0x140 [ 143.715334] el0t_64_sync+0x190/0x194 [ 143.715742] Code: a9bd7bfd 910003fd a90153f3 aa0003f3 (f9400000) [ 143.716510] ---[ end trace 0000000000000000 ]--- Segmentation fault",,,"[{""url"":""https://git.kernel.org/stable/c/2fc0ee435c9264cdb7c5e872f76cd9bb97640227"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/39cd75f2f3a43c0e2f95749eb6dd6420c553f87d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0213434fe3e4a0d118923dc98d31e7ff1cd9e45"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53094,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:28.363,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tty: serial: fsl_lpuart: fix race on RX DMA shutdown From time to time DMA completion can come in the middle of DMA shutdown: <process ctx>: <IRQ>: lpuart32_shutdown() lpuart_dma_shutdown() del_timer_sync() lpuart_dma_rx_complete() lpuart_copy_rx_to_tty() mod_timer() lpuart_dma_rx_free() When the timer fires a bit later, sport->dma_rx_desc is NULL: Unable to handle kernel NULL pointer dereference at virtual address 0000000000000004 pc : lpuart_copy_rx_to_tty+0xcc/0x5bc lr : lpuart_timer_func+0x1c/0x2c Call trace: lpuart_copy_rx_to_tty lpuart_timer_func call_timer_fn __run_timers.part.0 run_timer_softirq __do_softirq __irq_exit_rcu irq_exit handle_domain_irq gic_handle_irq call_on_irq_stack do_interrupt_handler ... To fix this fold del_timer_sync() into lpuart_dma_rx_free() after dmaengine_terminate_sync() to make sure timer will not be re-started in lpuart_copy_rx_to_tty() <= lpuart_dma_rx_complete().",,,"[{""url"":""https://git.kernel.org/stable/c/19a98d56dfedafb25652bdb9cd48a4e73ceba702"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1be6f2b15f902c02e055ae0b419ca789200473c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2a36b444cace9580380467fd1183bb5e85bcc80a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90530e7214c8a04dcdde57502d93fa96af288c38"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/954fc9931f0aabf272b5674cf468affdd88d3a36"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53095,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:28.453,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/ttm: Fix a NULL pointer dereference The LRU mechanism may look up a resource in the process of being removed from an object. The locking rules here are a bit unclear but it looks currently like res->bo assignment is protected by the LRU lock, whereas bo->resource is protected by the object lock, while *clearing* of bo->resource is also protected by the LRU lock. This means that if we check that bo->resource points to the LRU resource under the LRU lock we should be safe. So perform that check before deciding to swap out a bo. That avoids dereferencing a NULL bo->resource in ttm_bo_swapout().",,,"[{""url"":""https://git.kernel.org/stable/c/9a9a8fe26751334b7739193a94eba741073b8a55"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ba1720f6c4a0f13c3f3cb5c28132ee75555d04f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d9b1f9f7a72d83ebf173534e76b246349f32374"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53096,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:28.543,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: interconnect: fix mem leak when freeing nodes The node link array is allocated when adding links to a node but is not deallocated when nodes are destroyed.",,,"[{""url"":""https://git.kernel.org/stable/c/2e0b13a1827229a02abef97b50ffaf89ba25370a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3167306455d0fbbbcf08cb25651acc527a86a95e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a5904f415e1af72fa8fe6665aa4f554dc2099a95"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c1722e4113281fb34e5b4fb5c5387b17cd39a537"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/efae80ca13faa94457208852825731da44a788ad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1e3a20c60196c37a402c584d0c9de306ba988ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53097,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:28.643,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: powerpc/iommu: fix memory leak with using debugfs_lookup() When calling debugfs_lookup() the result must have dput() called on it, otherwise the memory will leak over time. To make things simpler, just call debugfs_lookup_and_remove() instead which handles all of the logic at once.",,,"[{""url"":""https://git.kernel.org/stable/c/24c1bd1cd0d1ff821fd7d2f01a1e648c7882dfc2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4050498c0ae3946c223fc63e9dd7b878b76611e0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b505063910c134778202dfad9332dfcecb76bab3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3a62a35f903fd8be5b44542fe3901ec45f16757"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53098,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:28.733,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: rc: gpio-ir-recv: add remove function In case runtime PM is enabled, do runtime PM clean up to remove cpu latency qos request, otherwise driver removal may have below kernel dump: [ 19.463299] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000048 [ 19.472161] Mem abort info: [ 19.474985] ESR = 0x0000000096000004 [ 19.478754] EC = 0x25: DABT (current EL), IL = 32 bits [ 19.484081] SET = 0, FnV = 0 [ 19.487149] EA = 0, S1PTW = 0 [ 19.490361] FSC = 0x04: level 0 translation fault [ 19.495256] Data abort info: [ 19.498149] ISV = 0, ISS = 0x00000004 [ 19.501997] CM = 0, WnR = 0 [ 19.504977] user pgtable: 4k pages, 48-bit VAs, pgdp=0000000049f81000 [ 19.511432] [0000000000000048] pgd=0000000000000000, p4d=0000000000000000 [ 19.518245] Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP [ 19.524520] Modules linked in: gpio_ir_recv(+) rc_core [last unloaded: rc_core] [ 19.531845] CPU: 0 PID: 445 Comm: insmod Not tainted 6.2.0-rc1-00028-g2c397a46d47c #72 [ 19.531854] Hardware name: FSL i.MX8MM EVK board (DT) [ 19.531859] pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 19.551777] pc : cpu_latency_qos_remove_request+0x20/0x110 [ 19.557277] lr : gpio_ir_recv_runtime_suspend+0x18/0x30 [gpio_ir_recv] [ 19.557294] sp : ffff800008ce3740 [ 19.557297] x29: ffff800008ce3740 x28: 0000000000000000 x27: ffff800008ce3d50 [ 19.574270] x26: ffffc7e3e9cea100 x25: 00000000000f4240 x24: ffffc7e3f9ef0e30 [ 19.574284] x23: 0000000000000000 x22: ffff0061803820f4 x21: 0000000000000008 [ 19.574296] x20: ffffc7e3fa75df30 x19: 0000000000000020 x18: ffffffffffffffff [ 19.588570] x17: 0000000000000000 x16: ffffc7e3f9efab70 x15: ffffffffffffffff [ 19.595712] x14: ffff800008ce37b8 x13: ffff800008ce37aa x12: 0000000000000001 [ 19.602853] x11: 0000000000000001 x10: ffffcbe3ec0dff87 x9 : 0000000000000008 [ 19.609991] x8 : 0101010101010101 x7 : 0000000000000000 x6 : 000000000f0bfe9f [ 19.624261] x5 : 00ffffffffffffff x4 : 0025ab8e00000000 x3 : ffff006180382010 [ 19.631405] x2 : ffffc7e3e9ce8030 x1 : ffffc7e3fc3eb810 x0 : 0000000000000020 [ 19.638548] Call trace: [ 19.640995] cpu_latency_qos_remove_request+0x20/0x110 [ 19.646142] gpio_ir_recv_runtime_suspend+0x18/0x30 [gpio_ir_recv] [ 19.652339] pm_generic_runtime_suspend+0x2c/0x44 [ 19.657055] __rpm_callback+0x48/0x1dc [ 19.660807] rpm_callback+0x6c/0x80 [ 19.664301] rpm_suspend+0x10c/0x640 [ 19.667880] rpm_idle+0x250/0x2d0 [ 19.671198] update_autosuspend+0x38/0xe0 [ 19.675213] pm_runtime_set_autosuspend_delay+0x40/0x60 [ 19.680442] gpio_ir_recv_probe+0x1b4/0x21c [gpio_ir_recv] [ 19.685941] platform_probe+0x68/0xc0 [ 19.689610] really_probe+0xc0/0x3dc [ 19.693189] __driver_probe_device+0x7c/0x190 [ 19.697550] driver_probe_device+0x3c/0x110 [ 19.701739] __driver_attach+0xf4/0x200 [ 19.705578] bus_for_each_dev+0x70/0xd0 [ 19.709417] driver_attach+0x24/0x30 [ 19.712998] bus_add_driver+0x17c/0x240 [ 19.716834] driver_register+0x78/0x130 [ 19.720676] __platform_driver_register+0x28/0x34 [ 19.725386] gpio_ir_recv_driver_init+0x20/0x1000 [gpio_ir_recv] [ 19.731404] do_one_initcall+0x44/0x2ac [ 19.735243] do_init_module+0x48/0x1d0 [ 19.739003] load_module+0x19fc/0x2034 [ 19.742759] __do_sys_finit_module+0xac/0x12c [ 19.747124] __arm64_sys_finit_module+0x20/0x30 [ 19.751664] invoke_syscall+0x48/0x114 [ 19.755420] el0_svc_common.constprop.0+0xcc/0xec [ 19.760132] do_el0_svc+0x38/0xb0 [ 19.763456] el0_svc+0x2c/0x84 [ 19.766516] el0t_64_sync_handler+0xf4/0x120 [ 19.770789] el0t_64_sync+0x190/0x194 [ 19.774460] Code: 910003fd a90153f3 aa0003f3 91204021 (f9401400) [ 19.780556] ---[ end trace 0000000000000000 ]---",,,"[{""url"":""https://git.kernel.org/stable/c/00e81f191bc00cb6faabf468960e96ebf0404a6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2ece4d2f7eac1cb51dc0e9859e09bfdb00faa28e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/30040818b338b8ebc956ce0ebd198f8d593586a6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/513572bb89e8075f5d2a2bb4c89f1152e44da9d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a5c140d88a69eb43de2a030f1d7ff7b16bff3b1a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53099,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:28.830,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: firmware: xilinx: don't make a sleepable memory allocation from an atomic context The following issue was discovered using lockdep: [ 6.691371] BUG: sleeping function called from invalid context at include/linux/sched/mm.h:209 [ 6.694602] in_atomic(): 1, irqs_disabled(): 128, non_block: 0, pid: 1, name: swapper/0 [ 6.702431] 2 locks held by swapper/0/1: [ 6.706300] #0: ffffff8800f6f188 (&dev->mutex){....}-{3:3}, at: __device_driver_lock+0x4c/0x90 [ 6.714900] #1: ffffffc009a2abb8 (enable_lock){....}-{2:2}, at: clk_enable_lock+0x4c/0x140 [ 6.723156] irq event stamp: 304030 [ 6.726596] hardirqs last enabled at (304029): [<ffffffc008d17ee0>] _raw_spin_unlock_irqrestore+0xc0/0xd0 [ 6.736142] hardirqs last disabled at (304030): [<ffffffc00876bc5c>] clk_enable_lock+0xfc/0x140 [ 6.744742] softirqs last enabled at (303958): [<ffffffc0080904f0>] _stext+0x4f0/0x894 [ 6.752655] softirqs last disabled at (303951): [<ffffffc0080e53b8>] irq_exit+0x238/0x280 [ 6.760744] CPU: 1 PID: 1 Comm: swapper/0 Tainted: G U 5.15.36 #2 [ 6.768048] Hardware name: xlnx,zynqmp (DT) [ 6.772179] Call trace: [ 6.774584] dump_backtrace+0x0/0x300 [ 6.778197] show_stack+0x18/0x30 [ 6.781465] dump_stack_lvl+0xb8/0xec [ 6.785077] dump_stack+0x1c/0x38 [ 6.788345] ___might_sleep+0x1a8/0x2a0 [ 6.792129] __might_sleep+0x6c/0xd0 [ 6.795655] kmem_cache_alloc_trace+0x270/0x3d0 [ 6.800127] do_feature_check_call+0x100/0x220 [ 6.804513] zynqmp_pm_invoke_fn+0x8c/0xb0 [ 6.808555] zynqmp_pm_clock_getstate+0x90/0xe0 [ 6.813027] zynqmp_pll_is_enabled+0x8c/0x120 [ 6.817327] zynqmp_pll_enable+0x38/0xc0 [ 6.821197] clk_core_enable+0x144/0x400 [ 6.825067] clk_core_enable+0xd4/0x400 [ 6.828851] clk_core_enable+0xd4/0x400 [ 6.832635] clk_core_enable+0xd4/0x400 [ 6.836419] clk_core_enable+0xd4/0x400 [ 6.840203] clk_core_enable+0xd4/0x400 [ 6.843987] clk_core_enable+0xd4/0x400 [ 6.847771] clk_core_enable+0xd4/0x400 [ 6.851555] clk_core_enable_lock+0x24/0x50 [ 6.855683] clk_enable+0x24/0x40 [ 6.858952] fclk_probe+0x84/0xf0 [ 6.862220] platform_probe+0x8c/0x110 [ 6.865918] really_probe+0x110/0x5f0 [ 6.869530] __driver_probe_device+0xcc/0x210 [ 6.873830] driver_probe_device+0x64/0x140 [ 6.877958] __driver_attach+0x114/0x1f0 [ 6.881828] bus_for_each_dev+0xe8/0x160 [ 6.885698] driver_attach+0x34/0x50 [ 6.889224] bus_add_driver+0x228/0x300 [ 6.893008] driver_register+0xc0/0x1e0 [ 6.896792] __platform_driver_register+0x44/0x60 [ 6.901436] fclk_driver_init+0x1c/0x28 [ 6.905220] do_one_initcall+0x104/0x590 [ 6.909091] kernel_init_freeable+0x254/0x2bc [ 6.913390] kernel_init+0x24/0x130 [ 6.916831] ret_from_fork+0x10/0x20 Fix it by passing the GFP_ATOMIC gfp flag for the corresponding memory allocation.",,,"[{""url"":""https://git.kernel.org/stable/c/162049c31eb64308afa22e341a257a723526eb5c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/38ed310c22e7a0fc978b1f8292136a4a4a8b3051"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/86afb633beaa02ee95b5126a14c9f22cfade4fd9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9bbab2843f2d1337a268499a1c02b435d2985a17"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b37d3ccbd549494890672136a0e623eb010d46a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53100,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:28.923,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: fix WARNING in ext4_update_inline_data Syzbot found the following issue: EXT4-fs (loop0): mounted filesystem 00000000-0000-0000-0000-000000000000 without journal. Quota mode: none. fscrypt: AES-256-CTS-CBC using implementation ""cts-cbc-aes-aesni"" fscrypt: AES-256-XTS using implementation ""xts-aes-aesni"" ------------[ cut here ]------------ WARNING: CPU: 0 PID: 5071 at mm/page_alloc.c:5525 __alloc_pages+0x30a/0x560 mm/page_alloc.c:5525 Modules linked in: CPU: 1 PID: 5071 Comm: syz-executor263 Not tainted 6.2.0-rc1-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022 RIP: 0010:__alloc_pages+0x30a/0x560 mm/page_alloc.c:5525 RSP: 0018:ffffc90003c2f1c0 EFLAGS: 00010246 RAX: ffffc90003c2f220 RBX: 0000000000000014 RCX: 0000000000000000 RDX: 0000000000000028 RSI: 0000000000000000 RDI: ffffc90003c2f248 RBP: ffffc90003c2f2d8 R08: dffffc0000000000 R09: ffffc90003c2f220 R10: fffff52000785e49 R11: 1ffff92000785e44 R12: 0000000000040d40 R13: 1ffff92000785e40 R14: dffffc0000000000 R15: 1ffff92000785e3c FS: 0000555556c0d300(0000) GS:ffff8880b9800000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f95d5e04138 CR3: 00000000793aa000 CR4: 00000000003506f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> __alloc_pages_node include/linux/gfp.h:237 [inline] alloc_pages_node include/linux/gfp.h:260 [inline] __kmalloc_large_node+0x95/0x1e0 mm/slab_common.c:1113 __do_kmalloc_node mm/slab_common.c:956 [inline] __kmalloc+0xfe/0x190 mm/slab_common.c:981 kmalloc include/linux/slab.h:584 [inline] kzalloc include/linux/slab.h:720 [inline] ext4_update_inline_data+0x236/0x6b0 fs/ext4/inline.c:346 ext4_update_inline_dir fs/ext4/inline.c:1115 [inline] ext4_try_add_inline_entry+0x328/0x990 fs/ext4/inline.c:1307 ext4_add_entry+0x5a4/0xeb0 fs/ext4/namei.c:2385 ext4_add_nondir+0x96/0x260 fs/ext4/namei.c:2772 ext4_create+0x36c/0x560 fs/ext4/namei.c:2817 lookup_open fs/namei.c:3413 [inline] open_last_lookups fs/namei.c:3481 [inline] path_openat+0x12ac/0x2dd0 fs/namei.c:3711 do_filp_open+0x264/0x4f0 fs/namei.c:3741 do_sys_openat2+0x124/0x4e0 fs/open.c:1310 do_sys_open fs/open.c:1326 [inline] __do_sys_openat fs/open.c:1342 [inline] __se_sys_openat fs/open.c:1337 [inline] __x64_sys_openat+0x243/0x290 fs/open.c:1337 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd Above issue happens as follows: ext4_iget ext4_find_inline_data_nolock ->i_inline_off=164 i_inline_size=60 ext4_try_add_inline_entry __ext4_mark_inode_dirty ext4_expand_extra_isize_ea ->i_extra_isize=32 s_want_extra_isize=44 ext4_xattr_shift_entries ->after shift i_inline_off is incorrect, actually is change to 176 ext4_try_add_inline_entry ext4_update_inline_dir get_max_inline_xattr_value_size if (EXT4_I(inode)->i_inline_off) entry = (struct ext4_xattr_entry *)((void *)raw_inode + EXT4_I(inode)->i_inline_off); free += EXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size)); ->As entry is incorrect, then 'free' may be negative ext4_update_inline_data value = kzalloc(len, GFP_NOFS); -> len is unsigned int, maybe very large, then trigger warning when 'kzalloc()' To resolve the above issue we need to update 'i_inline_off' after 'ext4_xattr_shift_entries()'. We do not need to set EXT4_STATE_MAY_INLINE_DATA flag here, since ext4_mark_inode_dirty() already sets this flag if needed. Setting EXT4_STATE_MAY_INLINE_DATA when it is needed may trigger a BUG_ON in ext4_writepages().",,,"[{""url"":""https://git.kernel.org/stable/c/2b96b4a5d9443ca4cad58b0040be455803c05a42"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/35161cec76772f74526f5886ad4082ec48511d5c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/39c5df2ca544368b44b59d0f6d80131e90763371"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74d775083e9f3d9dadf9e3b5f3e0028d1ad0bd5c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/92eee6a82a9a6f9f83559e17a2b6b935e1a5cd25"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9bd94f67b27739bbe8583c52256502bd4cc7e83"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c5aa102b433b1890e1ccaa40c06826c77dda1665"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca500cf2eceb5a8e93bf71ab97b5f7a18ecabce2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53101,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:29.023,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: zero i_disksize when initializing the bootloader inode If the boot loader inode has never been used before, the EXT4_IOC_SWAP_BOOT inode will initialize it, including setting the i_size to 0. However, if the ""never before used"" boot loader has a non-zero i_size, then i_disksize will be non-zero, and the inconsistency between i_size and i_disksize can trigger a kernel warning: WARNING: CPU: 0 PID: 2580 at fs/ext4/file.c:319 CPU: 0 PID: 2580 Comm: bb Not tainted 6.3.0-rc1-00004-g703695902cfa RIP: 0010:ext4_file_write_iter+0xbc7/0xd10 Call Trace: vfs_write+0x3b1/0x5c0 ksys_write+0x77/0x160 __x64_sys_write+0x22/0x30 do_syscall_64+0x39/0x80 Reproducer: 1. create corrupted image and mount it: mke2fs -t ext4 /tmp/foo.img 200 debugfs -wR ""sif <5> size 25700"" /tmp/foo.img mount -t ext4 /tmp/foo.img /mnt cd /mnt echo 123 > file 2. Run the reproducer program: posix_memalign(&buf, 1024, 1024) fd = open(""file"", O_RDWR | O_DIRECT); ioctl(fd, EXT4_IOC_SWAP_BOOT); write(fd, buf, 1024); Fix this by setting i_disksize as well as i_size to zero when initiaizing the boot loader inode.",,,"[{""url"":""https://git.kernel.org/stable/c/01a821aacc64d4b05dafd239dbc9b7856686002f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0d8a6c9a6415999fee1259ccf1796480c026b7d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f00c476da8fe7c4c34ea16abb55d74127120413"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/59eee0cdf8c036f554add97a4da7c06d7a9ff34a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9cb27b1e76f0cc886ac09055bc41c0ab3f205167"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9e9a4cc5486356158554f6ad73027d8635a48b34"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d6c1447e483c05dbcfb3ff77ac04237a82070b8c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f5361da1e60d54ec81346aee8e3d8baf1be0b762"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53102,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:29.127,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ice: xsk: disable txq irq before flushing hw ice_qp_dis() intends to stop a given queue pair that is a target of xsk pool attach/detach. One of the steps is to disable interrupts on these queues. It currently is broken in a way that txq irq is turned off *after* HW flush which in turn takes no effect. ice_qp_dis(): -> ice_qvec_dis_irq() --> disable rxq irq --> flush hw -> ice_vsi_stop_tx_ring() -->disable txq irq Below splat can be triggered by following steps: - start xdpsock WITHOUT loading xdp prog - run xdp_rxq_info with XDP_TX action on this interface - start traffic - terminate xdpsock [ 256.312485] BUG: kernel NULL pointer dereference, address: 0000000000000018 [ 256.319560] #PF: supervisor read access in kernel mode [ 256.324775] #PF: error_code(0x0000) - not-present page [ 256.329994] PGD 0 P4D 0 [ 256.332574] Oops: 0000 [#1] PREEMPT SMP NOPTI [ 256.337006] CPU: 3 PID: 32 Comm: ksoftirqd/3 Tainted: G OE 6.2.0-rc5+ #51 [ 256.345218] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0008.031920191559 03/19/2019 [ 256.355807] RIP: 0010:ice_clean_rx_irq_zc+0x9c/0x7d0 [ice] [ 256.361423] Code: b7 8f 8a 00 00 00 66 39 ca 0f 84 f1 04 00 00 49 8b 47 40 4c 8b 24 d0 41 0f b7 45 04 66 25 ff 3f 66 89 04 24 0f 84 85 02 00 00 <49> 8b 44 24 18 0f b7 14 24 48 05 00 01 00 00 49 89 04 24 49 89 44 [ 256.380463] RSP: 0018:ffffc900088bfd20 EFLAGS: 00010206 [ 256.385765] RAX: 000000000000003c RBX: 0000000000000035 RCX: 000000000000067f [ 256.393012] RDX: 0000000000000775 RSI: 0000000000000000 RDI: ffff8881deb3ac80 [ 256.400256] RBP: 000000000000003c R08: ffff889847982710 R09: 0000000000010000 [ 256.407500] R10: ffffffff82c060c0 R11: 0000000000000004 R12: 0000000000000000 [ 256.414746] R13: ffff88811165eea0 R14: ffffc9000d255000 R15: ffff888119b37600 [ 256.421990] FS: 0000000000000000(0000) GS:ffff8897e0cc0000(0000) knlGS:0000000000000000 [ 256.430207] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 256.436036] CR2: 0000000000000018 CR3: 0000000005c0a006 CR4: 00000000007706e0 [ 256.443283] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 256.450527] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [ 256.457770] PKRU: 55555554 [ 256.460529] Call Trace: [ 256.463015] <TASK> [ 256.465157] ? ice_xmit_zc+0x6e/0x150 [ice] [ 256.469437] ice_napi_poll+0x46d/0x680 [ice] [ 256.473815] ? _raw_spin_unlock_irqrestore+0x1b/0x40 [ 256.478863] __napi_poll+0x29/0x160 [ 256.482409] net_rx_action+0x136/0x260 [ 256.486222] __do_softirq+0xe8/0x2e5 [ 256.489853] ? smpboot_thread_fn+0x2c/0x270 [ 256.494108] run_ksoftirqd+0x2a/0x50 [ 256.497747] smpboot_thread_fn+0x1c1/0x270 [ 256.501907] ? __pfx_smpboot_thread_fn+0x10/0x10 [ 256.506594] kthread+0xea/0x120 [ 256.509785] ? __pfx_kthread+0x10/0x10 [ 256.513597] ret_from_fork+0x29/0x50 [ 256.517238] </TASK> In fact, irqs were not disabled and napi managed to be scheduled and run while xsk_pool pointer was still valid, but SW ring of xdp_buff pointers was already freed. To fix this, call ice_qvec_dis_irq() after ice_vsi_stop_tx_ring(). Also while at it, remove redundant ice_clean_rx_ring() call - this is handled in ice_qp_clean_rings().",,,"[{""url"":""https://git.kernel.org/stable/c/243cde8de10894d7812c8a6b62653bf04d8f9700"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2ecc6e44959382f95c9d427cd8da85121a9cecda"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b830c9642386867863ac64295185f896ff2928ac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b89a453c6918e0f346fb0562e8c7812b94d28c73"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cccba1ff0798a27f7b8d0c06762ef977400a2afb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53103,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:29.223,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bonding: restore bond's IFF_SLAVE flag if a non-eth dev enslave fails syzbot reported a warning[1] where the bond device itself is a slave and we try to enslave a non-ethernet device as the first slave which fails but then in the error path when ether_setup() restores the bond device it also clears all flags. In my previous fix[2] I restored the IFF_MASTER flag, but I didn't consider the case that the bond device itself might also be a slave with IFF_SLAVE set, so we need to restore that flag as well. Use the bond_ether_setup helper which does the right thing and restores the bond's flags properly. Steps to reproduce using a nlmon dev: $ ip l add nlmon0 type nlmon $ ip l add bond1 type bond $ ip l add bond2 type bond $ ip l set bond1 master bond2 $ ip l set dev nlmon0 master bond1 $ ip -d l sh dev bond1 22: bond1: <BROADCAST,MULTICAST,MASTER> mtu 1500 qdisc noqueue master bond2 state DOWN mode DEFAULT group default qlen 1000 (now bond1's IFF_SLAVE flag is gone and we'll hit a warning[3] if we try to delete it) [1] https://syzkaller.appspot.com/bug?id=391c7b1f6522182899efba27d891f1743e8eb3ef [2] commit 7d5cd2ce5292 (""bonding: correctly handle bonding type change on enslave failure"") [3] example warning: [ 27.008664] bond1: (slave nlmon0): The slave device specified does not support setting the MAC address [ 27.008692] bond1: (slave nlmon0): Error -95 calling set_mac_address [ 32.464639] bond1 (unregistering): Released all slaves [ 32.464685] ------------[ cut here ]------------ [ 32.464686] WARNING: CPU: 1 PID: 2004 at net/core/dev.c:10829 unregister_netdevice_many+0x72a/0x780 [ 32.464694] Modules linked in: br_netfilter bridge bonding virtio_net [ 32.464699] CPU: 1 PID: 2004 Comm: ip Kdump: loaded Not tainted 5.18.0-rc3+ #47 [ 32.464703] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.1-2.fc37 04/01/2014 [ 32.464704] RIP: 0010:unregister_netdevice_many+0x72a/0x780 [ 32.464707] Code: 99 fd ff ff ba 90 1a 00 00 48 c7 c6 f4 02 66 96 48 c7 c7 20 4d 35 96 c6 05 fa c7 2b 02 01 e8 be 6f 4a 00 0f 0b e9 73 fd ff ff <0f> 0b e9 5f fd ff ff 80 3d e3 c7 2b 02 00 0f 85 3b fd ff ff ba 59 [ 32.464710] RSP: 0018:ffffa006422d7820 EFLAGS: 00010206 [ 32.464712] RAX: ffff8f6e077140a0 RBX: ffffa006422d7888 RCX: 0000000000000000 [ 32.464714] RDX: ffff8f6e12edbe58 RSI: 0000000000000296 RDI: ffffffff96d4a520 [ 32.464716] RBP: ffff8f6e07714000 R08: ffffffff96d63600 R09: ffffa006422d7728 [ 32.464717] R10: 0000000000000ec0 R11: ffffffff9698c988 R12: ffff8f6e12edb140 [ 32.464719] R13: dead000000000122 R14: dead000000000100 R15: ffff8f6e12edb140 [ 32.464723] FS: 00007f297c2f1740(0000) GS:ffff8f6e5d900000(0000) knlGS:0000000000000000 [ 32.464725] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 32.464726] CR2: 00007f297bf1c800 CR3: 00000000115e8000 CR4: 0000000000350ee0 [ 32.464730] Call Trace: [ 32.464763] <TASK> [ 32.464767] rtnl_dellink+0x13e/0x380 [ 32.464776] ? cred_has_capability.isra.0+0x68/0x100 [ 32.464780] ? __rtnl_unlock+0x33/0x60 [ 32.464783] ? bpf_lsm_capset+0x10/0x10 [ 32.464786] ? security_capable+0x36/0x50 [ 32.464790] rtnetlink_rcv_msg+0x14e/0x3b0 [ 32.464792] ? _copy_to_iter+0xb1/0x790 [ 32.464796] ? post_alloc_hook+0xa0/0x160 [ 32.464799] ? rtnl_calcit.isra.0+0x110/0x110 [ 32.464802] netlink_rcv_skb+0x50/0xf0 [ 32.464806] netlink_unicast+0x216/0x340 [ 32.464809] netlink_sendmsg+0x23f/0x480 [ 32.464812] sock_sendmsg+0x5e/0x60 [ 32.464815] ____sys_sendmsg+0x22c/0x270 [ 32.464818] ? import_iovec+0x17/0x20 [ 32.464821] ? sendmsg_copy_msghdr+0x59/0x90 [ 32.464823] ? do_set_pte+0xa0/0xe0 [ 32.464828] ___sys_sendmsg+0x81/0xc0 [ 32.464832] ? mod_objcg_state+0xc6/0x300 [ 32.464835] ? refill_obj_stock+0xa9/0x160 [ 32.464838] ? memcg_slab_free_hook+0x1a5/0x1f0 [ 32.464842] __sys_sendm ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/0276813b8ab08d9bf5ca4159f301d0829ecf13fc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/93c8cbeb1b2b8ff670b3dfd01b3abd843995c80f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e667d469098671261d558be0cd93dca4d285ce1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ecb1b5135bd3f232d5335b3935e2c2ac11bfa02f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53104,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:29.317,2025-05-08T11:15:51.903,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53105,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:29.430,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/mlx5e: Fix cleanup null-ptr deref on encap lock During module is unloaded while a peer tc flow is still offloaded, first the peer uplink rep profile is changed to a nic profile, and so neigh encap lock is destroyed. Next during unload, the VF reps netdevs are unregistered which causes the original non-peer tc flow to be deleted, which deletes the peer flow. The peer flow deletion detaches the encap entry and try to take the already destroyed encap lock, causing the below trace. Fix this by clearing peer flows during tc eswitch cleanup (mlx5e_tc_esw_cleanup()). Relevant trace: [ 4316.837128] BUG: kernel NULL pointer dereference, address: 00000000000001d8 [ 4316.842239] RIP: 0010:__mutex_lock+0xb5/0xc40 [ 4316.851897] Call Trace: [ 4316.852481] <TASK> [ 4316.857214] mlx5e_rep_neigh_entry_release+0x93/0x790 [mlx5_core] [ 4316.858258] mlx5e_rep_encap_entry_detach+0xa7/0xf0 [mlx5_core] [ 4316.859134] mlx5e_encap_dealloc+0xa3/0xf0 [mlx5_core] [ 4316.859867] clean_encap_dests.part.0+0x5c/0xe0 [mlx5_core] [ 4316.860605] mlx5e_tc_del_fdb_flow+0x32a/0x810 [mlx5_core] [ 4316.862609] __mlx5e_tc_del_fdb_peer_flow+0x1a2/0x250 [mlx5_core] [ 4316.863394] mlx5e_tc_del_flow+0x(/0x630 [mlx5_core] [ 4316.864090] mlx5e_flow_put+0x5f/0x100 [mlx5_core] [ 4316.864771] mlx5e_delete_flower+0x4de/0xa40 [mlx5_core] [ 4316.865486] tc_setup_cb_reoffload+0x20/0x80 [ 4316.865905] fl_reoffload+0x47c/0x510 [cls_flower] [ 4316.869181] tcf_block_playback_offloads+0x91/0x1d0 [ 4316.869649] tcf_block_unbind+0xe7/0x1b0 [ 4316.870049] tcf_block_offload_cmd.isra.0+0x1ee/0x270 [ 4316.879266] tcf_block_offload_unbind+0x61/0xa0 [ 4316.879711] __tcf_block_put+0xa4/0x310",,,"[{""url"":""https://git.kernel.org/stable/c/01fdaea410787fe372daeaeda93a29ed0606d334"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b7350f8dbe0c2a1d4d3ad7c35b610abd3cb91750"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c9668f0b1d28570327dbba189f2c61f6f9e43ae7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53106,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:29.520,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nfc: st-nci: Fix use after free bug in ndlc_remove due to race condition This bug influences both st_nci_i2c_remove and st_nci_spi_remove. Take st_nci_i2c_remove as an example. In st_nci_i2c_probe, it called ndlc_probe and bound &ndlc->sm_work with llt_ndlc_sm_work. When it calls ndlc_recv or timeout handler, it will finally call schedule_work to start the work. When we call st_nci_i2c_remove to remove the driver, there may be a sequence as follows: Fix it by finishing the work before cleanup in ndlc_remove CPU0 CPU1 |llt_ndlc_sm_work st_nci_i2c_remove | ndlc_remove | st_nci_remove | nci_free_device| kfree(ndev) | //free ndlc->ndev | |llt_ndlc_rcv_queue |nci_recv_frame |//use ndlc->ndev",,,"[{""url"":""https://git.kernel.org/stable/c/2156490c4b7cacda9a18ec99929940b8376dc0e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3405eb641dafcc8b28d174784b203c1622c121bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/43aa468df246175207a7d5d7d6d31b231f15b49c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5000fe6c27827a61d8250a7e4a1d26c3298ef4f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e331022b448fbc5e76f24349cd0246844dcad25"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/84dd9cc34014e3a3dcce0eb6d54b8a067e97676b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b0c202a8dc63008205a5d546559736507a9aae66"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f589e5b56c562d99ea74e05b1c3f0eab78aa17a3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53107,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:29.620,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: veth: Fix use after free in XDP_REDIRECT Commit 718a18a0c8a6 (""veth: Rework veth_xdp_rcv_skb in order to accept non-linear skb"") introduced a bug where it tried to use pskb_expand_head() if the headroom was less than XDP_PACKET_HEADROOM. This however uses kmalloc to expand the head, which will later allow consume_skb() to free the skb while is it still in use by AF_XDP. Previously if the headroom was less than XDP_PACKET_HEADROOM we continued on to allocate a new skb from pages so this restores that behavior. BUG: KASAN: use-after-free in __xsk_rcv+0x18d/0x2c0 Read of size 78 at addr ffff888976250154 by task napi/iconduit-g/148640 CPU: 5 PID: 148640 Comm: napi/iconduit-g Kdump: loaded Tainted: G O 6.1.4-cloudflare-kasan-2023.1.2 #1 Hardware name: Quanta Computer Inc. QuantaPlex T41S-2U/S2S-MB, BIOS S2S_3B10.03 06/21/2018 Call Trace: <TASK> dump_stack_lvl+0x34/0x48 print_report+0x170/0x473 ? __xsk_rcv+0x18d/0x2c0 kasan_report+0xad/0x130 ? __xsk_rcv+0x18d/0x2c0 kasan_check_range+0x149/0x1a0 memcpy+0x20/0x60 __xsk_rcv+0x18d/0x2c0 __xsk_map_redirect+0x1f3/0x490 ? veth_xdp_rcv_skb+0x89c/0x1ba0 [veth] xdp_do_redirect+0x5ca/0xd60 veth_xdp_rcv_skb+0x935/0x1ba0 [veth] ? __netif_receive_skb_list_core+0x671/0x920 ? veth_xdp+0x670/0x670 [veth] veth_xdp_rcv+0x304/0xa20 [veth] ? do_xdp_generic+0x150/0x150 ? veth_xdp_rcv_one+0xde0/0xde0 [veth] ? _raw_spin_lock_bh+0xe0/0xe0 ? newidle_balance+0x887/0xe30 ? __perf_event_task_sched_in+0xdb/0x800 veth_poll+0x139/0x571 [veth] ? veth_xdp_rcv+0xa20/0xa20 [veth] ? _raw_spin_unlock+0x39/0x70 ? finish_task_switch.isra.0+0x17e/0x7d0 ? __switch_to+0x5cf/0x1070 ? __schedule+0x95b/0x2640 ? io_schedule_timeout+0x160/0x160 __napi_poll+0xa1/0x440 napi_threaded_poll+0x3d1/0x460 ? __napi_poll+0x440/0x440 ? __kthread_parkme+0xc6/0x1f0 ? __napi_poll+0x440/0x440 kthread+0x2a2/0x340 ? kthread_complete_and_exit+0x20/0x20 ret_from_fork+0x22/0x30 </TASK> Freed by task 148640: kasan_save_stack+0x23/0x50 kasan_set_track+0x21/0x30 kasan_save_free_info+0x2a/0x40 ____kasan_slab_free+0x169/0x1d0 slab_free_freelist_hook+0xd2/0x190 __kmem_cache_free+0x1a1/0x2f0 skb_release_data+0x449/0x600 consume_skb+0x9f/0x1c0 veth_xdp_rcv_skb+0x89c/0x1ba0 [veth] veth_xdp_rcv+0x304/0xa20 [veth] veth_poll+0x139/0x571 [veth] __napi_poll+0xa1/0x440 napi_threaded_poll+0x3d1/0x460 kthread+0x2a2/0x340 ret_from_fork+0x22/0x30 The buggy address belongs to the object at ffff888976250000 which belongs to the cache kmalloc-2k of size 2048 The buggy address is located 340 bytes inside of 2048-byte region [ffff888976250000, ffff888976250800) The buggy address belongs to the physical page: page:00000000ae18262a refcount:2 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x976250 head:00000000ae18262a order:3 compound_mapcount:0 compound_pincount:0 flags: 0x2ffff800010200(slab|head|node=0|zone=2|lastcpupid=0x1ffff) raw: 002ffff800010200 0000000000000000 dead000000000122 ffff88810004cf00 raw: 0000000000000000 0000000080080008 00000002ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffff888976250000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ffff888976250080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb > ffff888976250100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ^ ffff888976250180: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ffff888976250200: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb",,,"[{""url"":""https://git.kernel.org/stable/c/6e755b56896df48b0fae0db275e148f8d8aa7d6f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/717d20710596b5b26595ede454d1105fa176f4a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c10131803e45269ddc6c817f19ed649110f3cae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53108,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:29.713,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/iucv: Fix size of interrupt data iucv_irq_data needs to be 4 bytes larger. These bytes are not used by the iucv module, but written by the z/VM hypervisor in case a CPU is deconfigured. Reported as: BUG dma-kmalloc-64 (Not tainted): kmalloc Redzone overwritten ----------------------------------------------------------------------------- 0x0000000000400564-0x0000000000400567 @offset=1380. First byte 0x80 instead of 0xcc Allocated in iucv_cpu_prepare+0x44/0xd0 age=167839 cpu=2 pid=1 __kmem_cache_alloc_node+0x166/0x450 kmalloc_node_trace+0x3a/0x70 iucv_cpu_prepare+0x44/0xd0 cpuhp_invoke_callback+0x156/0x2f0 cpuhp_issue_call+0xf0/0x298 __cpuhp_setup_state_cpuslocked+0x136/0x338 __cpuhp_setup_state+0xf4/0x288 iucv_init+0xf4/0x280 do_one_initcall+0x78/0x390 do_initcalls+0x11a/0x140 kernel_init_freeable+0x25e/0x2a0 kernel_init+0x2e/0x170 __ret_from_fork+0x3c/0x58 ret_from_fork+0xa/0x40 Freed in iucv_init+0x92/0x280 age=167839 cpu=2 pid=1 __kmem_cache_free+0x308/0x358 iucv_init+0x92/0x280 do_one_initcall+0x78/0x390 do_initcalls+0x11a/0x140 kernel_init_freeable+0x25e/0x2a0 kernel_init+0x2e/0x170 __ret_from_fork+0x3c/0x58 ret_from_fork+0xa/0x40 Slab 0x0000037200010000 objects=32 used=30 fp=0x0000000000400640 flags=0x1ffff00000010200(slab|head|node=0|zone=0| Object 0x0000000000400540 @offset=1344 fp=0x0000000000000000 Redzone 0000000000400500: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc ................ Redzone 0000000000400510: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc ................ Redzone 0000000000400520: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc ................ Redzone 0000000000400530: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc ................ Object 0000000000400540: 00 01 00 03 00 00 00 00 00 00 00 00 00 00 00 00 ................ Object 0000000000400550: f3 86 81 f2 f4 82 f8 82 f0 f0 f0 f0 f0 f0 f0 f2 ................ Object 0000000000400560: 00 00 00 00 80 00 00 00 cc cc cc cc cc cc cc cc ................ Object 0000000000400570: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc ................ Redzone 0000000000400580: cc cc cc cc cc cc cc cc ........ Padding 00000000004005d4: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a ZZZZZZZZZZZZZZZZ Padding 00000000004005e4: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a ZZZZZZZZZZZZZZZZ Padding 00000000004005f4: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a ZZZZZZZZZZZZ CPU: 6 PID: 121030 Comm: 116-pai-crypto. Not tainted 6.3.0-20230221.rc0.git4.99b8246b2d71.300.fc37.s390x+debug #1 Hardware name: IBM 3931 A01 704 (z/VM 7.3.0) Call Trace: [<000000032aa034ec>] dump_stack_lvl+0xac/0x100 [<0000000329f5a6cc>] check_bytes_and_report+0x104/0x140 [<0000000329f5aa78>] check_object+0x370/0x3c0 [<0000000329f5ede6>] free_debug_processing+0x15e/0x348 [<0000000329f5f06a>] free_to_partial_list+0x9a/0x2f0 [<0000000329f5f4a4>] __slab_free+0x1e4/0x3a8 [<0000000329f61768>] __kmem_cache_free+0x308/0x358 [<000000032a91465c>] iucv_cpu_dead+0x6c/0x88 [<0000000329c2fc66>] cpuhp_invoke_callback+0x156/0x2f0 [<000000032aa062da>] _cpu_down.constprop.0+0x22a/0x5e0 [<0000000329c3243e>] cpu_device_down+0x4e/0x78 [<000000032a61dee0>] device_offline+0xc8/0x118 [<000000032a61e048>] online_store+0x60/0xe0 [<000000032a08b6b0>] kernfs_fop_write_iter+0x150/0x1e8 [<0000000329fab65c>] vfs_write+0x174/0x360 [<0000000329fab9fc>] ksys_write+0x74/0x100 [<000000032aa03a5a>] __do_syscall+0x1da/0x208 [<000000032aa177b2>] system_call+0x82/0xb0 INFO: lockdep is turned off. FIX dma-kmalloc-64: Restoring kmalloc Redzone 0x0000000000400564-0x0000000000400567=0xcc FIX dma-kmalloc-64: Object at 0x0000000000400540 not freed",,,"[{""url"":""https://git.kernel.org/stable/c/3cfdefdaaa4b2a77e84d0db5e0a47a7aa3bb615a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3d87debb8ed2649608ff432699e7c961c0c6f03b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/71da5991b6438ad6da13ceb25465ee2760a1c52f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/93a970494881004c348d8feb38463ee72496e99a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a908eae0f71811afee86be7088692f1aa5855c3b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b0d2bb5e31a693ebc8888eb407f8a257a3680efa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd2e78462ae18484e55ae4d285df2c86b86bdd12"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c78f1345db4e4b3b78f9b768f4074ebd60abe966"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53109,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:29.823,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: tunnels: annotate lockless accesses to dev->needed_headroom IP tunnels can apparently update dev->needed_headroom in their xmit path. This patch takes care of three tunnels xmit, and also the core LL_RESERVED_SPACE() and LL_RESERVED_SPACE_EXTRA() helpers. More changes might be needed for completeness. BUG: KCSAN: data-race in ip_tunnel_xmit / ip_tunnel_xmit read to 0xffff88815b9da0ec of 2 bytes by task 888 on cpu 1: ip_tunnel_xmit+0x1270/0x1730 net/ipv4/ip_tunnel.c:803 __gre_xmit net/ipv4/ip_gre.c:469 [inline] ipgre_xmit+0x516/0x570 net/ipv4/ip_gre.c:661 __netdev_start_xmit include/linux/netdevice.h:4881 [inline] netdev_start_xmit include/linux/netdevice.h:4895 [inline] xmit_one net/core/dev.c:3580 [inline] dev_hard_start_xmit+0x127/0x400 net/core/dev.c:3596 __dev_queue_xmit+0x1007/0x1eb0 net/core/dev.c:4246 dev_queue_xmit include/linux/netdevice.h:3051 [inline] neigh_direct_output+0x17/0x20 net/core/neighbour.c:1623 neigh_output include/net/neighbour.h:546 [inline] ip_finish_output2+0x740/0x840 net/ipv4/ip_output.c:228 ip_finish_output+0xf4/0x240 net/ipv4/ip_output.c:316 NF_HOOK_COND include/linux/netfilter.h:291 [inline] ip_output+0xe5/0x1b0 net/ipv4/ip_output.c:430 dst_output include/net/dst.h:444 [inline] ip_local_out+0x64/0x80 net/ipv4/ip_output.c:126 iptunnel_xmit+0x34a/0x4b0 net/ipv4/ip_tunnel_core.c:82 ip_tunnel_xmit+0x1451/0x1730 net/ipv4/ip_tunnel.c:813 __gre_xmit net/ipv4/ip_gre.c:469 [inline] ipgre_xmit+0x516/0x570 net/ipv4/ip_gre.c:661 __netdev_start_xmit include/linux/netdevice.h:4881 [inline] netdev_start_xmit include/linux/netdevice.h:4895 [inline] xmit_one net/core/dev.c:3580 [inline] dev_hard_start_xmit+0x127/0x400 net/core/dev.c:3596 __dev_queue_xmit+0x1007/0x1eb0 net/core/dev.c:4246 dev_queue_xmit include/linux/netdevice.h:3051 [inline] neigh_direct_output+0x17/0x20 net/core/neighbour.c:1623 neigh_output include/net/neighbour.h:546 [inline] ip_finish_output2+0x740/0x840 net/ipv4/ip_output.c:228 ip_finish_output+0xf4/0x240 net/ipv4/ip_output.c:316 NF_HOOK_COND include/linux/netfilter.h:291 [inline] ip_output+0xe5/0x1b0 net/ipv4/ip_output.c:430 dst_output include/net/dst.h:444 [inline] ip_local_out+0x64/0x80 net/ipv4/ip_output.c:126 iptunnel_xmit+0x34a/0x4b0 net/ipv4/ip_tunnel_core.c:82 ip_tunnel_xmit+0x1451/0x1730 net/ipv4/ip_tunnel.c:813 __gre_xmit net/ipv4/ip_gre.c:469 [inline] ipgre_xmit+0x516/0x570 net/ipv4/ip_gre.c:661 __netdev_start_xmit include/linux/netdevice.h:4881 [inline] netdev_start_xmit include/linux/netdevice.h:4895 [inline] xmit_one net/core/dev.c:3580 [inline] dev_hard_start_xmit+0x127/0x400 net/core/dev.c:3596 __dev_queue_xmit+0x1007/0x1eb0 net/core/dev.c:4246 dev_queue_xmit include/linux/netdevice.h:3051 [inline] neigh_direct_output+0x17/0x20 net/core/neighbour.c:1623 neigh_output include/net/neighbour.h:546 [inline] ip_finish_output2+0x740/0x840 net/ipv4/ip_output.c:228 ip_finish_output+0xf4/0x240 net/ipv4/ip_output.c:316 NF_HOOK_COND include/linux/netfilter.h:291 [inline] ip_output+0xe5/0x1b0 net/ipv4/ip_output.c:430 dst_output include/net/dst.h:444 [inline] ip_local_out+0x64/0x80 net/ipv4/ip_output.c:126 iptunnel_xmit+0x34a/0x4b0 net/ipv4/ip_tunnel_core.c:82 ip_tunnel_xmit+0x1451/0x1730 net/ipv4/ip_tunnel.c:813 __gre_xmit net/ipv4/ip_gre.c:469 [inline] ipgre_xmit+0x516/0x570 net/ipv4/ip_gre.c:661 __netdev_start_xmit include/linux/netdevice.h:4881 [inline] netdev_start_xmit include/linux/netdevice.h:4895 [inline] xmit_one net/core/dev.c:3580 [inline] dev_hard_start_xmit+0x127/0x400 net/core/dev.c:3596 __dev_queue_xmit+0x1007/0x1eb0 net/core/dev.c:4246 dev_queue_xmit include/linux/netdevice.h:3051 [inline] neigh_direct_output+0x17/0x20 net/core/neighbour.c:1623 neigh_output include/net/neighbour.h:546 [inline] ip_finish_output2+0x740/0x840 net/ipv4/ip_output.c:228 ip_finish_output+0xf4/0x240 net/ipv4/ip_output.c:316 NF_HOOK_COND include/linux/netfilter.h:291 [inline] ip_output+0xe5/0x1b0 net/i ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/4b397c06cb987935b1b097336532aa6b4210e091"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/51f3bd3765bc5ca4583af07a00833da00d2ace1d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5aaab217c8f5387b9c5fff9e940d80f135e04366"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e206f66d824b3b28a7f9ee1366dfc79a937bb46"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9b86a8702b042ee4e15d2d46375be873a6a8834f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a69b72b57b7d269e833e520ba7500d556e8189b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be59b87ee4aed81db7c10e44f603866a0ac3ca5d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0a557fc1daf5c1086e47150a4571aebadbb62be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53110,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:29.930,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/smc: fix NULL sndbuf_desc in smc_cdc_tx_handler() When performing a stress test on SMC-R by rmmod mlx5_ib driver during the wrk/nginx test, we found that there is a probability of triggering a panic while terminating all link groups. This issue dues to the race between smc_smcr_terminate_all() and smc_buf_create(). smc_smcr_terminate_all smc_buf_create /* init */ conn->sndbuf_desc = NULL; ... __smc_lgr_terminate smc_conn_kill smc_close_abort smc_cdc_get_slot_and_msg_send __softirqentry_text_start smc_wr_tx_process_cqe smc_cdc_tx_handler READ(conn->sndbuf_desc->len); /* panic dues to NULL sndbuf_desc */ conn->sndbuf_desc = xxx; This patch tries to fix the issue by always to check the sndbuf_desc before send any cdc msg, to make sure that no null pointer is seen during cqe processing.",,,"[{""url"":""https://git.kernel.org/stable/c/22a825c541d775c1dbe7b2402786025acad6727b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/31817c530768b0199771ec6019571b4f0ddbf230"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3c270435db8aa34929263dddae8fd050f5216ecb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ebac7cf0a184a8102821a7a00203f02bebda83c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b108bd9e6be000492ebebe867daa699285978a10"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53111,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:30.027,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: loop: Fix use-after-free issues do_req_filebacked() calls blk_mq_complete_request() synchronously or asynchronously when using asynchronous I/O unless memory allocation fails. Hence, modify loop_handle_cmd() such that it does not dereference 'cmd' nor 'rq' after do_req_filebacked() finished unless we are sure that the request has not yet been completed. This patch fixes the following kernel crash: Unable to handle kernel NULL pointer dereference at virtual address 0000000000000054 Call trace: css_put.42938+0x1c/0x1ac loop_process_work+0xc8c/0xfd4 loop_rootcg_workfn+0x24/0x34 process_one_work+0x244/0x558 worker_thread+0x400/0x8fc kthread+0x16c/0x1e0 ret_from_fork+0x10/0x20",,,"[{""url"":""https://git.kernel.org/stable/c/407badf73ec9fb0d5744bf2ca1745c1818aa222f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6917395c4667cfb607ed8bf1826205a59414657c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9b0cb770f5d7b1ff40bea7ca385438ee94570eec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3fda704903f6d1fc351412f1bc6620333959ada"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53112,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:30.140,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/i915/sseu: fix max_subslices array-index-out-of-bounds access It seems that commit bc3c5e0809ae (""drm/i915/sseu: Don't try to store EU mask internally in UAPI format"") exposed a potential out-of-bounds access, reported by UBSAN as following on a laptop with a gen 11 i915 card: UBSAN: array-index-out-of-bounds in drivers/gpu/drm/i915/gt/intel_sseu.c:65:27 index 6 is out of range for type 'u16 [6]' CPU: 2 PID: 165 Comm: systemd-udevd Not tainted 6.2.0-9-generic #9-Ubuntu Hardware name: Dell Inc. XPS 13 9300/077Y9N, BIOS 1.11.0 03/22/2022 Call Trace: <TASK> show_stack+0x4e/0x61 dump_stack_lvl+0x4a/0x6f dump_stack+0x10/0x18 ubsan_epilogue+0x9/0x3a __ubsan_handle_out_of_bounds.cold+0x42/0x47 gen11_compute_sseu_info+0x121/0x130 [i915] intel_sseu_info_init+0x15d/0x2b0 [i915] intel_gt_init_mmio+0x23/0x40 [i915] i915_driver_mmio_probe+0x129/0x400 [i915] ? intel_gt_probe_all+0x91/0x2e0 [i915] i915_driver_probe+0xe1/0x3f0 [i915] ? drm_privacy_screen_get+0x16d/0x190 [drm] ? acpi_dev_found+0x64/0x80 i915_pci_probe+0xac/0x1b0 [i915] ... According to the definition of sseu_dev_info, eu_mask->hsw is limited to a maximum of GEN_MAX_SS_PER_HSW_SLICE (6) sub-slices, but gen11_sseu_info_init() can potentially set 8 sub-slices, in the !IS_JSL_EHL(gt->i915) case. Fix this by reserving up to 8 slots for max_subslices in the eu_mask struct. (cherry picked from commit 3cba09a6ac86ea1d456909626eb2685596c07822)",,,"[{""url"":""https://git.kernel.org/stable/c/193c41926d152761764894f46e23b53c00186a82"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1a1682abf7399318ac074b1f2ac6a8c992b5b3da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/36b076ab6247cf0d2135b2ad6bb337617c3b5a1b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53113,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:30.407,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: nl80211: fix NULL-ptr deref in offchan check If, e.g. in AP mode, the link was already created by userspace but not activated yet, it has a chandef but the chandef isn't valid and has no channel. Check for this and ignore this link.",,,"[{""url"":""https://git.kernel.org/stable/c/201a836c2385fdd2b9d0a8e7737bba5b26f1863a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/87e80ea4fbc9ce2f2005905fdbcd38baaa47463a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f624bb6fad23df3270580b4fcef415c6e7bf7705"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53114,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:30.493,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: i40e: Fix kernel crash during reboot when adapter is in recovery mode If the driver detects during probe that firmware is in recovery mode then i40e_init_recovery_mode() is called and the rest of probe function is skipped including pci_set_drvdata(). Subsequent i40e_shutdown() called during shutdown/reboot dereferences NULL pointer as pci_get_drvdata() returns NULL. To fix call pci_set_drvdata() also during entering to recovery mode. Reproducer: 1) Lets have i40e NIC with firmware in recovery mode 2) Run reboot Result: [ 139.084698] i40e: Intel(R) Ethernet Connection XL710 Network Driver [ 139.090959] i40e: Copyright (c) 2013 - 2019 Intel Corporation. [ 139.108438] i40e 0000:02:00.0: Firmware recovery mode detected. Limiting functionality. [ 139.116439] i40e 0000:02:00.0: Refer to the Intel(R) Ethernet Adapters and Devices User Guide for details on firmware recovery mode. [ 139.129499] i40e 0000:02:00.0: fw 8.3.64775 api 1.13 nvm 8.30 0x8000b78d 1.3106.0 [8086:1583] [15d9:084a] [ 139.215932] i40e 0000:02:00.0 enp2s0f0: renamed from eth0 [ 139.223292] i40e 0000:02:00.1: Firmware recovery mode detected. Limiting functionality. [ 139.231292] i40e 0000:02:00.1: Refer to the Intel(R) Ethernet Adapters and Devices User Guide for details on firmware recovery mode. [ 139.244406] i40e 0000:02:00.1: fw 8.3.64775 api 1.13 nvm 8.30 0x8000b78d 1.3106.0 [8086:1583] [15d9:084a] [ 139.329209] i40e 0000:02:00.1 enp2s0f1: renamed from eth0 ... [ 156.311376] BUG: kernel NULL pointer dereference, address: 00000000000006c2 [ 156.318330] #PF: supervisor write access in kernel mode [ 156.323546] #PF: error_code(0x0002) - not-present page [ 156.328679] PGD 0 P4D 0 [ 156.331210] Oops: 0002 [#1] PREEMPT SMP NOPTI [ 156.335567] CPU: 26 PID: 15119 Comm: reboot Tainted: G E 6.2.0+ #1 [ 156.343126] Hardware name: Abacus electric, s.r.o. - servis@abacus.cz Super Server/H12SSW-iN, BIOS 2.4 04/13/2022 [ 156.353369] RIP: 0010:i40e_shutdown+0x15/0x130 [i40e] [ 156.358430] Code: c1 fc ff ff 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 0f 1f 44 00 00 55 48 89 fd 53 48 8b 9f 48 01 00 00 <f0> 80 8b c2 06 00 00 04 f0 80 8b c0 06 00 00 08 48 8d bb 08 08 00 [ 156.377168] RSP: 0018:ffffb223c8447d90 EFLAGS: 00010282 [ 156.382384] RAX: ffffffffc073ee70 RBX: 0000000000000000 RCX: 0000000000000001 [ 156.389510] RDX: 0000000080000001 RSI: 0000000000000246 RDI: ffff95db49988000 [ 156.396634] RBP: ffff95db49988000 R08: ffffffffffffffff R09: ffffffff8bd17d40 [ 156.403759] R10: 0000000000000001 R11: ffffffff8a5e3d28 R12: ffff95db49988000 [ 156.410882] R13: ffffffff89a6fe17 R14: ffff95db49988150 R15: 0000000000000000 [ 156.418007] FS: 00007fe7c0cc3980(0000) GS:ffff95ea8ee80000(0000) knlGS:0000000000000000 [ 156.426083] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 156.431819] CR2: 00000000000006c2 CR3: 00000003092fc005 CR4: 0000000000770ee0 [ 156.438944] PKRU: 55555554 [ 156.441647] Call Trace: [ 156.444096] <TASK> [ 156.446199] pci_device_shutdown+0x38/0x60 [ 156.450297] device_shutdown+0x163/0x210 [ 156.454215] kernel_restart+0x12/0x70 [ 156.457872] __do_sys_reboot+0x1ab/0x230 [ 156.461789] ? vfs_writev+0xa6/0x1a0 [ 156.465362] ? __pfx_file_free_rcu+0x10/0x10 [ 156.469635] ? __call_rcu_common.constprop.85+0x109/0x5a0 [ 156.475034] do_syscall_64+0x3e/0x90 [ 156.478611] entry_SYSCALL_64_after_hwframe+0x72/0xdc [ 156.483658] RIP: 0033:0x7fe7bff37ab7",,,"[{""url"":""https://git.kernel.org/stable/c/3cbecb1c9085a00155639404f7addbcbfc987ba3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4ff82695266576a0b4f1077a7100b2451e476df4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6e18f66b704bd725196508c1db93bf7338cdc8de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7e4f8a0c495413a50413e8c9f1032ce1bc633bae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3826fb3ea14646b3d4e6309bfc384b349f36eb6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c703362a66ea971905b9dc153fc54d1b6ac05423"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53115,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:30.590,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: mpi3mr: Fix memory leaks in mpi3mr_init_ioc() Don't allocate memory again when IOC is being reinitialized.",,,"[{""url"":""https://git.kernel.org/stable/c/5aab9342f12f980b64617a034d121efbbf09100a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7277b4eec2f25a0653646ba95b1f25fa16be1d6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c798304470cab88723d895726d17fcb96472e0e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53116,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:30.680,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nvmet: avoid potential UAF in nvmet_req_complete() An nvme target ->queue_response() operation implementation may free the request passed as argument. Such implementation potentially could result in a use after free of the request pointer when percpu_ref_put() is called in nvmet_req_complete(). Avoid such problem by using a local variable to save the sq pointer before calling __nvmet_req_complete(), thus avoiding dereferencing the req pointer after that function call.",,,"[{""url"":""https://git.kernel.org/stable/c/04c394208831d5e0d5cfee46722eb0f033cd4083"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6173a77b7e9d3e202bdb9897b23f2a8afe7bf286"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ed9813871038b25a934b21ab76b5b7dbf44fc3a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6317235da8aa7cb97529ebc8121cc2a4c4c437a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bcd535f07c58342302a2cd2bdd8894fe0872c8a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e5d99b29012bbf0e86929403209723b2806500c1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1d5888a5efe345b63c430b256e95acb0a475642"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fafcb4b26393870c45462f9af6a48e581dbbcf7e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53117,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:30.783,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fs: prevent out-of-bounds array speculation when closing a file descriptor Google-Bug-Id: 114199369",,,"[{""url"":""https://git.kernel.org/stable/c/3d5d9501b634fd268eb56428cda92cd317752d69"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/609d54441493c99f21c1823dfd66fa7f4c512ff4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6631c8da02cfad96c53b217cf647b511c7f34faf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a759905de9cd6ec9ca08ceadf0920272772ed830"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cec08b7d1ebcd3138d4658b3868ce26aeb1e8e06"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eea8e4e056a5ffbeb539a13854c017d5d62c756a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f31cd5da636682caea424fa1c22679016cbfc16b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8cd8754a03a3748384ee438c572423643c9c315"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53118,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:30.880,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: core: Fix a procfs host directory removal regression scsi_proc_hostdir_rm() decreases a reference counter and hence must only be called once per host that is removed. This change does not require a scsi_add_host_with_dma() change since scsi_add_host_with_dma() will return 0 (success) if scsi_proc_host_add() is called.",,,"[{""url"":""https://git.kernel.org/stable/c/2a764d55e938743efa7c2cba7305633bcf227f09"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/68c665bb185037e7eb66fb792c61da9d7151e99c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73f030d4ef6d1ad17f824a0a2eb637ef7a9c7d51"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7e0ae8667fcdd99d1756922e1140cac75f5fa279"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/88c3d3bb6469cea929ac68fd326bdcbefcdfdd83"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be03df3d4bfe7e8866d4aa43d62e648ffe884f5f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53119,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:30.980,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nfc: pn533: initialize struct pn533_out_arg properly struct pn533_out_arg used as a temporary context for out_urb is not initialized properly. Its uninitialized 'phy' field can be dereferenced in error cases inside pn533_out_complete() callback function. It causes the following failure: general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007] CPU: 1 PID: 0 Comm: swapper/1 Not tainted 6.2.0-rc3-next-20230110-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022 RIP: 0010:pn533_out_complete.cold+0x15/0x44 drivers/nfc/pn533/usb.c:441 Call Trace: <IRQ> __usb_hcd_giveback_urb+0x2b6/0x5c0 drivers/usb/core/hcd.c:1671 usb_hcd_giveback_urb+0x384/0x430 drivers/usb/core/hcd.c:1754 dummy_timer+0x1203/0x32d0 drivers/usb/gadget/udc/dummy_hcd.c:1988 call_timer_fn+0x1da/0x800 kernel/time/timer.c:1700 expire_timers+0x234/0x330 kernel/time/timer.c:1751 __run_timers kernel/time/timer.c:2022 [inline] __run_timers kernel/time/timer.c:1995 [inline] run_timer_softirq+0x326/0x910 kernel/time/timer.c:2035 __do_softirq+0x1fb/0xaf6 kernel/softirq.c:571 invoke_softirq kernel/softirq.c:445 [inline] __irq_exit_rcu+0x123/0x180 kernel/softirq.c:650 irq_exit_rcu+0x9/0x20 kernel/softirq.c:662 sysvec_apic_timer_interrupt+0x97/0xc0 arch/x86/kernel/apic/apic.c:1107 Initialize the field with the pn533_usb_phy currently used. Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",,,"[{""url"":""https://git.kernel.org/stable/c/0f9c1f26d434c32520dfe33326b28c5954bc4299"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2703da78849c47b6b5b4471edb35fc7b7f91dead"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2bd1ed6d607d7013ed4959e86990a04f028543ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2bee84369b76f6c9ef71938069c65a6ebd1a12f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2cbd4213baf7be5d87d183e2032c54003de0790f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/484b7059796e3bc1cb527caa61dfc60da649b4f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c20a07ed26a71a8ccc9c6d935fc181573f5462e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a97ef110c491b72c138111a595a3a3af56cbc94c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53120,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.083,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: mpi3mr: Fix config page DMA memory leak A fix for: DMA-API: pci 0000:83:00.0: device driver has pending DMA allocations while released from device [count=1]",,,"[{""url"":""https://git.kernel.org/stable/c/5fc4d698ed4b6507be2eb36d040a678adcb89da4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d2b02172b6a2ae6aecd7ef6480b9c4bf3dc59f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dca06ccf13de14e144d34f158f73ae0032f80e63"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53121,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.173,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tcp: tcp_make_synack() can be called from process context tcp_rtx_synack() now could be called in process context as explained in 0a375c822497 (""tcp: tcp_rtx_synack() can be called from process context""). tcp_rtx_synack() might call tcp_make_synack(), which will touch per-CPU variables with preemption enabled. This causes the following BUG: BUG: using __this_cpu_add() in preemptible [00000000] code: ThriftIO1/5464 caller is tcp_make_synack+0x841/0xac0 Call Trace: <TASK> dump_stack_lvl+0x10d/0x1a0 check_preemption_disabled+0x104/0x110 tcp_make_synack+0x841/0xac0 tcp_v6_send_synack+0x5c/0x450 tcp_rtx_synack+0xeb/0x1f0 inet_rtx_syn_ack+0x34/0x60 tcp_check_req+0x3af/0x9e0 tcp_rcv_state_process+0x59b/0x2030 tcp_v6_do_rcv+0x5f5/0x700 release_sock+0x3a/0xf0 tcp_sendmsg+0x33/0x40 ____sys_sendmsg+0x2f2/0x490 __sys_sendmsg+0x184/0x230 do_syscall_64+0x3d/0x90 Avoid calling __TCP_INC_STATS() with will touch per-cpu variables. Use TCP_INC_STATS() which is safe to be called from context switch.",,,"[{""url"":""https://git.kernel.org/stable/c/442aa78ed70188b21ccd8669738448702c0a3281"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7613cde8c0c1f02a7ec2e1d536c01b65b135fc1c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/77ad58bca0119e8cc3e0e9d91a3f22caa66e4dfa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9180aa4622a720b433e842b4d3aa34d73eec577a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad07290d63ff6689f50565b02f5b6f34ec15a5ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bced3f7db95ff2e6ca29dc4d1c9751ab5e736a09"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d493d4fe88195a144d6a277a90062a7534ed2192"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e23ca307745be3df7fe9762f3e2a7e311a57852e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53122,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.270,2025-05-08T11:15:52.123,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53123,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.360,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: PCI: s390: Fix use-after-free of PCI resources with per-function hotplug On s390 PCI functions may be hotplugged individually even when they belong to a multi-function device. In particular on an SR-IOV device VFs may be removed and later re-added. In commit a50297cf8235 (""s390/pci: separate zbus creation from scanning"") it was missed however that struct pci_bus and struct zpci_bus's resource list retained a reference to the PCI functions MMIO resources even though those resources are released and freed on hot-unplug. These stale resources may subsequently be claimed when the PCI function re-appears resulting in use-after-free. One idea of fixing this use-after-free in s390 specific code that was investigated was to simply keep resources around from the moment a PCI function first appeared until the whole virtual PCI bus created for a multi-function device disappears. The problem with this however is that due to the requirement of artificial MMIO addreesses (address cookies) extra logic is then needed to keep the address cookies compatible on re-plug. At the same time the MMIO resources semantically belong to the PCI function so tying their lifecycle to the function seems more logical. Instead a simpler approach is to remove the resources of an individually hot-unplugged PCI function from the PCI bus's resource list while keeping the resources of other PCI functions on the PCI bus untouched. This is done by introducing pci_bus_remove_resource() to remove an individual resource. Similarly the resource also needs to be removed from the struct zpci_bus's resource list. It turns out however, that there is really no need to add the MMIO resources to the struct zpci_bus's resource list at all and instead we can simply use the zpci_bar_struct's resource pointer directly.",,,"[{""url"":""https://git.kernel.org/stable/c/437bb839e36cc9f35adc6d2a2bf113b7a0fc9985"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a2410d0c3d2d714ed968a135dfcbed6aa3ff7027"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ab909509850b27fd39b8ba99e44cda39dbc3858c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b99ebf4b62774e690e73a551cf5fbf6f219bdd96"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53124,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.453,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: mpt3sas: Fix NULL pointer access in mpt3sas_transport_port_add() Port is allocated by sas_port_alloc_num() and rphy is allocated by either sas_end_device_alloc() or sas_expander_alloc(), all of which may return NULL. So we need to check the rphy to avoid possible NULL pointer access. If sas_rphy_add() returned with failure, rphy is set to NULL. We would access the rphy in the following lines which would also result NULL pointer access.",,,"[{""url"":""https://git.kernel.org/stable/c/090305c36185c0547e4441d4c08f1cf096b32134"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6f0c2f70d9929208d8427ec72c3ed91e2251e289"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9937f784a608944107dcc2ba9a9c3333f8330b9e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a26c775ccc4cfe46f9b718b51bd24313053c7e0b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b5e5bbb3fa5f8412e96c5eda7f4a4af6241d6bd3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3c57724f1569311e4b81e98fad0931028b9bdcd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53125,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.547,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: usb: smsc75xx: Limit packet length to skb->len Packet length retrieved from skb data may be larger than the actual socket buffer length (up to 9026 bytes). In such case the cloned skb passed up the network stack will leak kernel memory contents.",,,"[{""url"":""https://git.kernel.org/stable/c/105db6574281e1e03fcbf87983f4fee111682306"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4a4de0a68b18485c68ab4f0cfa665b1633c6d277"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/53966d572d056d6b234cfe76a5f9d60049d3c178"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ee5df9c039e37b9d8eb5e3de08bfb7f53d31cb6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9fabdd79051a9fe51388df099aff6e4b660fedd2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c7bdc137ca163b90917c1eeba4f1937684bd4f8b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d8b228318935044dafe3a5bc07ee71a1f1424b8d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e294f0aa47e4844f3d3c8766c02accd5a76a7d4e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53126,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.643,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: mpi3mr: Fix sas_hba.phy memory leak in mpi3mr_remove() Free mrioc->sas_hba.phy at .remove.",,,"[{""url"":""https://git.kernel.org/stable/c/480aae2f30637b5140e9c7a9b10298e538df2b5e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c60a7c7508645a9f36e4a18a5f548fb79378acd1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d4caa1a4255cc44be56bcab3db2c97c632e6cc10"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53127,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.730,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: mpi3mr: Fix expander node leak in mpi3mr_remove() Add a missing resource clean up in .remove.",,,"[{""url"":""https://git.kernel.org/stable/c/0023972a7593720f8878aed06c03ac9e541078be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce756daa36e1ba271bb3334267295e447aa57a5c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cf9777be5683c5e55680c089df02ee27d2226aa8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53128,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.820,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: mpi3mr: Fix throttle_groups memory leak Add a missing kfree().",,,"[{""url"":""https://git.kernel.org/stable/c/574cc10edaa7dba833764efed8c57ee0e6bf7574"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/85349a227eb4a56520adc190c666075f80d4ae70"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f305a7b6ca21a665e8d0cf70b5936991a298c93c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53129,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.907,2025-05-08T11:15:52.333,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53130,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.997,2025-05-08T11:15:52.570,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53131,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:32.087,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: SUNRPC: Fix a server shutdown leak Fix a race where kthread_stop() may prevent the threadfn from ever getting called. If that happens the svc_rqst will not be cleaned up.",,,"[{""url"":""https://git.kernel.org/stable/c/7a3720361068ab520aed4608bad31ea9a6cc7fe7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ca6705d9d609441d34f8b853e1e4a6369b3b171"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad7e40ee157ba33950a4ccdc284334580da3638d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce7dd61e004002bc1c48d1ca47c887f3f3cc7370"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f74b3286859463cd63cc9d4aeaabd8b0c640182a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53132,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:32.170,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: mpi3mr: Fix mpi3mr_hba_port memory leak in mpi3mr_remove() Free mpi3mr_hba_port at .remove.",,,"[{""url"":""https://git.kernel.org/stable/c/6322569273071745f2dd0c541b154b9666ae7767"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d0f3c3728da8af76dfe435f7f0cfa2b9d9e43ef0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f28bdab9e208792212c52b0c232a13bba84cf048"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53133,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:32.260,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf, sockmap: Fix an infinite loop error when len is 0 in tcp_bpf_recvmsg_parser() When the buffer length of the recvmsg system call is 0, we got the flollowing soft lockup problem: watchdog: BUG: soft lockup - CPU#3 stuck for 27s! [a.out:6149] CPU: 3 PID: 6149 Comm: a.out Kdump: loaded Not tainted 6.2.0+ #30 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.15.0-1 04/01/2014 RIP: 0010:remove_wait_queue+0xb/0xc0 Code: 5e 41 5f c3 cc cc cc cc 0f 1f 80 00 00 00 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 0f 1f 44 00 00 41 57 <41> 56 41 55 41 54 55 48 89 fd 53 48 89 f3 4c 8d 6b 18 4c 8d 73 20 RSP: 0018:ffff88811b5978b8 EFLAGS: 00000246 RAX: 0000000000000000 RBX: ffff88811a7d3780 RCX: ffffffffb7a4d768 RDX: dffffc0000000000 RSI: ffff88811b597908 RDI: ffff888115408040 RBP: 1ffff110236b2f1b R08: 0000000000000000 R09: ffff88811a7d37e7 R10: ffffed10234fa6fc R11: 0000000000000001 R12: ffff88811179b800 R13: 0000000000000001 R14: ffff88811a7d38a8 R15: ffff88811a7d37e0 FS: 00007f6fb5398740(0000) GS:ffff888237180000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000020000000 CR3: 000000010b6ba002 CR4: 0000000000370ee0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> tcp_msg_wait_data+0x279/0x2f0 tcp_bpf_recvmsg_parser+0x3c6/0x490 inet_recvmsg+0x280/0x290 sock_recvmsg+0xfc/0x120 ____sys_recvmsg+0x160/0x3d0 ___sys_recvmsg+0xf0/0x180 __sys_recvmsg+0xea/0x1a0 do_syscall_64+0x3f/0x90 entry_SYSCALL_64_after_hwframe+0x72/0xdc The logic in tcp_bpf_recvmsg_parser is as follows: msg_bytes_ready: copied = sk_msg_recvmsg(sk, psock, msg, len, flags); if (!copied) { wait data; goto msg_bytes_ready; } In this case, ""copied"" always is 0, the infinite loop occurs. According to the Linux system call man page, 0 should be returned in this case. Therefore, in tcp_bpf_recvmsg_parser(), if the length is 0, directly return. Also modify several other functions with the same problem.",,,"[{""url"":""https://git.kernel.org/stable/c/4a476285f6d2921c3c9faa494eab83b78f78fc55"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf0579989de64d36e177c0611c685dc4a91457a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d900f3d20cc3169ce42ec72acc850e662a4d4db2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f45cf3ae3068e70e2c7f3e24a7f8e8aa99511f03"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53134,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:32.353,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bnxt_en: Avoid order-5 memory allocation for TPA data The driver needs to keep track of all the possible concurrent TPA (GRO/LRO) completions on the aggregation ring. On P5 chips, the maximum number of concurrent TPA is 256 and the amount of memory we allocate is order-5 on systems using 4K pages. Memory allocation failure has been reported: NetworkManager: page allocation failure: order:5, mode:0x40dc0(GFP_KERNEL|__GFP_COMP|__GFP_ZERO), nodemask=(null),cpuset=/,mems_allowed=0-1 CPU: 15 PID: 2995 Comm: NetworkManager Kdump: loaded Not tainted 5.10.156 #1 Hardware name: Dell Inc. PowerEdge R660/0M1CC5, BIOS 0.2.25 08/12/2022 Call Trace: dump_stack+0x57/0x6e warn_alloc.cold.120+0x7b/0xdd ? _cond_resched+0x15/0x30 ? __alloc_pages_direct_compact+0x15f/0x170 __alloc_pages_slowpath.constprop.108+0xc58/0xc70 __alloc_pages_nodemask+0x2d0/0x300 kmalloc_order+0x24/0xe0 kmalloc_order_trace+0x19/0x80 bnxt_alloc_mem+0x1150/0x15c0 [bnxt_en] ? bnxt_get_func_stat_ctxs+0x13/0x60 [bnxt_en] __bnxt_open_nic+0x12e/0x780 [bnxt_en] bnxt_open+0x10b/0x240 [bnxt_en] __dev_open+0xe9/0x180 __dev_change_flags+0x1af/0x220 dev_change_flags+0x21/0x60 do_setlink+0x35c/0x1100 Instead of allocating this big chunk of memory and dividing it up for the concurrent TPA instances, allocate each small chunk separately for each TPA instance. This will reduce it to order-0 allocations.",,,"[{""url"":""https://git.kernel.org/stable/c/16f3aae1aa2dd89bc8d073a67f190af580386ae9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/20fd0607acbf9770db9b99e3418dd75614f80b6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/accd7e23693aaaa9aa0d3e9eca0ae77d1be80ab3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad529d1fae1565d38f929479d4ea8aea90054bd2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d16701a385b54f44bf41ff1d7485e7a11080deb3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fcae40e65802547def39b4deaa2ae38a29864d81"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53135,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:32.447,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: riscv: Use READ_ONCE_NOCHECK in imprecise unwinding stack mode When CONFIG_FRAME_POINTER is unset, the stack unwinding function walk_stackframe randomly reads the stack and then, when KASAN is enabled, it can lead to the following backtrace: [ 0.000000] ================================================================== [ 0.000000] BUG: KASAN: stack-out-of-bounds in walk_stackframe+0xa6/0x11a [ 0.000000] Read of size 8 at addr ffffffff81807c40 by task swapper/0 [ 0.000000] [ 0.000000] CPU: 0 PID: 0 Comm: swapper Not tainted 6.2.0-12919-g24203e6db61f #43 [ 0.000000] Hardware name: riscv-virtio,qemu (DT) [ 0.000000] Call Trace: [ 0.000000] [<ffffffff80007ba8>] walk_stackframe+0x0/0x11a [ 0.000000] [<ffffffff80099ecc>] init_param_lock+0x26/0x2a [ 0.000000] [<ffffffff80007c4a>] walk_stackframe+0xa2/0x11a [ 0.000000] [<ffffffff80c49c80>] dump_stack_lvl+0x22/0x36 [ 0.000000] [<ffffffff80c3783e>] print_report+0x198/0x4a8 [ 0.000000] [<ffffffff80099ecc>] init_param_lock+0x26/0x2a [ 0.000000] [<ffffffff80007c4a>] walk_stackframe+0xa2/0x11a [ 0.000000] [<ffffffff8015f68a>] kasan_report+0x9a/0xc8 [ 0.000000] [<ffffffff80007c4a>] walk_stackframe+0xa2/0x11a [ 0.000000] [<ffffffff80007c4a>] walk_stackframe+0xa2/0x11a [ 0.000000] [<ffffffff8006e99c>] desc_make_final+0x80/0x84 [ 0.000000] [<ffffffff8009a04e>] stack_trace_save+0x88/0xa6 [ 0.000000] [<ffffffff80099fc2>] filter_irq_stacks+0x72/0x76 [ 0.000000] [<ffffffff8006b95e>] devkmsg_read+0x32a/0x32e [ 0.000000] [<ffffffff8015ec16>] kasan_save_stack+0x28/0x52 [ 0.000000] [<ffffffff8006e998>] desc_make_final+0x7c/0x84 [ 0.000000] [<ffffffff8009a04a>] stack_trace_save+0x84/0xa6 [ 0.000000] [<ffffffff8015ec52>] kasan_set_track+0x12/0x20 [ 0.000000] [<ffffffff8015f22e>] __kasan_slab_alloc+0x58/0x5e [ 0.000000] [<ffffffff8015e7ea>] __kmem_cache_create+0x21e/0x39a [ 0.000000] [<ffffffff80e133ac>] create_boot_cache+0x70/0x9c [ 0.000000] [<ffffffff80e17ab2>] kmem_cache_init+0x6c/0x11e [ 0.000000] [<ffffffff80e00fd6>] mm_init+0xd8/0xfe [ 0.000000] [<ffffffff80e011d8>] start_kernel+0x190/0x3ca [ 0.000000] [ 0.000000] The buggy address belongs to stack of task swapper/0 [ 0.000000] and is located at offset 0 in frame: [ 0.000000] stack_trace_save+0x0/0xa6 [ 0.000000] [ 0.000000] This frame has 1 object: [ 0.000000] [32, 56) 'c' [ 0.000000] [ 0.000000] The buggy address belongs to the physical page: [ 0.000000] page:(____ptrval____) refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x81a07 [ 0.000000] flags: 0x1000(reserved|zone=0) [ 0.000000] raw: 0000000000001000 ff600003f1e3d150 ff600003f1e3d150 0000000000000000 [ 0.000000] raw: 0000000000000000 0000000000000000 00000001ffffffff [ 0.000000] page dumped because: kasan: bad access detected [ 0.000000] [ 0.000000] Memory state around the buggy address: [ 0.000000] ffffffff81807b00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 0.000000] ffffffff81807b80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 0.000000] >ffffffff81807c00: 00 00 00 00 00 00 00 00 f1 f1 f1 f1 00 00 00 f3 [ 0.000000] ^ [ 0.000000] ffffffff81807c80: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00 [ 0.000000] ffffffff81807d00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 0.000000] ================================================================== Fix that by using READ_ONCE_NOCHECK when reading the stack in imprecise mode.",,,"[{""url"":""https://git.kernel.org/stable/c/17fa90ffba20743c946920fbb0afe160d0ead8c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/324912d6c0c4006711054d389faa2239c1655e1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3a9418d2c93c1c86ce4d0595112d91c7a8e70c2c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3de277af481ab931fab9e295ad8762692920732a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/76950340cf03b149412fe0d5f0810e52ac1df8cb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a99a61d9e1bfca2fc37d223a6a185c0eb66aba02"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53136,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:32.540,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: af_unix: fix struct pid leaks in OOB support syzbot reported struct pid leak [1]. Issue is that queue_oob() calls maybe_add_creds() which potentially holds a reference on a pid. But skb->destructor is not set (either directly or by calling unix_scm_to_skb()) This means that subsequent kfree_skb() or consume_skb() would leak this reference. In this fix, I chose to fully support scm even for the OOB message. [1] BUG: memory leak unreferenced object 0xffff8881053e7f80 (size 128): comm ""syz-executor242"", pid 5066, jiffies 4294946079 (age 13.220s) hex dump (first 32 bytes): 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ backtrace: [<ffffffff812ae26a>] alloc_pid+0x6a/0x560 kernel/pid.c:180 [<ffffffff812718df>] copy_process+0x169f/0x26c0 kernel/fork.c:2285 [<ffffffff81272b37>] kernel_clone+0xf7/0x610 kernel/fork.c:2684 [<ffffffff812730cc>] __do_sys_clone+0x7c/0xb0 kernel/fork.c:2825 [<ffffffff849ad699>] do_syscall_x64 arch/x86/entry/common.c:50 [inline] [<ffffffff849ad699>] do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80 [<ffffffff84a0008b>] entry_SYSCALL_64_after_hwframe+0x63/0xcd",,,"[{""url"":""https://git.kernel.org/stable/c/2aab4b96900272885bc157f8b236abf1cdc02e08"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a59d6306263c38e5c0592ea4451ca26a0778c947"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac1968ac399205fda9ee3b18f7de7416cb3a5d0d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f3969427fb06a2c3cd6efd7faab63505cfa76e76"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53137,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:32.633,2025-09-05T20:15:32.140,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53138,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:32.720,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: caif: Fix use-after-free in cfusbl_device_notify() syzbot reported use-after-free in cfusbl_device_notify() [1]. This causes a stack trace like below: BUG: KASAN: use-after-free in cfusbl_device_notify+0x7c9/0x870 net/caif/caif_usb.c:138 Read of size 8 at addr ffff88807ac4e6f0 by task kworker/u4:6/1214 CPU: 0 PID: 1214 Comm: kworker/u4:6 Not tainted 5.19.0-rc3-syzkaller-00146-g92f20ff72066 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: netns cleanup_net Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106 print_address_description.constprop.0.cold+0xeb/0x467 mm/kasan/report.c:313 print_report mm/kasan/report.c:429 [inline] kasan_report.cold+0xf4/0x1c6 mm/kasan/report.c:491 cfusbl_device_notify+0x7c9/0x870 net/caif/caif_usb.c:138 notifier_call_chain+0xb5/0x200 kernel/notifier.c:87 call_netdevice_notifiers_info+0xb5/0x130 net/core/dev.c:1945 call_netdevice_notifiers_extack net/core/dev.c:1983 [inline] call_netdevice_notifiers net/core/dev.c:1997 [inline] netdev_wait_allrefs_any net/core/dev.c:10227 [inline] netdev_run_todo+0xbc0/0x10f0 net/core/dev.c:10341 default_device_exit_batch+0x44e/0x590 net/core/dev.c:11334 ops_exit_list+0x125/0x170 net/core/net_namespace.c:167 cleanup_net+0x4ea/0xb00 net/core/net_namespace.c:594 process_one_work+0x996/0x1610 kernel/workqueue.c:2289 worker_thread+0x665/0x1080 kernel/workqueue.c:2436 kthread+0x2e9/0x3a0 kernel/kthread.c:376 ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:302 </TASK> When unregistering a net device, unregister_netdevice_many_notify() sets the device's reg_state to NETREG_UNREGISTERING, calls notifiers with NETDEV_UNREGISTER, and adds the device to the todo list. Later on, devices in the todo list are processed by netdev_run_todo(). netdev_run_todo() waits devices' reference count become 1 while rebdoadcasting NETDEV_UNREGISTER notification. When cfusbl_device_notify() is called with NETDEV_UNREGISTER multiple times, the parent device might be freed. This could cause UAF. Processing NETDEV_UNREGISTER multiple times also causes inbalance of reference count for the module. This patch fixes the issue by accepting only first NETDEV_UNREGISTER notification.",,,"[{""url"":""https://git.kernel.org/stable/c/1793da97a23e31c5bf06631f3f3e5a25f368fd64"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/287027d8a567168a5d8ce5cb0cba16a34791a48c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f14457e1584224f4296af613bbd99deb60b5d91"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/68a45c3cf0e2242a533657f4f535d9b6a7447a79"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9781e98a97110f5e76999058368b4be76a788484"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9dc16be373b382ddd4c274052a6e870a95e76c01"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c3aaec463a632cf4187dc017e421bfa69d7834a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d1a11bbdbb5ea9f172019c5a4a3e9d8eabd72179"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53139,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:32.817,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nfc: fdp: add null check of devm_kmalloc_array in fdp_nci_i2c_read_device_properties devm_kmalloc_array may fails, *fw_vsc_cfg might be null and cause out-of-bounds write in device_property_read_u8_array later.",,,"[{""url"":""https://git.kernel.org/stable/c/0a3664a1058d4b2b1ea2112cc275ca47fba7fc08"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/11f180a5d62a51b484e9648f9b310e1bd50b1a57"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/27824b2f98818215adc9661e563252c48dab1a13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4357bbb921fe9e81d0fd9f70d669d1f177d8380e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/80be62358fa5507cefbaa067c7e6648401f2c3da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/98f49e693e02c1dafd5786be3468657840dd6f06"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad11b872bc9b5d27e56183c6b01f9218c85395d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce93f1afc05941a572f5a69e2ed4012af905a693"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53140,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:32.920,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: core: Remove the /proc/scsi/${proc_name} directory earlier Remove the /proc/scsi/${proc_name} directory earlier to fix a race condition between unloading and reloading kernel modules. This fixes a bug introduced in 2009 by commit 77c019768f06 (""[SCSI] fix /proc memory leak in the SCSI core""). Fix the following kernel warning: proc_dir_entry 'scsi/scsi_debug' already registered WARNING: CPU: 19 PID: 27986 at fs/proc/generic.c:376 proc_register+0x27d/0x2e0 Call Trace: proc_mkdir+0xb5/0xe0 scsi_proc_hostdir_add+0xb5/0x170 scsi_host_alloc+0x683/0x6c0 sdebug_driver_probe+0x6b/0x2d0 [scsi_debug] really_probe+0x159/0x540 __driver_probe_device+0xdc/0x230 driver_probe_device+0x4f/0x120 __device_attach_driver+0xef/0x180 bus_for_each_drv+0xe5/0x130 __device_attach+0x127/0x290 device_initial_probe+0x17/0x20 bus_probe_device+0x110/0x130 device_add+0x673/0xc80 device_register+0x1e/0x30 sdebug_add_host_helper+0x1a7/0x3b0 [scsi_debug] scsi_debug_init+0x64f/0x1000 [scsi_debug] do_one_initcall+0xd7/0x470 do_init_module+0xe7/0x330 load_module+0x122a/0x12c0 __do_sys_finit_module+0x124/0x1a0 __x64_sys_finit_module+0x46/0x50 do_syscall_64+0x38/0x80 entry_SYSCALL_64_after_hwframe+0x46/0xb0",,,"[{""url"":""https://git.kernel.org/stable/c/13daafe1e209b03e9bda16ff2bd2b2da145a139b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/17e98a5ede81b7696bec421f7afa2dfe467f5e6b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1ec363599f8346d5a8d08c71a0d9860d6c420ec0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6b223e32d66ca9db1f252f433514783d8b22a8e1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/891a3cba425cf483d96facca55aebd6ff1da4338"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e471e928de97b00f297ad1015cc14f9459765713"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc663711b94468f4e1427ebe289c9f05669699c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53141,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:33.023,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ila: do not generate empty messages in ila_xlat_nl_cmd_get_mapping() ila_xlat_nl_cmd_get_mapping() generates an empty skb, triggerring a recent sanity check [1]. Instead, return an error code, so that user space can get it. [1] skb_assert_len WARNING: CPU: 0 PID: 5923 at include/linux/skbuff.h:2527 skb_assert_len include/linux/skbuff.h:2527 [inline] WARNING: CPU: 0 PID: 5923 at include/linux/skbuff.h:2527 __dev_queue_xmit+0x1bc0/0x3488 net/core/dev.c:4156 Modules linked in: CPU: 0 PID: 5923 Comm: syz-executor269 Not tainted 6.2.0-syzkaller-18300-g2ebd1fbb946d #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/21/2023 pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : skb_assert_len include/linux/skbuff.h:2527 [inline] pc : __dev_queue_xmit+0x1bc0/0x3488 net/core/dev.c:4156 lr : skb_assert_len include/linux/skbuff.h:2527 [inline] lr : __dev_queue_xmit+0x1bc0/0x3488 net/core/dev.c:4156 sp : ffff80001e0d6c40 x29: ffff80001e0d6e60 x28: dfff800000000000 x27: ffff0000c86328c0 x26: dfff800000000000 x25: ffff0000c8632990 x24: ffff0000c8632a00 x23: 0000000000000000 x22: 1fffe000190c6542 x21: ffff0000c8632a10 x20: ffff0000c8632a00 x19: ffff80001856e000 x18: ffff80001e0d5fc0 x17: 0000000000000000 x16: ffff80001235d16c x15: 0000000000000000 x14: 0000000000000000 x13: 0000000000000001 x12: 0000000000000001 x11: ff80800008353a30 x10: 0000000000000000 x9 : 21567eaf25bfb600 x8 : 21567eaf25bfb600 x7 : 0000000000000001 x6 : 0000000000000001 x5 : ffff80001e0d6558 x4 : ffff800015c74760 x3 : ffff800008596744 x2 : 0000000000000001 x1 : 0000000100000000 x0 : 000000000000000e Call trace: skb_assert_len include/linux/skbuff.h:2527 [inline] __dev_queue_xmit+0x1bc0/0x3488 net/core/dev.c:4156 dev_queue_xmit include/linux/netdevice.h:3033 [inline] __netlink_deliver_tap_skb net/netlink/af_netlink.c:307 [inline] __netlink_deliver_tap+0x45c/0x6f8 net/netlink/af_netlink.c:325 netlink_deliver_tap+0xf4/0x174 net/netlink/af_netlink.c:338 __netlink_sendskb net/netlink/af_netlink.c:1283 [inline] netlink_sendskb+0x6c/0x154 net/netlink/af_netlink.c:1292 netlink_unicast+0x334/0x8d4 net/netlink/af_netlink.c:1380 nlmsg_unicast include/net/netlink.h:1099 [inline] genlmsg_unicast include/net/genetlink.h:433 [inline] genlmsg_reply include/net/genetlink.h:443 [inline] ila_xlat_nl_cmd_get_mapping+0x620/0x7d0 net/ipv6/ila/ila_xlat.c:493 genl_family_rcv_msg_doit net/netlink/genetlink.c:968 [inline] genl_family_rcv_msg net/netlink/genetlink.c:1048 [inline] genl_rcv_msg+0x938/0xc1c net/netlink/genetlink.c:1065 netlink_rcv_skb+0x214/0x3c4 net/netlink/af_netlink.c:2574 genl_rcv+0x38/0x50 net/netlink/genetlink.c:1076 netlink_unicast_kernel net/netlink/af_netlink.c:1339 [inline] netlink_unicast+0x660/0x8d4 net/netlink/af_netlink.c:1365 netlink_sendmsg+0x800/0xae0 net/netlink/af_netlink.c:1942 sock_sendmsg_nosec net/socket.c:714 [inline] sock_sendmsg net/socket.c:734 [inline] ____sys_sendmsg+0x558/0x844 net/socket.c:2479 ___sys_sendmsg net/socket.c:2533 [inline] __sys_sendmsg+0x26c/0x33c net/socket.c:2562 __do_sys_sendmsg net/socket.c:2571 [inline] __se_sys_sendmsg net/socket.c:2569 [inline] __arm64_sys_sendmsg+0x80/0x94 net/socket.c:2569 __invoke_syscall arch/arm64/kernel/syscall.c:38 [inline] invoke_syscall+0x98/0x2c0 arch/arm64/kernel/syscall.c:52 el0_svc_common+0x138/0x258 arch/arm64/kernel/syscall.c:142 do_el0_svc+0x64/0x198 arch/arm64/kernel/syscall.c:193 el0_svc+0x58/0x168 arch/arm64/kernel/entry-common.c:637 el0t_64_sync_handler+0x84/0xf0 arch/arm64/kernel/entry-common.c:655 el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S:591 irq event stamp: 136484 hardirqs last enabled at (136483): [<ffff800008350244>] __up_console_sem+0x60/0xb4 kernel/printk/printk.c:345 hardirqs last disabled at (136484): [<ffff800012358d60>] el1_dbg+0x24/0x80 arch/arm64/kernel/entry-common.c:405 softirqs last enabled at (136418): [<ffff800008020ea8>] softirq_ha ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/25b54f247ea060aeb85ec88a82c75060fca03521"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/42d9ed4e5dc5f87fbd67c232e2e4a9b88ceeb47f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/60fe7cb483c8c5dcadaeeac867251d6e59c7badc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/693aa2c0d9b6d5b1f2745d31b6e70d09dbbaf06e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/783f218940b3c7b872e4111d0145000f26ecbdf6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/91aceb3844d4aec555c7f423f9fd843eff5835e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b26bc5861505f04dea933ca3e522772b20fa086f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c631e52aea0fc8d4deea06e439f5810a8b40ad0f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53142,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:33.137,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ice: copy last block omitted in ice_get_module_eeprom() ice_get_module_eeprom() is broken since commit e9c9692c8a81 (""ice: Reimplement module reads used by ethtool"") In this refactor, ice_get_module_eeprom() reads the eeprom in blocks of size 8. But the condition that should protect the buffer overflow ignores the last block. The last block always contains zeros. Bug uncovered by ethtool upstream commit 9538f384b535 (""netlink: eeprom: Defer page requests to individual parsers"") After this commit, ethtool reads a block with length = 1; to read the SFF-8024 identifier value. unpatched driver: $ ethtool -m enp65s0f0np0 offset 0x90 length 8 Offset Values ------ ------ 0x0090: 00 00 00 00 00 00 00 00 $ ethtool -m enp65s0f0np0 offset 0x90 length 12 Offset Values ------ ------ 0x0090: 00 00 01 a0 4d 65 6c 6c 00 00 00 00 $ $ ethtool -m enp65s0f0np0 Offset Values ------ ------ 0x0000: 11 06 06 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0060: 00 00 00 00 00 00 00 00 00 00 00 00 00 01 08 00 0x0070: 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 patched driver: $ ethtool -m enp65s0f0np0 offset 0x90 length 8 Offset Values ------ ------ 0x0090: 00 00 01 a0 4d 65 6c 6c $ ethtool -m enp65s0f0np0 offset 0x90 length 12 Offset Values ------ ------ 0x0090: 00 00 01 a0 4d 65 6c 6c 61 6e 6f 78 $ ethtool -m enp65s0f0np0 Identifier : 0x11 (QSFP28) Extended identifier : 0x00 Extended identifier description : 1.5W max. Power consumption Extended identifier description : No CDR in TX, No CDR in RX Extended identifier description : High Power Class (> 3.5 W) not enabled Connector : 0x23 (No separable connector) Transceiver codes : 0x88 0x00 0x00 0x00 0x00 0x00 0x00 0x00 Transceiver type : 40G Ethernet: 40G Base-CR4 Transceiver type : 25G Ethernet: 25G Base-CR CA-N Encoding : 0x05 (64B/66B) BR, Nominal : 25500Mbps Rate identifier : 0x00 Length (SMF,km) : 0km Length (OM3 50um) : 0m Length (OM2 50um) : 0m Length (OM1 62.5um) : 0m Length (Copper or Active cable) : 1m Transmitter technology : 0xa0 (Copper cable unequalized) Attenuation at 2.5GHz : 4db Attenuation at 5.0GHz : 5db Attenuation at 7.0GHz : 7db Attenuation at 12.9GHz : 10db ........ ....",,,"[{""url"":""https://git.kernel.org/stable/c/84cba1840e68430325ac133a11be06bfb2f7acd8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8cfbdda65588e75bfbd93e5ee847efcb4796ad09"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90b40ab29298db3a4879c1d3c4e685184386bce6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c813f7a3161481483ae2077651b21bc217c419e0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53143,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:33.240,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: fix another off-by-one fsmap error on 1k block filesystems Apparently syzbot figured out that issuing this FSMAP call: struct fsmap_head cmd = { .fmh_count = ...; .fmh_keys = { { .fmr_device = /* ext4 dev */, .fmr_physical = 0, }, { .fmr_device = /* ext4 dev */, .fmr_physical = 0, }, }, ... }; ret = ioctl(fd, FS_IOC_GETFSMAP, &cmd); Produces this crash if the underlying filesystem is a 1k-block ext4 filesystem: kernel BUG at fs/ext4/ext4.h:3331! invalid opcode: 0000 [#1] PREEMPT SMP CPU: 3 PID: 3227965 Comm: xfs_io Tainted: G W O 6.2.0-rc8-achx Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.15.0-1 04/01/2014 RIP: 0010:ext4_mb_load_buddy_gfp+0x47c/0x570 [ext4] RSP: 0018:ffffc90007c03998 EFLAGS: 00010246 RAX: ffff888004978000 RBX: ffffc90007c03a20 RCX: ffff888041618000 RDX: 0000000000000000 RSI: 00000000000005a4 RDI: ffffffffa0c99b11 RBP: ffff888012330000 R08: ffffffffa0c2b7d0 R09: 0000000000000400 R10: ffffc90007c03950 R11: 0000000000000000 R12: 0000000000000001 R13: 00000000ffffffff R14: 0000000000000c40 R15: ffff88802678c398 FS: 00007fdf2020c880(0000) GS:ffff88807e100000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007ffd318a5fe8 CR3: 000000007f80f001 CR4: 00000000001706e0 Call Trace: <TASK> ext4_mballoc_query_range+0x4b/0x210 [ext4 dfa189daddffe8fecd3cdfd00564e0f265a8ab80] ext4_getfsmap_datadev+0x713/0x890 [ext4 dfa189daddffe8fecd3cdfd00564e0f265a8ab80] ext4_getfsmap+0x2b7/0x330 [ext4 dfa189daddffe8fecd3cdfd00564e0f265a8ab80] ext4_ioc_getfsmap+0x153/0x2b0 [ext4 dfa189daddffe8fecd3cdfd00564e0f265a8ab80] __ext4_ioctl+0x2a7/0x17e0 [ext4 dfa189daddffe8fecd3cdfd00564e0f265a8ab80] __x64_sys_ioctl+0x82/0xa0 do_syscall_64+0x2b/0x80 entry_SYSCALL_64_after_hwframe+0x46/0xb0 RIP: 0033:0x7fdf20558aff RSP: 002b:00007ffd318a9e30 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 00000000000200c0 RCX: 00007fdf20558aff RDX: 00007fdf1feb2010 RSI: 00000000c0c0583b RDI: 0000000000000003 RBP: 00005625c0634be0 R08: 00005625c0634c40 R09: 0000000000000001 R10: 0000000000000000 R11: 0000000000000246 R12: 00007fdf1feb2010 R13: 00005625be70d994 R14: 0000000000000800 R15: 0000000000000000 For GETFSMAP calls, the caller selects a physical block device by writing its block number into fsmap_head.fmh_keys[01].fmr_device. To query mappings for a subrange of the device, the starting byte of the range is written to fsmap_head.fmh_keys[0].fmr_physical and the last byte of the range goes in fsmap_head.fmh_keys[1].fmr_physical. IOWs, to query what mappings overlap with bytes 3-14 of /dev/sda, you'd set the inputs as follows: fmh_keys[0] = { .fmr_device = major(8, 0), .fmr_physical = 3}, fmh_keys[1] = { .fmr_device = major(8, 0), .fmr_physical = 14}, Which would return you whatever is mapped in the 12 bytes starting at physical offset 3. The crash is due to insufficient range validation of keys[1] in ext4_getfsmap_datadev. On 1k-block filesystems, block 0 is not part of the filesystem, which means that s_first_data_block is nonzero. ext4_get_group_no_and_offset subtracts this quantity from the blocknr argument before cracking it into a group number and a block number within a group. IOWs, block group 0 spans blocks 1-8192 (1-based) instead of 0-8191 (0-based) like what happens with larger blocksizes. The net result of this encoding is that blocknr < s_first_data_block is not a valid input to this function. The end_fsb variable is set from the keys that are copied from userspace, which means that in the above example, its value is zero. That leads to an underflow here: blocknr = blocknr - le32_to_cpu(es->s_first_data_block); The division then operates on -1: offset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >> EXT4_SB(sb)->s_cluster_bits; Leaving an impossibly large group number (2^32-1) in blocknr. ext4_getfsmap_check_keys checked that keys[0 ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/15ebade3266b300da9cd1edce4004fe8fd6a2b88"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1d2366624b4c19a2ba6baf67fe57f4a1b0f67c05"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a70b49dc7eee5dbe3775a650ce598e3557ff5475"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c24f838493792b5e78a3596b4ca96375aa0af4c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c5d7c31e17224d847a330180ec1b03bf390632b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c993799baf9c5861f8df91beb80e1611b12efcbd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb3a695aa71a514f2e7f5778e05faba3733b70a0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f16054ac1774915160ca4e1c73ff7a269465a1b9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53144,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:33.357,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: erofs: fix wrong kunmap when using LZMA on HIGHMEM platforms As the call trace shown, the root cause is kunmap incorrect pages: BUG: kernel NULL pointer dereference, address: 00000000 CPU: 1 PID: 40 Comm: kworker/u5:0 Not tainted 6.2.0-rc5 #4 Workqueue: erofs_worker z_erofs_decompressqueue_work EIP: z_erofs_lzma_decompress+0x34b/0x8ac z_erofs_decompress+0x12/0x14 z_erofs_decompress_queue+0x7e7/0xb1c z_erofs_decompressqueue_work+0x32/0x60 process_one_work+0x24b/0x4d8 ? process_one_work+0x1a4/0x4d8 worker_thread+0x14c/0x3fc kthread+0xe6/0x10c ? rescuer_thread+0x358/0x358 ? kthread_complete_and_exit+0x18/0x18 ret_from_fork+0x1c/0x28 ---[ end trace 0000000000000000 ]--- The bug is trivial and should be fixed now. It has no impact on !HIGHMEM platforms.",,,"[{""url"":""https://git.kernel.org/stable/c/28aea8ae6cf212a5bf3ed962b27921e2029ad754"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8f121dfb15f7b4ab345992ce96003eb63fd608f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa4056781ac067b5946c6811459e1a36842047fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53145,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-10T15:15:58.587,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: btsdio: fix use after free bug in btsdio_remove due to race condition In btsdio_probe, the data->work is bound with btsdio_work. It will be started in btsdio_send_frame. If the btsdio_remove runs with a unfinished work, there may be a race condition that hdev is freed but used in btsdio_work. Fix it by canceling the work before do cleanup in btsdio_remove.",,,"[{""url"":""https://git.kernel.org/stable/c/179c65828593aff1f444e15debd40a477cb23cf4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3efcbf25e5ab4d4ad1b7e6ba0869ff85540e3f6e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c3653627397a0d6eab19b20a59423e118985a6b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73f7b171b7c09139eb3c6a5677c200dc1be5f318"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/746b363bef41cc159c051c47f9e30800bc6b520d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a5c2a467e9e789ae0891de55b766daac52e3b7b3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6650d27ab2c12a8ee750f396edb5ac8b4558b2e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53146,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-14T13:15:47.083,2025-05-16T14:43:56.797,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: dw2102: Fix null-ptr-deref in dw2102_i2c_transfer() In dw2102_i2c_transfer, msg is controlled by user. When msg[i].buf is null and msg[i].len is zero, former checks on msg[i].buf would be passed. Malicious data finally reach dw2102_i2c_transfer. If accessing msg[i].buf[0] without sanity check, null ptr deref would happen. We add check on msg[i].len to prevent crash. Similar commit: commit 950e252cb469 (""[media] dw2102: limit messages to buffer size"")",,,"[{""url"":""https://git.kernel.org/stable/c/08dfcbd03b2b7f918c4f87c6ff637054e510df74"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5ae544d94abc8ff77b1b9bf8774def3fa5689b5b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/77cbd42d29de9ffc93d5529bab8813cde53af14c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/903566208ae6bb9c0e7e54355ce75bf6cf72485d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/97fdbdb750342cbc204befde976872fedb406ee6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/beb9550494e7349f92b9eaa283256a5ad9b1c9be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ecbe6d011b95c7da59f014f8d26cb7245ed1e11e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fb28afab113a82b89ffec48c8155ec05b4f8cb5e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53154,cve@mitre.org,2025-05-23T16:15:22.080,2025-06-16T18:21:16.333,Analyzed,[],"parse_string in cJSON before 1.7.18 has a heap-based buffer over-read via {""1"":1, with no trailing newline if cJSON_ParseWithLength is called.","[{""source"":""cve@mitre.org"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-125""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:cjson_project:cjson:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""1.7.18"",""matchCriteriaId"":""DB89DBA4-DAFF-437E-B8C7-D9096DDD5D95""}]}]}]","[{""url"":""https://github.com/DaveGamble/cJSON/compare/v1.7.17...v1.7.18"",""source"":""cve@mitre.org"",""tags"":[""Release Notes""]},{""url"":""https://github.com/DaveGamble/cJSON/issues/800"",""source"":""cve@mitre.org"",""tags"":[""Exploit"",""Issue Tracking"",""Vendor Advisory""]},{""url"":""https://github.com/DaveGamble/cJSON/issues/800"",""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""tags"":[""Exploit"",""Issue Tracking"",""Vendor Advisory""]}]","[{""source"":""cve@mitre.org"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L"",""baseScore"":2.9,""baseSeverity"":""LOW"",""attackVector"":""LOCAL"",""attackComplexity"":""HIGH"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""LOW""},""exploitabilityScore"":1.4,""impactScore"":1.4},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53155,cve@mitre.org,2025-07-25T17:15:29.353,2025-07-29T14:14:55.157,Awaiting Analysis,[],goform/formTest in EmbedThis GoAhead 2.5 allows HTML injection via the name parameter.,"[{""source"":""cve@mitre.org"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-79""}]}]",,"[{""url"":""https://www.exploit-db.com/exploits/51762"",""source"":""cve@mitre.org""}]","[{""source"":""cve@mitre.org"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:L/A:N"",""baseScore"":7.2,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""CHANGED"",""confidentialityImpact"":""LOW"",""integrityImpact"":""LOW"",""availabilityImpact"":""NONE""},""exploitabilityScore"":3.9,""impactScore"":2.7}]",,,,,,,,
CVE-2023-53156,cve@mitre.org,2025-07-27T21:15:25.687,2025-08-07T15:08:46.397,Analyzed,[],The transpose crate before 0.2.3 for Rust allows an integer overflow via input_width and input_height arguments.,"[{""source"":""cve@mitre.org"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-190""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:ejmahler:transpose:*:*:*:*:*:rust:*:*"",""versionStartIncluding"":""0.1.0"",""versionEndExcluding"":""0.2.3"",""matchCriteriaId"":""DFD2347F-2C84-44C7-8E54-44EB7317FCAE""}]}]}]","[{""url"":""https://crates.io/crates/transpose"",""source"":""cve@mitre.org"",""tags"":[""Product""]},{""url"":""https://github.com/advisories/GHSA-5gmm-6m36-r7jh"",""source"":""cve@mitre.org"",""tags"":[""Third Party Advisory""]},{""url"":""https://github.com/ejmahler/transpose/issues/11"",""source"":""cve@mitre.org"",""tags"":[""Issue Tracking""]},{""url"":""https://rustsec.org/advisories/RUSTSEC-2023-0080.html"",""source"":""cve@mitre.org"",""tags"":[""Third Party Advisory""]}]","[{""source"":""cve@mitre.org"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:C/C:N/I:L/A:L"",""baseScore"":4.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""HIGH"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""CHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""LOW"",""availabilityImpact"":""LOW""},""exploitabilityScore"":1.4,""impactScore"":2.7},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N"",""baseScore"":5.3,""baseSeverity"":""MEDIUM"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""LOW"",""availabilityImpact"":""NONE""},""exploitabilityScore"":3.9,""impactScore"":1.4}]",,,,,,,,
CVE-2023-53157,cve@mitre.org,2025-07-28T00:15:25.253,2025-08-07T15:21:17.903,Analyzed,[],The rosenpass crate before 0.2.1 for Rust allows remote attackers to cause a denial of service (panic) via a one-byte UDP packet.,"[{""source"":""cve@mitre.org"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-130""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:rosenpass:rosenpass:*:*:*:*:*:rust:*:*"",""versionEndExcluding"":""0.2.1"",""matchCriteriaId"":""8A618F79-D271-4D71-B90E-9AAEAEC8838E""}]}]}]","[{""url"":""https://crates.io/crates/rosenpass"",""source"":""cve@mitre.org"",""tags"":[""Product""]},{""url"":""https://github.com/advisories/GHSA-6ggr-cwv4-g7qg"",""source"":""cve@mitre.org"",""tags"":[""Third Party Advisory""]},{""url"":""https://github.com/rosenpass/rosenpass/commit/93439858d1c44294a7b377f775c4fc897a370bb2"",""source"":""cve@mitre.org"",""tags"":[""Patch""]},{""url"":""https://rustsec.org/advisories/RUSTSEC-2023-0077.html"",""source"":""cve@mitre.org"",""tags"":[""Third Party Advisory""]}]","[{""source"":""cve@mitre.org"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L"",""baseScore"":5.3,""baseSeverity"":""MEDIUM"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""LOW""},""exploitabilityScore"":3.9,""impactScore"":1.4},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":7.5,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":3.9,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53158,cve@mitre.org,2025-07-28T01:15:24.837,2025-07-29T14:14:29.590,Awaiting Analysis,[],"The gix-transport crate before 0.36.1 for Rust allows command execution via the ""gix clone 'ssh://-oProxyCommand=open$IFS"" substring. NOTE: this was discovered before CVE-2024-32884, a similar vulnerability (involving a username field) that is more difficult to exploit.","[{""source"":""cve@mitre.org"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-78""}]}]",,"[{""url"":""https://crates.io/crates/gix-transport"",""source"":""cve@mitre.org""},{""url"":""https://github.com/GitoxideLabs/gitoxide/pull/1032"",""source"":""cve@mitre.org""},{""url"":""https://github.com/advisories/GHSA-rrjw-j4m2-mf34"",""source"":""cve@mitre.org""},{""url"":""https://rustsec.org/advisories/RUSTSEC-2023-0064.html"",""source"":""cve@mitre.org""}]","[{""source"":""cve@mitre.org"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:C/C:L/I:L/A:N"",""baseScore"":4.1,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""HIGH"",""privilegesRequired"":""NONE"",""userInteraction"":""REQUIRED"",""scope"":""CHANGED"",""confidentialityImpact"":""LOW"",""integrityImpact"":""LOW"",""availabilityImpact"":""NONE""},""exploitabilityScore"":1.0,""impactScore"":2.7}]",,,,,,,,
CVE-2023-53159,cve@mitre.org,2025-07-28T03:15:23.193,2025-08-07T15:30:41.580,Analyzed,[],The openssl crate before 0.10.55 for Rust allows an out-of-bounds read via an empty string to X509VerifyParamRef::set_host.,"[{""source"":""cve@mitre.org"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-126""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:sfackler:openssl:*:*:*:*:*:rust:*:*"",""versionEndExcluding"":""0.10.55"",""matchCriteriaId"":""57EF18B7-20B6-4EA8-BE0D-732910E67318""}]}]}]","[{""url"":""https://crates.io/crates/openssl"",""source"":""cve@mitre.org"",""tags"":[""Product""]},{""url"":""https://github.com/sfackler/rust-openssl/issues/1965"",""source"":""cve@mitre.org"",""tags"":[""Exploit"",""Patch""]},{""url"":""https://rustsec.org/advisories/RUSTSEC-2023-0044.html"",""source"":""cve@mitre.org"",""tags"":[""Third Party Advisory""]}]","[{""source"":""cve@mitre.org"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:C/C:L/I:N/A:L"",""baseScore"":4.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""HIGH"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""CHANGED"",""confidentialityImpact"":""LOW"",""integrityImpact"":""NONE"",""availabilityImpact"":""LOW""},""exploitabilityScore"":1.4,""impactScore"":2.7},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H"",""baseScore"":9.1,""baseSeverity"":""CRITICAL"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":3.9,""impactScore"":5.2}]",,,,,,,,
CVE-2023-53160,cve@mitre.org,2025-07-28T03:15:23.373,2025-08-06T21:15:47.147,Analyzed,[],The sequoia-openpgp crate before 1.16.0 for Rust allows out-of-bounds array access and a panic.,"[{""source"":""cve@mitre.org"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-125""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:sequoia-pgp:sequoia-openpgp:*:*:*:*:*:rust:*:*"",""versionEndExcluding"":""1.1.1"",""matchCriteriaId"":""899EAF37-6EF6-49B0-AE10-38533DABC70C""},{""vulnerable"":true,""criteria"":""cpe:2.3:a:sequoia-pgp:sequoia-openpgp:*:*:*:*:*:rust:*:*"",""versionStartIncluding"":""1.2.0"",""versionEndExcluding"":""1.8.1"",""matchCriteriaId"":""AD15C962-C5C6-4FBF-BE9F-635A85B4617B""},{""vulnerable"":true,""criteria"":""cpe:2.3:a:sequoia-pgp:sequoia-openpgp:*:*:*:*:*:rust:*:*"",""versionStartIncluding"":""1.9.0"",""versionEndExcluding"":""1.16.0"",""matchCriteriaId"":""669DC8B7-70D0-462F-9FA7-3DFACD9B7D3D""}]}]}]","[{""url"":""https://crates.io/crates/sequoia-openpgp"",""source"":""cve@mitre.org"",""tags"":[""Product""]},{""url"":""https://github.com/advisories/GHSA-25mx-8f3v-8wh7"",""source"":""cve@mitre.org"",""tags"":[""Third Party Advisory""]},{""url"":""https://lists.sequoia-pgp.org/hyperkitty/list/announce@lists.sequoia-pgp.org/thread/SN2E3QRT4DMQ5JNEK6VIN6DJ5SH766DI/"",""source"":""cve@mitre.org"",""tags"":[""Patch""]},{""url"":""https://rustsec.org/advisories/RUSTSEC-2023-0038.html"",""source"":""cve@mitre.org"",""tags"":[""Third Party Advisory""]}]","[{""source"":""cve@mitre.org"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L"",""baseScore"":2.9,""baseSeverity"":""LOW"",""attackVector"":""LOCAL"",""attackComplexity"":""HIGH"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""LOW""},""exploitabilityScore"":1.4,""impactScore"":1.4},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L"",""baseScore"":5.3,""baseSeverity"":""MEDIUM"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""LOW""},""exploitabilityScore"":3.9,""impactScore"":1.4}]",,,,,,,,
CVE-2023-53161,cve@mitre.org,2025-07-28T03:15:23.557,2025-08-06T21:16:58.247,Analyzed,[],The buffered-reader crate before 1.1.5 for Rust allows out-of-bounds array access and a panic.,"[{""source"":""cve@mitre.org"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-125""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:sequoia-pgp:buffered-reader:*:*:*:*:*:rust:*:*"",""versionEndExcluding"":""1.0.2"",""matchCriteriaId"":""99CAB7B8-E8C3-42A6-96AA-49B4218193C1""},{""vulnerable"":true,""criteria"":""cpe:2.3:a:sequoia-pgp:buffered-reader:*:*:*:*:*:rust:*:*"",""versionStartIncluding"":""1.1.0"",""versionEndExcluding"":""1.1.5"",""matchCriteriaId"":""82601D7A-1269-4BCC-A503-6D1F17906FCA""}]}]}]","[{""url"":""https://crates.io/crates/buffered-reader"",""source"":""cve@mitre.org"",""tags"":[""Product""]},{""url"":""https://github.com/advisories/GHSA-29mf-62xx-28jq"",""source"":""cve@mitre.org"",""tags"":[""Third Party Advisory""]},{""url"":""https://gitlab.com/sequoia-pgp/sequoia/-/tags/buffered-reader%2Fv1.0.2"",""source"":""cve@mitre.org"",""tags"":[""Release Notes""]},{""url"":""https://gitlab.com/sequoia-pgp/sequoia/-/tags/buffered-reader%2Fv1.1.5"",""source"":""cve@mitre.org"",""tags"":[""Release Notes""]},{""url"":""https://lists.sequoia-pgp.org/hyperkitty/list/announce@lists.sequoia-pgp.org/thread/SN2E3QRT4DMQ5JNEK6VIN6DJ5SH766DI/"",""source"":""cve@mitre.org"",""tags"":[""Patch""]},{""url"":""https://rustsec.org/advisories/RUSTSEC-2023-0039.html"",""source"":""cve@mitre.org"",""tags"":[""Third Party Advisory""]}]","[{""source"":""cve@mitre.org"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L"",""baseScore"":2.9,""baseSeverity"":""LOW"",""attackVector"":""LOCAL"",""attackComplexity"":""HIGH"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""LOW""},""exploitabilityScore"":1.4,""impactScore"":1.4},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L"",""baseScore"":5.3,""baseSeverity"":""MEDIUM"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""LOW""},""exploitabilityScore"":3.9,""impactScore"":1.4}]",,,,,,,,
