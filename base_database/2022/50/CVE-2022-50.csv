id,sourceidentifier,published,lastmodified,vulnstatus,cvetags,descriptions,weaknesses,configurations,references,metrics_cvssmetricv31,metrics_cvssmetricv2,cisaexploitadd,cisaactiondue,cisarequiredaction,cisavulnerabilityname,metrics_cvssmetricv30,metrics_cvssmetricv40,evaluatorcomment
CVE-2022-50000,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:27.817,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: flowtable: fix stuck flows on cleanup due to pending work To clear the flow table on flow table free, the following sequence normally happens in order: 1) gc_step work is stopped to disable any further stats/del requests. 2) All flow table entries are set to teardown state. 3) Run gc_step which will queue HW del work for each flow table entry. 4) Waiting for the above del work to finish (flush). 5) Run gc_step again, deleting all entries from the flow table. 6) Flow table is freed. But if a flow table entry already has pending HW stats or HW add work step 3 will not queue HW del work (it will be skipped), step 4 will wait for the pending add/stats to finish, and step 5 will queue HW del work which might execute after freeing of the flow table. To fix the above, this patch flushes the pending work, then it sets the teardown flag to all flows in the flowtable and it forces a garbage collector run to queue work to remove the flows from hardware, then it flushes this new pending work and (finally) it forces another garbage collector run to remove the entry from the software flowtable. Stack trace: [47773.882335] BUG: KASAN: use-after-free in down_read+0x99/0x460 [47773.883634] Write of size 8 at addr ffff888103b45aa8 by task kworker/u20:6/543704 [47773.885634] CPU: 3 PID: 543704 Comm: kworker/u20:6 Not tainted 5.12.0-rc7+ #2 [47773.886745] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009) [47773.888438] Workqueue: nf_ft_offload_del flow_offload_work_handler [nf_flow_table] [47773.889727] Call Trace: [47773.890214] dump_stack+0xbb/0x107 [47773.890818] print_address_description.constprop.0+0x18/0x140 [47773.892990] kasan_report.cold+0x7c/0xd8 [47773.894459] kasan_check_range+0x145/0x1a0 [47773.895174] down_read+0x99/0x460 [47773.899706] nf_flow_offload_tuple+0x24f/0x3c0 [nf_flow_table] [47773.907137] flow_offload_work_handler+0x72d/0xbe0 [nf_flow_table] [47773.913372] process_one_work+0x8ac/0x14e0 [47773.921325] [47773.921325] Allocated by task 592159: [47773.922031] kasan_save_stack+0x1b/0x40 [47773.922730] __kasan_kmalloc+0x7a/0x90 [47773.923411] tcf_ct_flow_table_get+0x3cb/0x1230 [act_ct] [47773.924363] tcf_ct_init+0x71c/0x1156 [act_ct] [47773.925207] tcf_action_init_1+0x45b/0x700 [47773.925987] tcf_action_init+0x453/0x6b0 [47773.926692] tcf_exts_validate+0x3d0/0x600 [47773.927419] fl_change+0x757/0x4a51 [cls_flower] [47773.928227] tc_new_tfilter+0x89a/0x2070 [47773.936652] [47773.936652] Freed by task 543704: [47773.937303] kasan_save_stack+0x1b/0x40 [47773.938039] kasan_set_track+0x1c/0x30 [47773.938731] kasan_set_free_info+0x20/0x30 [47773.939467] __kasan_slab_free+0xe7/0x120 [47773.940194] slab_free_freelist_hook+0x86/0x190 [47773.941038] kfree+0xce/0x3a0 [47773.941644] tcf_ct_flow_table_cleanup_work Original patch description and stack trace by Paul Blakey.",,,"[{""url"":""https://git.kernel.org/stable/c/89e135a36a9eb81412b5459df94a80995ce62eef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8fbdec08dbf7d7ab8e35bdc65eb4394bc82d1e26"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9afb4b27349a499483ae0134282cefd0c90f480f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50001,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:27.950,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: nft_tproxy: restrict to prerouting hook TPROXY is only allowed from prerouting, but nft_tproxy doesn't check this. This fixes a crash (null dereference) when using tproxy from e.g. output.",,,"[{""url"":""https://git.kernel.org/stable/c/0b21edf4cc13516716848e0a4fdf726aa2a62cd9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/18bbc3213383a82b05383827f4b1b882e3f0a5a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/343fed6b0daeb528ae5c9d4d84d9ff763ac95619"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/83ef55c4281f1b4c6bd4457c2e96ccd1c9e80200"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9a1d92cbeac3335fee99fa865b8c5b0f2e71a8f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eaba3f9b672c3a3f820da8ee9584b9520674eafa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50002,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:28.063,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/mlx5: LAG, fix logic over MLX5_LAG_FLAG_NDEVS_READY Only set MLX5_LAG_FLAG_NDEVS_READY if both netdevices are registered. Doing so guarantees that both ldev->pf[MLX5_LAG_P0].dev and ldev->pf[MLX5_LAG_P1].dev have valid pointers when MLX5_LAG_FLAG_NDEVS_READY is set. The core issue is asymmetry in setting MLX5_LAG_FLAG_NDEVS_READY and clearing it. Setting it is done wrongly when both ldev->pf[MLX5_LAG_P0].dev and ldev->pf[MLX5_LAG_P1].dev are set; clearing it is done right when either of ldev->pf[i].netdev is cleared. Consider the following scenario: 1. PF0 loads and sets ldev->pf[MLX5_LAG_P0].dev to a valid pointer 2. PF1 loads and sets both ldev->pf[MLX5_LAG_P1].dev and ldev->pf[MLX5_LAG_P1].netdev with valid pointers. This results in MLX5_LAG_FLAG_NDEVS_READY is set. 3. PF0 is unloaded before setting dev->pf[MLX5_LAG_P0].netdev. MLX5_LAG_FLAG_NDEVS_READY remains set. Further execution of mlx5_do_bond() will result in null pointer dereference when calling mlx5_lag_is_multipath() This patch fixes the following call trace actually encountered: [ 1293.475195] BUG: kernel NULL pointer dereference, address: 00000000000009a8 [ 1293.478756] #PF: supervisor read access in kernel mode [ 1293.481320] #PF: error_code(0x0000) - not-present page [ 1293.483686] PGD 0 P4D 0 [ 1293.484434] Oops: 0000 [#1] SMP PTI [ 1293.485377] CPU: 1 PID: 23690 Comm: kworker/u16:2 Not tainted 5.18.0-rc5_for_upstream_min_debug_2022_05_05_10_13 #1 [ 1293.488039] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 [ 1293.490836] Workqueue: mlx5_lag mlx5_do_bond_work [mlx5_core] [ 1293.492448] RIP: 0010:mlx5_lag_is_multipath+0x5/0x50 [mlx5_core] [ 1293.494044] Code: e8 70 40 ff e0 48 8b 14 24 48 83 05 5c 1a 1b 00 01 e9 19 ff ff ff 48 83 05 47 1a 1b 00 01 eb d7 0f 1f 44 00 00 0f 1f 44 00 00 <48> 8b 87 a8 09 00 00 48 85 c0 74 26 48 83 05 a7 1b 1b 00 01 41 b8 [ 1293.498673] RSP: 0018:ffff88811b2fbe40 EFLAGS: 00010202 [ 1293.500152] RAX: ffff88818a94e1c0 RBX: ffff888165eca6c0 RCX: 0000000000000000 [ 1293.501841] RDX: 0000000000000001 RSI: ffff88818a94e1c0 RDI: 0000000000000000 [ 1293.503585] RBP: 0000000000000000 R08: ffff888119886740 R09: ffff888165eca73c [ 1293.505286] R10: 0000000000000018 R11: 0000000000000018 R12: ffff88818a94e1c0 [ 1293.506979] R13: ffff888112729800 R14: 0000000000000000 R15: ffff888112729858 [ 1293.508753] FS: 0000000000000000(0000) GS:ffff88852cc40000(0000) knlGS:0000000000000000 [ 1293.510782] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 1293.512265] CR2: 00000000000009a8 CR3: 00000001032d4002 CR4: 0000000000370ea0 [ 1293.514001] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 1293.515806] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400",,,"[{""url"":""https://git.kernel.org/stable/c/4c040acf5744e87a7b3490f9ec8bedd0d15c9f29"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6e675a66175869b7d87c0e1dd0ddf93e04f8098"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50003,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:28.173,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ice: xsk: prohibit usage of non-balanced queue id Fix the following scenario: 1. ethtool -L $IFACE rx 8 tx 96 2. xdpsock -q 10 -t -z Above refers to a case where user would like to attach XSK socket in txonly mode at a queue id that does not have a corresponding Rx queue. At this moment ice's XSK logic is tightly bound to act on a ""queue pair"", e.g. both Tx and Rx queues at a given queue id are disabled/enabled and both of them will get XSK pool assigned, which is broken for the presented queue configuration. This results in the splat included at the bottom, which is basically an OOB access to Rx ring array. To fix this, allow using the ids only in scope of ""combined"" queues reported by ethtool. However, logic should be rewritten to allow such configurations later on, which would end up as a complete rewrite of the control path, so let us go with this temporary fix. [420160.558008] BUG: kernel NULL pointer dereference, address: 0000000000000082 [420160.566359] #PF: supervisor read access in kernel mode [420160.572657] #PF: error_code(0x0000) - not-present page [420160.579002] PGD 0 P4D 0 [420160.582756] Oops: 0000 [#1] PREEMPT SMP NOPTI [420160.588396] CPU: 10 PID: 21232 Comm: xdpsock Tainted: G OE 5.19.0-rc7+ #10 [420160.597893] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0008.031920191559 03/19/2019 [420160.609894] RIP: 0010:ice_xsk_pool_setup+0x44/0x7d0 [ice] [420160.616968] Code: f3 48 83 ec 40 48 8b 4f 20 48 8b 3f 65 48 8b 04 25 28 00 00 00 48 89 44 24 38 31 c0 48 8d 04 ed 00 00 00 00 48 01 c1 48 8b 11 <0f> b7 92 82 00 00 00 48 85 d2 0f 84 2d 75 00 00 48 8d 72 ff 48 85 [420160.639421] RSP: 0018:ffffc9002d2afd48 EFLAGS: 00010282 [420160.646650] RAX: 0000000000000050 RBX: ffff88811d8bdd00 RCX: ffff888112c14ff8 [420160.655893] RDX: 0000000000000000 RSI: ffff88811d8bdd00 RDI: ffff888109861000 [420160.665166] RBP: 000000000000000a R08: 000000000000000a R09: 0000000000000000 [420160.674493] R10: 000000000000889f R11: 0000000000000000 R12: 000000000000000a [420160.683833] R13: 000000000000000a R14: 0000000000000000 R15: ffff888117611828 [420160.693211] FS: 00007fa869fc1f80(0000) GS:ffff8897e0880000(0000) knlGS:0000000000000000 [420160.703645] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [420160.711783] CR2: 0000000000000082 CR3: 00000001d076c001 CR4: 00000000007706e0 [420160.721399] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [420160.731045] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [420160.740707] PKRU: 55555554 [420160.745960] Call Trace: [420160.750962] <TASK> [420160.755597] ? kmalloc_large_node+0x79/0x90 [420160.762703] ? __kmalloc_node+0x3f5/0x4b0 [420160.769341] xp_assign_dev+0xfd/0x210 [420160.775661] ? shmem_file_read_iter+0x29a/0x420 [420160.782896] xsk_bind+0x152/0x490 [420160.788943] __sys_bind+0xd0/0x100 [420160.795097] ? exit_to_user_mode_prepare+0x20/0x120 [420160.802801] __x64_sys_bind+0x16/0x20 [420160.809298] do_syscall_64+0x38/0x90 [420160.815741] entry_SYSCALL_64_after_hwframe+0x63/0xcd [420160.823731] RIP: 0033:0x7fa86a0dd2fb [420160.830264] Code: c3 66 0f 1f 44 00 00 48 8b 15 69 8b 0c 00 f7 d8 64 89 02 b8 ff ff ff ff eb bc 0f 1f 44 00 00 f3 0f 1e fa b8 31 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 3d 8b 0c 00 f7 d8 64 89 01 48 [420160.855410] RSP: 002b:00007ffc1146f618 EFLAGS: 00000246 ORIG_RAX: 0000000000000031 [420160.866366] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fa86a0dd2fb [420160.876957] RDX: 0000000000000010 RSI: 00007ffc1146f680 RDI: 0000000000000003 [420160.887604] RBP: 000055d7113a0520 R08: 00007fa868fb8000 R09: 0000000080000000 [420160.898293] R10: 0000000000008001 R11: 0000000000000246 R12: 000055d7113a04e0 [420160.909038] R13: 000055d7113a0320 R14: 000000000000000a R15: 0000000000000000 [420160.919817] </TASK> [420160.925659] Modules linked in: ice(OE) af_packet binfmt_misc ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/03a3f29fe5b1751ad9b5c892c894183e75a6e4c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1bfdcde723d8ceb2d73291b0415767e7c1cc1d8a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a42f112d367bb4700a8a41f5c12724fde6bfbb9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe76b3e674665ea4059337f8f66d20cdfb0168eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50004,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:28.287,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: xfrm: policy: fix metadata dst->dev xmit null pointer dereference When we try to transmit an skb with metadata_dst attached (i.e. dst->dev == NULL) through xfrm interface we can hit a null pointer dereference[1] in xfrmi_xmit2() -> xfrm_lookup_with_ifid() due to the check for a loopback skb device when there's no policy which dereferences dst->dev unconditionally. Not having dst->dev can be interepreted as it not being a loopback device, so just add a check for a null dst_orig->dev. With this fix xfrm interface's Tx error counters go up as usual. [1] net-next calltrace captured via netconsole: BUG: kernel NULL pointer dereference, address: 00000000000000c0 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 0 P4D 0 Oops: 0000 [#1] PREEMPT SMP CPU: 1 PID: 7231 Comm: ping Kdump: loaded Not tainted 5.19.0+ #24 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.0-1.fc36 04/01/2014 RIP: 0010:xfrm_lookup_with_ifid+0x5eb/0xa60 Code: 8d 74 24 38 e8 26 a4 37 00 48 89 c1 e9 12 fc ff ff 49 63 ed 41 83 fd be 0f 85 be 01 00 00 41 be ff ff ff ff 45 31 ed 48 8b 03 <f6> 80 c0 00 00 00 08 75 0f 41 80 bc 24 19 0d 00 00 01 0f 84 1e 02 RSP: 0018:ffffb0db82c679f0 EFLAGS: 00010246 RAX: 0000000000000000 RBX: ffffd0db7fcad430 RCX: ffffb0db82c67a10 RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffb0db82c67a80 RBP: ffffb0db82c67a80 R08: ffffb0db82c67a14 R09: 0000000000000000 R10: 0000000000000000 R11: ffff8fa449667dc8 R12: ffffffff966db880 R13: 0000000000000000 R14: 00000000ffffffff R15: 0000000000000000 FS: 00007ff35c83f000(0000) GS:ffff8fa478480000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00000000000000c0 CR3: 000000001ebb7000 CR4: 0000000000350ee0 Call Trace: <TASK> xfrmi_xmit+0xde/0x460 ? tcf_bpf_act+0x13d/0x2a0 dev_hard_start_xmit+0x72/0x1e0 __dev_queue_xmit+0x251/0xd30 ip_finish_output2+0x140/0x550 ip_push_pending_frames+0x56/0x80 raw_sendmsg+0x663/0x10a0 ? try_charge_memcg+0x3fd/0x7a0 ? __mod_memcg_lruvec_state+0x93/0x110 ? sock_sendmsg+0x30/0x40 sock_sendmsg+0x30/0x40 __sys_sendto+0xeb/0x130 ? handle_mm_fault+0xae/0x280 ? do_user_addr_fault+0x1e7/0x680 ? kvm_read_and_reset_apf_flags+0x3b/0x50 __x64_sys_sendto+0x20/0x30 do_syscall_64+0x34/0x80 entry_SYSCALL_64_after_hwframe+0x46/0xb0 RIP: 0033:0x7ff35cac1366 Code: eb 0b 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b8 0f 1f 00 41 89 ca 64 8b 04 25 18 00 00 00 85 c0 75 11 b8 2c 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 72 c3 90 55 48 83 ec 30 44 89 4c 24 2c 4c 89 RSP: 002b:00007fff738e4028 EFLAGS: 00000246 ORIG_RAX: 000000000000002c RAX: ffffffffffffffda RBX: 00007fff738e57b0 RCX: 00007ff35cac1366 RDX: 0000000000000040 RSI: 0000557164e4b450 RDI: 0000000000000003 RBP: 0000557164e4b450 R08: 00007fff738e7a2c R09: 0000000000000010 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000040 R13: 00007fff738e5770 R14: 00007fff738e4030 R15: 0000001d00000001 </TASK> Modules linked in: netconsole veth br_netfilter bridge bonding virtio_net [last unloaded: netconsole] CR2: 00000000000000c0",,,"[{""url"":""https://git.kernel.org/stable/c/17ecd4a4db4783392edd4944f5e8268205083f70"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2761612bcde9776dd93ce60ce55ef0b7c7329153"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/96f2758a6d028d1ac08616de9c3c7ff2a122ecf1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e26d676c1f9f335510780b566a10475c47ce03d0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50005,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:28.397,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nfc: pn533: Fix use-after-free bugs caused by pn532_cmd_timeout When the pn532 uart device is detaching, the pn532_uart_remove() is called. But there are no functions in pn532_uart_remove() that could delete the cmd_timeout timer, which will cause use-after-free bugs. The process is shown below: (thread 1) | (thread 2) | pn532_uart_send_frame pn532_uart_remove | mod_timer(&pn532->cmd_timeout,...) ... | (wait a time) kfree(pn532) //FREE | pn532_cmd_timeout | pn532_uart_send_frame | pn532->... //USE This patch adds del_timer_sync() in pn532_uart_remove() in order to prevent the use-after-free bugs. What's more, the pn53x_unregister_nfc() is well synchronized, it sets nfc_dev->shutting_down to true and there are no syscalls could restart the cmd_timeout timer.",,,"[{""url"":""https://git.kernel.org/stable/c/2c71f5d55a86fd5969428abf525c1ae6b1c7b0f5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/50403ee6daddf0d7a14e9d3b51a377c39a08ec8c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9c34c33893db7a80d0e4b55c23d3b65e29609cfb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1e941dbf80a9b8bab0bffbc4cbe41cc7f4c6fb6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50006,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:28.503,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: NFSv4.2 fix problems with __nfs42_ssc_open A destination server while doing a COPY shouldn't accept using the passed in filehandle if its not a regular filehandle. If alloc_file_pseudo() has failed, we need to decrement a reference on the newly created inode, otherwise it leaks.",,,"[{""url"":""https://git.kernel.org/stable/c/5626f95356111602ad26fc05445a4d1f818a0992"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e49ea099850feadcbf33c74b4f514a3e8049b91"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c2a47f6903e270c308c40ad4a23c17b30a54373c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fcfc8be1e9cf2f12b50dce8b579b3ae54443a014"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50007,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:28.617,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: xfrm: fix refcount leak in __xfrm_policy_check() The issue happens on an error path in __xfrm_policy_check(). When the fetching process of the object `pols[1]` fails, the function simply returns 0, forgetting to decrement the reference count of `pols[0]`, which is incremented earlier by either xfrm_sk_policy_lookup() or xfrm_policy_lookup(). This may result in memory leaks. Fix it by decreasing the reference count of `pols[0]` in that path.",,,"[{""url"":""https://git.kernel.org/stable/c/0769491a8acd3e85ca4c3f65080eac2c824262df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1305d7d4f35ca6f214a2d23b075aa6a924cff3be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/18e6b6e2555c93f5ca09f2b85ef1fa025c8accea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/26ad2398fe4984f4f6f930bcb3bc9047fa77265b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/63da7a2bbf3f28094920e0b8a17d2571a9bd842d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8f94b933103ee1bda119543369cc18a1be5536db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9c9cb23e00ddf45679b21b4dacc11d1ae7961ebe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d66c052879791313f90c0584420f196a038fb8b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50008,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:28.737,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: kprobes: don't call disarm_kprobe() for disabled kprobes The assumption in __disable_kprobe() is wrong, and it could try to disarm an already disarmed kprobe and fire the WARN_ONCE() below. [0] We can easily reproduce this issue. 1. Write 0 to /sys/kernel/debug/kprobes/enabled. # echo 0 > /sys/kernel/debug/kprobes/enabled 2. Run execsnoop. At this time, one kprobe is disabled. # /usr/share/bcc/tools/execsnoop & [1] 2460 PCOMM PID PPID RET ARGS # cat /sys/kernel/debug/kprobes/list ffffffff91345650 r __x64_sys_execve+0x0 [FTRACE] ffffffff91345650 k __x64_sys_execve+0x0 [DISABLED][FTRACE] 3. Write 1 to /sys/kernel/debug/kprobes/enabled, which changes kprobes_all_disarmed to false but does not arm the disabled kprobe. # echo 1 > /sys/kernel/debug/kprobes/enabled # cat /sys/kernel/debug/kprobes/list ffffffff91345650 r __x64_sys_execve+0x0 [FTRACE] ffffffff91345650 k __x64_sys_execve+0x0 [DISABLED][FTRACE] 4. Kill execsnoop, when __disable_kprobe() calls disarm_kprobe() for the disabled kprobe and hits the WARN_ONCE() in __disarm_kprobe_ftrace(). # fg /usr/share/bcc/tools/execsnoop ^C Actually, WARN_ONCE() is fired twice, and __unregister_kprobe_top() misses some cleanups and leaves the aggregated kprobe in the hash table. Then, __unregister_trace_kprobe() initialises tk->rp.kp.list and creates an infinite loop like this. aggregated kprobe.list -> kprobe.list -. ^ | '.__.' In this situation, these commands fall into the infinite loop and result in RCU stall or soft lockup. cat /sys/kernel/debug/kprobes/list : show_kprobe_addr() enters into the infinite loop with RCU. /usr/share/bcc/tools/execsnoop : warn_kprobe_rereg() holds kprobe_mutex, and __get_valid_kprobe() is stuck in the loop. To avoid the issue, make sure we don't call disarm_kprobe() for disabled kprobes. [0] Failed to disarm kprobe-ftrace at __x64_sys_execve+0x0/0x40 (error -2) WARNING: CPU: 6 PID: 2460 at kernel/kprobes.c:1130 __disarm_kprobe_ftrace.isra.19 (kernel/kprobes.c:1129) Modules linked in: ena CPU: 6 PID: 2460 Comm: execsnoop Not tainted 5.19.0+ #28 Hardware name: Amazon EC2 c5.2xlarge/, BIOS 1.0 10/16/2017 RIP: 0010:__disarm_kprobe_ftrace.isra.19 (kernel/kprobes.c:1129) Code: 24 8b 02 eb c1 80 3d c4 83 f2 01 00 75 d4 48 8b 75 00 89 c2 48 c7 c7 90 fa 0f 92 89 04 24 c6 05 ab 83 01 e8 e4 94 f0 ff <0f> 0b 8b 04 24 eb b1 89 c6 48 c7 c7 60 fa 0f 92 89 04 24 e8 cc 94 RSP: 0018:ffff9e6ec154bd98 EFLAGS: 00010282 RAX: 0000000000000000 RBX: ffffffff930f7b00 RCX: 0000000000000001 RDX: 0000000080000001 RSI: ffffffff921461c5 RDI: 00000000ffffffff RBP: ffff89c504286da8 R08: 0000000000000000 R09: c0000000fffeffff R10: 0000000000000000 R11: ffff9e6ec154bc28 R12: ffff89c502394e40 R13: ffff89c502394c00 R14: ffff9e6ec154bc00 R15: 0000000000000000 FS: 00007fe800398740(0000) GS:ffff89c812d80000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000000c00057f010 CR3: 0000000103b54006 CR4: 00000000007706e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 PKRU: 55555554 Call Trace: <TASK> __disable_kprobe (kernel/kprobes.c:1716) disable_kprobe (kernel/kprobes.c:2392) __disable_trace_kprobe (kernel/trace/trace_kprobe.c:340) disable_trace_kprobe (kernel/trace/trace_kprobe.c:429) perf_trace_event_unreg.isra.2 (./include/linux/tracepoint.h:93 kernel/trace/trace_event_perf.c:168) perf_kprobe_destroy (kernel/trace/trace_event_perf.c:295) _free_event (kernel/events/core.c:4971) perf_event_release_kernel (kernel/events/core.c:5176) perf_release (kernel/events/core.c:5186) __fput (fs/file_table.c:321) task_work_run (./include/linux/ ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/19cd630712e7c13a3dedfc6986a9b983fed6fd98"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/55c7a91527343d2e0b5647cc308c6e04ddd2aa52"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6f3c1bc22fc2165461883f506b4d2c3594bd7137"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/744b0d3080709a172f0408aedabd1cedd24c2ee6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9c80e79906b4ca440d09e7f116609262bb747909"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b474ff1b20951f1eac75d100a93861e6da2b522b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bc3188d8a3b8c08c306a4c851ddb2c92ba4599ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc91d2db55acdaf0c0075b624e572d3520ca3bc3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50009,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:28.857,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: f2fs: fix null-ptr-deref in f2fs_get_dnode_of_data There is issue as follows when test f2fs atomic write: F2FS-fs (loop0): Can't find valid F2FS filesystem in 2th superblock F2FS-fs (loop0): invalid crc_offset: 0 F2FS-fs (loop0): f2fs_check_nid_range: out-of-range nid=1, run fsck to fix. F2FS-fs (loop0): f2fs_check_nid_range: out-of-range nid=2, run fsck to fix. ================================================================== BUG: KASAN: null-ptr-deref in f2fs_get_dnode_of_data+0xac/0x16d0 Read of size 8 at addr 0000000000000028 by task rep/1990 CPU: 4 PID: 1990 Comm: rep Not tainted 5.19.0-rc6-next-20220715 #266 Call Trace: <TASK> dump_stack_lvl+0x6e/0x91 print_report.cold+0x49a/0x6bb kasan_report+0xa8/0x130 f2fs_get_dnode_of_data+0xac/0x16d0 f2fs_do_write_data_page+0x2a5/0x1030 move_data_page+0x3c5/0xdf0 do_garbage_collect+0x2015/0x36c0 f2fs_gc+0x554/0x1d30 f2fs_balance_fs+0x7f5/0xda0 f2fs_write_single_data_page+0xb66/0xdc0 f2fs_write_cache_pages+0x716/0x1420 f2fs_write_data_pages+0x84f/0x9a0 do_writepages+0x130/0x3a0 filemap_fdatawrite_wbc+0x87/0xa0 file_write_and_wait_range+0x157/0x1c0 f2fs_do_sync_file+0x206/0x12d0 f2fs_sync_file+0x99/0xc0 vfs_fsync_range+0x75/0x140 f2fs_file_write_iter+0xd7b/0x1850 vfs_write+0x645/0x780 ksys_write+0xf1/0x1e0 do_syscall_64+0x3b/0x90 entry_SYSCALL_64_after_hwframe+0x63/0xcd As 3db1de0e582c commit changed atomic write way which new a cow_inode for atomic write file, and also mark cow_inode as FI_ATOMIC_FILE. When f2fs_do_write_data_page write cow_inode will use cow_inode's cow_inode which is NULL. Then will trigger null-ptr-deref. To solve above issue, introduce FI_COW_FILE flag for COW inode. Fiexes: 3db1de0e582c(""f2fs: change the current atomic write way"")",,,"[{""url"":""https://git.kernel.org/stable/c/0f63e33eca6fa29a11c76fa31db5fe1cada5ad6e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4a2c5b7994960fac29cf8a3f4e62855bae1b27d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7000ad53ec1b17bd2fac76984b7b0c663755cbb7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50010,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:28.970,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: video: fbdev: i740fb: Check the argument of i740_calc_vclk() Since the user can control the arguments of the ioctl() from the user space, under special arguments that may result in a divide-by-zero bug. If the user provides an improper 'pixclock' value that makes the argumet of i740_calc_vclk() less than 'I740_RFREQ_FIX', it will cause a divide-by-zero bug in: drivers/video/fbdev/i740fb.c:353 p_best = min(15, ilog2(I740_MAX_VCO_FREQ / (freq / I740_RFREQ_FIX))); The following log can reveal it: divide error: 0000 [#1] PREEMPT SMP KASAN PTI RIP: 0010:i740_calc_vclk drivers/video/fbdev/i740fb.c:353 [inline] RIP: 0010:i740fb_decode_var drivers/video/fbdev/i740fb.c:646 [inline] RIP: 0010:i740fb_set_par+0x163f/0x3b70 drivers/video/fbdev/i740fb.c:742 Call Trace: fb_set_var+0x604/0xeb0 drivers/video/fbdev/core/fbmem.c:1034 do_fb_ioctl+0x234/0x670 drivers/video/fbdev/core/fbmem.c:1110 fb_ioctl+0xdd/0x130 drivers/video/fbdev/core/fbmem.c:1189 Fix this by checking the argument of i740_calc_vclk() first.",,,"[{""url"":""https://git.kernel.org/stable/c/2b7f559152a33c55f51b569b22efbe5e24886798"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/40bf722f8064f50200b8c4f8946cd625b441dda9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4b20c61365140d432dee7da7aa294215e7b900d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/59cefb583c984c0da8cf21a4c57d26d5a20dff5c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/656689cb03ada4650016c153346939a1c334b1ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d2d375eb68b4b8de6ea7460483a26fa9de56b443"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e740e787f06671455b59d1e498c9945f7b4e7b3b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f350812e2d15278f1d867eeb997407782234fb3c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50011,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:29.093,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: venus: pm_helpers: Fix warning in OPP during probe Fix the following WARN triggered during Venus driver probe on 5.19.0-rc8-next-20220728: WARNING: CPU: 7 PID: 339 at drivers/opp/core.c:2471 dev_pm_opp_set_config+0x49c/0x610 Modules linked in: qcom_spmi_adc5 rtc_pm8xxx qcom_spmi_adc_tm5 leds_qcom_lpg led_class_multicolor qcom_pon qcom_vadc_common venus_core(+) qcom_spmi_temp_alarm v4l2_mem2mem videobuf2_v4l2 msm(+) videobuf2_common crct10dif_ce spi_geni_qcom snd_soc_sm8250 i2c_qcom_geni gpu_sched snd_soc_qcom_common videodev qcom_q6v5_pas soundwire_qcom drm_dp_aux_bus qcom_stats drm_display_helper qcom_pil_info soundwire_bus snd_soc_lpass_va_macro mc qcom_q6v5 phy_qcom_snps_femto_v2 qcom_rng snd_soc_lpass_macro_common snd_soc_lpass_wsa_macro lpass_gfm_sm8250 slimbus qcom_sysmon qcom_common qcom_glink_smem qmi_helpers qcom_wdt mdt_loader socinfo icc_osm_l3 display_connector drm_kms_helper qnoc_sm8250 drm fuse ip_tables x_tables ipv6 CPU: 7 PID: 339 Comm: systemd-udevd Not tainted 5.19.0-rc8-next-20220728 #4 Hardware name: Qualcomm Technologies, Inc. Robotics RB5 (DT) pstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : dev_pm_opp_set_config+0x49c/0x610 lr : dev_pm_opp_set_config+0x58/0x610 sp : ffff8000093c3710 x29: ffff8000093c3710 x28: ffffbca3959d82b8 x27: ffff8000093c3d00 x26: ffffbca3959d8e08 x25: ffff4396cac98118 x24: ffff4396c0e24810 x23: ffff4396c4272c40 x22: ffff4396c0e24810 x21: ffff8000093c3810 x20: ffff4396cac36800 x19: ffff4396cac96800 x18: 0000000000000000 x17: 0000000000000003 x16: ffffbca3f4edf198 x15: 0000001cba64a858 x14: 0000000000000180 x13: 000000000000017e x12: 0000000000000000 x11: 0000000000000002 x10: 0000000000000a60 x9 : ffff8000093c35c0 x8 : ffff4396c4273700 x7 : ffff43983efca6c0 x6 : ffff43983efca640 x5 : 00000000410fd0d0 x4 : ffff4396c4272c40 x3 : ffffbca3f5d1e008 x2 : 0000000000000000 x1 : ffff4396c2421600 x0 : ffff4396cac96860 Call trace: dev_pm_opp_set_config+0x49c/0x610 devm_pm_opp_set_config+0x18/0x70 vcodec_domains_get+0xb8/0x1638 [venus_core] core_get_v4+0x1d8/0x218 [venus_core] venus_probe+0xf4/0x468 [venus_core] platform_probe+0x68/0xd8 really_probe+0xbc/0x2a8 __driver_probe_device+0x78/0xe0 driver_probe_device+0x3c/0xf0 __driver_attach+0x70/0x120 bus_for_each_dev+0x70/0xc0 driver_attach+0x24/0x30 bus_add_driver+0x150/0x200 driver_register+0x64/0x120 __platform_driver_register+0x28/0x38 qcom_venus_driver_init+0x24/0x1000 [venus_core] do_one_initcall+0x54/0x1c8 do_init_module+0x44/0x1d0 load_module+0x16c8/0x1aa0 __do_sys_finit_module+0xbc/0x110 __arm64_sys_finit_module+0x20/0x30 invoke_syscall+0x44/0x108 el0_svc_common.constprop.0+0xcc/0xf0 do_el0_svc+0x2c/0xb8 el0_svc+0x2c/0x88 el0t_64_sync_handler+0xb8/0xc0 el0t_64_sync+0x18c/0x190 qcom-venus: probe of aa00000.video-codec failed with error -16 The fix is re-ordering the code related to OPP core. The OPP core expects all configuration options to be provided before the OPP table is added.",,,"[{""url"":""https://git.kernel.org/stable/c/0bdec5eed69c73886af4cfbb94b663e1e10b8344"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1d95af02f23031c2e1cca7607c514b86ce85bc6e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8d4eccd78461c3e3555bff67148432bb6c21d059"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50012,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:29.213,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: powerpc/64: Init jump labels before parse_early_param() On 64-bit, calling jump_label_init() in setup_feature_keys() is too late because static keys may be used in subroutines of parse_early_param() which is again subroutine of early_init_devtree(). For example booting with ""threadirqs"": static_key_enable_cpuslocked(): static key '0xc000000002953260' used before call to jump_label_init() WARNING: CPU: 0 PID: 0 at kernel/jump_label.c:166 static_key_enable_cpuslocked+0xfc/0x120 ... NIP static_key_enable_cpuslocked+0xfc/0x120 LR static_key_enable_cpuslocked+0xf8/0x120 Call Trace: static_key_enable_cpuslocked+0xf8/0x120 (unreliable) static_key_enable+0x30/0x50 setup_forced_irqthreads+0x28/0x40 do_early_param+0xa0/0x108 parse_args+0x290/0x4e0 parse_early_options+0x48/0x5c parse_early_param+0x58/0x84 early_init_devtree+0xd4/0x518 early_setup+0xb4/0x214 So call jump_label_init() just before parse_early_param() in early_init_devtree(). [mpe: Add call trace to change log and minor wording edits.]",,,"[{""url"":""https://git.kernel.org/stable/c/4bb1188e2b1ed98fa2b618cc0628ccba63c6c80f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e14b04c8459afbeea1eeb74e81af86d7b196a4d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8992141cb88f1d99fd11580f4423634700a99240"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8f9357313cdcadb0a311b44c29d4eaccc7fa632f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c4ced9fd10073adc854919976b88ad6004271119"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca829e05d3d4f728810cc5e4b468d9ebc7745eb3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dac28dff90849af4200b8269fcdc84cdc12fa46c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3c9e9452a8ea12d335b1e59b2c72e1b99c699b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50013,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:29.340,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to avoid use f2fs_bug_on() in f2fs_new_node_page() As Dipanjan Das <mail.dipanjan.das@gmail.com> reported, syzkaller found a f2fs bug as below: RIP: 0010:f2fs_new_node_page+0x19ac/0x1fc0 fs/f2fs/node.c:1295 Call Trace: write_all_xattrs fs/f2fs/xattr.c:487 [inline] __f2fs_setxattr+0xe76/0x2e10 fs/f2fs/xattr.c:743 f2fs_setxattr+0x233/0xab0 fs/f2fs/xattr.c:790 f2fs_xattr_generic_set+0x133/0x170 fs/f2fs/xattr.c:86 __vfs_setxattr+0x115/0x180 fs/xattr.c:182 __vfs_setxattr_noperm+0x125/0x5f0 fs/xattr.c:216 __vfs_setxattr_locked+0x1cf/0x260 fs/xattr.c:277 vfs_setxattr+0x13f/0x330 fs/xattr.c:303 setxattr+0x146/0x160 fs/xattr.c:611 path_setxattr+0x1a7/0x1d0 fs/xattr.c:630 __do_sys_lsetxattr fs/xattr.c:653 [inline] __se_sys_lsetxattr fs/xattr.c:649 [inline] __x64_sys_lsetxattr+0xbd/0x150 fs/xattr.c:649 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x46/0xb0 NAT entry and nat bitmap can be inconsistent, e.g. one nid is free in nat bitmap, and blkaddr in its NAT entry is not NULL_ADDR, it may trigger BUG_ON() in f2fs_new_node_page(), fix it.",,,"[{""url"":""https://git.kernel.org/stable/c/141170b759e03958f296033bb7001be62d1d363b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/29e734ec33ae4bd7de4018fb0fb0eec808c36b92"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/43ce0a0bda2c54dad91d5a1943554eed9e050f55"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a01e45b925a0bc9718eccd33e5920f1a4e44caf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/800ba8979111184d5194f4233cc83afe683efc54"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fbfad62b29e9f8f1c1026a806c9e064ec2a7c342"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50014,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:29.470,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm/gup: fix FOLL_FORCE COW security issue and remove FOLL_COW Ever since the Dirty COW (CVE-2016-5195) security issue happened, we know that FOLL_FORCE can be possibly dangerous, especially if there are races that can be exploited by user space. Right now, it would be sufficient to have some code that sets a PTE of a R/O-mapped shared page dirty, in order for it to erroneously become writable by FOLL_FORCE. The implications of setting a write-protected PTE dirty might not be immediately obvious to everyone. And in fact ever since commit 9ae0f87d009c (""mm/shmem: unconditionally set pte dirty in mfill_atomic_install_pte""), we can use UFFDIO_CONTINUE to map a shmem page R/O while marking the pte dirty. This can be used by unprivileged user space to modify tmpfs/shmem file content even if the user does not have write permissions to the file, and to bypass memfd write sealing -- Dirty COW restricted to tmpfs/shmem (CVE-2022-2590). To fix such security issues for good, the insight is that we really only need that fancy retry logic (FOLL_COW) for COW mappings that are not writable (!VM_WRITE). And in a COW mapping, we really only broke COW if we have an exclusive anonymous page mapped. If we have something else mapped, or the mapped anonymous page might be shared (!PageAnonExclusive), we have to trigger a write fault to break COW. If we don't find an exclusive anonymous page when we retry, we have to trigger COW breaking once again because something intervened. Let's move away from this mandatory-retry + dirty handling and rely on our PageAnonExclusive() flag for making a similar decision, to use the same COW logic as in other kernel parts here as well. In case we stumble over a PTE in a COW mapping that does not map an exclusive anonymous page, COW was not properly broken and we have to trigger a fake write-fault to break COW. Just like we do in can_change_pte_writable() added via commit 64fe24a3e05e (""mm/mprotect: try avoiding write faults for exclusive anonymous pages when changing protection"") and commit 76aefad628aa (""mm/mprotect: fix soft-dirty check in can_change_pte_writable()""), take care of softdirty and uffd-wp manually. For example, a write() via /proc/self/mem to a uffd-wp-protected range has to fail instead of silently granting write access and bypassing the userspace fault handler. Note that FOLL_FORCE is not only used for debug access, but also triggered by applications without debug intentions, for example, when pinning pages via RDMA. This fixes CVE-2022-2590. Note that only x86_64 and aarch64 are affected, because only those support CONFIG_HAVE_ARCH_USERFAULTFD_MINOR. Fortunately, FOLL_COW is no longer required to handle FOLL_FORCE. So let's just get rid of it. Thanks to Nadav Amit for pointing out that the pte_dirty() check in FOLL_FORCE code is problematic and might be exploitable. Note 1: We don't check for the PTE being dirty because it doesn't matter for making a ""was COWed"" decision anymore, and whoever modifies the page has to set the page dirty either way. Note 2: Kernels before extended uffd-wp support and before PageAnonExclusive (< 5.19) can simply revert the problematic commit instead and be safe regarding UFFDIO_CONTINUE. A backport to v5.19 requires minor adjustments due to lack of vma_soft_dirty_enabled().",,,"[{""url"":""https://git.kernel.org/stable/c/5535be3099717646781ce1540cf725965d680e7b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9def52eb10baab3b700858003d462fcf17d62873"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50015,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:29.593,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: SOF: Intel: hda-ipc: Do not process IPC reply before firmware boot It is not yet clear, but it is possible to create a firmware so broken that it will send a reply message before a FW_READY message (it is not yet clear if FW_READY will arrive later). Since the reply_data is allocated only after the FW_READY message, this will lead to a NULL pointer dereference if not filtered out. The issue was reported with IPC4 firmware but the same condition is present for IPC3.",,,"[{""url"":""https://git.kernel.org/stable/c/48945246cf802b9866f3a821103f1a7a196baf68"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/499cc881b09c8283ab5e75b0d6d21cb427722161"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50016,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:29.700,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: SOF: Intel: cnl: Do not process IPC reply before firmware boot It is not yet clear, but it is possible to create a firmware so broken that it will send a reply message before a FW_READY message (it is not yet clear if FW_READY will arrive later). Since the reply_data is allocated only after the FW_READY message, this will lead to a NULL pointer dereference if not filtered out. The issue was reported with IPC4 firmware but the same condition is present for IPC3.",,,"[{""url"":""https://git.kernel.org/stable/c/230f646085d17a008b609eb8fe8befb8811868f0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/acacd9eefd0def5a83244d88e5483b5f38ee7287"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50017,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:29.807,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mips: cavium-octeon: Fix missing of_node_put() in octeon2_usb_clocks_start We should call of_node_put() for the reference 'uctl_node' returned by of_get_parent() which will increase the refcount. Otherwise, there will be a refcount leak bug.",,,"[{""url"":""https://git.kernel.org/stable/c/1b49707df679b5510ed06ace7378ddc2aec5c3fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1e39037e44d7fa3728686af146f9285ea197097d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7822d994eb9579a1df4cdbc315db090a041e50f3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7a9f743ceead60ed454c46fbc3085ee9a79cbebb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d1afa0169a84dcd5b79901d792edeb8403684ab"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a80016c40cc797c7f3e5a705b8e12ae447280335"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/af87a469695dc2b2419b2fdff0bf41db5265b325"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c06166a484eece51916dd700a870e53356b7e1bc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50018,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:29.923,2025-06-18T14:15:24.040,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2022-50019,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:30.030,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tty: serial: Fix refcount leak bug in ucc_uart.c In soc_info(), of_find_node_by_type() will return a node pointer with refcount incremented. We should use of_node_put() when it is not used anymore.",,,"[{""url"":""https://git.kernel.org/stable/c/17c32546166d8a7d2579c4b57c8b16241f94a66b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/59bc4c19d53bdac61ec952c01c6e864f5f0f8367"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/81939c4fbc2d5c754d0f1c1f05149d4b70d751ed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8245e7d1d7f75a9255ad1e8146752e5051d528b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca3fc1c38e4253bc019881301a28ea60b8b0bca3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d24d7bb2cd947676f9b71fb944d045e09b8b282f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec56f886f3bf0f15f7a3844d4c025e165b8e8de7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f6ed634eedb1a8a6a8cb110a7695c7abb70ffcbf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50020,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:30.150,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: avoid resizing to a partial cluster size This patch avoids an attempt to resize the filesystem to an unaligned cluster boundary. An online resize to a size that is not integral to cluster size results in the last iteration attempting to grow the fs by a negative amount, which trips a BUG_ON and leaves the fs with a corrupted in-memory superblock.",,,"[{""url"":""https://git.kernel.org/stable/c/0082e99a9074ff88eff729c70c93454c8588d8e1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/53f62a4201be1cfc1e3c971e566888b182c3ffb0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/69cb8e9d8cd97cdf5e293b26d70a9dee3e35e6bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/72b850a2a996f72541172e7cf686d54a2b29bcd8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7bdfb01fc5f6b3696728aeb527c50386e0ee09a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/80288883294c5b4ed18bae0d8bd9c4a12f297074"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/952b3dc02baaae6a69c71c0aca23e06741182d9a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6805b3dcf5cd41f2ae3a03dca43411135b99849"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50021,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:30.280,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: block range must be validated before use in ext4_mb_clear_bb() Block range to free is validated in ext4_free_blocks() using ext4_inode_block_valid() and then it's passed to ext4_mb_clear_bb(). However in some situations on bigalloc file system the range might be adjusted after the validation in ext4_free_blocks() which can lead to troubles on corrupted file systems such as one found by syzkaller that resulted in the following BUG kernel BUG at fs/ext4/ext4.h:3319! PREEMPT SMP NOPTI CPU: 28 PID: 4243 Comm: repro Kdump: loaded Not tainted 5.19.0-rc6+ #1 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.15.0-1.fc35 04/01/2014 RIP: 0010:ext4_free_blocks+0x95e/0xa90 Call Trace: <TASK> ? lock_timer_base+0x61/0x80 ? __es_remove_extent+0x5a/0x760 ? __mod_timer+0x256/0x380 ? ext4_ind_truncate_ensure_credits+0x90/0x220 ext4_clear_blocks+0x107/0x1b0 ext4_free_data+0x15b/0x170 ext4_ind_truncate+0x214/0x2c0 ? _raw_spin_unlock+0x15/0x30 ? ext4_discard_preallocations+0x15a/0x410 ? ext4_journal_check_start+0xe/0x90 ? __ext4_journal_start_sb+0x2f/0x110 ext4_truncate+0x1b5/0x460 ? __ext4_journal_start_sb+0x2f/0x110 ext4_evict_inode+0x2b4/0x6f0 evict+0xd0/0x1d0 ext4_enable_quotas+0x11f/0x1f0 ext4_orphan_cleanup+0x3de/0x430 ? proc_create_seq_private+0x43/0x50 ext4_fill_super+0x295f/0x3ae0 ? snprintf+0x39/0x40 ? sget_fc+0x19c/0x330 ? ext4_reconfigure+0x850/0x850 get_tree_bdev+0x16d/0x260 vfs_get_tree+0x25/0xb0 path_mount+0x431/0xa70 __x64_sys_mount+0xe2/0x120 do_syscall_64+0x5b/0x80 ? do_user_addr_fault+0x1e2/0x670 ? exc_page_fault+0x70/0x170 entry_SYSCALL_64_after_hwframe+0x46/0xb0 RIP: 0033:0x7fdf4e512ace Fix it by making sure that the block range is properly validated before used every time it changes in ext4_free_blocks() or ext4_mb_clear_bb().",,,"[{""url"":""https://git.kernel.org/stable/c/1e1c2b86ef86a8477fd9b9a4f48a6bfe235606f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/560a2744cbbf03cac65a6394f9b0d99aa437c867"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7550aade978371ac582f6d43b14c4cb89ca54463"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a2522041d248a8c969cbbc97e1fc2cd8b4de120d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50022,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:30.390,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drivers:md:fix a potential use-after-free bug In line 2884, ""raid5_release_stripe(sh);"" drops the reference to sh and may cause sh to be released. However, sh is subsequently used in lines 2886 ""if (sh->batch_head && sh != sh->batch_head)"". This may result in an use-after-free bug. It can be fixed by moving ""raid5_release_stripe(sh);"" to the bottom of the function.",,,"[{""url"":""https://git.kernel.org/stable/c/09cf99bace7789d91caa8d10fbcfc8b2fb35857f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/104212471b1c1817b311771d817fb692af983173"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5d8325fd15892c8ab1146edc1d7ed8463de39636"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7470a4314b239e9a9580f248fdf4c9a92805490e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d9b94c3ace549433de8a93eeb27b0391fc8ac406"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e5b3dd2d92c4511e81f6e4ec9c5bb7ad25e03d13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb3a4f73f43f839df981dda5859e8e075067a360"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f5d46f1b47f65da1faf468277b261eb78c8e25b5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50023,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:30.530,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dmaengine: dw-axi-dmac: ignore interrupt if no descriptor If the channel has no descriptor and the interrupt is raised then the kernel will OOPS. Check the result of vchan_next_desc() in the handler axi_chan_block_xfer_complete() to avoid the error happening.",,,"[{""url"":""https://git.kernel.org/stable/c/3d05aeebbde8c69593d8aa512b7c08b8f0ad25ba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/54aa6c49361b79f7f6b15fc63dfe9ea52c70bb03"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/820f5ce999d2f99961e88c16d65cd26764df0590"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50024,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:30.650,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dmaengine: dw-axi-dmac: do not print NULL LLI during error During debugging we have seen an issue where axi_chan_dump_lli() is passed a NULL LLI pointer which ends up causing an OOPS due to trying to get fields from it. Simply print NULL LLI and exit to avoid this.",,,"[{""url"":""https://git.kernel.org/stable/c/86cb0defe0e275453bc39e856bb523eb425a6537"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad764df73ae5eada265fffc0408404703cbb2b8d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/af76e6fdcf92f1a742b788d0dba5edd194267bf9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50025,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:30.760,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: cxl: Fix a memory leak in an error handling path A bitmap_zalloc() must be balanced by a corresponding bitmap_free() in the error handling path of afu_allocate_irqs().",,,"[{""url"":""https://git.kernel.org/stable/c/3a15b45b5454da862376b5d69a4967f5c6fa1368"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4be138bcd6d68cec0ce47051b117541061f5141a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6544ff559315498ad6c0a311359ca44987f9ca07"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/695af60af755873399ce01cb97176768828bc1fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/89d51dc6878c47b6400922fac21b6a33f9d1a588"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/addff638c41753639368c252d0c5ba0d8fe9ed97"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c2557780ee7818b701681c226fa4cb7c0b171665"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c2c7a29f99788e9e5dfe41d16868ea33da7cc235"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50026,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:30.880,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: habanalabs/gaudi: fix shift out of bounds When validating NIC queues, queue offset calculation must be performed only for NIC queues.",,,"[{""url"":""https://git.kernel.org/stable/c/01622098aeb05a5efbb727199bbc2a4653393255"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/19958bf4ef3124f6e93fd9e2de0b54d2a356a4db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b09e5ab18c9f52ff14cf968770e15d5b2dd85c43"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50027,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:30.990,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: lpfc: Fix possible memory leak when failing to issue CMF WQE There is no corresponding free routine if lpfc_sli4_issue_wqe fails to issue the CMF WQE in lpfc_issue_cmf_sync_wqe. If ret_val is non-zero, then free the iocbq request structure.",,,"[{""url"":""https://git.kernel.org/stable/c/2f67dc7970bce3529edce93a0a14234d88b3fcd5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4eb7a1beff03836d3df271cd23b790884e3facb9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9c8e2e607270a368834a0ef72aa82d970f89c596"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50028,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:31.097,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: gadgetfs: ep_io - wait until IRQ finishes after usb_ep_queue() if wait_for_completion_interruptible() is interrupted we need to wait until IRQ gets finished. Otherwise complete() from epio_complete() can corrupt stack.",,,"[{""url"":""https://git.kernel.org/stable/c/04cb742d4d8f30dc2e83b46ac317eec09191c68e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/118d967ce00a3d128bf731b35e4e2cb0facf5f00"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2b06d5d97c0e067108a122986767731d40742138"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/67a4874461422e633236a0286a01b483cd647113"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/77040efe59a141286d090c8a0d37c65a355a1832"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/94aadba8d000d5de56af4ce8da3f334f21bf7a79"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ac14f973cb91f0c01776517e6d50981f32b8038"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca06b4cde54f8ec8be3aa53fd339bd56e62c12b3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50029,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:31.220,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: clk: qcom: ipq8074: dont disable gcc_sleep_clk_src Once the usb sleep clocks are disabled, clock framework is trying to disable the sleep clock source also. However, it seems that it cannot be disabled and trying to do so produces: [ 245.436390] ------------[ cut here ]------------ [ 245.441233] gcc_sleep_clk_src status stuck at 'on' [ 245.441254] WARNING: CPU: 2 PID: 223 at clk_branch_wait+0x130/0x140 [ 245.450435] Modules linked in: xhci_plat_hcd xhci_hcd dwc3 dwc3_qcom leds_gpio [ 245.456601] CPU: 2 PID: 223 Comm: sh Not tainted 5.18.0-rc4 #215 [ 245.463889] Hardware name: Xiaomi AX9000 (DT) [ 245.470050] pstate: 204000c5 (nzCv daIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 245.474307] pc : clk_branch_wait+0x130/0x140 [ 245.481073] lr : clk_branch_wait+0x130/0x140 [ 245.485588] sp : ffffffc009f2bad0 [ 245.489838] x29: ffffffc009f2bad0 x28: ffffff8003e6c800 x27: 0000000000000000 [ 245.493057] x26: 0000000000000000 x25: 0000000000000000 x24: ffffff800226ef20 [ 245.500175] x23: ffffffc0089ff550 x22: 0000000000000000 x21: ffffffc008476ad0 [ 245.507294] x20: 0000000000000000 x19: ffffffc00965ac70 x18: fffffffffffc51a7 [ 245.514413] x17: 68702e3030303837 x16: 3a6d726f6674616c x15: ffffffc089f2b777 [ 245.521531] x14: ffffffc0095c9d18 x13: 0000000000000129 x12: 0000000000000129 [ 245.528649] x11: 00000000ffffffea x10: ffffffc009621d18 x9 : 0000000000000001 [ 245.535767] x8 : 0000000000000001 x7 : 0000000000017fe8 x6 : 0000000000000001 [ 245.542885] x5 : ffffff803fdca6d8 x4 : 0000000000000000 x3 : 0000000000000027 [ 245.550002] x2 : 0000000000000027 x1 : 0000000000000023 x0 : 0000000000000026 [ 245.557122] Call trace: [ 245.564229] clk_branch_wait+0x130/0x140 [ 245.566490] clk_branch2_disable+0x2c/0x40 [ 245.570656] clk_core_disable+0x60/0xb0 [ 245.574561] clk_core_disable+0x68/0xb0 [ 245.578293] clk_disable+0x30/0x50 [ 245.582113] dwc3_qcom_remove+0x60/0xc0 [dwc3_qcom] [ 245.585588] platform_remove+0x28/0x60 [ 245.590361] device_remove+0x4c/0x80 [ 245.594179] device_release_driver_internal+0x1dc/0x230 [ 245.597914] device_driver_detach+0x18/0x30 [ 245.602861] unbind_store+0xec/0x110 [ 245.607027] drv_attr_store+0x24/0x40 [ 245.610847] sysfs_kf_write+0x44/0x60 [ 245.614405] kernfs_fop_write_iter+0x128/0x1c0 [ 245.618052] new_sync_write+0xc0/0x130 [ 245.622391] vfs_write+0x1d4/0x2a0 [ 245.626123] ksys_write+0x58/0xe0 [ 245.629508] __arm64_sys_write+0x1c/0x30 [ 245.632895] invoke_syscall.constprop.0+0x5c/0x110 [ 245.636890] do_el0_svc+0xa0/0x150 [ 245.641488] el0_svc+0x18/0x60 [ 245.644872] el0t_64_sync_handler+0xa4/0x130 [ 245.647914] el0t_64_sync+0x174/0x178 [ 245.652340] ---[ end trace 0000000000000000 ]--- So, add CLK_IS_CRITICAL flag to the clock so that the kernel won't try to disable the sleep clock.",,,"[{""url"":""https://git.kernel.org/stable/c/17d58499dc9c7e059dab7d170e9bae1e7e9c561b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1bf7305e79aab095196131bdc87a97796e0e3fac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/38cee0d2b65eed42a44052de1bfdc0177b6c3f05"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4203b76abe539f3cac258d4cf1e16e2dd95ea60f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/459411b9f0180e3f382d7abfa3028dd3285984c3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6b90ab952401bd6c1a321dcfc0e0df080f2bc905"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d401611a93b332914cf91eb9bc0b63fa1bdc17e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50030,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:31.340,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: lpfc: Prevent buffer overflow crashes in debugfs with malformed user input Malformed user input to debugfs results in buffer overflow crashes. Adapt input string lengths to fit within internal buffers, leaving space for NULL terminators.",,,"[{""url"":""https://git.kernel.org/stable/c/2d544e9d19c109dfe34b3dc1253a8b2971abe060"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/927907f1cbb3408cadde637fccfc17bb6b10a87d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b92506dc51f81741eb26609175ac206c20f06e0a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c29a4baaad38a332c0ae480cf6d6c5bf75ac1828"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8191d40aa612981ce897e66cda6a88db8df17bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50031,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:31.450,2025-08-11T16:15:28.750,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2022-50032,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:31.557,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: renesas: Fix refcount leak bug In usbhs_rza1_hardware_init(), of_find_node_by_name() will return a node pointer with refcount incremented. We should use of_node_put() when it is not used anymore.",,,"[{""url"":""https://git.kernel.org/stable/c/36b18b777dece704b7c2e9e7947ca41a9b0fb009"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5c4b699193eba51f1bbf462d758d66f545fddd35"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9790a5a4f07f38a5add85ec58c44797d3a7c3677"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d6d5303c39b8bc182475b22f45504106a07f086"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cfa8f707a58d68b2341a9dd0b33cf048f0628b4d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fbdbd61a36d887e00114321c6758e359e9573a8e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50033,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:31.677,2025-06-18T13:46:52.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: host: ohci-ppc-of: Fix refcount leak bug In ohci_hcd_ppc_of_probe(), of_find_compatible_node() will return a node pointer with refcount incremented. We should use of_node_put() when it is not used anymore.",,,"[{""url"":""https://git.kernel.org/stable/c/0334d23c56ecf1ee1563bb83e29cc5a51ed7fb4e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0fc62bbc95319bbd330e3645afc7c286acec9ef8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/403132881e66db7aa98b55c6655daedd80d407fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/40a959d7042bb7711e404ad2318b30e9f92c6b9b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c5c5bd5cdcc6dc9f75f53d1c89af463d39a2bb96"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cb5dd65e889163e723df1c2f02288cc527a57785"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec583e300aee9f152a64911445092d18e1c36729"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe6fe64403710287f0ae61a516954d8a4f7c9e3f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50034,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:31.790,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: cdns3 fix use-after-free at workaround 2 BUG: KFENCE: use-after-free read in __list_del_entry_valid+0x10/0xac cdns3_wa2_remove_old_request() { ... kfree(priv_req->request.buf); cdns3_gadget_ep_free_request(&priv_ep->endpoint, &priv_req->request); list_del_init(&priv_req->list); ^^^ use after free ... } cdns3_gadget_ep_free_request() free the space pointed by priv_req, but priv_req is used in the following list_del_init(). This patch move list_del_init() before cdns3_gadget_ep_free_request().",,,"[{""url"":""https://git.kernel.org/stable/c/6d7ac60098b206d0472475b666cb09d556bec03d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6fd50446e7c9a98b4bcf96815f5c9602a16ea472"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d602f30149a117eea260208b1661bc404c21dfd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c3c1dbad3a2db32ecf371c97f2058491b8ba0f9a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e65d9b7147d7be3504893ca7dfb85286bda83d40"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50035,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:31.897,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Fix use-after-free on amdgpu_bo_list mutex If amdgpu_cs_vm_handling returns r != 0, then it will unlock the bo_list_mutex inside the function amdgpu_cs_vm_handling and again on amdgpu_cs_parser_fini. This problem results in the following use-after-free problem: [ 220.280990] ------------[ cut here ]------------ [ 220.281000] refcount_t: underflow; use-after-free. [ 220.281019] WARNING: CPU: 1 PID: 3746 at lib/refcount.c:28 refcount_warn_saturate+0xba/0x110 [ 220.281029] ------------[ cut here ]------------ [ 220.281415] CPU: 1 PID: 3746 Comm: chrome:cs0 Tainted: G W L ------- --- 5.20.0-0.rc0.20220812git7ebfc85e2cd7.10.fc38.x86_64 #1 [ 220.281421] Hardware name: System manufacturer System Product Name/ROG STRIX X570-I GAMING, BIOS 4403 04/27/2022 [ 220.281426] RIP: 0010:refcount_warn_saturate+0xba/0x110 [ 220.281431] Code: 01 01 e8 79 4a 6f 00 0f 0b e9 42 47 a5 00 80 3d de 7e be 01 00 75 85 48 c7 c7 f8 98 8e 98 c6 05 ce 7e be 01 01 e8 56 4a 6f 00 <0f> 0b e9 1f 47 a5 00 80 3d b9 7e be 01 00 0f 85 5e ff ff ff 48 c7 [ 220.281437] RSP: 0018:ffffb4b0d18d7a80 EFLAGS: 00010282 [ 220.281443] RAX: 0000000000000026 RBX: 0000000000000003 RCX: 0000000000000000 [ 220.281448] RDX: 0000000000000001 RSI: ffffffff988d06dc RDI: 00000000ffffffff [ 220.281452] RBP: 00000000ffffffff R08: 0000000000000000 R09: ffffb4b0d18d7930 [ 220.281457] R10: 0000000000000003 R11: ffffa0672e2fffe8 R12: ffffa058ca360400 [ 220.281461] R13: ffffa05846c50a18 R14: 00000000fffffe00 R15: 0000000000000003 [ 220.281465] FS: 00007f82683e06c0(0000) GS:ffffa066e2e00000(0000) knlGS:0000000000000000 [ 220.281470] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 220.281475] CR2: 00003590005cc000 CR3: 00000001fca46000 CR4: 0000000000350ee0 [ 220.281480] Call Trace: [ 220.281485] <TASK> [ 220.281490] amdgpu_cs_ioctl+0x4e2/0x2070 [amdgpu] [ 220.281806] ? amdgpu_cs_find_mapping+0xe0/0xe0 [amdgpu] [ 220.282028] drm_ioctl_kernel+0xa4/0x150 [ 220.282043] drm_ioctl+0x21f/0x420 [ 220.282053] ? amdgpu_cs_find_mapping+0xe0/0xe0 [amdgpu] [ 220.282275] ? lock_release+0x14f/0x460 [ 220.282282] ? _raw_spin_unlock_irqrestore+0x30/0x60 [ 220.282290] ? _raw_spin_unlock_irqrestore+0x30/0x60 [ 220.282297] ? lockdep_hardirqs_on+0x7d/0x100 [ 220.282305] ? _raw_spin_unlock_irqrestore+0x40/0x60 [ 220.282317] amdgpu_drm_ioctl+0x4a/0x80 [amdgpu] [ 220.282534] __x64_sys_ioctl+0x90/0xd0 [ 220.282545] do_syscall_64+0x5b/0x80 [ 220.282551] ? futex_wake+0x6c/0x150 [ 220.282568] ? lock_is_held_type+0xe8/0x140 [ 220.282580] ? do_syscall_64+0x67/0x80 [ 220.282585] ? lockdep_hardirqs_on+0x7d/0x100 [ 220.282592] ? do_syscall_64+0x67/0x80 [ 220.282597] ? do_syscall_64+0x67/0x80 [ 220.282602] ? lockdep_hardirqs_on+0x7d/0x100 [ 220.282609] entry_SYSCALL_64_after_hwframe+0x63/0xcd [ 220.282616] RIP: 0033:0x7f8282a4f8bf [ 220.282639] Code: 00 48 89 44 24 18 31 c0 48 8d 44 24 60 c7 04 24 10 00 00 00 48 89 44 24 08 48 8d 44 24 20 48 89 44 24 10 b8 10 00 00 00 0f 05 <89> c2 3d 00 f0 ff ff 77 18 48 8b 44 24 18 64 48 2b 04 25 28 00 00 [ 220.282644] RSP: 002b:00007f82683df410 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 [ 220.282651] RAX: ffffffffffffffda RBX: 00007f82683df588 RCX: 00007f8282a4f8bf [ 220.282655] RDX: 00007f82683df4d0 RSI: 00000000c0186444 RDI: 0000000000000018 [ 220.282659] RBP: 00007f82683df4d0 R08: 00007f82683df5e0 R09: 00007f82683df4b0 [ 220.282663] R10: 00001d04000a0600 R11: 0000000000000246 R12: 00000000c0186444 [ 220.282667] R13: 0000000000000018 R14: 00007f82683df588 R15: 0000000000000003 [ 220.282689] </TASK> [ 220.282693] irq event stamp: 6232311 [ 220.282697] hardirqs last enabled at (6232319): [<ffffffff9718cd7e>] __up_console_sem+0x5e/0x70 [ 220.282704] hardirqs last disabled at (6232326): [<ffffffff9718cd63>] __up_console_sem+0x43/0x70 [ 220.282709] softirqs last enabled at (6232072): [<ffffffff970ff669>] __irq_exit_rcu+0xf9/0x170 [ 220.282716] softirqs last disabled at (6232061): [<ffffffff97 ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/1b38e3b423f0bb41ee6abae5ca9deec1546ba227"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bbca24d0a3c11193bafb9e174f89f52a379006e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50036,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:32.003,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/sun4i: dsi: Prevent underflow when computing packet sizes Currently, the packet overhead is subtracted using unsigned arithmetic. With a short sync pulse, this could underflow and wrap around to near the maximal u16 value. Fix this by using signed subtraction. The call to max() will correctly handle any negative numbers that are produced. Apply the same fix to the other timings, even though those subtractions are less likely to underflow.",,,"[{""url"":""https://git.kernel.org/stable/c/82a1356a933d8443139f8886f11b63c974a09a67"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/98e28de472ef248352f04f87e29e634ebb0ec240"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a1e7908f78f5a7f53f8cd83c7dcdfec974c95f26"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fb837f5b83461624e525727a8f4add14b201147e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50037,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:32.117,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/i915/ttm: don't leak the ccs state The kernel only manages the ccs state with lmem-only objects, however the kernel should still take care not to leak the CCS state from the previous user. (cherry picked from commit 353819d85f87be46aeb9c1dd929d445a006fc6ec)",,,"[{""url"":""https://git.kernel.org/stable/c/232d150fa15606e96c0e01e5c7a2d4e03f621787"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b431cffb4883b9e90d48f0c408674c50fef428a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50038,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:32.220,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/meson: Fix refcount bugs in meson_vpu_has_available_connectors() In this function, there are two refcount leak bugs: (1) when breaking out of for_each_endpoint_of_node(), we need call the of_node_put() for the 'ep'; (2) we should call of_node_put() for the reference returned by of_graph_get_remote_port() when it is not used anymore.",,,"[{""url"":""https://git.kernel.org/stable/c/3aa710e96747c8b4e52ba12ffe09edcb2755897c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6a758f0ba11699837af9e1a0f7cbac6ef765a23e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8dec38e19f6928235d4009ce55f7add8af34e5c7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/91b3c8dbe898df158fd2a84675f3a284ff6666f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d58ef256781398ad115aef44de0a02ad27ea6c3a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc1fc2abfcb9235d0ece9a4d858426fb617cfa66"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe71d84c1a6c0d54657431e8eeaefc9d24895304"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50039,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:32.337,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: stmmac: intel: Add a missing clk_disable_unprepare() call in intel_eth_pci_remove() Commit 09f012e64e4b (""stmmac: intel: Fix clock handling on error and remove paths"") removed this clk_disable_unprepare() This was partly revert by commit ac322f86b56c (""net: stmmac: Fix clock handling on remove path"") which removed this clk_disable_unprepare() because: "" While unloading the dwmac-intel driver, clk_disable_unprepare() is being called twice in stmmac_dvr_remove() and intel_eth_pci_remove(). This causes kernel panic on the second call. "" However later on, commit 5ec55823438e8 (""net: stmmac: add clocks management for gmac driver"") has updated stmmac_dvr_remove() which do not call clk_disable_unprepare() anymore. So this call should now be called from intel_eth_pci_remove().",,,"[{""url"":""https://git.kernel.org/stable/c/02f3642d8e657c05f382729c165bed46745dc18c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/47129531196054b374017555165b47a43cdb6f41"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5c23d6b717e4e956376f3852b90f58e262946b50"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9400aeb419d35e718e90aa14a97c11229d0a40bc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50040,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:32.450,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: dsa: sja1105: fix buffer overflow in sja1105_setup_devlink_regions() If an error occurs in dsa_devlink_region_create(), then 'priv->regions' array will be accessed by negative index '-1'. Found by Linux Verification Center (linuxtesting.org) with SVACE.",,,"[{""url"":""https://git.kernel.org/stable/c/7983e1e44cb322eba6af84160b6d18df80603fb8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/79f86b862416126a2e826cb74224180d6625a32f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e84c6321f3578c38cb3c24258db91a92672b17a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd8e899cdb5ecaf8e8ee73854a99e10807eef1de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50041,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:32.560,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ice: Fix call trace with null VSI during VF reset During stress test with attaching and detaching VF from KVM and simultaneously changing VFs spoofcheck and trust there was a call trace in ice_reset_vf that VF's VSI is null. [145237.352797] WARNING: CPU: 46 PID: 840629 at drivers/net/ethernet/intel/ice/ice_vf_lib.c:508 ice_reset_vf+0x3d6/0x410 [ice] [145237.352851] Modules linked in: ice(E) vfio_pci vfio_pci_core vfio_virqfd vfio_iommu_type1 vfio iavf dm_mod xt_CHECKSUM xt_MASQUERADE xt_conntrack ipt_REJECT nf_reject_ipv4 nft_compat nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 nf_tables nfnetlink tun bridge stp llc sunrpc intel_rapl_msr intel_rapl_common sb_edac x86_pkg_temp_thermal intel_powerclamp coretemp kvm_intel kvm iTCO_wdt iTC O_vendor_support irqbypass crct10dif_pclmul crc32_pclmul ghash_clmulni_intel rapl ipmi_si intel_cstate ipmi_devintf joydev intel_uncore m ei_me ipmi_msghandler i2c_i801 pcspkr mei lpc_ich ioatdma i2c_smbus acpi_pad acpi_power_meter ip_tables xfs libcrc32c i2c_algo_bit drm_sh mem_helper drm_kms_helper sd_mod t10_pi crc64_rocksoft syscopyarea crc64 sysfillrect sg sysimgblt fb_sys_fops drm i40e ixgbe ahci libahci libata crc32c_intel mdio dca wmi fuse [last unloaded: ice] [145237.352917] CPU: 46 PID: 840629 Comm: kworker/46:2 Tainted: G S W I E 5.19.0-rc6+ #24 [145237.352921] Hardware name: Intel Corporation S2600WTT/S2600WTT, BIOS SE5C610.86B.01.01.0008.021120151325 02/11/2015 [145237.352923] Workqueue: ice ice_service_task [ice] [145237.352948] RIP: 0010:ice_reset_vf+0x3d6/0x410 [ice] [145237.352984] Code: 30 ec f3 cc e9 28 fd ff ff 0f b7 4b 50 48 c7 c2 48 19 9c c0 4c 89 ee 48 c7 c7 30 fe 9e c0 e8 d1 21 9d cc 31 c0 e9 a 9 fe ff ff <0f> 0b b8 ea ff ff ff e9 c1 fc ff ff 0f 0b b8 fb ff ff ff e9 91 fe [145237.352987] RSP: 0018:ffffb453e257fdb8 EFLAGS: 00010246 [145237.352990] RAX: ffff8bd0040181c0 RBX: ffff8be68db8f800 RCX: 0000000000000000 [145237.352991] RDX: 000000000000ffff RSI: 0000000000000000 RDI: ffff8be68db8f800 [145237.352993] RBP: ffff8bd0040181c0 R08: 0000000000001000 R09: ffff8bcfd520e000 [145237.352995] R10: 0000000000000000 R11: 00008417b5ab0bc0 R12: 0000000000000005 [145237.352996] R13: ffff8bcee061c0d0 R14: ffff8bd004019640 R15: 0000000000000000 [145237.352998] FS: 0000000000000000(0000) GS:ffff8be5dfb00000(0000) knlGS:0000000000000000 [145237.353000] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [145237.353002] CR2: 00007fd81f651d68 CR3: 0000001a0fe10001 CR4: 00000000001726e0 [145237.353003] Call Trace: [145237.353008] <TASK> [145237.353011] ice_process_vflr_event+0x8d/0xb0 [ice] [145237.353049] ice_service_task+0x79f/0xef0 [ice] [145237.353074] process_one_work+0x1c8/0x390 [145237.353081] ? process_one_work+0x390/0x390 [145237.353084] worker_thread+0x30/0x360 [145237.353087] ? process_one_work+0x390/0x390 [145237.353090] kthread+0xe8/0x110 [145237.353094] ? kthread_complete_and_exit+0x20/0x20 [145237.353097] ret_from_fork+0x22/0x30 [145237.353103] </TASK> Remove WARN_ON() from check if VSI is null in ice_reset_vf. Add ""VF is already removed\n"" in dev_dbg(). This WARN_ON() is unnecessary and causes call trace, despite that call trace, driver still works. There is no need for this warn because this piece of code is responsible for disabling VF's Tx/Rx queues when VF is disabled, but when VF is already removed there is no need to do reset or disable queues.",,,"[{""url"":""https://git.kernel.org/stable/c/af1b0d1547dd1686ae842cac7f3678649a5cbd89"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cf90b74341eecc32ceef0c136954a1668e43b1e7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50042,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:32.673,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: genl: fix error path memory leak in policy dumping If construction of the array of policies fails when recording non-first policy we need to unwind. netlink_policy_dump_add_policy() itself also needs fixing as it currently gives up on error without recording the allocated pointer in the pstate pointer.",,,"[{""url"":""https://git.kernel.org/stable/c/249801360db3dec4f73768c502192020bfddeacc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/26b6acd365823e99e46be3b27500f5dc235dda5e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/83411c9f05d5a8b637293b3389eca3d378197c04"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b0672895d8be5d19d4b05ac83f807026fc791037"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50043,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:32.787,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: fix potential refcount leak in ndisc_router_discovery() The issue happens on specific paths in the function. After both the object `rt` and `neigh` are grabbed successfully, when `lifetime` is nonzero but the metric needs change, the function just deletes the route and set `rt` to NULL. Then, it may try grabbing `rt` and `neigh` again if above conditions hold. The function simply overwrite `neigh` if succeeds or returns if fails, without decreasing the reference count of previous `neigh`. This may result in memory leaks. Fix it by decrementing the reference count of `neigh` in place.",,,"[{""url"":""https://git.kernel.org/stable/c/7396ba87f1edf549284869451665c7c4e74ecd4f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7998043d31d000c3a93f46182e6569dd0eecda34"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ffb15594433391fd7885eb88ce5a7f7bdeefbb15"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50044,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:32.897,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: qrtr: start MHI channel after endpoit creation MHI channel may generates event/interrupt right after enabling. It may leads to 2 race conditions issues. 1) Such event may be dropped by qcom_mhi_qrtr_dl_callback() at check: if (!qdev || mhi_res->transaction_status) return; Because dev_set_drvdata(&mhi_dev->dev, qdev) may be not performed at this moment. In this situation qrtr-ns will be unable to enumerate services in device. --------------------------------------------------------------- 2) Such event may come at the moment after dev_set_drvdata() and before qrtr_endpoint_register(). In this case kernel will panic with accessing wrong pointer at qcom_mhi_qrtr_dl_callback(): rc = qrtr_endpoint_post(&qdev->ep, mhi_res->buf_addr, mhi_res->bytes_xferd); Because endpoint is not created yet. -------------------------------------------------------------- So move mhi_prepare_for_transfer_autoqueue after endpoint creation to fix it.",,,"[{""url"":""https://git.kernel.org/stable/c/68a838b84effb7b57ba7d50b1863fc6ae35a54ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a1a75f78a2937567946b1b756f82462874b5ca20"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c682fb70a7dfc25b848a4ff3a385b0471b470606"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50045,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:33.050,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: powerpc/pci: Fix get_phb_number() locking The recent change to get_phb_number() causes a DEBUG_ATOMIC_SLEEP warning on some systems: BUG: sleeping function called from invalid context at kernel/locking/mutex.c:580 in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 1, name: swapper preempt_count: 1, expected: 0 RCU nest depth: 0, expected: 0 1 lock held by swapper/1: #0: c157efb0 (hose_spinlock){+.+.}-{2:2}, at: pcibios_alloc_controller+0x64/0x220 Preemption disabled at: [<00000000>] 0x0 CPU: 0 PID: 1 Comm: swapper Not tainted 5.19.0-yocto-standard+ #1 Call Trace: [d101dc90] [c073b264] dump_stack_lvl+0x50/0x8c (unreliable) [d101dcb0] [c0093b70] __might_resched+0x258/0x2a8 [d101dcd0] [c0d3e634] __mutex_lock+0x6c/0x6ec [d101dd50] [c0a84174] of_alias_get_id+0x50/0xf4 [d101dd80] [c002ec78] pcibios_alloc_controller+0x1b8/0x220 [d101ddd0] [c140c9dc] pmac_pci_init+0x198/0x784 [d101de50] [c140852c] discover_phbs+0x30/0x4c [d101de60] [c0007fd4] do_one_initcall+0x94/0x344 [d101ded0] [c1403b40] kernel_init_freeable+0x1a8/0x22c [d101df10] [c00086e0] kernel_init+0x34/0x160 [d101df30] [c001b334] ret_from_kernel_thread+0x5c/0x64 This is because pcibios_alloc_controller() holds hose_spinlock but of_alias_get_id() takes of_mutex which can sleep. The hose_spinlock protects the phb_bitmap, and also the hose_list, but it doesn't need to be held while get_phb_number() calls the OF routines, because those are only looking up information in the device tree. So fix it by having get_phb_number() take the hose_spinlock itself, only where required, and then dropping the lock before returning. pcibios_alloc_controller() then needs to take the lock again before the list_add() but that's safe, the order of the list is not important.",,,"[{""url"":""https://git.kernel.org/stable/c/1d9e75c3d8cdf7c96a94cb77450d4ee070279e6a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5db5ce0f1963c6c8275719a80cb65e9c98d32726"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6f75057c21eab12c6ccb7f06f859641a6edfab99"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8d48562a2729742f767b0fdd994d6b2a56a49c63"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90f195c01a2e8d8da6281791617e21109719c981"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a868f771ee41c97a25a04b8c632a7f06689b307b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ccb0a42d3f40c436295e0fef57ab613ae5b925a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50046,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:33.170,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/sunrpc: fix potential memory leaks in rpc_sysfs_xprt_state_change() The issue happens on some error handling paths. When the function fails to grab the object `xprt`, it simply returns 0, forgetting to decrease the reference count of another object `xps`, which is increased by rpc_sysfs_xprt_kobj_get_xprt_switch(), causing refcount leaks. Also, the function forgets to check whether `xps` is valid before using it, which may result in NULL-dereferencing issues. Fix it by adding proper error handling code when either `xprt` or `xps` is NULL.",,,"[{""url"":""https://git.kernel.org/stable/c/76fbeb1662b1c56514325118a07fba74dc4c79fe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bfc48f1b0505ffcb03a6d749139b7577d6b81ae0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c0434f0e058648649250b8ed6078b66d773de723"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50047,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:33.280,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: dsa: mv88e6060: prevent crash on an unused port If the port isn't a CPU port nor a user port, 'cpu_dp' is a null pointer and a crash happened on dereferencing it in mv88e6060_setup_port(): [ 9.575872] Unable to handle kernel NULL pointer dereference at virtual address 00000014 ... [ 9.942216] mv88e6060_setup from dsa_register_switch+0x814/0xe84 [ 9.948616] dsa_register_switch from mdio_probe+0x2c/0x54 [ 9.954433] mdio_probe from really_probe.part.0+0x98/0x2a0 [ 9.960375] really_probe.part.0 from driver_probe_device+0x30/0x10c [ 9.967029] driver_probe_device from __device_attach_driver+0xb8/0x13c [ 9.973946] __device_attach_driver from bus_for_each_drv+0x90/0xe0 [ 9.980509] bus_for_each_drv from __device_attach+0x110/0x184 [ 9.986632] __device_attach from bus_probe_device+0x8c/0x94 [ 9.992577] bus_probe_device from deferred_probe_work_func+0x78/0xa8 [ 9.999311] deferred_probe_work_func from process_one_work+0x290/0x73c [ 10.006292] process_one_work from worker_thread+0x30/0x4b8 [ 10.012155] worker_thread from kthread+0xd4/0x10c [ 10.017238] kthread from ret_from_fork+0x14/0x3c",,,"[{""url"":""https://git.kernel.org/stable/c/246bbf2f977ea36aaf41f5d24370fef433250728"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/92dc64e8f591425ce4dabf7d479ebf6e67fb8853"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cb1753bc689c7a7f94da6eee7efc1ae6d8abb36c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dd236b62d25e44ecfa26b0910a12f8d8251aff00"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f3a4b55829617cad2d36fa6524367ef629566ba6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50048,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:33.393,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: nf_tables: possible module reference underflow in error path dst->ops is set on when nft_expr_clone() fails, but module refcount has not been bumped yet, therefore nft_expr_destroy() leads to module reference underflow.",,,"[{""url"":""https://git.kernel.org/stable/c/1e52e6cfec6342c3d0df47dc3a76724fb3dabf56"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b59bee8b05b0e789b5a298cacb09e8aaa3367a29"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c485c35ff6783ccd12c160fcac6a0e504e83e0bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50049,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:33.500,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: DPCM: Don't pick up BE without substream When DPCM tries to add valid BE connections at dpcm_add_paths(), it doesn't check whether the picked BE actually supports for the given stream direction. Due to that, when an asymmetric BE stream is present, it picks up wrongly and this may result in a NULL dereference at a later point where the code assumes the existence of a corresponding BE substream. This patch adds the check for the presence of the substream for the target BE for avoiding the problem above. Note that we have already some fix for non-existing BE substream at commit 6246f283d5e0 (""ASoC: dpcm: skip missing substream while applying symmetry""). But the code path we've hit recently is rather happening before the previous fix. So this patch tries to fix at picking up a BE instead of parsing BE lists.",,,"[{""url"":""https://git.kernel.org/stable/c/6a840e8ef6b6c56d1b7e6a555adc31135e517875"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/754590651ccbbcc74a7c20907be4bb15d642bde3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa803e6ecac78e93b24ebefa17c207d6392d8ad4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50050,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:33.613,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: SOF: Intel: hda: Fix potential buffer overflow by snprintf() snprintf() returns the would-be-filled size when the string overflows the given buffer size, hence using this value may result in the buffer overflow (although it's unrealistic). This patch replaces with a safer version, scnprintf() for papering over such a potential issue.",,,"[{""url"":""https://git.kernel.org/stable/c/6ee1310f4d148dbf04c4159b88afd0b941018903"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/94c1ceb043c1a002de9649bb630c8e8347645982"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f7915c5614a7ece117ec390f21a410531eac48de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50051,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:33.723,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: SOF: debug: Fix potential buffer overflow by snprintf() snprintf() returns the would-be-filled size when the string overflows the given buffer size, hence using this value may result in the buffer overflow (although it's unrealistic). This patch replaces with a safer version, scnprintf() for papering over such a potential issue.",,,"[{""url"":""https://git.kernel.org/stable/c/1eb123ce985e6cf302ac6e3f19862d132d86fa8f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a67971a17604ae7de278fb09243432459afc51e1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b318b9dd2ac67f39d0338ce563879d1f59a0347a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50052,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:33.833,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: Intel: avs: Fix potential buffer overflow by snprintf() snprintf() returns the would-be-filled size when the string overflows the given buffer size, hence using this value may result in a buffer overflow (although it's unrealistic). This patch replaces it with a safer version, scnprintf() for papering over such a potential issue.",,,"[{""url"":""https://git.kernel.org/stable/c/840311a09f75632b9d41fbc1cd5c7aea94ce5f7e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca3b7b9dc9bc1fa552f4697b7cccfa0258a44d00"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50053,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:33.940,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iavf: Fix reset error handling Do not call iavf_close in iavf_reset_task error handling. Doing so can lead to double call of napi_disable, which can lead to deadlock there. Removing VF would lead to iavf_remove task being stuck, because it requires crit_lock, which is held by iavf_close. Call iavf_disable_vf if reset fail, so that driver will clean up remaining invalid resources. During rapid VF resets, HW can fail to setup VF mailbox. Wrong error handling can lead to iavf_remove being stuck with: [ 5218.999087] iavf 0000:82:01.0: Failed to init adminq: -53 ... [ 5267.189211] INFO: task repro.sh:11219 blocked for more than 30 seconds. [ 5267.189520] Tainted: G S E 5.18.0-04958-ga54ce3703613-dirty #1 [ 5267.189764] ""echo 0 > /proc/sys/kernel/hung_task_timeout_secs"" disables this message. [ 5267.190062] task:repro.sh state:D stack: 0 pid:11219 ppid: 8162 flags:0x00000000 [ 5267.190347] Call Trace: [ 5267.190647] <TASK> [ 5267.190927] __schedule+0x460/0x9f0 [ 5267.191264] schedule+0x44/0xb0 [ 5267.191563] schedule_preempt_disabled+0x14/0x20 [ 5267.191890] __mutex_lock.isra.12+0x6e3/0xac0 [ 5267.192237] ? iavf_remove+0xf9/0x6c0 [iavf] [ 5267.192565] iavf_remove+0x12a/0x6c0 [iavf] [ 5267.192911] ? _raw_spin_unlock_irqrestore+0x1e/0x40 [ 5267.193285] pci_device_remove+0x36/0xb0 [ 5267.193619] device_release_driver_internal+0xc1/0x150 [ 5267.193974] pci_stop_bus_device+0x69/0x90 [ 5267.194361] pci_stop_and_remove_bus_device+0xe/0x20 [ 5267.194735] pci_iov_remove_virtfn+0xba/0x120 [ 5267.195130] sriov_disable+0x2f/0xe0 [ 5267.195506] ice_free_vfs+0x7d/0x2f0 [ice] [ 5267.196056] ? pci_get_device+0x4f/0x70 [ 5267.196496] ice_sriov_configure+0x78/0x1a0 [ice] [ 5267.196995] sriov_numvfs_store+0xfe/0x140 [ 5267.197466] kernfs_fop_write_iter+0x12e/0x1c0 [ 5267.197918] new_sync_write+0x10c/0x190 [ 5267.198404] vfs_write+0x24e/0x2d0 [ 5267.198886] ksys_write+0x5c/0xd0 [ 5267.199367] do_syscall_64+0x3a/0x80 [ 5267.199827] entry_SYSCALL_64_after_hwframe+0x46/0xb0 [ 5267.200317] RIP: 0033:0x7f5b381205c8 [ 5267.200814] RSP: 002b:00007fff8c7e8c78 EFLAGS: 00000246 ORIG_RAX: 0000000000000001 [ 5267.201981] RAX: ffffffffffffffda RBX: 0000000000000002 RCX: 00007f5b381205c8 [ 5267.202620] RDX: 0000000000000002 RSI: 00005569420ee900 RDI: 0000000000000001 [ 5267.203426] RBP: 00005569420ee900 R08: 000000000000000a R09: 00007f5b38180820 [ 5267.204327] R10: 000000000000000a R11: 0000000000000246 R12: 00007f5b383c06e0 [ 5267.205193] R13: 0000000000000002 R14: 00007f5b383bb880 R15: 0000000000000002 [ 5267.206041] </TASK> [ 5267.206970] Kernel panic - not syncing: hung_task: blocked tasks [ 5267.207809] CPU: 48 PID: 551 Comm: khungtaskd Kdump: loaded Tainted: G S E 5.18.0-04958-ga54ce3703613-dirty #1 [ 5267.208726] Hardware name: Dell Inc. PowerEdge R730/0WCJNT, BIOS 2.11.0 11/02/2019 [ 5267.209623] Call Trace: [ 5267.210569] <TASK> [ 5267.211480] dump_stack_lvl+0x33/0x42 [ 5267.212472] panic+0x107/0x294 [ 5267.213467] watchdog.cold.8+0xc/0xbb [ 5267.214413] ? proc_dohung_task_timeout_secs+0x30/0x30 [ 5267.215511] kthread+0xf4/0x120 [ 5267.216459] ? kthread_complete_and_exit+0x20/0x20 [ 5267.217505] ret_from_fork+0x22/0x30 [ 5267.218459] </TASK>",,,"[{""url"":""https://git.kernel.org/stable/c/0828e27971f18ea317710acb228afe6e72606082"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/31071173771e079f7bc08dacd61e0db913262fbf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/743dc4377bbac06a6fe44c3c5baf75a49439678a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50054,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:34.050,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iavf: Fix NULL pointer dereference in iavf_get_link_ksettings Fix possible NULL pointer dereference, due to freeing of adapter->vf_res in iavf_init_get_resources. Previous commit introduced a regression, where receiving IAVF_ERR_ADMIN_QUEUE_NO_WORK from iavf_get_vf_config would free adapter->vf_res. However, netdev is still registered, so ethtool_ops can be called. Calling iavf_get_link_ksettings with no vf_res, will result with: [ 9385.242676] BUG: kernel NULL pointer dereference, address: 0000000000000008 [ 9385.242683] #PF: supervisor read access in kernel mode [ 9385.242686] #PF: error_code(0x0000) - not-present page [ 9385.242690] PGD 0 P4D 0 [ 9385.242696] Oops: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC PTI [ 9385.242701] CPU: 6 PID: 3217 Comm: pmdalinux Kdump: loaded Tainted: G S E 5.18.0-04958-ga54ce3703613-dirty #1 [ 9385.242708] Hardware name: Dell Inc. PowerEdge R730/0WCJNT, BIOS 2.11.0 11/02/2019 [ 9385.242710] RIP: 0010:iavf_get_link_ksettings+0x29/0xd0 [iavf] [ 9385.242745] Code: 00 0f 1f 44 00 00 b8 01 ef ff ff 48 c7 46 30 00 00 00 00 48 c7 46 38 00 00 00 00 c6 46 0b 00 66 89 46 08 48 8b 87 68 0e 00 00 <f6> 40 08 80 75 50 8b 87 5c 0e 00 00 83 f8 08 74 7a 76 1d 83 f8 20 [ 9385.242749] RSP: 0018:ffffc0560ec7fbd0 EFLAGS: 00010246 [ 9385.242755] RAX: 0000000000000000 RBX: ffffc0560ec7fc08 RCX: 0000000000000000 [ 9385.242759] RDX: ffffffffc0ad4550 RSI: ffffc0560ec7fc08 RDI: ffffa0fc66674000 [ 9385.242762] RBP: 00007ffd1fb2bf50 R08: b6a2d54b892363ee R09: ffffa101dc14fb00 [ 9385.242765] R10: 0000000000000000 R11: 0000000000000004 R12: ffffa0fc66674000 [ 9385.242768] R13: 0000000000000000 R14: ffffa0fc66674000 R15: 00000000ffffffa1 [ 9385.242771] FS: 00007f93711a2980(0000) GS:ffffa0fad72c0000(0000) knlGS:0000000000000000 [ 9385.242775] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 9385.242778] CR2: 0000000000000008 CR3: 0000000a8e61c003 CR4: 00000000003706e0 [ 9385.242781] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 9385.242784] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [ 9385.242787] Call Trace: [ 9385.242791] <TASK> [ 9385.242793] ethtool_get_settings+0x71/0x1a0 [ 9385.242814] __dev_ethtool+0x426/0x2f40 [ 9385.242823] ? slab_post_alloc_hook+0x4f/0x280 [ 9385.242836] ? kmem_cache_alloc_trace+0x15d/0x2f0 [ 9385.242841] ? dev_ethtool+0x59/0x170 [ 9385.242848] dev_ethtool+0xa7/0x170 [ 9385.242856] dev_ioctl+0xc3/0x520 [ 9385.242866] sock_do_ioctl+0xa0/0xe0 [ 9385.242877] sock_ioctl+0x22f/0x320 [ 9385.242885] __x64_sys_ioctl+0x84/0xc0 [ 9385.242896] do_syscall_64+0x3a/0x80 [ 9385.242904] entry_SYSCALL_64_after_hwframe+0x46/0xb0 [ 9385.242918] RIP: 0033:0x7f93702396db [ 9385.242923] Code: 73 01 c3 48 8b 0d ad 57 38 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa b8 10 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 7d 57 38 00 f7 d8 64 89 01 48 [ 9385.242927] RSP: 002b:00007ffd1fb2bf18 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 [ 9385.242932] RAX: ffffffffffffffda RBX: 000055671b1d2fe0 RCX: 00007f93702396db [ 9385.242935] RDX: 00007ffd1fb2bf20 RSI: 0000000000008946 RDI: 0000000000000007 [ 9385.242937] RBP: 00007ffd1fb2bf20 R08: 0000000000000003 R09: 0030763066307330 [ 9385.242940] R10: 0000000000000000 R11: 0000000000000246 R12: 00007ffd1fb2bf80 [ 9385.242942] R13: 0000000000000007 R14: 0000556719f6de90 R15: 00007ffd1fb2c1b0 [ 9385.242948] </TASK> [ 9385.242949] Modules linked in: iavf(E) xt_CHECKSUM xt_MASQUERADE xt_conntrack ipt_REJECT nft_compat nf_nat_tftp nft_objref nf_conntrack_tftp bridge stp llc nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables rfkill nfnetlink vfat fat irdma ib_uverbs ib_core intel_rapl_msr intel_rapl_common sb_edac x86_pkg_temp_thermal intel_powerclamp coretem ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/541a1af451b0cb3779e915d48d08efb17915207b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b305c7e9363f5a174ee08ac5f056e4b209f0325b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50055,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:34.160,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iavf: Fix adminq error handling iavf_alloc_asq_bufs/iavf_alloc_arq_bufs allocates with dma_alloc_coherent memory for VF mailbox. Free DMA regions for both ASQ and ARQ in case error happens during configuration of ASQ/ARQ registers. Without this change it is possible to see when unloading interface: 74626.583369: dma_debug_device_change: device driver has pending DMA allocations while released from device [count=32] One of leaked entries details: [device address=0x0000000b27ff9000] [size=4096 bytes] [mapped with DMA_BIDIRECTIONAL] [mapped as coherent]",,,"[{""url"":""https://git.kernel.org/stable/c/35c63581fdefdcbaeae8cded18908523252353ad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/419831617ed349992c84344dbd9e627f9e68f842"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4fe80492d53971d9a49f39f3c86d2d67c6f3638a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dab6b551f5ba4c79a0dd4970dd8533c37a7b100f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff289f2be5899efd0e897d2b434a78e36df2c69b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50056,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:34.277,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: Fix missing i_op in ntfs_read_mft There is null pointer dereference because i_op == NULL. The bug happens because we don't initialize i_op for records in $Extend.",,,"[{""url"":""https://git.kernel.org/stable/c/37a530bfe56ca9a0d3129598803f2794c7428aae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8089a1bc27b41e6800590a92d17c119e9aa8ff53"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c293e8abc09e6e1faa50d967bd8862b1cbd575e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50057,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:34.387,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: Fix NULL deref in ntfs_update_mftmirr If ntfs_fill_super() wasn't called then sbi->sb will be equal to NULL. Code should check this ptr before dereferencing. Syzbot hit this issue via passing wrong mount param as can be seen from log below Fail log: ntfs3: Unknown parameter 'iochvrset' general protection fault, probably for non-canonical address 0xdffffc0000000003: 0000 [#1] PREEMPT SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000018-0x000000000000001f] CPU: 1 PID: 3589 Comm: syz-executor210 Not tainted 5.18.0-rc3-syzkaller-00016-gb253435746d9 #0 ... Call Trace: <TASK> put_ntfs+0x1ed/0x2a0 fs/ntfs3/super.c:463 ntfs_fs_free+0x6a/0xe0 fs/ntfs3/super.c:1363 put_fs_context+0x119/0x7a0 fs/fs_context.c:469 do_new_mount+0x2b4/0xad0 fs/namespace.c:3044 do_mount fs/namespace.c:3383 [inline] __do_sys_mount fs/namespace.c:3591 [inline]",,,"[{""url"":""https://git.kernel.org/stable/c/321460ca3b55f48b3ba6008248264ab2bd6407d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e8e1a84dac7a3d2b432162a70d7fb6a75960772"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf6089dc01ba3194ab962105d7b85690843c256f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50058,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:34.497,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: vdpa_sim_blk: set number of address spaces and virtqueue groups Commit bda324fd037a (""vdpasim: control virtqueue support"") added two new fields (nas, ngroups) to vdpasim_dev_attr, but we forgot to initialize them for vdpa_sim_blk. When creating a new vdpa_sim_blk device this causes the kernel to panic in this way: $ vdpa dev add mgmtdev vdpasim_blk name blk0 BUG: kernel NULL pointer dereference, address: 0000000000000030 ... RIP: 0010:vhost_iotlb_add_range_ctx+0x41/0x220 [vhost_iotlb] ... Call Trace: <TASK> vhost_iotlb_add_range+0x11/0x800 [vhost_iotlb] vdpasim_map_range+0x91/0xd0 [vdpa_sim] vdpasim_alloc_coherent+0x56/0x90 [vdpa_sim] ... This happens because vdpasim->iommu[0] is not initialized when dev_attr.nas is 0. Let's fix this issue by initializing both (nas, ngroups) to 1 for vdpa_sim_blk.",,,"[{""url"":""https://git.kernel.org/stable/c/19cd4a5471b8eaa4bd161b0fdb4567f2fc88d809"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a291c7d289fac2cb13fb2614a9a251afbbd86ce9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50059,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:34.600,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ceph: don't leak snap_rwsem in handle_cap_grant When handle_cap_grant is called on an IMPORT op, then the snap_rwsem is held and the function is expected to release it before returning. It currently fails to do that in all cases which could lead to a deadlock.",,,"[{""url"":""https://git.kernel.org/stable/c/58dd4385577ed7969b80cdc9e2a31575aba6c712"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a090cc69699ec2d11b5e34cee8c61f0d4b0068cb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aee18421bda6bf12a7cba6a3d7751c0e1cfd0094"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f546faa216d0f53a42ca73ba1fd8c48765b22d77"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50060,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:34.710,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: octeontx2-af: Fix mcam entry resource leak The teardown sequence in FLR handler returns if no NIX LF is attached to PF/VF because it indicates that graceful shutdown of resources already happened. But there is a chance of all allocated MCAM entries not being freed by PF/VF. Hence free mcam entries even in case of detached LF.",,,"[{""url"":""https://git.kernel.org/stable/c/3f8fe40ab7730cf8eb6f8b8ff412012f7f6f8f48"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc32347f48111eea8d0165538c92aca92ede83f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc5be2d4f9285efe0d16f1bf00250df91d05d809"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50061,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:34.817,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: pinctrl: nomadik: Fix refcount leak in nmk_pinctrl_dt_subnode_to_map of_parse_phandle() returns a node pointer with refcount incremented, we should use of_node_put() on it when not need anymore. Add missing of_node_put() to avoid refcount leak.""",,,"[{""url"":""https://git.kernel.org/stable/c/4b32e054335ea0ce50967f63a7bfd4db058b14b9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/587ac8ac00a1a9f4572785229d9441870fd7b187"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/78d05103891d3e96144b846fbc39f2cfb3384eae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/81abaab5a4b815c0ed9f4d2c9745777ac5cc395b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9272265f2f76629e1a67e6d49b3a4461b3da1a73"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c26012a1e61c7bbd1b393d3bbae8dffdb6df65bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c35f89a9021fa947ecede0584ae509368a52ec5a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f498542bc703bf1e5c6a1610e1ea493a437f0196"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50062,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:34.930,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: bgmac: Fix a BUG triggered by wrong bytes_compl On one of our machines we got: kernel BUG at lib/dynamic_queue_limits.c:27! Internal error: Oops - BUG: 0 [#1] PREEMPT SMP ARM CPU: 0 PID: 1166 Comm: irq/41-bgmac Tainted: G W O 4.14.275-rt132 #1 Hardware name: BRCM XGS iProc task: ee3415c0 task.stack: ee32a000 PC is at dql_completed+0x168/0x178 LR is at bgmac_poll+0x18c/0x6d8 pc : [<c03b9430>] lr : [<c04b5a18>] psr: 800a0313 sp : ee32be14 ip : 000005ea fp : 00000bd4 r10: ee558500 r9 : c0116298 r8 : 00000002 r7 : 00000000 r6 : ef128810 r5 : 01993267 r4 : 01993851 r3 : ee558000 r2 : 000070e1 r1 : 00000bd4 r0 : ee52c180 Flags: Nzcv IRQs on FIQs on Mode SVC_32 ISA ARM Segment none Control: 12c5387d Table: 8e88c04a DAC: 00000051 Process irq/41-bgmac (pid: 1166, stack limit = 0xee32a210) Stack: (0xee32be14 to 0xee32c000) be00: ee558520 ee52c100 ef128810 be20: 00000000 00000002 c0116298 c04b5a18 00000000 c0a0c8c4 c0951780 00000040 be40: c0701780 ee558500 ee55d520 ef05b340 ef6f9780 ee558520 00000001 00000040 be60: ffffe000 c0a56878 ef6fa040 c0952040 0000012c c0528744 ef6f97b0 fffcfb6a be80: c0a04104 2eda8000 c0a0c4ec c0a0d368 ee32bf44 c0153534 ee32be98 ee32be98 bea0: ee32bea0 ee32bea0 ee32bea8 ee32bea8 00000000 c01462e4 ffffe000 ef6f22a8 bec0: ffffe000 00000008 ee32bee4 c0147430 ffffe000 c094a2a8 00000003 ffffe000 bee0: c0a54528 00208040 0000000c c0a0c8c4 c0a65980 c0124d3c 00000008 ee558520 bf00: c094a23c c0a02080 00000000 c07a9910 ef136970 ef136970 ee30a440 ef136900 bf20: ee30a440 00000001 ef136900 ee30a440 c016d990 00000000 c0108db0 c012500c bf40: ef136900 c016da14 ee30a464 ffffe000 00000001 c016dd14 00000000 c016db28 bf60: ffffe000 ee21a080 ee30a400 00000000 ee32a000 ee30a440 c016dbfc ee25fd70 bf80: ee21a09c c013edcc ee32a000 ee30a400 c013ec7c 00000000 00000000 00000000 bfa0: 00000000 00000000 00000000 c0108470 00000000 00000000 00000000 00000000 bfc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 bfe0: 00000000 00000000 00000000 00000000 00000013 00000000 00000000 00000000 [<c03b9430>] (dql_completed) from [<c04b5a18>] (bgmac_poll+0x18c/0x6d8) [<c04b5a18>] (bgmac_poll) from [<c0528744>] (net_rx_action+0x1c4/0x494) [<c0528744>] (net_rx_action) from [<c0124d3c>] (do_current_softirqs+0x1ec/0x43c) [<c0124d3c>] (do_current_softirqs) from [<c012500c>] (__local_bh_enable+0x80/0x98) [<c012500c>] (__local_bh_enable) from [<c016da14>] (irq_forced_thread_fn+0x84/0x98) [<c016da14>] (irq_forced_thread_fn) from [<c016dd14>] (irq_thread+0x118/0x1c0) [<c016dd14>] (irq_thread) from [<c013edcc>] (kthread+0x150/0x158) [<c013edcc>] (kthread) from [<c0108470>] (ret_from_fork+0x14/0x24) Code: a83f15e0 0200001a 0630a0e1 c3ffffea (f201f0e7) The issue seems similar to commit 90b3b339364c (""net: hisilicon: Fix a BUG trigered by wrong bytes_compl"") and potentially introduced by commit b38c83dd0866 (""bgmac: simplify tx ring index handling""). If there is an RX interrupt between setting ring->end and netdev_sent_queue() we can hit the BUG_ON as bgmac_dma_tx_free() can miscalculate the queue size while called from bgmac_poll(). The machine which triggered the BUG runs a v4.14 RT kernel - but the issue seems present in mainline too.",,,"[{""url"":""https://git.kernel.org/stable/c/1b7680c6c1f6de9904f1d9b05c952f0c64a03350"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ab2b55bb25db289ba0b68e3d58494476bdb1041d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac6d4482f29ab992b605c1b4bd1347f1f679f4e4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c506c9a97120f43257e9b3ce7b1f9a24eafc3787"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da1421a29d3b8681ba6a7f686bd0b40dda5acaf3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50063,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:35.047,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: dsa: felix: suppress non-changes to the tagging protocol The way in which dsa_tree_change_tag_proto() works is that when dsa_tree_notify() fails, it doesn't know whether the operation failed mid way in a multi-switch tree, or it failed for a single-switch tree. So even though drivers need to fail cleanly in ds->ops->change_tag_protocol(), DSA will still call dsa_tree_notify() again, to restore the old tag protocol for potential switches in the tree where the change did succeeed (before failing for others). This means for the felix driver that if we report an error in felix_change_tag_protocol(), we'll get another call where proto_ops == old_proto_ops. If we proceed to act upon that, we may do unexpected things. For example, we will call dsa_tag_8021q_register() twice in a row, without any dsa_tag_8021q_unregister() in between. Then we will actually call dsa_tag_8021q_unregister() via old_proto_ops->teardown, which (if it manages to run at all, after walking through corrupted data structures) will leave the ports inoperational anyway. The bug can be readily reproduced if we force an error while in tag_8021q mode; this crashes the kernel. echo ocelot-8021q > /sys/class/net/eno2/dsa/tagging echo edsa > /sys/class/net/eno2/dsa/tagging # -EPROTONOSUPPORT Unable to handle kernel NULL pointer dereference at virtual address 0000000000000014 Call trace: vcap_entry_get+0x24/0x124 ocelot_vcap_filter_del+0x198/0x270 felix_tag_8021q_vlan_del+0xd4/0x21c dsa_switch_tag_8021q_vlan_del+0x168/0x2cc dsa_switch_event+0x68/0x1170 dsa_tree_notify+0x14/0x34 dsa_port_tag_8021q_vlan_del+0x84/0x110 dsa_tag_8021q_unregister+0x15c/0x1c0 felix_tag_8021q_teardown+0x16c/0x180 felix_change_tag_protocol+0x1bc/0x230 dsa_switch_event+0x14c/0x1170 dsa_tree_change_tag_proto+0x118/0x1c0",,,"[{""url"":""https://git.kernel.org/stable/c/4c46bb49460ee14c69629e813640d8b929e88941"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e432f157c3edc5a97a7244c666589a438f5e4d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50064,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:35.157,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: virtio-blk: Avoid use-after-free on suspend/resume hctx->user_data is set to vq in virtblk_init_hctx(). However, vq is freed on suspend and reallocated on resume. So, hctx->user_data is invalid after resume, and it will cause use-after-free accessing which will result in the kernel crash something like below: [ 22.428391] Call Trace: [ 22.428899] <TASK> [ 22.429339] virtqueue_add_split+0x3eb/0x620 [ 22.430035] ? __blk_mq_alloc_requests+0x17f/0x2d0 [ 22.430789] ? kvm_clock_get_cycles+0x14/0x30 [ 22.431496] virtqueue_add_sgs+0xad/0xd0 [ 22.432108] virtblk_add_req+0xe8/0x150 [ 22.432692] virtio_queue_rqs+0xeb/0x210 [ 22.433330] blk_mq_flush_plug_list+0x1b8/0x280 [ 22.434059] __blk_flush_plug+0xe1/0x140 [ 22.434853] blk_finish_plug+0x20/0x40 [ 22.435512] read_pages+0x20a/0x2e0 [ 22.436063] ? folio_add_lru+0x62/0xa0 [ 22.436652] page_cache_ra_unbounded+0x112/0x160 [ 22.437365] filemap_get_pages+0xe1/0x5b0 [ 22.437964] ? context_to_sid+0x70/0x100 [ 22.438580] ? sidtab_context_to_sid+0x32/0x400 [ 22.439979] filemap_read+0xcd/0x3d0 [ 22.440917] xfs_file_buffered_read+0x4a/0xc0 [ 22.441984] xfs_file_read_iter+0x65/0xd0 [ 22.442970] __kernel_read+0x160/0x2e0 [ 22.443921] bprm_execve+0x21b/0x640 [ 22.444809] do_execveat_common.isra.0+0x1a8/0x220 [ 22.446008] __x64_sys_execve+0x2d/0x40 [ 22.446920] do_syscall_64+0x37/0x90 [ 22.447773] entry_SYSCALL_64_after_hwframe+0x63/0xcd This patch fixes this issue by getting vq from vblk, and removes virtblk_init_hctx().",,,"[{""url"":""https://git.kernel.org/stable/c/2b54e14535bc34bf649372060d518ec9f2b893b3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8d12ec10292877751ee4463b11a63bd850bc09b5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50065,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:35.267,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: virtio_net: fix memory leak inside XPD_TX with mergeable When we call xdp_convert_buff_to_frame() to get xdpf, if it returns NULL, we should check if xdp_page was allocated by xdp_linearize_page(). If it is newly allocated, it should be freed here alone. Just like any other ""goto err_xdp"".",,,"[{""url"":""https://git.kernel.org/stable/c/18e383afbd7047af7b055df6e25436e0ce28f8a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7a542bee27c6a57e45c33cbbdc963325fd6493af"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3723eab11196475ef83279571b2b0bd0924cf82"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/faafa2a87f697ee537c29446097e1cc3143506fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50066,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:35.377,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: atlantic: fix aq_vec index out of range error The final update statement of the for loop exceeds the array range, the dereference of self->aq_vec[i] is not checked and then leads to the index out of range error. Also fixed this kind of coding style in other for loop. [ 97.937604] UBSAN: array-index-out-of-bounds in drivers/net/ethernet/aquantia/atlantic/aq_nic.c:1404:48 [ 97.937607] index 8 is out of range for type 'aq_vec_s *[8]' [ 97.937608] CPU: 38 PID: 3767 Comm: kworker/u256:18 Not tainted 5.19.0+ #2 [ 97.937610] Hardware name: Dell Inc. Precision 7865 Tower/, BIOS 1.0.0 06/12/2022 [ 97.937611] Workqueue: events_unbound async_run_entry_fn [ 97.937616] Call Trace: [ 97.937617] <TASK> [ 97.937619] dump_stack_lvl+0x49/0x63 [ 97.937624] dump_stack+0x10/0x16 [ 97.937626] ubsan_epilogue+0x9/0x3f [ 97.937627] __ubsan_handle_out_of_bounds.cold+0x44/0x49 [ 97.937629] ? __scm_send+0x348/0x440 [ 97.937632] ? aq_vec_stop+0x72/0x80 [atlantic] [ 97.937639] aq_nic_stop+0x1b6/0x1c0 [atlantic] [ 97.937644] aq_suspend_common+0x88/0x90 [atlantic] [ 97.937648] aq_pm_suspend_poweroff+0xe/0x20 [atlantic] [ 97.937653] pci_pm_suspend+0x7e/0x1a0 [ 97.937655] ? pci_pm_suspend_noirq+0x2b0/0x2b0 [ 97.937657] dpm_run_callback+0x54/0x190 [ 97.937660] __device_suspend+0x14c/0x4d0 [ 97.937661] async_suspend+0x23/0x70 [ 97.937663] async_run_entry_fn+0x33/0x120 [ 97.937664] process_one_work+0x21f/0x3f0 [ 97.937666] worker_thread+0x4a/0x3c0 [ 97.937668] ? process_one_work+0x3f0/0x3f0 [ 97.937669] kthread+0xf0/0x120 [ 97.937671] ? kthread_complete_and_exit+0x20/0x20 [ 97.937672] ret_from_fork+0x22/0x30 [ 97.937676] </TASK> v2. fixed ""warning: variable 'aq_vec' set but not used"" v3. simplified a for loop",,,"[{""url"":""https://git.kernel.org/stable/c/23bf155476539354ab5c8cc9bb460fd1209b39b5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2ba5e47fb75fbb8fab45f5c1bc8d5c33d8834bd3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/422a02a771599cac96f2b2900d993e0bb7ba5b88"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/df60c534d4c5a681172952dd4b475a5d818b3a86"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50067,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:35.490,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: unset reloc control if transaction commit fails in prepare_to_relocate() In btrfs_relocate_block_group(), the rc is allocated. Then btrfs_relocate_block_group() calls relocate_block_group() prepare_to_relocate() set_reloc_control() that assigns rc to the variable fs_info->reloc_ctl. When prepare_to_relocate() returns, it calls btrfs_commit_transaction() btrfs_start_dirty_block_groups() btrfs_alloc_path() kmem_cache_zalloc() which may fail for example (or other errors could happen). When the failure occurs, btrfs_relocate_block_group() detects the error and frees rc and doesn't set fs_info->reloc_ctl to NULL. After that, in btrfs_init_reloc_root(), rc is retrieved from fs_info->reloc_ctl and then used, which may cause a use-after-free bug. This possible bug can be triggered by calling btrfs_ioctl_balance() before calling btrfs_ioctl_defrag(). To fix this possible bug, in prepare_to_relocate(), check if btrfs_commit_transaction() fails. If the failure occurs, unset_reloc_control() is called to set fs_info->reloc_ctl to NULL. The error log in our fault-injection testing is shown as follows: [ 58.751070] BUG: KASAN: use-after-free in btrfs_init_reloc_root+0x7ca/0x920 [btrfs] ... [ 58.753577] Call Trace: ... [ 58.755800] kasan_report+0x45/0x60 [ 58.756066] btrfs_init_reloc_root+0x7ca/0x920 [btrfs] [ 58.757304] record_root_in_trans+0x792/0xa10 [btrfs] [ 58.757748] btrfs_record_root_in_trans+0x463/0x4f0 [btrfs] [ 58.758231] start_transaction+0x896/0x2950 [btrfs] [ 58.758661] btrfs_defrag_root+0x250/0xc00 [btrfs] [ 58.759083] btrfs_ioctl_defrag+0x467/0xa00 [btrfs] [ 58.759513] btrfs_ioctl+0x3c95/0x114e0 [btrfs] ... [ 58.768510] Allocated by task 23683: [ 58.768777] ____kasan_kmalloc+0xb5/0xf0 [ 58.769069] __kmalloc+0x227/0x3d0 [ 58.769325] alloc_reloc_control+0x10a/0x3d0 [btrfs] [ 58.769755] btrfs_relocate_block_group+0x7aa/0x1e20 [btrfs] [ 58.770228] btrfs_relocate_chunk+0xf1/0x760 [btrfs] [ 58.770655] __btrfs_balance+0x1326/0x1f10 [btrfs] [ 58.771071] btrfs_balance+0x3150/0x3d30 [btrfs] [ 58.771472] btrfs_ioctl_balance+0xd84/0x1410 [btrfs] [ 58.771902] btrfs_ioctl+0x4caa/0x114e0 [btrfs] ... [ 58.773337] Freed by task 23683: ... [ 58.774815] kfree+0xda/0x2b0 [ 58.775038] free_reloc_control+0x1d6/0x220 [btrfs] [ 58.775465] btrfs_relocate_block_group+0x115c/0x1e20 [btrfs] [ 58.775944] btrfs_relocate_chunk+0xf1/0x760 [btrfs] [ 58.776369] __btrfs_balance+0x1326/0x1f10 [btrfs] [ 58.776784] btrfs_balance+0x3150/0x3d30 [btrfs] [ 58.777185] btrfs_ioctl_balance+0xd84/0x1410 [btrfs] [ 58.777621] btrfs_ioctl+0x4caa/0x114e0 [btrfs] ...",,,"[{""url"":""https://git.kernel.org/stable/c/5d741afed0bac206640cc64d77b97853283cf719"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/78f8c2370e3d33e35f23bdc648653d779aeacb6e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/85f02d6c856b9f3a0acf5219de6e32f58b9778eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e546674031fc1576da501e27a8fd165222e5a37"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b60e862e133f646f19023ece1d476d630a660de1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dcb11fe0a0a9cca2b7425191b9bf30dc29f2ad0f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff0e8ed8dfb584575cffc1561f17a1d094e8565b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50068,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:35.620,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/ttm: Fix dummy res NULL ptr deref bug Check the bo->resource value before accessing the resource mem_type. v2: Fix commit description unwrapped warning <log snip> [ 40.191227][ T184] general protection fault, probably for non-canonical address 0xdffffc0000000002: 0000 [#1] SMP KASAN PTI [ 40.192995][ T184] KASAN: null-ptr-deref in range [0x0000000000000010-0x0000000000000017] [ 40.194411][ T184] CPU: 1 PID: 184 Comm: systemd-udevd Not tainted 5.19.0-rc4-00721-gb297c22b7070 #1 [ 40.196063][ T184] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.0-debian-1.16.0-4 04/01/2014 [ 40.199605][ T184] RIP: 0010:ttm_bo_validate+0x1b3/0x240 [ttm] [ 40.200754][ T184] Code: e8 72 c5 ff ff 83 f8 b8 74 d4 85 c0 75 54 49 8b 9e 58 01 00 00 48 b8 00 00 00 00 00 fc ff df 48 8d 7b 10 48 89 fa 48 c1 ea 03 <0f> b6 04 02 84 c0 74 04 3c 03 7e 44 8b 53 10 31 c0 85 d2 0f 85 58 [ 40.203685][ T184] RSP: 0018:ffffc900006df0c8 EFLAGS: 00010202 [ 40.204630][ T184] RAX: dffffc0000000000 RBX: 0000000000000000 RCX: 1ffff1102f4bb71b [ 40.205864][ T184] RDX: 0000000000000002 RSI: ffffc900006df208 RDI: 0000000000000010 [ 40.207102][ T184] RBP: 1ffff920000dbe1a R08: ffffc900006df208 R09: 0000000000000000 [ 40.208394][ T184] R10: ffff88817a5f0000 R11: 0000000000000001 R12: ffffc900006df110 [ 40.209692][ T184] R13: ffffc900006df0f0 R14: ffff88817a5db800 R15: ffffc900006df208 [ 40.210862][ T184] FS: 00007f6b1d16e8c0(0000) GS:ffff88839d700000(0000) knlGS:0000000000000000 [ 40.212250][ T184] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 40.213275][ T184] CR2: 000055a1001d4ff0 CR3: 00000001700f4000 CR4: 00000000000006e0 [ 40.214469][ T184] Call Trace: [ 40.214974][ T184] <TASK> [ 40.215438][ T184] ? ttm_bo_bounce_temp_buffer+0x140/0x140 [ttm] [ 40.216572][ T184] ? mutex_spin_on_owner+0x240/0x240 [ 40.217456][ T184] ? drm_vma_offset_add+0xaa/0x100 [drm] [ 40.218457][ T184] ttm_bo_init_reserved+0x3d6/0x540 [ttm] [ 40.219410][ T184] ? shmem_get_inode+0x744/0x980 [ 40.220231][ T184] ttm_bo_init_validate+0xb1/0x200 [ttm] [ 40.221172][ T184] ? bo_driver_evict_flags+0x340/0x340 [drm_vram_helper] [ 40.222530][ T184] ? ttm_bo_init_reserved+0x540/0x540 [ttm] [ 40.223643][ T184] ? __do_sys_finit_module+0x11a/0x1c0 [ 40.224654][ T184] ? __shmem_file_setup+0x102/0x280 [ 40.234764][ T184] drm_gem_vram_create+0x305/0x480 [drm_vram_helper] [ 40.235766][ T184] ? bo_driver_evict_flags+0x340/0x340 [drm_vram_helper] [ 40.236846][ T184] ? __kasan_slab_free+0x108/0x180 [ 40.237650][ T184] drm_gem_vram_fill_create_dumb+0x134/0x340 [drm_vram_helper] [ 40.238864][ T184] ? local_pci_probe+0xdf/0x180 [ 40.239674][ T184] ? drmm_vram_helper_init+0x400/0x400 [drm_vram_helper] [ 40.240826][ T184] drm_client_framebuffer_create+0x19c/0x400 [drm] [ 40.241955][ T184] ? drm_client_buffer_delete+0x200/0x200 [drm] [ 40.243001][ T184] ? drm_client_pick_crtcs+0x554/0xb80 [drm] [ 40.244030][ T184] drm_fb_helper_generic_probe+0x23f/0x940 [drm_kms_helper] [ 40.245226][ T184] ? __cond_resched+0x1c/0xc0 [ 40.245987][ T184] ? drm_fb_helper_memory_range_to_clip+0x180/0x180 [drm_kms_helper] [ 40.247316][ T184] ? mutex_unlock+0x80/0x100 [ 40.248005][ T184] ? __mutex_unlock_slowpath+0x2c0/0x2c0 [ 40.249083][ T184] drm_fb_helper_single_fb_probe+0x907/0xf00 [drm_kms_helper] [ 40.250314][ T184] ? drm_fb_helper_check_var+0x1180/0x1180 [drm_kms_helper] [ 40.251540][ T184] ? __cond_resched+0x1c/0xc0 [ 40.252321][ T184] ? mutex_lock+0x9f/0x100 [ 40.253062][ T184] __drm_fb_helper_initial_config_and_unlock+0xb9/0x2c0 [drm_kms_helper] [ 40.254394][ T184] drm_fbdev_client_hotplug+0x56f/0x840 [drm_kms_helper] [ 40.255477][ T184] drm_fbdev_generic_setup+0x165/0x3c0 [drm_kms_helper] [ 40.256607][ T184] bochs_pci_probe+0x6b7/0x900 [bochs] [ ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/76672cd326c146ded2c2712ff257b8908dcf23d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9bd970d4097287778a4449452e70b35d0bfaa3aa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cf4b7387c0a842d64bdd7c353e6d3298174a7740"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50069,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:35.733,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: BPF: Fix potential bad pointer dereference in bpf_sys_bpf() The bpf_sys_bpf() helper function allows an eBPF program to load another eBPF program from within the kernel. In this case the argument union bpf_attr pointer (as well as the insns and license pointers inside) is a kernel address instead of a userspace address (which is the case of a usual bpf() syscall). To make the memory copying process in the syscall work in both cases, bpfptr_t was introduced to wrap around the pointer and distinguish its origin. Specifically, when copying memory contents from a bpfptr_t, a copy_from_user() is performed in case of a userspace address and a memcpy() is performed for a kernel address. This can lead to problems because the in-kernel pointer is never checked for validity. The problem happens when an eBPF syscall program tries to call bpf_sys_bpf() to load a program but provides a bad insns pointer -- say 0xdeadbeef -- in the bpf_attr union. The helper calls __sys_bpf() which would then call bpf_prog_load() to load the program. bpf_prog_load() is responsible for copying the eBPF instructions to the newly allocated memory for the program; it creates a kernel bpfptr_t for insns and invokes copy_from_bpfptr(). Internally, all bpfptr_t operations are backed by the corresponding sockptr_t operations, which performs direct memcpy() on kernel pointers for copy_from/strncpy_from operations. Therefore, the code is always happy to dereference the bad pointer to trigger a un-handle-able page fault and in turn an oops. However, this is not supposed to happen because at that point the eBPF program is already verified and should not cause a memory error. Sample KASAN trace: [ 25.685056][ T228] ================================================================== [ 25.685680][ T228] BUG: KASAN: user-memory-access in copy_from_bpfptr+0x21/0x30 [ 25.686210][ T228] Read of size 80 at addr 00000000deadbeef by task poc/228 [ 25.686732][ T228] [ 25.686893][ T228] CPU: 3 PID: 228 Comm: poc Not tainted 5.19.0-rc7 #7 [ 25.687375][ T228] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS d55cb5a 04/01/2014 [ 25.687991][ T228] Call Trace: [ 25.688223][ T228] <TASK> [ 25.688429][ T228] dump_stack_lvl+0x73/0x9e [ 25.688747][ T228] print_report+0xea/0x200 [ 25.689061][ T228] ? copy_from_bpfptr+0x21/0x30 [ 25.689401][ T228] ? _printk+0x54/0x6e [ 25.689693][ T228] ? _raw_spin_lock_irqsave+0x70/0xd0 [ 25.690071][ T228] ? copy_from_bpfptr+0x21/0x30 [ 25.690412][ T228] kasan_report+0xb5/0xe0 [ 25.690716][ T228] ? copy_from_bpfptr+0x21/0x30 [ 25.691059][ T228] kasan_check_range+0x2bd/0x2e0 [ 25.691405][ T228] ? copy_from_bpfptr+0x21/0x30 [ 25.691734][ T228] memcpy+0x25/0x60 [ 25.692000][ T228] copy_from_bpfptr+0x21/0x30 [ 25.692328][ T228] bpf_prog_load+0x604/0x9e0 [ 25.692653][ T228] ? cap_capable+0xb4/0xe0 [ 25.692956][ T228] ? security_capable+0x4f/0x70 [ 25.693324][ T228] __sys_bpf+0x3af/0x580 [ 25.693635][ T228] bpf_sys_bpf+0x45/0x240 [ 25.693937][ T228] bpf_prog_f0ec79a5a3caca46_bpf_func1+0xa2/0xbd [ 25.694394][ T228] bpf_prog_run_pin_on_cpu+0x2f/0xb0 [ 25.694756][ T228] bpf_prog_test_run_syscall+0x146/0x1c0 [ 25.695144][ T228] bpf_prog_test_run+0x172/0x190 [ 25.695487][ T228] __sys_bpf+0x2c5/0x580 [ 25.695776][ T228] __x64_sys_bpf+0x3a/0x50 [ 25.696084][ T228] do_syscall_64+0x60/0x90 [ 25.696393][ T228] ? fpregs_assert_state_consistent+0x50/0x60 [ 25.696815][ T228] ? exit_to_user_mode_prepare+0x36/0xa0 [ 25.697202][ T228] ? syscall_exit_to_user_mode+0x20/0x40 [ 25.697586][ T228] ? do_syscall_64+0x6e/0x90 [ 25.697899][ T228] entry_SYSCALL_64_after_hwframe+0x63/0xcd [ 25.698312][ T228] RIP: 0033:0x7f6d543fb759 [ 25.698624][ T228] Code: 08 5b 89 e8 5d c3 66 2e 0f 1f 84 00 00 00 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/1f6db7148ed7382b336c5827af33b5d9e992630e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/41fd6cc88aaf7058b9dfc9c7a09cc80f99c8c830"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e2dcac2f58f5a95ab092d1da237ffdc0da1832cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50070,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:35.843,2025-08-28T15:15:37.713,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mptcp: do not queue data on closed subflows Dipanjan reported a syzbot splat at close time: WARNING: CPU: 1 PID: 10818 at net/ipv4/af_inet.c:153 inet_sock_destruct+0x6d0/0x8e0 net/ipv4/af_inet.c:153 Modules linked in: uio_ivshmem(OE) uio(E) CPU: 1 PID: 10818 Comm: kworker/1:16 Tainted: G OE 5.19.0-rc6-g2eae0556bb9d #2 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014 Workqueue: events mptcp_worker RIP: 0010:inet_sock_destruct+0x6d0/0x8e0 net/ipv4/af_inet.c:153 Code: 21 02 00 00 41 8b 9c 24 28 02 00 00 e9 07 ff ff ff e8 34 4d 91 f9 89 ee 4c 89 e7 e8 4a 47 60 ff e9 a6 fc ff ff e8 20 4d 91 f9 <0f> 0b e9 84 fe ff ff e8 14 4d 91 f9 0f 0b e9 d4 fd ff ff e8 08 4d RSP: 0018:ffffc9001b35fa78 EFLAGS: 00010246 RAX: 0000000000000000 RBX: 00000000002879d0 RCX: ffff8881326f3b00 RDX: 0000000000000000 RSI: ffff8881326f3b00 RDI: 0000000000000002 RBP: ffff888179662674 R08: ffffffff87e983a0 R09: 0000000000000000 R10: 0000000000000005 R11: 00000000000004ea R12: ffff888179662400 R13: ffff888179662428 R14: 0000000000000001 R15: ffff88817e38e258 FS: 0000000000000000(0000) GS:ffff8881f5f00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000020007bc0 CR3: 0000000179592000 CR4: 0000000000150ee0 Call Trace: <TASK> __sk_destruct+0x4f/0x8e0 net/core/sock.c:2067 sk_destruct+0xbd/0xe0 net/core/sock.c:2112 __sk_free+0xef/0x3d0 net/core/sock.c:2123 sk_free+0x78/0xa0 net/core/sock.c:2134 sock_put include/net/sock.h:1927 [inline] __mptcp_close_ssk+0x50f/0x780 net/mptcp/protocol.c:2351 __mptcp_destroy_sock+0x332/0x760 net/mptcp/protocol.c:2828 mptcp_worker+0x5d2/0xc90 net/mptcp/protocol.c:2586 process_one_work+0x9cc/0x1650 kernel/workqueue.c:2289 worker_thread+0x623/0x1070 kernel/workqueue.c:2436 kthread+0x2e9/0x3a0 kernel/kthread.c:376 ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:302 </TASK> The root cause of the problem is that an mptcp-level (re)transmit can race with mptcp_close() and the packet scheduler checks the subflow state before acquiring the socket lock: we can try to (re)transmit on an already closed ssk. Fix the issue checking again the subflow socket status under the subflow socket lock protection. Additionally add the missing check for the fallback-to-tcp case.",,,"[{""url"":""https://git.kernel.org/stable/c/8caf5c15b5288d52d9c89374d6c10fa32ee84ec5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c886d70286bf3ad411eb3d689328a67f7102c6ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fb9c73ef2ac2ec816efdc8b9267bc04e1369c20b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50071,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:35.950,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mptcp: move subflow cleanup in mptcp_destroy_common() If the mptcp socket creation fails due to a CGROUP_INET_SOCK_CREATE eBPF program, the MPTCP protocol ends-up leaking all the subflows: the related cleanup happens in __mptcp_destroy_sock() that is not invoked in such code path. Address the issue moving the subflow sockets cleanup in the mptcp_destroy_common() helper, which is invoked in every msk cleanup path. Additionally get rid of the intermediate list_splice_init step, which is an unneeded relic from the past. The issue is present since before the reported root cause commit, but any attempt to backport the fix before that hash will require a complete rewrite.",,,"[{""url"":""https://git.kernel.org/stable/c/6139039c8fc5c9dbcdc3ad389b9a6d0cacb4d693"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c0bf3c6aa444a5ef44acc57ef6cfa53fd4fc1c9b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50072,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:36.057,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: NFSv4/pnfs: Fix a use-after-free bug in open If someone cancels the open RPC call, then we must not try to free either the open slot or the layoutget operation arguments, since they are likely still in use by the hung RPC call.",,,"[{""url"":""https://git.kernel.org/stable/c/0fffb46ff3d5ed4668aca96441ec7a25b793bd6f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2135e5d56278ffdb1c2e6d325dc6b87f669b9dac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/76ffd2042438769298f34b76102b40dea89de616"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a4cf3dadd1fa43609f7c6570c9116b0e0a9923d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b03d1117e9be7c7da60e466eaf9beed85c5916c8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f7ee3b772d9de87387a725caa04bc041ac7fe5ec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50073,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:36.173,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: tap: NULL pointer derefence in dev_parse_header_protocol when skb->dev is null Fixes a NULL pointer derefence bug triggered from tap driver. When tap_get_user calls virtio_net_hdr_to_skb the skb->dev is null (in tap.c skb->dev is set after the call to virtio_net_hdr_to_skb) virtio_net_hdr_to_skb calls dev_parse_header_protocol which needs skb->dev field to be valid. The line that trigers the bug is in dev_parse_header_protocol (dev is at offset 0x10 from skb and is stored in RAX register) if (!dev->header_ops || !dev->header_ops->parse_protocol) 22e1: mov 0x10(%rbx),%rax 22e5: mov 0x230(%rax),%rax Setting skb->dev before the call in tap.c fixes the issue. BUG: kernel NULL pointer dereference, address: 0000000000000230 RIP: 0010:virtio_net_hdr_to_skb.constprop.0+0x335/0x410 [tap] Code: c0 0f 85 b7 fd ff ff eb d4 41 39 c6 77 cf 29 c6 48 89 df 44 01 f6 e8 7a 79 83 c1 48 85 c0 0f 85 d9 fd ff ff eb b7 48 8b 43 10 <48> 8b 80 30 02 00 00 48 85 c0 74 55 48 8b 40 28 48 85 c0 74 4c 48 RSP: 0018:ffffc90005c27c38 EFLAGS: 00010246 RAX: 0000000000000000 RBX: ffff888298f25300 RCX: 0000000000000010 RDX: 0000000000000005 RSI: ffffc90005c27cb6 RDI: ffff888298f25300 RBP: ffffc90005c27c80 R08: 00000000ffffffea R09: 00000000000007e8 R10: ffff88858ec77458 R11: 0000000000000000 R12: 0000000000000001 R13: 0000000000000014 R14: ffffc90005c27e08 R15: ffffc90005c27cb6 FS: 0000000000000000(0000) GS:ffff88858ec40000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000230 CR3: 0000000281408006 CR4: 00000000003706e0 Call Trace: tap_get_user+0x3f1/0x540 [tap] tap_sendmsg+0x56/0x362 [tap] ? get_tx_bufs+0xc2/0x1e0 [vhost_net] handle_tx_copy+0x114/0x670 [vhost_net] handle_tx+0xb0/0xe0 [vhost_net] handle_tx_kick+0x15/0x20 [vhost_net] vhost_worker+0x7b/0xc0 [vhost] ? vhost_vring_call_reset+0x40/0x40 [vhost] kthread+0xfa/0x120 ? kthread_complete_and_exit+0x20/0x20 ret_from_fork+0x1f/0x30",,,"[{""url"":""https://git.kernel.org/stable/c/4f61f133f354853bc394ec7d6028adb9b02dd701"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dd29648fcf69339713f2d25f7014ae905dcdfc18"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50074,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:36.283,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: apparmor: Fix memleak in aa_simple_write_to_buffer() When copy_from_user failed, the memory is freed by kvfree. however the management struct and data blob are allocated independently, so only kvfree(data) cause a memleak issue here. Use aa_put_loaddata(data) to fix this issue.",,,"[{""url"":""https://git.kernel.org/stable/c/417ea9fe972d2654a268ad66e89c8fcae67017c3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6500eb3a48ac221051b1791818a1ac74744ef617"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6583edbf459de2e06b9759f264c0ae27e452b97a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7db182a2ebeefded86fea542fcc5d6a68bb77f58"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8aab4295582eb397a125d2788b829fa62b88dbf7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf7ebebce2c25071c719fd8a2f1307e0c243c2d7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50075,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:36.397,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tracing/eprobes: Have event probes be consistent with kprobes and uprobes Currently, if a symbol ""@"" is attempted to be used with an event probe (eprobes), it will cause a NULL pointer dereference crash. Both kprobes and uprobes can reference data other than the main registers. Such as immediate address, symbols and the current task name. Have eprobes do the same thing. For ""comm"", if ""comm"" is used and the event being attached to does not have the ""comm"" field, then make it the ""$comm"" that kprobes has. This is consistent to the way histograms and filters work.",,,"[{""url"":""https://git.kernel.org/stable/c/47cc883f21fa3bcf24891b4b455f4cd461ce2d6e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6a832ec3d680b3a4f4fad5752672827d71bae501"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b489aca082a23033a3d8355cfb0032f0e2523440"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50076,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:36.513,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: cifs: Fix memory leak on the deferred close xfstests on smb21 report kmemleak as below: unreferenced object 0xffff8881767d6200 (size 64): comm ""xfs_io"", pid 1284, jiffies 4294777434 (age 20.789s) hex dump (first 32 bytes): 80 5a d0 11 81 88 ff ff 78 8a aa 63 81 88 ff ff .Z......x..c.... 00 71 99 76 81 88 ff ff 00 00 00 00 00 00 00 00 .q.v............ backtrace: [<00000000ad04e6ea>] cifs_close+0x92/0x2c0 [<0000000028b93c82>] __fput+0xff/0x3f0 [<00000000d8116851>] task_work_run+0x85/0xc0 [<0000000027e14f9e>] do_exit+0x5e5/0x1240 [<00000000fb492b95>] do_group_exit+0x58/0xe0 [<00000000129a32d9>] __x64_sys_exit_group+0x28/0x30 [<00000000e3f7d8e9>] do_syscall_64+0x35/0x80 [<00000000102e8a0b>] entry_SYSCALL_64_after_hwframe+0x46/0xb0 When cancel the deferred close work, we should also cleanup the struct cifs_deferred_close.",,,"[{""url"":""https://git.kernel.org/stable/c/60b6d38add7b9c17d6e5d49ee8e930ea1a5650c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/860efae127888ae535bc4eda1b7f27642727c69e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca08d0eac020d48a3141dbec0a3cf64fbdb17cde"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50077,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:36.627,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: apparmor: fix reference count leak in aa_pivotroot() The aa_pivotroot() function has a reference counting bug in a specific path. When aa_replace_current_label() returns on success, the function forgets to decrement the reference count of “target”, which is increased earlier by build_pivotroot(), causing a reference leak. Fix it by decreasing the refcount of “target” in that path.",,,"[{""url"":""https://git.kernel.org/stable/c/11c3627ec6b56c1525013f336f41b79a983b4d46"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2ceeb3296e9dde1d5772348046affcefdea605e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ca40ad7afae144169a43988ef1a3f16182faf0a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/64103ea357734b82384c925cba4758fdb909be0c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d53194707d2a1851be027cd74266b96ceff799d3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ef6fb6f0d0d8440595b45a7e53c6162c737177f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f4d5c7796571624e3f380b447ada52834270a287"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50078,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:36.753,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tracing/eprobes: Do not allow eprobes to use $stack, or % for regs While playing with event probes (eprobes), I tried to see what would happen if I attempted to retrieve the instruction pointer (%rip) knowing that event probes do not use pt_regs. The result was: BUG: kernel NULL pointer dereference, address: 0000000000000024 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 0 P4D 0 Oops: 0000 [#1] PREEMPT SMP PTI CPU: 1 PID: 1847 Comm: trace-cmd Not tainted 5.19.0-rc5-test+ #309 Hardware name: Hewlett-Packard HP Compaq Pro 6300 SFF/339A, BIOS K01 v03.03 07/14/2016 RIP: 0010:get_event_field.isra.0+0x0/0x50 Code: ff 48 c7 c7 c0 8f 74 a1 e8 3d 8b f5 ff e8 88 09 f6 ff 4c 89 e7 e8 50 6a 13 00 48 89 ef 5b 5d 41 5c 41 5d e9 42 6a 13 00 66 90 <48> 63 47 24 8b 57 2c 48 01 c6 8b 47 28 83 f8 02 74 0e 83 f8 04 74 RSP: 0018:ffff916c394bbaf0 EFLAGS: 00010086 RAX: ffff916c854041d8 RBX: ffff916c8d9fbf50 RCX: ffff916c255d2000 RDX: 0000000000000000 RSI: ffff916c255d2008 RDI: 0000000000000000 RBP: 0000000000000000 R08: ffff916c3a2a0c08 R09: ffff916c394bbda8 R10: 0000000000000000 R11: 0000000000000000 R12: ffff916c854041d8 R13: ffff916c854041b0 R14: 0000000000000000 R15: 0000000000000000 FS: 0000000000000000(0000) GS:ffff916c9ea40000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000024 CR3: 000000011b60a002 CR4: 00000000001706e0 Call Trace: <TASK> get_eprobe_size+0xb4/0x640 ? __mod_node_page_state+0x72/0xc0 __eprobe_trace_func+0x59/0x1a0 ? __mod_lruvec_page_state+0xaa/0x1b0 ? page_remove_file_rmap+0x14/0x230 ? page_remove_rmap+0xda/0x170 event_triggers_call+0x52/0xe0 trace_event_buffer_commit+0x18f/0x240 trace_event_raw_event_sched_wakeup_template+0x7a/0xb0 try_to_wake_up+0x260/0x4c0 __wake_up_common+0x80/0x180 __wake_up_common_lock+0x7c/0xc0 do_notify_parent+0x1c9/0x2a0 exit_notify+0x1a9/0x220 do_exit+0x2ba/0x450 do_group_exit+0x2d/0x90 __x64_sys_exit_group+0x14/0x20 do_syscall_64+0x3b/0x90 entry_SYSCALL_64_after_hwframe+0x46/0xb0 Obviously this is not the desired result. Move the testing for TPARG_FL_TPOINT which is only used for event probes to the top of the ""$"" variable check, as all the other variables are not used for event probes. Also add a check in the register parsing ""%"" to fail if an event probe is used.",,,"[{""url"":""https://git.kernel.org/stable/c/2673c60ee67e71f2ebe34386e62d348f71edee47"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c262114a576d94c0ced80e232bbb17391a55908"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba53c21ce9773743b8e0a8ada048c96ff2d55c67"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50079,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:36.873,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check correct bounds for stream encoder instances for DCN303 [Why & How] eng_id for DCN303 cannot be more than 1, since we have only two instances of stream encoders. Check the correct boundary condition for engine ID for DCN303 prevent the potential out of bounds access.",,,"[{""url"":""https://git.kernel.org/stable/c/4c31dca1799612eb3b6413e3e574f90c3fb8f865"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/82a27c1855445d48aacc67b0c0640f3dadebe52f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/89b008222c2bf21e50219725caed31590edfd9d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50080,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:36.980,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tee: add overflow check in register_shm_helper() With special lengths supplied by user space, register_shm_helper() has an integer overflow when calculating the number of pages covered by a supplied user space memory region. This causes internal_get_user_pages_fast() a helper function of pin_user_pages_fast() to do a NULL pointer dereference: Unable to handle kernel NULL pointer dereference at virtual address 0000000000000010 Modules linked in: CPU: 1 PID: 173 Comm: optee_example_a Not tainted 5.19.0 #11 Hardware name: QEMU QEMU Virtual Machine, BIOS 0.0.0 02/06/2015 pc : internal_get_user_pages_fast+0x474/0xa80 Call trace: internal_get_user_pages_fast+0x474/0xa80 pin_user_pages_fast+0x24/0x4c register_shm_helper+0x194/0x330 tee_shm_register_user_buf+0x78/0x120 tee_ioctl+0xd0/0x11a0 __arm64_sys_ioctl+0xa8/0xec invoke_syscall+0x48/0x114 Fix this by adding an an explicit call to access_ok() in tee_shm_register_user_buf() to catch an invalid user space address early.",,,"[{""url"":""https://git.kernel.org/stable/c/2f8e79a1a6128214cb9b205a9869341af5dfb16b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/573ae4f13f630d6660008f1974c0a8a29c30e18a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/578c349570d2a912401963783b36e0ec7a25c053"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/58c008d4d398f792ca67f35650610864725518fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/965333345fe952cc7eebc8e3a565ffc709441af2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b37e0f17653c00b586cdbcdf0dbca475358ecffd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c12f0e6126ad223806a365084e86370511654bf1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50081,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:37.103,2025-06-18T14:15:24.150,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2022-50082,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:37.223,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: fix warning in ext4_iomap_begin as race between bmap and write We got issue as follows: ------------[ cut here ]------------ WARNING: CPU: 3 PID: 9310 at fs/ext4/inode.c:3441 ext4_iomap_begin+0x182/0x5d0 RIP: 0010:ext4_iomap_begin+0x182/0x5d0 RSP: 0018:ffff88812460fa08 EFLAGS: 00010293 RAX: ffff88811f168000 RBX: 0000000000000000 RCX: ffffffff97793c12 RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000003 RBP: ffff88812c669160 R08: ffff88811f168000 R09: ffffed10258cd20f R10: ffff88812c669077 R11: ffffed10258cd20e R12: 0000000000000001 R13: 00000000000000a4 R14: 000000000000000c R15: ffff88812c6691ee FS: 00007fd0d6ff3740(0000) GS:ffff8883af180000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007fd0d6dda290 CR3: 0000000104a62000 CR4: 00000000000006e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: iomap_apply+0x119/0x570 iomap_bmap+0x124/0x150 ext4_bmap+0x14f/0x250 bmap+0x55/0x80 do_vfs_ioctl+0x952/0xbd0 __x64_sys_ioctl+0xc6/0x170 do_syscall_64+0x33/0x40 entry_SYSCALL_64_after_hwframe+0x44/0xa9 Above issue may happen as follows: bmap write bmap ext4_bmap iomap_bmap ext4_iomap_begin ext4_file_write_iter ext4_buffered_write_iter generic_perform_write ext4_da_write_begin ext4_da_write_inline_data_begin ext4_prepare_inline_data ext4_create_inline_data ext4_set_inode_flag(inode, EXT4_INODE_INLINE_DATA); if (WARN_ON_ONCE(ext4_has_inline_data(inode))) ->trigger bug_on To solved above issue hold inode lock in ext4_bamp.",,,"[{""url"":""https://git.kernel.org/stable/c/30dfb75e1f8645404a536c74d468d498adcd4e74"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/51ae846cff568c8c29921b1b28eb2dfbcd4ac12d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9fe6d1e3d343d7309f501b1f48020ce7127221f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e1682c7171a6c0ff576fe8116b8cba5b8f538b94"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa6482f374fda29a71ad44d76d35b4842d43cda4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50083,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:37.340,2025-08-20T15:15:31.010,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2022-50084,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:37.460,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dm raid: fix address sanitizer warning in raid_status There is this warning when using a kernel with the address sanitizer and running this testsuite: https://gitlab.com/cki-project/kernel-tests/-/tree/main/storage/swraid/scsi_raid ================================================================== BUG: KASAN: slab-out-of-bounds in raid_status+0x1747/0x2820 [dm_raid] Read of size 4 at addr ffff888079d2c7e8 by task lvcreate/13319 CPU: 0 PID: 13319 Comm: lvcreate Not tainted 5.18.0-0.rc3.<snip> #1 Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011 Call Trace: <TASK> dump_stack_lvl+0x6a/0x9c print_address_description.constprop.0+0x1f/0x1e0 print_report.cold+0x55/0x244 kasan_report+0xc9/0x100 raid_status+0x1747/0x2820 [dm_raid] dm_ima_measure_on_table_load+0x4b8/0xca0 [dm_mod] table_load+0x35c/0x630 [dm_mod] ctl_ioctl+0x411/0x630 [dm_mod] dm_ctl_ioctl+0xa/0x10 [dm_mod] __x64_sys_ioctl+0x12a/0x1a0 do_syscall_64+0x5b/0x80 The warning is caused by reading conf->max_nr_stripes in raid_status. The code in raid_status reads mddev->private, casts it to struct r5conf and reads the entry max_nr_stripes. However, if we have different raid type than 4/5/6, mddev->private doesn't point to struct r5conf; it may point to struct r0conf, struct r1conf, struct r10conf or struct mpconf. If we cast a pointer to one of these structs to struct r5conf, we will be reading invalid memory and KASAN warns about it. Fix this bug by reading struct r5conf only if raid type is 4, 5 or 6.",,,"[{""url"":""https://git.kernel.org/stable/c/1ae0ebfb576b72c2ef400917a5484ebe7892d80b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1fbeea217d8f297fe0e0956a1516d14ba97d0396"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/49dba30638e091120256a9e89125340795f034dc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c233811a49578634d10a5e70a9dfa569d451e94"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90b006da40dd42285b24dd3c940d2c32aca9a70b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b4c6c07c92b6cba2bf3cb2dfa722debeaf8a8abe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b856ce5f4b55f752144baf17e9d5c415072652c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cb583ca6125ac64c98e9d65128e95ebb5be7d322"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d8971b595d7adac3421c21f59918241f1574061e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50085,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:37.577,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dm raid: fix address sanitizer warning in raid_resume There is a KASAN warning in raid_resume when running the lvm test lvconvert-raid.sh. The reason for the warning is that mddev->raid_disks is greater than rs->raid_disks, so the loop touches one entry beyond the allocated length.",,,"[{""url"":""https://git.kernel.org/stable/c/2a9faa704d83ff0b04387e385efd8ae21cd95af6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3bfdc95466f5be4d8d95db5a5b470d61641a7c24"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/50235d9a1f1f742619ed9963cb9f240e5b821d46"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/71f601c779b3cc1baf497796f5b922c3fe5d2a1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74af83732a39ab7d3bc9b49219a535853e25679f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7dad24db59d2d2803576f2e3645728866a056dab"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c2d47bef93fb74aa97d90f9a40ca657b8f376083"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c2f075e729636a44e98d9722e3852c2fa6fa49b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50086,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:37.690,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: block: don't allow the same type rq_qos add more than once In our test of iocost, we encountered some list add/del corruptions of inner_walk list in ioc_timer_fn. The reason can be described as follows: cpu 0 cpu 1 ioc_qos_write ioc_qos_write ioc = q_to_ioc(queue); if (!ioc) { ioc = kzalloc(); ioc = q_to_ioc(queue); if (!ioc) { ioc = kzalloc(); ... rq_qos_add(q, rqos); } ... rq_qos_add(q, rqos); ... } When the io.cost.qos file is written by two cpus concurrently, rq_qos may be added to one disk twice. In that case, there will be two iocs enabled and running on one disk. They own different iocgs on their active list. In the ioc_timer_fn function, because of the iocgs from two iocs have the same root iocg, the root iocg's walk_list may be overwritten by each other and this leads to list add/del corruptions in building or destroying the inner_walk list. And so far, the blk-rq-qos framework works in case that one instance for one type rq_qos per queue by default. This patch make this explicit and also fix the crash above.",,,"[{""url"":""https://git.kernel.org/stable/c/08ef66e800a85afc6b54cb95841f6502627eee2e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0b7f5d7a4d2a72ad9de04ab8ccba2a31904aa638"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0c9bb1acd1d103a3070b2126870eb52761d606ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/14a6e2eb7df5c7897c15b109cba29ab0c4a791b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50087,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:37.803,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: firmware: arm_scpi: Ensure scpi_info is not assigned if the probe fails When scpi probe fails, at any point, we need to ensure that the scpi_info is not set and will remain NULL until the probe succeeds. If it is not taken care, then it could result use-after-free as the value is exported via get_scpi_ops() and could refer to a memory allocated via devm_kzalloc() but freed when the probe fails.",,,"[{""url"":""https://git.kernel.org/stable/c/08272646cd7c310642c39b7f54348fddd7987643"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0c29e149b6bb498778ed8a1c9597b51acfba7856"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/18048cba444a7c41dbf42c180d6b46606fc24c51"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4f2d7b46d6b53c07f44a4f8f8f4438888f0e9e87"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5aa558232edc30468d1f35108826dd5b3ffe978f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/689640efc0a2c4e07e6f88affe6d42cd40cc3f85"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/87c4896d5dd7fd9927c814cf3c6289f41de3b562"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50088,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:37.917,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm/damon/reclaim: fix potential memory leak in damon_reclaim_init() damon_reclaim_init() allocates a memory chunk for ctx with damon_new_ctx(). When damon_select_ops() fails, ctx is not released, which will lead to a memory leak. We should release the ctx with damon_destroy_ctx() when damon_select_ops() fails to fix the memory leak.",,,"[{""url"":""https://git.kernel.org/stable/c/188043c7f4f2bd662f2a55957d684fffa543e600"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/700aa4e11a3c4d2a44d06758db431a013d9e1b61"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d3e9e1e0856f4c905bbb870f16f42ae72477071"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50089,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:38.023,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: ensure pages are unlocked on cow_file_range() failure There is a hung_task report on zoned btrfs like below. https://github.com/naota/linux/issues/59 [726.328648] INFO: task rocksdb:high0:11085 blocked for more than 241 seconds. [726.329839] Not tainted 5.16.0-rc1+ #1 [726.330484] ""echo 0 > /proc/sys/kernel/hung_task_timeout_secs"" disables this message. [726.331603] task:rocksdb:high0 state:D stack: 0 pid:11085 ppid: 11082 flags:0x00000000 [726.331608] Call Trace: [726.331611] <TASK> [726.331614] __schedule+0x2e5/0x9d0 [726.331622] schedule+0x58/0xd0 [726.331626] io_schedule+0x3f/0x70 [726.331629] __folio_lock+0x125/0x200 [726.331634] ? find_get_entries+0x1bc/0x240 [726.331638] ? filemap_invalidate_unlock_two+0x40/0x40 [726.331642] truncate_inode_pages_range+0x5b2/0x770 [726.331649] truncate_inode_pages_final+0x44/0x50 [726.331653] btrfs_evict_inode+0x67/0x480 [726.331658] evict+0xd0/0x180 [726.331661] iput+0x13f/0x200 [726.331664] do_unlinkat+0x1c0/0x2b0 [726.331668] __x64_sys_unlink+0x23/0x30 [726.331670] do_syscall_64+0x3b/0xc0 [726.331674] entry_SYSCALL_64_after_hwframe+0x44/0xae [726.331677] RIP: 0033:0x7fb9490a171b [726.331681] RSP: 002b:00007fb943ffac68 EFLAGS: 00000246 ORIG_RAX: 0000000000000057 [726.331684] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fb9490a171b [726.331686] RDX: 00007fb943ffb040 RSI: 000055a6bbe6ec20 RDI: 00007fb94400d300 [726.331687] RBP: 00007fb943ffad00 R08: 0000000000000000 R09: 0000000000000000 [726.331688] R10: 0000000000000031 R11: 0000000000000246 R12: 00007fb943ffb000 [726.331690] R13: 00007fb943ffb040 R14: 0000000000000000 R15: 00007fb943ffd260 [726.331693] </TASK> While we debug the issue, we found running fstests generic/551 on 5GB non-zoned null_blk device in the emulated zoned mode also had a similar hung issue. Also, we can reproduce the same symptom with an error injected cow_file_range() setup. The hang occurs when cow_file_range() fails in the middle of allocation. cow_file_range() called from do_allocation_zoned() can split the give region ([start, end]) for allocation depending on current block group usages. When btrfs can allocate bytes for one part of the split regions but fails for the other region (e.g. because of -ENOSPC), we return the error leaving the pages in the succeeded regions locked. Technically, this occurs only when @unlock == 0. Otherwise, we unlock the pages in an allocated region after creating an ordered extent. Considering the callers of cow_file_range(unlock=0) won't write out the pages, we can unlock the pages on error exit from cow_file_range(). So, we can ensure all the pages except @locked_page are unlocked on error case. In summary, cow_file_range now behaves like this: - page_started == 1 (return value) - All the pages are unlocked. IO is started. - unlock == 1 - All the pages except @locked_page are unlocked in any case - unlock == 0 - On success, all the pages are locked for writing out them - On failure, all the pages except @locked_page are unlocked",,,"[{""url"":""https://git.kernel.org/stable/c/9535ec371d741fa037e37eddc0a5b25ba82d0027"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ce7466f372d83054c7494f6b3e4b9abaf3f0355"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b367f125c80fa838eae49e3b138dc67dfc9f46ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e160aa87c87a9c4e0c8d1430235f715a3a91e2cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50090,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:38.153,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: replace BTRFS_MAX_EXTENT_SIZE with fs_info->max_extent_size On zoned filesystem, data write out is limited by max_zone_append_size, and a large ordered extent is split according the size of a bio. OTOH, the number of extents to be written is calculated using BTRFS_MAX_EXTENT_SIZE, and that estimated number is used to reserve the metadata bytes to update and/or create the metadata items. The metadata reservation is done at e.g, btrfs_buffered_write() and then released according to the estimation changes. Thus, if the number of extent increases massively, the reserved metadata can run out. The increase of the number of extents easily occurs on zoned filesystem if BTRFS_MAX_EXTENT_SIZE > max_zone_append_size. And, it causes the following warning on a small RAM environment with disabling metadata over-commit (in the following patch). [75721.498492] ------------[ cut here ]------------ [75721.505624] BTRFS: block rsv 1 returned -28 [75721.512230] WARNING: CPU: 24 PID: 2327559 at fs/btrfs/block-rsv.c:537 btrfs_use_block_rsv+0x560/0x760 [btrfs] [75721.581854] CPU: 24 PID: 2327559 Comm: kworker/u64:10 Kdump: loaded Tainted: G W 5.18.0-rc2-BTRFS-ZNS+ #109 [75721.597200] Hardware name: Supermicro Super Server/H12SSL-NT, BIOS 2.0 02/22/2021 [75721.607310] Workqueue: btrfs-endio-write btrfs_work_helper [btrfs] [75721.616209] RIP: 0010:btrfs_use_block_rsv+0x560/0x760 [btrfs] [75721.646649] RSP: 0018:ffffc9000fbdf3e0 EFLAGS: 00010286 [75721.654126] RAX: 0000000000000000 RBX: 0000000000004000 RCX: 0000000000000000 [75721.663524] RDX: 0000000000000004 RSI: 0000000000000008 RDI: fffff52001f7be6e [75721.672921] RBP: ffffc9000fbdf420 R08: 0000000000000001 R09: ffff889f8d1fc6c7 [75721.682493] R10: ffffed13f1a3f8d8 R11: 0000000000000001 R12: ffff88980a3c0e28 [75721.692284] R13: ffff889b66590000 R14: ffff88980a3c0e40 R15: ffff88980a3c0e8a [75721.701878] FS: 0000000000000000(0000) GS:ffff889f8d000000(0000) knlGS:0000000000000000 [75721.712601] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [75721.720726] CR2: 000055d12e05c018 CR3: 0000800193594000 CR4: 0000000000350ee0 [75721.730499] Call Trace: [75721.735166] <TASK> [75721.739886] btrfs_alloc_tree_block+0x1e1/0x1100 [btrfs] [75721.747545] ? btrfs_alloc_logged_file_extent+0x550/0x550 [btrfs] [75721.756145] ? btrfs_get_32+0xea/0x2d0 [btrfs] [75721.762852] ? btrfs_get_32+0xea/0x2d0 [btrfs] [75721.769520] ? push_leaf_left+0x420/0x620 [btrfs] [75721.776431] ? memcpy+0x4e/0x60 [75721.781931] split_leaf+0x433/0x12d0 [btrfs] [75721.788392] ? btrfs_get_token_32+0x580/0x580 [btrfs] [75721.795636] ? push_for_double_split.isra.0+0x420/0x420 [btrfs] [75721.803759] ? leaf_space_used+0x15d/0x1a0 [btrfs] [75721.811156] btrfs_search_slot+0x1bc3/0x2790 [btrfs] [75721.818300] ? lock_downgrade+0x7c0/0x7c0 [75721.824411] ? free_extent_buffer.part.0+0x107/0x200 [btrfs] [75721.832456] ? split_leaf+0x12d0/0x12d0 [btrfs] [75721.839149] ? free_extent_buffer.part.0+0x14f/0x200 [btrfs] [75721.846945] ? free_extent_buffer+0x13/0x20 [btrfs] [75721.853960] ? btrfs_release_path+0x4b/0x190 [btrfs] [75721.861429] btrfs_csum_file_blocks+0x85c/0x1500 [btrfs] [75721.869313] ? rcu_read_lock_sched_held+0x16/0x80 [75721.876085] ? lock_release+0x552/0xf80 [75721.881957] ? btrfs_del_csums+0x8c0/0x8c0 [btrfs] [75721.888886] ? __kasan_check_write+0x14/0x20 [75721.895152] ? do_raw_read_unlock+0x44/0x80 [75721.901323] ? _raw_write_lock_irq+0x60/0x80 [75721.907983] ? btrfs_global_root+0xb9/0xe0 [btrfs] [75721.915166] ? btrfs_csum_root+0x12b/0x180 [btrfs] [75721.921918] ? btrfs_get_global_root+0x820/0x820 [btrfs] [75721.929166] ? _raw_write_unlock+0x23/0x40 [75721.935116] ? unpin_extent_cache+0x1e3/0x390 [btrfs] [75721.942041] btrfs_finish_ordered_io.isra.0+0xa0c/0x1dc0 [btrfs] [75721.949906] ? try_to_wake_up+0x30/0x14a0 [75721.955700] ? btrfs_unlink_subvol+0xda0/0xda0 [btrfs] [75721.962661] ? rcu ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/096e8eb9639b342bc35f9b741cf05e26d0106e92"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1aa262c1d056551dd1246115af8b7e351184deae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6cb4b96df97082a54634ba02196516919cda228c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f7b12a62f008a3041f42f2426983e59a6a0a3c59"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50091,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:38.277,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: locking/csd_lock: Change csdlock_debug from early_param to __setup The csdlock_debug kernel-boot parameter is parsed by the early_param() function csdlock_debug(). If set, csdlock_debug() invokes static_branch_enable() to enable csd_lock_wait feature, which triggers a panic on arm64 for kernels built with CONFIG_SPARSEMEM=y and CONFIG_SPARSEMEM_VMEMMAP=n. With CONFIG_SPARSEMEM_VMEMMAP=n, __nr_to_section is called in static_key_enable() and returns NULL, resulting in a NULL dereference because mem_section is initialized only later in sparse_init(). This is also a problem for powerpc because early_param() functions are invoked earlier than jump_label_init(), also resulting in static_key_enable() failures. These failures cause the warning ""static key 'xxx' used before call to jump_label_init()"". Thus, early_param is too early for csd_lock_wait to run static_branch_enable(), so changes it to __setup to fix these.",,,"[{""url"":""https://git.kernel.org/stable/c/05de9e2e33b1625c71aee69e353fe906dd2be88a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9c9b26b0df270d4f9246e483a44686fca951a29c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b480d1e9a8c11ecc1c99dc01814b28e3103bd0a0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d2cbdbe22b5f190055d2d0ae92e7454479343a30"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50092,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:38.383,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dm thin: fix use-after-free crash in dm_sm_register_threshold_callback Fault inject on pool metadata device reports: BUG: KASAN: use-after-free in dm_pool_register_metadata_threshold+0x40/0x80 Read of size 8 at addr ffff8881b9d50068 by task dmsetup/950 CPU: 7 PID: 950 Comm: dmsetup Tainted: G W 5.19.0-rc6 #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-1.fc33 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x34/0x44 print_address_description.constprop.0.cold+0xeb/0x3f4 kasan_report.cold+0xe6/0x147 dm_pool_register_metadata_threshold+0x40/0x80 pool_ctr+0xa0a/0x1150 dm_table_add_target+0x2c8/0x640 table_load+0x1fd/0x430 ctl_ioctl+0x2c4/0x5a0 dm_ctl_ioctl+0xa/0x10 __x64_sys_ioctl+0xb3/0xd0 do_syscall_64+0x35/0x80 entry_SYSCALL_64_after_hwframe+0x46/0xb0 This can be easily reproduced using: echo offline > /sys/block/sda/device/state dd if=/dev/zero of=/dev/mapper/thin bs=4k count=10 dmsetup load pool --table ""0 20971520 thin-pool /dev/sda /dev/sdb 128 0 0"" If a metadata commit fails, the transaction will be aborted and the metadata space maps will be destroyed. If a DM table reload then happens for this failed thin-pool, a use-after-free will occur in dm_sm_register_threshold_callback (called from dm_pool_register_metadata_threshold). Fix this by in dm_pool_register_metadata_threshold() by returning the -EINVAL error if the thin-pool is in fail mode. Also fail pool_ctr() with a new error message: ""Error registering metadata threshold"".",,,"[{""url"":""https://git.kernel.org/stable/c/05cef0999b3208b5a6ede1bfac855139e4de55ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1a199fa9217d28511ff88529238fd9980ea64cf3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3534e5a5ed2997ca1b00f44a0378a075bd05e8a3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e2cf705155a1514be3c96ea664a9cd356998ee7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e4dbe24f4bfd8377e7ba79fdcdb7c4d6eb1c6790"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f83131a3071a0b61a4d7dca70f95adb3ffad920e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50093,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:38.497,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iommu/vt-d: avoid invalid memory access via node_online(NUMA_NO_NODE) KASAN reports: [ 4.668325][ T0] BUG: KASAN: wild-memory-access in dmar_parse_one_rhsa (arch/x86/include/asm/bitops.h:214 arch/x86/include/asm/bitops.h:226 include/asm-generic/bitops/instrumented-non-atomic.h:142 include/linux/nodemask.h:415 drivers/iommu/intel/dmar.c:497) [ 4.676149][ T0] Read of size 8 at addr 1fffffff85115558 by task swapper/0/0 [ 4.683454][ T0] [ 4.685638][ T0] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.19.0-rc3-00004-g0e862838f290 #1 [ 4.694331][ T0] Hardware name: Supermicro SYS-5018D-FN4T/X10SDV-8C-TLN4F, BIOS 1.1 03/02/2016 [ 4.703196][ T0] Call Trace: [ 4.706334][ T0] <TASK> [ 4.709133][ T0] ? dmar_parse_one_rhsa (arch/x86/include/asm/bitops.h:214 arch/x86/include/asm/bitops.h:226 include/asm-generic/bitops/instrumented-non-atomic.h:142 include/linux/nodemask.h:415 drivers/iommu/intel/dmar.c:497) after converting the type of the first argument (@nr, bit number) of arch_test_bit() from `long` to `unsigned long`[0]. Under certain conditions (for example, when ACPI NUMA is disabled via command line), pxm_to_node() can return %NUMA_NO_NODE (-1). It is valid 'magic' number of NUMA node, but not valid bit number to use in bitops. node_online() eventually descends to test_bit() without checking for the input, assuming it's on caller side (which might be good for perf-critical tasks). There, -1 becomes %ULONG_MAX which leads to an insane array index when calculating bit position in memory. For now, add an explicit check for @node being not %NUMA_NO_NODE before calling test_bit(). The actual logics didn't change here at all. [0] https://github.com/norov/linux/commit/0e862838f290147ea9c16db852d8d494b552d38d",,,"[{""url"":""https://git.kernel.org/stable/c/0b4c0003aeda32a600f95df53b2848da8a5aa3fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5659efdadf04b56707d58c1b758df16d2e0eff2c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73ce2046e04ad488cecc66757c36cbe1bdf089d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b0b0b77ea611e3088e9523e60860f4f41b62b235"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b12304984654d8e58a2b22ff94c4410906d6267f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c2304c50f4d94f56c2e326f25c9dc8cf2ba6f5fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50094,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:38.620,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: spmi: trace: fix stack-out-of-bound access in SPMI tracing functions trace_spmi_write_begin() and trace_spmi_read_end() both call memcpy() with a length of ""len + 1"". This leads to one extra byte being read beyond the end of the specified buffer. Fix this out-of-bound memory access by using a length of ""len"" instead. Here is a KASAN log showing the issue: BUG: KASAN: stack-out-of-bounds in trace_event_raw_event_spmi_read_end+0x1d0/0x234 Read of size 2 at addr ffffffc0265b7540 by task thermal@2.0-ser/1314 ... Call trace: dump_backtrace+0x0/0x3e8 show_stack+0x2c/0x3c dump_stack_lvl+0xdc/0x11c print_address_description+0x74/0x384 kasan_report+0x188/0x268 kasan_check_range+0x270/0x2b0 memcpy+0x90/0xe8 trace_event_raw_event_spmi_read_end+0x1d0/0x234 spmi_read_cmd+0x294/0x3ac spmi_ext_register_readl+0x84/0x9c regmap_spmi_ext_read+0x144/0x1b0 [regmap_spmi] _regmap_raw_read+0x40c/0x754 regmap_raw_read+0x3a0/0x514 regmap_bulk_read+0x418/0x494 adc5_gen3_poll_wait_hs+0xe8/0x1e0 [qcom_spmi_adc5_gen3] ... __arm64_sys_read+0x4c/0x60 invoke_syscall+0x80/0x218 el0_svc_common+0xec/0x1c8 ... addr ffffffc0265b7540 is located in stack of task thermal@2.0-ser/1314 at offset 32 in frame: adc5_gen3_poll_wait_hs+0x0/0x1e0 [qcom_spmi_adc5_gen3] this frame has 1 object: [32, 33) 'status' Memory state around the buggy address: ffffffc0265b7400: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1 ffffffc0265b7480: 04 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00 >ffffffc0265b7500: 00 00 00 00 f1 f1 f1 f1 01 f3 f3 f3 00 00 00 00 ^ ffffffc0265b7580: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ffffffc0265b7600: f1 f1 f1 f1 01 f2 07 f2 f2 f2 01 f3 00 00 00 00 ==================================================================",,,"[{""url"":""https://git.kernel.org/stable/c/1e0ca3d809c36ad3d1f542917718fc22ec6316e7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2af28b241eea816e6f7668d1954f15894b45d7e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/37690cb8662cec672cacda19e6e4fd2ca7b13f0b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/504090815c1ad3fd3fa34618b54d706727f8911c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/80f7c93e573ea9f524924bb529c2af8cb28b1c43"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac730c72bddc889f5610d51d8a7abf425e08da1a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bcc1b6b1ed3f42ed25858c1f1eb24a2f741db93f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc6033a7761254e5a5ba7df36b64db787a53313c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dd02510fb43168310abfd0b9ccf49993a722fb91"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50095,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:38.740,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: posix-cpu-timers: Cleanup CPU timers before freeing them during exec Commit 55e8c8eb2c7b (""posix-cpu-timers: Store a reference to a pid not a task"") started looking up tasks by PID when deleting a CPU timer. When a non-leader thread calls execve, it will switch PIDs with the leader process. Then, as it calls exit_itimers, posix_cpu_timer_del cannot find the task because the timer still points out to the old PID. That means that armed timers won't be disarmed, that is, they won't be removed from the timerqueue_list. exit_itimers will still release their memory, and when that list is later processed, it leads to a use-after-free. Clean up the timers from the de-threaded task before freeing them. This prevents a reported use-after-free.",,,"[{""url"":""https://git.kernel.org/stable/c/541840859ace9c2ccebc32fa9e376c7bd3def490"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9e255ed238fc67058df87b0388ad6d4b2ef3a2bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b2fc1723eb65abb83e00d5f011de670296af0b28"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e362359ace6f87c201531872486ff295df306d13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e8cb6e8fd9890780f1bfcf5592889e1b879e779c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50096,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:38.850,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: x86/kprobes: Update kcb status flag after singlestepping Fix kprobes to update kcb (kprobes control block) status flag to KPROBE_HIT_SSDONE even if the kp->post_handler is not set. This bug may cause a kernel panic if another INT3 user runs right after kprobes because kprobe_int3_handler() misunderstands the INT3 is kprobe's single stepping INT3.",,,"[{""url"":""https://git.kernel.org/stable/c/1cbf3882cb372bbe752efd7c3045ca1c9ab40ac6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/663cdda2716b70751df9c7e60b81bd0850fdfe3c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b9c3401f7cac6ae291a16784dadcd1bf116218fe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dec8784c9088b131a1523f582c2194cfc8107dc0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/edc2ac7c7265b33660fa0190898966b49966b855"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50097,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:38.963,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: video: fbdev: s3fb: Check the size of screen before memset_io() In the function s3fb_set_par(), the value of 'screen_size' is calculated by the user input. If the user provides the improper value, the value of 'screen_size' may larger than 'info->screen_size', which may cause the following bug: [ 54.083733] BUG: unable to handle page fault for address: ffffc90003000000 [ 54.083742] #PF: supervisor write access in kernel mode [ 54.083744] #PF: error_code(0x0002) - not-present page [ 54.083760] RIP: 0010:memset_orig+0x33/0xb0 [ 54.083782] Call Trace: [ 54.083788] s3fb_set_par+0x1ec6/0x4040 [ 54.083806] fb_set_var+0x604/0xeb0 [ 54.083836] do_fb_ioctl+0x234/0x670 Fix the this by checking the value of 'screen_size' before memset_io().",,,"[{""url"":""https://git.kernel.org/stable/c/3c35a0dc2b4e7acf24c796043b64fa3eee799239"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/52461d387cc8c8f8dc40320caa2e9e101f73e7ba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/574912261528589012b61f82d368256247c3a5a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e0da18956d38e7106664dc1d06367b22f06edd3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6ba592fa014f21f35a8ee8da4ca7b95a018f13e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce50d94afcb8690813c5522f24cd38737657db81"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e2d7cacc6a2a1d77e7e20a492daf458a12cf19e0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eacb50f1733660911827d7c3720f4c5425d0cdda"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50098,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:39.083,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: qla2xxx: Fix crash due to stale SRB access around I/O timeouts Ensure SRB is returned during I/O timeout error escalation. If that is not possible fail the escalation path. Following crash stack was seen: BUG: unable to handle kernel paging request at 0000002f56aa90f8 IP: qla_chk_edif_rx_sa_delete_pending+0x14/0x30 [qla2xxx] Call Trace: ? qla2x00_status_entry+0x19f/0x1c50 [qla2xxx] ? qla2x00_start_sp+0x116/0x1170 [qla2xxx] ? dma_pool_alloc+0x1d6/0x210 ? mempool_alloc+0x54/0x130 ? qla24xx_process_response_queue+0x548/0x12b0 [qla2xxx] ? qla_do_work+0x2d/0x40 [qla2xxx] ? process_one_work+0x14c/0x390",,,"[{""url"":""https://git.kernel.org/stable/c/7dcd49c42b14717dd668fd73b503d241fdf82439"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b70553175d0f94ebd73670bc16ade90bd7f7d76f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b7bae3886a30d258b5b4fee26647043d68da3661"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c39587bc0abaf16593f7abcdf8aeec3c038c7d52"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50099,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:39.200,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: video: fbdev: arkfb: Check the size of screen before memset_io() In the function arkfb_set_par(), the value of 'screen_size' is calculated by the user input. If the user provides the improper value, the value of 'screen_size' may larger than 'info->screen_size', which may cause the following bug: [ 659.399066] BUG: unable to handle page fault for address: ffffc90003000000 [ 659.399077] #PF: supervisor write access in kernel mode [ 659.399079] #PF: error_code(0x0002) - not-present page [ 659.399094] RIP: 0010:memset_orig+0x33/0xb0 [ 659.399116] Call Trace: [ 659.399122] arkfb_set_par+0x143f/0x24c0 [ 659.399130] fb_set_var+0x604/0xeb0 [ 659.399161] do_fb_ioctl+0x234/0x670 [ 659.399189] fb_ioctl+0xdd/0x130 Fix the this by checking the value of 'screen_size' before memset_io().",,,"[{""url"":""https://git.kernel.org/stable/c/0701df594bc1d7ae55fed407fb65dd90a93f8a9c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/09e733d6ac948e6fda4b16252e44ea46f98fc8b4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2ce61c39c2a0b8ec82f48e0f7136f0dac105ae75"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/352305ea50d682b8e081d826da53caf9e744d7d0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4a20c5510aa2c031a096a58deb356e91609781c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/53198b81930e567ad6b879812d88052a1e8ac79e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8bcb1a06e3091716b7cbebe0e91d1de9895068cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/96b550971c65d54d64728d8ba973487878a06454"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50100,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:39.320,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: sched/core: Do not requeue task on CPU excluded from cpus_mask The following warning was triggered on a large machine early in boot on a distribution kernel but the same problem should also affect mainline. WARNING: CPU: 439 PID: 10 at ../kernel/workqueue.c:2231 process_one_work+0x4d/0x440 Call Trace: <TASK> rescuer_thread+0x1f6/0x360 kthread+0x156/0x180 ret_from_fork+0x22/0x30 </TASK> Commit c6e7bd7afaeb (""sched/core: Optimize ttwu() spinning on p->on_cpu"") optimises ttwu by queueing a task that is descheduling on the wakelist, but does not check if the task descheduling is still allowed to run on that CPU. In this warning, the problematic task is a workqueue rescue thread which checks if the rescue is for a per-cpu workqueue and running on the wrong CPU. While this is early in boot and it should be possible to create workers, the rescue thread may still used if the MAYDAY_INITIAL_TIMEOUT is reached or MAYDAY_INTERVAL and on a sufficiently large machine, the rescue thread is being used frequently. Tracing confirmed that the task should have migrated properly using the stopper thread to handle the migration. However, a parallel wakeup from udev running on another CPU that does not share CPU cache observes p->on_cpu and uses task_cpu(p), queues the task on the old CPU and triggers the warning. Check that the wakee task that is descheduling is still allowed to run on its current CPU and if not, wait for the descheduling to complete and select an allowed CPU.",,,"[{""url"":""https://git.kernel.org/stable/c/302f7b0fc337746f41c69eb08522907f6a90c643"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/748d2e9585ae53cb6be48e84f93d2f082ae1d135"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/751d4cbc43879229dbc124afefe240b70fd29a85"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fde45283f4c8a91c367ea5f20f87036468755121"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50101,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:39.437,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: video: fbdev: vt8623fb: Check the size of screen before memset_io() In the function vt8623fb_set_par(), the value of 'screen_size' is calculated by the user input. If the user provides the improper value, the value of 'screen_size' may larger than 'info->screen_size', which may cause the following bug: [ 583.339036] BUG: unable to handle page fault for address: ffffc90005000000 [ 583.339049] #PF: supervisor write access in kernel mode [ 583.339052] #PF: error_code(0x0002) - not-present page [ 583.339074] RIP: 0010:memset_orig+0x33/0xb0 [ 583.339110] Call Trace: [ 583.339118] vt8623fb_set_par+0x11cd/0x21e0 [ 583.339146] fb_set_var+0x604/0xeb0 [ 583.339181] do_fb_ioctl+0x234/0x670 [ 583.339209] fb_ioctl+0xdd/0x130 Fix the this by checking the value of 'screen_size' before memset_io().",,,"[{""url"":""https://git.kernel.org/stable/c/4a3cef1eaced13ba9b55381d46bfad937a3dac2c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/52ad9bfeb8a0e62de30de6d39e8a49a72dd78150"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73280a184aa2e1a625ce54ce761042955cc79cd0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b17caec5127bba6f90af92bcc85871df54548ac0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd8269e57621e5b38cc0b4bd2fa02e85c9f2a441"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c7a3f41e4b133d4dd25bc996b69039b19a34d69d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d71528ccdc7ae8d7500d414091d27805c51407a2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec0754c60217248fa77cc9005d66b2b55200ac06"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50102,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:39.553,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: video: fbdev: arkfb: Fix a divide-by-zero bug in ark_set_pixclock() Since the user can control the arguments of the ioctl() from the user space, under special arguments that may result in a divide-by-zero bug in: drivers/video/fbdev/arkfb.c:784: ark_set_pixclock(info, (hdiv * info->var.pixclock) / hmul); with hdiv=1, pixclock=1 and hmul=2 you end up with (1*1)/2 = (int) 0. and then in: drivers/video/fbdev/arkfb.c:504: rv = dac_set_freq(par->dac, 0, 1000000000 / pixclock); we'll get a division-by-zero. The following log can reveal it: divide error: 0000 [#1] PREEMPT SMP KASAN PTI RIP: 0010:ark_set_pixclock drivers/video/fbdev/arkfb.c:504 [inline] RIP: 0010:arkfb_set_par+0x10fc/0x24c0 drivers/video/fbdev/arkfb.c:784 Call Trace: fb_set_var+0x604/0xeb0 drivers/video/fbdev/core/fbmem.c:1034 do_fb_ioctl+0x234/0x670 drivers/video/fbdev/core/fbmem.c:1110 fb_ioctl+0xdd/0x130 drivers/video/fbdev/core/fbmem.c:1189 Fix this by checking the argument of ark_set_pixclock() first.",,,"[{""url"":""https://git.kernel.org/stable/c/0288fa799e273b08839037499d704dc7bdc13e9a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/15661642511b2b192077684a89f42a8d95d54286"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/236c1502520b7b08955467ec2e50b3232e34f1f9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2f1c4523f7a3aaabe7e53d3ebd378292947e95c8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/76b3f0a0b56e53a960a14624a0f48b3d94b5e7e7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ebc5031958c1f3a2795e4533b4091d77c738d14"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a249e1b89ca25e1c34bdf96154e3f6224a91a9af"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b9a66f23612b84617e04412169e155a4b92f632d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50103,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:39.670,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: sched, cpuset: Fix dl_cpu_busy() panic due to empty cs->cpus_allowed With cgroup v2, the cpuset's cpus_allowed mask can be empty indicating that the cpuset will just use the effective CPUs of its parent. So cpuset_can_attach() can call task_can_attach() with an empty mask. This can lead to cpumask_any_and() returns nr_cpu_ids causing the call to dl_bw_of() to crash due to percpu value access of an out of bound CPU value. For example: [80468.182258] BUG: unable to handle page fault for address: ffffffff8b6648b0 : [80468.191019] RIP: 0010:dl_cpu_busy+0x30/0x2b0 : [80468.207946] Call Trace: [80468.208947] cpuset_can_attach+0xa0/0x140 [80468.209953] cgroup_migrate_execute+0x8c/0x490 [80468.210931] cgroup_update_dfl_csses+0x254/0x270 [80468.211898] cgroup_subtree_control_write+0x322/0x400 [80468.212854] kernfs_fop_write_iter+0x11c/0x1b0 [80468.213777] new_sync_write+0x11f/0x1b0 [80468.214689] vfs_write+0x1eb/0x280 [80468.215592] ksys_write+0x5f/0xe0 [80468.216463] do_syscall_64+0x5c/0x80 [80468.224287] entry_SYSCALL_64_after_hwframe+0x44/0xae Fix that by using effective_cpus instead. For cgroup v1, effective_cpus is the same as cpus_allowed. For v2, effective_cpus is the real cpumask to be used by tasks within the cpuset anyway. Also update task_can_attach()'s 2nd argument name to cs_effective_cpus to reflect the change. In addition, a check is added to task_can_attach() to guard against the possibility that cpumask_any_and() may return a value >= nr_cpu_ids.",,,"[{""url"":""https://git.kernel.org/stable/c/147f66d22f58712dce7ccdd6a1f6cb3ee8042df4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/336626564b58071b8980a4e6a31a8f5d92705d9b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/357f3f0e522a6ce1ce4a571cb780d9861d53bec7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b6e8d40d43ae4dec00c8fea2593eeea3114b8f44"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f56607b44c9896e51678a7e8cdd3a5479f4b4548"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50104,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:39.787,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: powerpc/xive: Fix refcount leak in xive_get_max_prio of_find_node_by_path() returns a node pointer with refcount incremented, we should use of_node_put() on it when done. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/255b650cbec6849443ce2e0cdd187fd5e61c218c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2e18b869a8d574cfe9ee64df9c3d0a7ac7ed07a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5ed9709d262bf026b2ff64979fbfe0f496287588"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6d1e53f7f181a11a8a343def1e0d0209905b7c64"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/79b8eae24b7ee157bda07695d802be8576983fa8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d99733ad47a6c990b52e136608455643bfa708f2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ea494e8a9852abd0ba60f69b254ce0d7c38449e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f658d5b528ce97a68efbb64ee54f6fe0909b189a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50105,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:39.900,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: powerpc/spufs: Fix refcount leak in spufs_init_isolated_loader of_find_node_by_path() returns remote device nodepointer with refcount incremented, we should use of_node_put() on it when done. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/0aa5de2547b7ccf0a31bc740d12f829fae243112"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/14329d29a048dc35aac2374fb3d588d8190095a2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4288eb035ba4ddb53245e9365c919bb51ac00c2c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/43584490ee6c8a104797444af6bf89d0dafe95c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/69e9fa07b229badab808980e984a9fe824116f00"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6ac059dacffa8ab2f7798f20e4bd3333890c541c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/85aff6a9b7b7ec4e5c319f7946c9864c8d5e3d4a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d0cb99948c5f6d8fe56f6e69b8dd0a05ee5f9cec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50106,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:40.023,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: powerpc/cell/axon_msi: Fix refcount leak in setup_msi_msg_address of_get_next_parent() returns a node pointer with refcount incremented, we should use of_node_put() on it when not need anymore. Add missing of_node_put() in the error path to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/00dc7cbbb558955ff410fd392cc9b0366eb06df0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/02ed44125d7a7238999750ca126b60f8dd7a88b1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/51cf876b11fb6ca06f69e9d1de58f892d1522e9d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5eaa93caa63abf382b319dbe2f032232026740c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6263ec8032c411b8ef6b7f00198cb18c855ee6cb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/af41cff4ada533b1cf40de6c468ba164fd32c22d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/df5d4b616ee76abc97e5bd348e22659c2b095b1c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f388643657cd5a04dc47a68d85321876c5b4c208"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50107,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:40.140,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: cifs: Fix memory leak when using fscache If we hit the 'index == next_cached' case, we leak a refcount on the struct page. Fix this by using readahead_folio() which takes care of the refcount for you.",,,"[{""url"":""https://git.kernel.org/stable/c/7105b4047481bc2950fb767cff328d8b75292c0f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ae497726cd090673a4d20ac725ccc2de8067a7a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c6f62f81b488d00afaa86bae26c6ce9ab12c709e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50108,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:40.263,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mfd: max77620: Fix refcount leak in max77620_initialise_fps of_get_child_by_name() returns a node pointer with refcount incremented, we should use of_node_put() on it when not need anymore. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/1520669c8255bd637c6b248b2be910e2688d38dd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/50d5fe8cb94c319cb4316f4d824570c075565354"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a29c40814039535b950149311986a5f348b5db14"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/afdbadbf18c19779d7bc5df70d872924f9bbd76b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b948ff8a9e9ad46d4dff9127777caa14c8c2b53c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/facd31bbc799f4d0cd25d9d688af7ca41e7f38ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50109,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:40.397,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: video: fbdev: amba-clcd: Fix refcount leak bugs In clcdfb_of_init_display(), we should call of_node_put() for the references returned by of_graph_get_next_endpoint() and of_graph_get_remote_port_parent() which have increased the refcount. Besides, we should call of_node_put() both in fail path or when the references are not used anymore.",,,"[{""url"":""https://git.kernel.org/stable/c/2688df86c02da6bdc9866b62d974e169a2678883"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/26c2b7d9fac42eb8317f3ceefa4c1a9a9170ca69"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/29f06f1905c312671a09ee85ca92ac04a1d9f305"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/49a4c1a87ef884e43cdda58b142a2a30f2f09efc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a51519ebd0fdad3546463018b8f6bc3b0f4d3032"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a88ab277cca99aeb9a3b2b7db358f1a6dd528b0c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a97ff8a949dbf41be89f436b2b1a2b3d794493df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da276dc288bf838ea0fd778b5441ec0f601c69f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50110,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:40.530,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: watchdog: sp5100_tco: Fix a memory leak of EFCH MMIO resource Unlike release_mem_region(), a call to release_resource() does not free the resource, so it has to be freed explicitly to avoid a memory leak.",,,"[{""url"":""https://git.kernel.org/stable/c/3a1becb1f13268ef58f19190608a7c742fb6fcf5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/84ddf527f90755beec6b55ce2e31331f5ccd4e37"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c6d9c0798ed366a09a9e53d71edcd2266e34a6eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee1fb8f75abe361413913e3a6e93c8c0a4d83cd9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50111,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:40.660,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: mt6359: Fix refcount leak bug In mt6359_parse_dt() and mt6359_accdet_parse_dt(), we should call of_node_put() for the reference returned by of_get_child_by_name() which has increased the refcount.",,,"[{""url"":""https://git.kernel.org/stable/c/1e7fe6906e9755d9e0242f9619c894ecd82fb9da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3d69d86b3e9d82f524e7e1906adcbbe939dc836e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a8d5df69e2ec702d979f7d04ed519caf8691a032"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ffaef892bfef5ec68dadfd3bbed49e3d4ef7b6c7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50112,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:40.793,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: rpmsg: qcom_smd: Fix refcount leak in qcom_smd_parse_edge of_parse_phandle() returns a node pointer with refcount incremented, we should use of_node_put() on it when done.",,,"[{""url"":""https://git.kernel.org/stable/c/43e42c25a232a6862e7d2f292a069ac828559030"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/65382585f067d4256ba087934f30f85c9b6984de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ee5d40ae29e63f6fd6cbf9dcfc0a48c474013db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9715809b9eeb85b3f9b083857a2f29a9e2351125"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ae7fdbab97df6a2115eed6b7e39c278b805c9c7d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cb50423e46ea585620a6be307d7f7b71587936b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ece6cfe62a103cc6032664983be557f1b5a1ff7e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50113,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:40.917,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoc: audio-graph-card2: Fix refcount leak bug in __graph_get_type() We should call of_node_put() for the reference before its replacement as it returned by of_get_parent() which has increased the refcount. Besides, we should also call of_node_put() before return.",,,"[{""url"":""https://git.kernel.org/stable/c/3bb0c0b5f0f866fc3785380e0860dc37ceacf342"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7a63a8c253bf57dfd9fa3ee2a7f1a3727505f947"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eda26893dabfc6da7a1e1ff5f8628ed9faab3ab9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50114,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:41.030,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: 9p: fix refcount leak in p9_read_work() error handling p9_req_put need to be called when m->rreq->rc.sdata is NULL to avoid temporary refcount leak. [Dominique: commit wording adjustments, p9_req_put argument fixes for rebase]",,,"[{""url"":""https://git.kernel.org/stable/c/34b9a188557c1d5a50e07cf228d054101aee0af3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4ac7573e1f9333073fa8d303acc941c9b7ab7f61"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/622f2a467bdfbce73fd43ea74b5f0fd2caaa8c5d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8324649b0035cbb30ebc3ca901540cb392e89041"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50115,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:41.140,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: SOF: ipc3-topology: Prevent double freeing of ipc_control_data via load_bytes We have sanity checks for byte controls and if any of the fail the locally allocated scontrol->ipc_control_data is freed up, but not set to NULL. On a rollback path of the error the higher level code will also try to free the scontrol->ipc_control_data which will eventually going to lead to memory corruption as double freeing memory is not a good thing.",,,"[{""url"":""https://git.kernel.org/stable/c/8463986b54295e6b65ddf2b7c65627d01ce7643b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c2eddfcafcffaf1b9245ea0dde9143bbfb47d5d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d5bd47f3ca124058a8e87eae4508afeda2132611"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50116,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:41.257,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tty: n_gsm: fix deadlock and link starvation in outgoing data path The current implementation queues up new control and user packets as needed and processes this queue down to the ldisc in the same code path. That means that the upper and the lower layer are hard coupled in the code. Due to this deadlocks can happen as seen below while transmitting data, especially during ldisc congestion. Furthermore, the data channels starve the control channel on high transmission load on the ldisc. Introduce an additional control channel data queue to prevent timeouts and link hangups during ldisc congestion. This is being processed before the user channel data queue in gsm_data_kick(), i.e. with the highest priority. Put the queue to ldisc data path into a workqueue and trigger it whenever new data has been put into the transmission queue. Change gsm_dlci_data_sweep() accordingly to fill up the transmission queue until TX_THRESH_HI. This solves the locking issue, keeps latency low and provides good performance on high data load. Note that now all packets from a DLCI are removed from the internal queue if the associated DLCI was closed. This ensures that no data is sent by the introduced write task to an already closed DLCI. BUG: spinlock recursion on CPU#0, test_v24_loop/124 lock: serial8250_ports+0x3a8/0x7500, .magic: dead4ead, .owner: test_v24_loop/124, .owner_cpu: 0 CPU: 0 PID: 124 Comm: test_v24_loop Tainted: G O 5.18.0-rc2 #3 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 Call Trace: <IRQ> dump_stack_lvl+0x34/0x44 do_raw_spin_lock+0x76/0xa0 _raw_spin_lock_irqsave+0x72/0x80 uart_write_room+0x3b/0xc0 gsm_data_kick+0x14b/0x240 [n_gsm] gsmld_write_wakeup+0x35/0x70 [n_gsm] tty_wakeup+0x53/0x60 tty_port_default_wakeup+0x1b/0x30 serial8250_tx_chars+0x12f/0x220 serial8250_handle_irq.part.0+0xfe/0x150 serial8250_default_handle_irq+0x48/0x80 serial8250_interrupt+0x56/0xa0 __handle_irq_event_percpu+0x78/0x1f0 handle_irq_event+0x34/0x70 handle_fasteoi_irq+0x90/0x1e0 __common_interrupt+0x69/0x100 common_interrupt+0x48/0xc0 asm_common_interrupt+0x1e/0x40 RIP: 0010:__do_softirq+0x83/0x34e Code: 2a 0a ff 0f b7 ed c7 44 24 10 0a 00 00 00 48 c7 c7 51 2a 64 82 e8 2d e2 d5 ff 65 66 c7 05 83 af 1e 7e 00 00 fb b8 ff ff ff ff <49> c7 c2 40 61 80 82 0f bc c5 41 89 c4 41 83 c4 01 0f 84 e6 00 00 RSP: 0018:ffffc90000003f98 EFLAGS: 00000286 RAX: 00000000ffffffff RBX: 0000000000000000 RCX: 0000000000000000 RDX: 0000000000000000 RSI: ffffffff82642a51 RDI: ffffffff825bb5e7 RBP: 0000000000000200 R08: 00000008de3271a8 R09: 0000000000000000 R10: 0000000000000001 R11: 0000000000000000 R12: 0000000000000000 R13: 0000000000000030 R14: 0000000000000000 R15: 0000000000000000 ? __do_softirq+0x73/0x34e irq_exit_rcu+0xb5/0x100 common_interrupt+0xa4/0xc0 </IRQ> <TASK> asm_common_interrupt+0x1e/0x40 RIP: 0010:_raw_spin_unlock_irqrestore+0x2e/0x50 Code: 00 55 48 89 fd 48 83 c7 18 53 48 89 f3 48 8b 74 24 10 e8 85 28 36 ff 48 89 ef e8 cd 58 36 ff 80 e7 02 74 01 fb bf 01 00 00 00 <e8> 3d 97 33 ff 65 8b 05 96 23 2b 7e 85 c0 74 03 5b 5d c3 0f 1f 44 RSP: 0018:ffffc9000020fd08 EFLAGS: 00000202 RAX: 0000000000000000 RBX: 0000000000000246 RCX: 0000000000000000 RDX: 0000000000000004 RSI: ffffffff8257fd74 RDI: 0000000000000001 RBP: ffff8880057de3a0 R08: 00000008de233000 R09: 0000000000000000 R10: 0000000000000001 R11: 0000000000000000 R12: 0000000000000000 R13: 0000000000000100 R14: 0000000000000202 R15: ffff8880057df0b8 ? _raw_spin_unlock_irqrestore+0x23/0x50 gsmtty_write+0x65/0x80 [n_gsm] n_tty_write+0x33f/0x530 ? swake_up_all+0xe0/0xe0 file_tty_write.constprop.0+0x1b1/0x320 ? n_tty_flush_buffer+0xb0/0xb0 new_sync_write+0x10c/0x190 vfs_write+0x282/0x310 ksys_write+0x68/0xe0 do_syscall_64+0x3b/0x90 entry_SYSCALL_64_after_hwframe+0x44/0xae RIP: 0033:0x7f3e5e35c15c Code: 8b 7c 24 08 89 c5 e8 c5 ff ff ff 89 ef 89 44 24 ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/0af021678d5d30c31f5a6b631f404ead3575212a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7962a4b900099cf90e02859bb297f2c618d8d940"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c165698c9919b000bdbe73859d3bb7b33bdb9223"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50117,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:41.370,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: vfio: Split migration ops from main device ops vfio core checks whether the driver sets some migration op (e.g. set_state/get_state) and accordingly calls its op. However, currently mlx5 driver sets the above ops without regards to its migration caps. This might lead to unexpected usage/Oops if user space may call to the above ops even if the driver doesn't support migration. As for example, the migration state_mutex is not initialized in that case. The cleanest way to manage that seems to split the migration ops from the main device ops, this will let the driver setting them separately from the main ops when it's applicable. As part of that, validate ops construction on registration and include a check for VFIO_MIGRATION_STOP_COPY since the uAPI claims it must be set in migration_flags. HISI driver was changed as well to match this scheme. This scheme may enable down the road to come with some extra group of ops (e.g. DMA log) that can be set without regards to the other options based on driver caps.",,,"[{""url"":""https://git.kernel.org/stable/c/6e97eba8ad8748fabb795cffc5d9e1a7dcfd7367"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bba6b12d73d36e0ddbc2c3ac5668a667b00d4345"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50118,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:41.477,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: powerpc/perf: Optimize clearing the pending PMI and remove WARN_ON for PMI check in power_pmu_disable commit 2c9ac51b850d (""powerpc/perf: Fix PMU callbacks to clear pending PMI before resetting an overflown PMC"") added a new function ""pmi_irq_pending"" in hw_irq.h. This function is to check if there is a PMI marked as pending in Paca (PACA_IRQ_PMI).This is used in power_pmu_disable in a WARN_ON. The intention here is to provide a warning if there is PMI pending, but no counter is found overflown. During some of the perf runs, below warning is hit: WARNING: CPU: 36 PID: 0 at arch/powerpc/perf/core-book3s.c:1332 power_pmu_disable+0x25c/0x2c0 Modules linked in: ----- NIP [c000000000141c3c] power_pmu_disable+0x25c/0x2c0 LR [c000000000141c8c] power_pmu_disable+0x2ac/0x2c0 Call Trace: [c000000baffcfb90] [c000000000141c8c] power_pmu_disable+0x2ac/0x2c0 (unreliable) [c000000baffcfc10] [c0000000003e2f8c] perf_pmu_disable+0x4c/0x60 [c000000baffcfc30] [c0000000003e3344] group_sched_out.part.124+0x44/0x100 [c000000baffcfc80] [c0000000003e353c] __perf_event_disable+0x13c/0x240 [c000000baffcfcd0] [c0000000003dd334] event_function+0xc4/0x140 [c000000baffcfd20] [c0000000003d855c] remote_function+0x7c/0xa0 [c000000baffcfd50] [c00000000026c394] flush_smp_call_function_queue+0xd4/0x300 [c000000baffcfde0] [c000000000065b24] smp_ipi_demux_relaxed+0xa4/0x100 [c000000baffcfe20] [c0000000000cb2b0] xive_muxed_ipi_action+0x20/0x40 [c000000baffcfe40] [c000000000207c3c] __handle_irq_event_percpu+0x8c/0x250 [c000000baffcfee0] [c000000000207e2c] handle_irq_event_percpu+0x2c/0xa0 [c000000baffcff10] [c000000000210a04] handle_percpu_irq+0x84/0xc0 [c000000baffcff40] [c000000000205f14] generic_handle_irq+0x54/0x80 [c000000baffcff60] [c000000000015740] __do_irq+0x90/0x1d0 [c000000baffcff90] [c000000000016990] __do_IRQ+0xc0/0x140 [c0000009732f3940] [c000000bafceaca8] 0xc000000bafceaca8 [c0000009732f39d0] [c000000000016b78] do_IRQ+0x168/0x1c0 [c0000009732f3a00] [c0000000000090c8] hardware_interrupt_common_virt+0x218/0x220 This means that there is no PMC overflown among the active events in the PMU, but there is a PMU pending in Paca. The function ""any_pmc_overflown"" checks the PMCs on active events in cpuhw->n_events. Code snippet: <<>> if (any_pmc_overflown(cpuhw)) clear_pmi_irq_pending(); else WARN_ON(pmi_irq_pending()); <<>> Here the PMC overflown is not from active event. Example: When we do perf record, default cycles and instructions will be running on PMC6 and PMC5 respectively. It could happen that overflowed event is currently not active and pending PMI is for the inactive event. Debug logs from trace_printk: <<>> any_pmc_overflown: idx is 5: pmc value is 0xd9a power_pmu_disable: PMC1: 0x0, PMC2: 0x0, PMC3: 0x0, PMC4: 0x0, PMC5: 0xd9a, PMC6: 0x80002011 <<>> Here active PMC (from idx) is PMC5 , but overflown PMC is PMC6(0x80002011). When we handle PMI interrupt for such cases, if the PMC overflown is from inactive event, it will be ignored. Reference commit: commit bc09c219b2e6 (""powerpc/perf: Fix finding overflowed PMC in interrupt"") Patch addresses two changes: 1) Fix 1 : Removal of warning ( WARN_ON(pmi_irq_pending()); ) We were printing warning if no PMC is found overflown among active PMU events, but PMI pending in PACA. But this could happen in cases where PMC overflown is not in active PMC. An inactive event could have caused the overflow. Hence the warning is not needed. To know pending PMI is from an inactive event, we need to loop through all PMC's which will cause more SPR reads via mfspr and increase in context switch. Also in existing function: perf_event_interrupt, already we ignore PMI's overflown when it is from an inactive PMC. 2) Fix 2: optimization in clearing pending PMI. Currently we check for any active PMC overflown before clearing PMI pending in Paca. This is causing additional SP ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/0a24ea26c3278216642a43291df7976a73a0a7ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7e83af3dd4a3afca8f83ffde518cafd52f45b830"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/875b2bf469d094754ac2ba9af91dcd529eb12bf6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/87b1a9175f08313f40fcb6d6dc536dbe451090eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/890005a7d98f7452cfe86dcfb2aeeb7df01132ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50119,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:41.573,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: rpmsg: Fix possible refcount leak in rpmsg_register_device_override() rpmsg_register_device_override need to call put_device to free vch when driver_set_override fails. Fix this by adding a put_device() to the error path.",,,"[{""url"":""https://git.kernel.org/stable/c/01e6885b75e25a2dd0726455ef18ef9ce5e7dc87"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/280ae5a028ef5d14ef9277746a3026a30aaebe4f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3fdd5b2bb09fc2b5bf3504778f51c89bb48c097f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c29335612ff44df979678a38e1f55c62004f421c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c449b28e437d18ae807479c4ac6b69d87b287c79"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d4c8bf5635c4bedaf2470761ced1f502b2d5434e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d7bd416d35121c95fe47330e09a5c04adbc5f928"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50120,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:41.683,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: remoteproc: imx_rproc: Fix refcount leak in imx_rproc_addr_init of_parse_phandle() returns a node pointer with refcount incremented, we should use of_node_put() on it when not needed anymore. This function has two paths missing of_node_put().",,,"[{""url"":""https://git.kernel.org/stable/c/0dc1663e3fc22c72e1ab33be7701a0d51cca84ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/16da9f84e26f89e58cac194ff19fefd9de27d975"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/61afafe8b938bc74841cf4b1a73dd08b9d287c5a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d8ac68927856c3a6d197a95be73c92ec0bd4b012"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50121,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:41.797,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: remoteproc: k3-r5: Fix refcount leak in k3_r5_cluster_of_init Every iteration of for_each_available_child_of_node() decrements the reference count of the previous node. When breaking early from a for_each_available_child_of_node() loop, we need to explicitly call of_node_put() on the child node. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/3f83c4cf1b78331c23876977aa7b9151aff2f9e1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/61cd8cd3b6b33c7eae3b45cf783b114f2ae53528"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/75358732af9b26acfe3e609943290bcba13330fc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cf112a52d758092ca3d5ebdad51dd17bda5ba3e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa220c05d282e7479abe08b54e3bdffd06c25e97"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50122,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:41.900,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: mediatek: mt8173-rt5650: Fix refcount leak in mt8173_rt5650_dev_probe of_parse_phandle() returns a node pointer with refcount incremented, we should use of_node_put() on it when not need anymore. Fix refcount leak in some error paths.",,,"[{""url"":""https://git.kernel.org/stable/c/06ace427953f5036b64aed658f0055f65d76fd27"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/403d46971936f9f704b91cecffe66e44aa39e915"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5ec83aa7a9e5bcca80ccd49978916feb4e0ffc07"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/79f566907d27abbd7600cebe51def5081d5796b5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/994f2edeeb2114bb22b62741cb8fb030fc7e5441"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e024a24fb264523149658c10c76bb363b3d0004d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e38e4952ac7a316c9002af30980d6aa850214474"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/efe2178d1a32492f99e7f1f2568eea5c88a85729"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50123,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:42.017,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: mediatek: mt8173: Fix refcount leak in mt8173_rt5650_rt5676_dev_probe of_parse_phandle() returns a node pointer with refcount incremented, we should use of_node_put() on it when not need anymore. Fix missing of_node_put() in error paths.",,,"[{""url"":""https://git.kernel.org/stable/c/540c7b7385fb110740703888b4b2bbfa06c7f79c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/58567ed2878f70e0ded242cb529fb4a7618ea9f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/769399bce8825e1dcc5050dab78e15ab578baf4f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa1214ece37944e4dbbb5cfb1d02bf37e4d89b02"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa668f8e93199cda8fa1612eb49ff70f5ecd8c92"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ae4f11c1ed2d67192fdf3d89db719ee439827c11"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d6d41f04640db0f946e2c3f7963bb2774afc7a0d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fab5eb31819a2693b0c3d6f3df6a0d193af9a089"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50124,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:42.133,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: mt6797-mt6351: Fix refcount leak in mt6797_mt6351_dev_probe of_parse_phandle() returns a node pointer with refcount incremented, we should use of_node_put() on it when not need anymore. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/1042353bb67cd1c9109d7481ea182c7794336458"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/38dc6faef05f33b4c889be8b7d65878e465c1c4b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/67a28402a9e8c229c7588f214d81d52903ea06ea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7472eb8d7dd12b6b9b1a4f4527719cc9c7f5965f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7dee72b1bcecb26bfff8d6360f2169f8656dbaf6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a0381a9f3e595988e83bac4c4dd1e45ed2b3c744"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b488ceb2336905f071f80627bc8a7d657274e5de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50125,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:42.250,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: cros_ec_codec: Fix refcount leak in cros_ec_codec_platform_probe of_parse_phandle() returns a node pointer with refcount incremented, we should use of_node_put() on it when not need anymore. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/0a034d93ee929a9ea89f3fa5f1d8492435b9ee6e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1065c385325845c88350c765cc6e449f46741984"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3e64b5562c077218295f2230fb5cf181193cb06"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bae95c5aee1f67da6608ceaebfb744d900e5ffbf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca6c9244e6c9827a0b2fe8808c5e7b1ee8ab7104"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50126,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:42.360,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: jbd2: fix assertion 'jh->b_frozen_data == NULL' failure when journal aborted Following process will fail assertion 'jh->b_frozen_data == NULL' in jbd2_journal_dirty_metadata(): jbd2_journal_commit_transaction unlink(dir/a) jh->b_transaction = trans1 jh->b_jlist = BJ_Metadata journal->j_running_transaction = NULL trans1->t_state = T_COMMIT unlink(dir/b) handle->h_trans = trans2 do_get_write_access jh->b_modified = 0 jh->b_frozen_data = frozen_buffer jh->b_next_transaction = trans2 jbd2_journal_dirty_metadata is_handle_aborted is_journal_aborted // return false --> jbd2 abort <-- while (commit_transaction->t_buffers) if (is_journal_aborted) jbd2_journal_refile_buffer __jbd2_journal_refile_buffer WRITE_ONCE(jh->b_transaction, jh->b_next_transaction) WRITE_ONCE(jh->b_next_transaction, NULL) __jbd2_journal_file_buffer(jh, BJ_Reserved) J_ASSERT_JH(jh, jh->b_frozen_data == NULL) // assertion failure ! The reproducer (See detail in [Link]) reports: ------------[ cut here ]------------ kernel BUG at fs/jbd2/transaction.c:1629! invalid opcode: 0000 [#1] PREEMPT SMP CPU: 2 PID: 584 Comm: unlink Tainted: G W 5.19.0-rc6-00115-g4a57a8400075-dirty #697 RIP: 0010:jbd2_journal_dirty_metadata+0x3c5/0x470 RSP: 0018:ffffc90000be7ce0 EFLAGS: 00010202 Call Trace: <TASK> __ext4_handle_dirty_metadata+0xa0/0x290 ext4_handle_dirty_dirblock+0x10c/0x1d0 ext4_delete_entry+0x104/0x200 __ext4_unlink+0x22b/0x360 ext4_unlink+0x275/0x390 vfs_unlink+0x20b/0x4c0 do_unlinkat+0x42f/0x4c0 __x64_sys_unlink+0x37/0x50 do_syscall_64+0x35/0x80 After journal aborting, __jbd2_journal_refile_buffer() is executed with holding @jh->b_state_lock, we can fix it by moving 'is_handle_aborted()' into the area protected by @jh->b_state_lock.",,,"[{""url"":""https://git.kernel.org/stable/c/0f61c6dc4b714be9d79cf0782ca02ba01c1b7ac3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4a734f0869f970b8a9b65062ea40b09a5da9dba8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6073389db83b903678a0920554fa19f5bdc51c48"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/731c1662d838fe954c6759e3ee43229b0d928fe4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ddd896792e1718cb84c96f3e618270589b6886dc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e62f79827784f56499a50ea2e893c98317b5407b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f7161d0da975adc234161cd0641d0e484f5ce375"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa5b65d39332fef7a11ae99cb1f0696012a61527"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50127,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:42.477,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/rxe: Fix error unwind in rxe_create_qp() In the function rxe_create_qp(), rxe_qp_from_init() is called to initialize qp, internally things like the spin locks are not setup until rxe_qp_init_req(). If an error occures before this point then the unwind will call rxe_cleanup() and eventually to rxe_qp_do_cleanup()/rxe_cleanup_task() which will oops when trying to access the uninitialized spinlock. Move the spinlock initializations earlier before any failures.",,,"[{""url"":""https://git.kernel.org/stable/c/1a63f24e724f677db1ab21251f4d0011ae0bb5b5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2ceeb04252e621c0b128ecc8fedbca922d11adba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3c838ca6fbdb173102780d7bdf18f2f7d9e30979"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ef491b26c720a87fcfbd78b7dc8eb83d9753fe6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b348e204a53103f51070513a7494da7c62ecbdaa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/db924bd8484c76558a4ac4c4b5aeb52e857f0341"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f05b7cf02123aaf99db78abfe638efefdbe15555"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd5382c5805c4bcb50fd25b7246247d3f7114733"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50128,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:42.590,2025-06-18T14:15:24.210,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2022-50129,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:42.700,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/srpt: Fix a use-after-free Change the LIO port members inside struct srpt_port from regular members into pointers. Allocate the LIO port data structures from inside srpt_make_tport() and free these from inside srpt_make_tport(). Keep struct srpt_device as long as either an RDMA port or a LIO target port is associated with it. This patch decouples the lifetime of struct srpt_port (controlled by the RDMA core) and struct srpt_port_id (controlled by LIO). This patch fixes the following KASAN complaint: BUG: KASAN: use-after-free in srpt_enable_tpg+0x31/0x70 [ib_srpt] Read of size 8 at addr ffff888141cc34b8 by task check/5093 Call Trace: <TASK> show_stack+0x4e/0x53 dump_stack_lvl+0x51/0x66 print_address_description.constprop.0.cold+0xea/0x41e print_report.cold+0x90/0x205 kasan_report+0xb9/0xf0 __asan_load8+0x69/0x90 srpt_enable_tpg+0x31/0x70 [ib_srpt] target_fabric_tpg_base_enable_store+0xe2/0x140 [target_core_mod] configfs_write_iter+0x18b/0x210 new_sync_write+0x1f2/0x2f0 vfs_write+0x3e3/0x540 ksys_write+0xbb/0x140 __x64_sys_write+0x42/0x50 do_syscall_64+0x34/0x80 entry_SYSCALL_64_after_hwframe+0x46/0xb0 </TASK>",,,"[{""url"":""https://git.kernel.org/stable/c/388326bb1c32fcd09371c1d494af71471ef3a04b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4ee8c39968a648d58b273582d4b021044a41ee5e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b5605148e6ce36bb21020d49010b617693933128"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de95b52d9aabc979166aba81ccbe623aaf9c16a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e60d7e2462bf57273563c4e00dbfa79ee973b9e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50130,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:42.810,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: staging: fbtft: core: set smem_len before fb_deferred_io_init call The fbtft_framebuffer_alloc() calls fb_deferred_io_init() before initializing info->fix.smem_len. It is set to zero by the framebuffer_alloc() function. It will trigger a WARN_ON() at the start of fb_deferred_io_init() and the function will not do anything.",,,"[{""url"":""https://git.kernel.org/stable/c/4178bfa3fc9de556dfe248a6eabe29280f0ffda5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5185c319e8ea67657e0d3edd520a7276516c506a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6ae6abe240306f878557d6eadd950a2e2561f59f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/81e878887ff82a7dd42f22951391069a5d520627"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50131,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:42.920,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: HID: mcp2221: prevent a buffer overflow in mcp_smbus_write() Smatch Warning: drivers/hid/hid-mcp2221.c:388 mcp_smbus_write() error: __memcpy() '&mcp->txbuf[5]' too small (59 vs 255) drivers/hid/hid-mcp2221.c:388 mcp_smbus_write() error: __memcpy() 'buf' too small (34 vs 255) The 'len' variable can take a value between 0-255 as it can come from data->block[0] and it is user data. So add an bound check to prevent a buffer overflow in memcpy().",,,"[{""url"":""https://git.kernel.org/stable/c/3c0f8a59f2cc8841ee6653399a77f4f3e6e9a270"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/62ac2473553a00229e67bdf3cb023b62cf7f5a9a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6402116a7b5ec80fa40fd145a80c813019cd555f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/66c8e816f2f2ca4a61b406503bd10bad1b35f72f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/91443c669d280937968f0aa4edefa741cfe35314"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50132,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:43.030,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: cdns3: change place of 'priv_ep' assignment in cdns3_gadget_ep_dequeue(), cdns3_gadget_ep_enable() If 'ep' is NULL, result of ep_to_cdns3_ep(ep) is invalid pointer and its dereference with priv_ep->cdns3_dev may cause panic. Found by Linux Verification Center (linuxtesting.org) with SVACE.",,,"[{""url"":""https://git.kernel.org/stable/c/7af83bb516d7aa4f96835288e4aeda21d7aa2a17"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bfa0201468587072454dba7933e4a4a7be44467a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c3ffc9c4ca44bfe9562166793d133e1fb0630ea6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d342203df9f2d0851b4acd9ed577d73d10eade77"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb82c0382285ee17a9966aaab27b8becb08eb1ac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50133,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:43.140,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: xhci_plat_remove: avoid NULL dereference Since commit 4736ebd7fcaff1eb8481c140ba494962847d6e0a (""usb: host: xhci-plat: omit shared hcd if either root hub has no ports"") xhci->shared_hcd can be NULL, which causes the following Oops on reboot: [ 710.124450] systemd-shutdown[1]: Rebooting. [ 710.298861] xhci-hcd xhci-hcd.2.auto: remove, state 4 [ 710.304217] usb usb3: USB disconnect, device number 1 [ 710.317441] xhci-hcd xhci-hcd.2.auto: USB bus 3 deregistered [ 710.323280] xhci-hcd xhci-hcd.2.auto: remove, state 1 [ 710.328401] usb usb2: USB disconnect, device number 1 [ 710.333515] usb 2-3: USB disconnect, device number 2 [ 710.467649] xhci-hcd xhci-hcd.2.auto: USB bus 2 deregistered [ 710.475450] Unable to handle kernel NULL pointer dereference at virtual address 00000000000003b8 [ 710.484425] Mem abort info: [ 710.487265] ESR = 0x0000000096000004 [ 710.491060] EC = 0x25: DABT (current EL), IL = 32 bits [ 710.496427] SET = 0, FnV = 0 [ 710.499525] EA = 0, S1PTW = 0 [ 710.502716] FSC = 0x04: level 0 translation fault [ 710.507648] Data abort info: [ 710.510577] ISV = 0, ISS = 0x00000004 [ 710.514462] CM = 0, WnR = 0 [ 710.517480] user pgtable: 4k pages, 48-bit VAs, pgdp=00000008b0050000 [ 710.523976] [00000000000003b8] pgd=0000000000000000, p4d=0000000000000000 [ 710.530961] Internal error: Oops: 96000004 [#1] PREEMPT SMP [ 710.536551] Modules linked in: rfkill input_leds snd_soc_simple_card snd_soc_simple_card_utils snd_soc_nau8822 designware_i2s snd_soc_core dw_hdmi_ahb_audio snd_pcm_dmaengine arm_ccn panfrost ac97_bus gpu_sched snd_pcm at24 fuse configfs sdhci_of_dwcmshc sdhci_pltfm sdhci nvme led_class mmc_core nvme_core bt1_pvt polynomial tp_serio snd_seq_midi snd_seq_midi_event snd_seq snd_timer snd_rawmidi snd_seq_device snd soundcore efivarfs ipv6 [ 710.575286] CPU: 7 PID: 1 Comm: systemd-shutdow Not tainted 5.19.0-rc7-00043-gfd8619f4fd54 #1 [ 710.583822] Hardware name: T-Platforms TF307-MB/BM1BM1-A, BIOS 5.6 07/06/2022 [ 710.590972] pstate: 40000005 (nZcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 710.597949] pc : usb_remove_hcd+0x34/0x1e4 [ 710.602067] lr : xhci_plat_remove+0x74/0x140 [ 710.606351] sp : ffff800009f3b7c0 [ 710.609674] x29: ffff800009f3b7c0 x28: ffff000800960040 x27: 0000000000000000 [ 710.616833] x26: ffff800008dc22a0 x25: 0000000000000000 x24: 0000000000000000 [ 710.623992] x23: 0000000000000000 x22: ffff000805465810 x21: ffff000805465800 [ 710.631149] x20: ffff000800f80000 x19: 0000000000000000 x18: ffffffffffffffff [ 710.638307] x17: ffff000805096000 x16: ffff00080633b800 x15: ffff000806537a1c [ 710.645465] x14: 0000000000000001 x13: 0000000000000000 x12: ffff00080378d6f0 [ 710.652621] x11: ffff00080041a900 x10: ffff800009b204e8 x9 : ffff8000088abaa4 [ 710.659779] x8 : ffff000800960040 x7 : ffff800009409000 x6 : 0000000000000001 [ 710.666936] x5 : ffff800009241000 x4 : ffff800009241440 x3 : 0000000000000000 [ 710.674094] x2 : ffff000800960040 x1 : ffff000800960040 x0 : 0000000000000000 [ 710.681251] Call trace: [ 710.683704] usb_remove_hcd+0x34/0x1e4 [ 710.687467] xhci_plat_remove+0x74/0x140 [ 710.691400] platform_remove+0x34/0x70 [ 710.695165] device_remove+0x54/0x90 [ 710.698753] device_release_driver_internal+0x200/0x270 [ 710.703992] device_release_driver+0x24/0x30 [ 710.708273] bus_remove_device+0xe0/0x16c [ 710.712293] device_del+0x178/0x390 [ 710.715797] platform_device_del.part.0+0x24/0x90 [ 710.720514] platform_device_unregister+0x30/0x50 [ 710.725232] dwc3_host_exit+0x20/0x30 [ 710.728907] dwc3_remove+0x174/0x1b0 [ 710.732494] platform_remove+0x34/0x70 [ 710.736254] device_remove+0x54/0x90 [ 710.739840] device_release_driver_internal+0x200/0x270 [ 710.745078] device_release_driver+0x24/0x30 [ 710.749359] bus_remove_device+0xe0/0x16c [ 710.753380] device_del+0x178/0x390 [ 710.756881] platform_device_del.part ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/371a8af4f26e06b4d51d893b4436f520b48d07fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d7de14d74d6551f0d097430f9893ce82ad17e5b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50134,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:43.263,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/hfi1: fix potential memory leak in setup_base_ctxt() setup_base_ctxt() allocates a memory chunk for uctxt->groups with hfi1_alloc_ctxt_rcv_groups(). When init_user_ctxt() fails, uctxt->groups is not released, which will lead to a memory leak. We should release the uctxt->groups with hfi1_free_ctxt_rcv_groups() when init_user_ctxt() fails.",,,"[{""url"":""https://git.kernel.org/stable/c/1750be1e9f18787cf717c24dbc5fa029fc372a22"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2f90813f1c21c3d780585390af961bd17c8515ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90ef48a718f88935d4af53d7dadd1ceafe103ce6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a85c7dd1edadcdeca24e603a6618153a3bcc81ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9055dfe437efae77e28e57205437c878a03ccb7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa2a1df3a2c85f855af7d54466ac10bd48645d63"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e25b828553aecb3185a8d8d0c4f9b4e133fb5db6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc4de8009fd6c2ca51986c6757efa964040e7d02"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50135,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:43.387,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/rxe: Fix BUG: KASAN: null-ptr-deref in rxe_qp_do_cleanup The function rxe_create_qp calls rxe_qp_from_init. If some error occurs, the error handler of function rxe_qp_from_init will set both scq and rcq to NULL. Then rxe_create_qp calls rxe_put to handle qp. In the end, rxe_qp_do_cleanup is called by rxe_put. rxe_qp_do_cleanup directly accesses scq and rcq before checking them. This will cause null-ptr-deref error. The call graph is as below: rxe_create_qp { ... rxe_qp_from_init { ... err1: ... qp->rcq = NULL; <---rcq is set to NULL qp->scq = NULL; <---scq is set to NULL ... } qp_init: rxe_put{ ... rxe_qp_do_cleanup { ... atomic_dec(&qp->scq->num_wq); <--- scq is accessed ... atomic_dec(&qp->rcq->num_wq); <--- rcq is accessed } }",,,"[{""url"":""https://git.kernel.org/stable/c/37da51efe6eaa0560f46803c8c436a48a2084da7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8598b9d0a364c1663c96fc0fab9df0d36c809aea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50136,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:43.493,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/siw: Fix duplicated reported IW_CM_EVENT_CONNECT_REPLY event If siw_recv_mpa_rr returns -EAGAIN, it means that the MPA reply hasn't been received completely, and should not report IW_CM_EVENT_CONNECT_REPLY in this case. This may trigger a call trace in iw_cm. A simple way to trigger this: server: ib_send_lat client: ib_send_lat -R <server_ip> The call trace looks like this: kernel BUG at drivers/infiniband/core/iwcm.c:894! invalid opcode: 0000 [#1] PREEMPT SMP NOPTI <...> Workqueue: iw_cm_wq cm_work_handler [iw_cm] Call Trace: <TASK> cm_work_handler+0x1dd/0x370 [iw_cm] process_one_work+0x1e2/0x3b0 worker_thread+0x49/0x2e0 ? rescuer_thread+0x370/0x370 kthread+0xe5/0x110 ? kthread_complete_and_exit+0x20/0x20 ret_from_fork+0x1f/0x30 </TASK>",,,"[{""url"":""https://git.kernel.org/stable/c/0066246d2d7e2619f3ecf3cf07333c59e6e7d84d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/11edf0bba15ea9df49478affec7974f351bb2f6e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1434de50a5d9dab91c8ce031bc23b3e2178379c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3056fc6c32e613b760422b94c7617ac9a24a4721"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ade92ddaf2347fb34298c02080caaa3cdd7c27b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f6e26e1a5f600b760dc32135d3fac846eabe09e7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50137,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:43.623,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/irdma: Fix a window for use-after-free During a destroy CQ an interrupt may cause processing of a CQE after CQ resources are freed by irdma_cq_free_rsrc(). Fix this by moving the call to irdma_cq_free_rsrc() after the irdma_sc_cleanup_ceqes(), which is called under the cq_lock.",,,"[{""url"":""https://git.kernel.org/stable/c/0abf2eef80295923b819ce89ff9edc1fe61be17c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/350ac793a03c8a30a3f2b27fc282cd1c67070763"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ecef7890b3aea78c8bbb501a4b5b8134367b821"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/92520864ef9f912f38b403d172a0ded020683d55"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50138,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:43.733,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/qedr: Fix potential memory leak in __qedr_alloc_mr() __qedr_alloc_mr() allocates a memory chunk for ""mr->info.pbl_table"" with init_mr_info(). When rdma_alloc_tid() and rdma_register_tid() fail, ""mr"" is released while ""mr->info.pbl_table"" is not released, which will lead to a memory leak. We should release the ""mr->info.pbl_table"" with qedr_free_pbl() when error occurs to fix the memory leak.",,,"[{""url"":""https://git.kernel.org/stable/c/07ba048df306dc93fc4d2ef670b9e24644a2069f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/79ce50dddaf28b5c57911ecc80a2be17a0b17f83"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7e647a8d5fc0a2c8e0f36f585a6388286a25bb15"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3236a64ddd125a455ef5b5316c1b9051b732974"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b4c9f7db9f0148423557539af0fdf513338efe08"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50139,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:43.840,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: aspeed-vhub: Fix refcount leak bug in ast_vhub_init_desc() We should call of_node_put() for the reference returned by of_get_child_by_name() which has increased the refcount.",,,"[{""url"":""https://git.kernel.org/stable/c/0e0a40c803643f4edc30f0660f2f3bea4d57a99a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/220fafb4ed04187e9c17be4152da5a7f2ffbdd8c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3503305225ca24c3229414c769323fb8bf39b4bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4070f3c83cd28267f469a59751480ad39435f26a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e6db5780c2bf6e23be7b315809ef349b4b4f2213"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50140,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:43.953,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: memstick/ms_block: Fix a memory leak 'erased_blocks_bitmap' is never freed. As it is allocated at the same time as 'used_blocks_bitmap', it is likely that it should be freed also at the same time. Add the corresponding bitmap_free() in msb_data_clear().",,,"[{""url"":""https://git.kernel.org/stable/c/16e07966638717416abf45393d6a80a5a1034429"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/37958980eb4cd71ae594ace093c11b6a91e165e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/39be95d1ff7b44c1e969af72ba9da7332dfcc1da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/54eb7a55be6779c4d0c25eaf5056498a28595049"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9260a154b3b5e387dbceec7c0ac441470646bc6f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/961d7d12080fe70847f944d656e36cd0dd0214ba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d8b911fe3c3ed788c66edba7c90e32a4a7a5f53"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/efd675246aec045507b9425c67b548cc2d782d8f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50141,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:44.070,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mmc: sdhci-of-esdhc: Fix refcount leak in esdhc_signal_voltage_switch of_find_matching_node() returns a node pointer with refcount incremented, we should use of_node_put() on it when not need anymore. Add missing of_node_put() to avoid refcount leak. of_node_put() checks null pointer.",,,"[{""url"":""https://git.kernel.org/stable/c/352377cf74710bc3368dddf78f17210dfe456933"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c472a2c9ed6ea9d272268d7f484d4303c549f1a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/547db1dd98d1815574ebea7358015a17199a93bc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8b902840f6a3584f702bcb59834691b30f3d7c5a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a63d5d01e83b984b1b9c7ae8fc9c8c93697a3820"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b074f1e8060836baeb0ee91181f4194b9a0ee16a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b305475df756256a186623f0991d05a816de881a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b5899a3e2f783a27b268e38d37f9b24c71bddf45"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50142,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:44.187,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: intel_th: msu: Fix vmalloced buffers After commit f5ff79fddf0e (""dma-mapping: remove CONFIG_DMA_REMAP"") there's a chance of DMA buffer getting allocated via vmalloc(), which messes up the mmapping code: > RIP: msc_mmap_fault [intel_th_msu] > Call Trace: > <TASK> > __do_fault > do_fault ... Fix this by accounting for vmalloc possibility.",,,"[{""url"":""https://git.kernel.org/stable/c/0ed72c6bc632cbf8d979ac60f982ff84b7bb610a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4914c50670b6a531e2cb17cd984cc565b4681312"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/566887bad7ff2297d6b3f9659c702ba075f3d62d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6ae2881c1d1fa0e33f4763b7c786f8ef05a9c828"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac12ad3ccf6d386e64a9d6a890595a2509d24edd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b5d924cb4c7b952eaa61622f14427723a78137a3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50143,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:44.297,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: intel_th: Fix a resource leak in an error handling path If an error occurs after calling 'pci_alloc_irq_vectors()', 'pci_free_irq_vectors()' must be called as already done in the remove function.",,,"[{""url"":""https://git.kernel.org/stable/c/086c28ab7c5699256aced0049aae9c42f1410313"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/859342220accd0d332864fafbf4e3d2d0492bc3f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9b5469573a274729bdb04b60a8d71f8d09940a31"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a8f3b78b1f8e959d06801ae82149f140a75724e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ed4d5ecb7d7fd80336afb2f9ac6685651a6aa32f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fae9da7d4c2ccad3792de03e3cac1fe2bfabb73d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50144,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:44.413,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: soundwire: revisit driver bind/unbind and callbacks In the SoundWire probe, we store a pointer from the driver ops into the 'slave' structure. This can lead to kernel oopses when unbinding codec drivers, e.g. with the following sequence to remove machine driver and codec driver. /sbin/modprobe -r snd_soc_sof_sdw /sbin/modprobe -r snd_soc_rt711 The full details can be found in the BugLink below, for reference the two following examples show different cases of driver ops/callbacks being invoked after the driver .remove(). kernel: BUG: kernel NULL pointer dereference, address: 0000000000000150 kernel: Workqueue: events cdns_update_slave_status_work [soundwire_cadence] kernel: RIP: 0010:mutex_lock+0x19/0x30 kernel: Call Trace: kernel: ? sdw_handle_slave_status+0x426/0xe00 [soundwire_bus 94ff184bf398570c3f8ff7efe9e32529f532e4ae] kernel: ? newidle_balance+0x26a/0x400 kernel: ? cdns_update_slave_status_work+0x1e9/0x200 [soundwire_cadence 1bcf98eebe5ba9833cd433323769ac923c9c6f82] kernel: BUG: unable to handle page fault for address: ffffffffc07654c8 kernel: Workqueue: pm pm_runtime_work kernel: RIP: 0010:sdw_bus_prep_clk_stop+0x6f/0x160 [soundwire_bus] kernel: Call Trace: kernel: <TASK> kernel: sdw_cdns_clock_stop+0xb5/0x1b0 [soundwire_cadence 1bcf98eebe5ba9833cd433323769ac923c9c6f82] kernel: intel_suspend_runtime+0x5f/0x120 [soundwire_intel aca858f7c87048d3152a4a41bb68abb9b663a1dd] kernel: ? dpm_sysfs_remove+0x60/0x60 This was not detected earlier in Intel tests since the tests first remove the parent PCI device and shut down the bus. The sequence above is a corner case which keeps the bus operational but without a driver bound. While trying to solve this kernel oopses, it became clear that the existing SoundWire bus does not deal well with the unbind case. Commit 528be501b7d4a (""soundwire: sdw_slave: add probe_complete structure and new fields"") added a 'probed' status variable and a 'probe_complete' struct completion. This status is however not reset on remove and likewise the 'probe complete' is not re-initialized, so the bind/unbind/bind test cases would fail. The timeout used before the 'update_status' callback was also a bad idea in hindsight, there should really be no timing assumption as to if and when a driver is bound to a device. An initial draft was based on device_lock() and device_unlock() was tested. This proved too complicated, with deadlocks created during the suspend-resume sequences, which also use the same device_lock/unlock() as the bind/unbind sequences. On a CometLake device, a bad DSDT/BIOS caused spurious resumes and the use of device_lock() caused hangs during suspend. After multiple weeks or testing and painful reverse-engineering of deadlocks on different devices, we looked for alternatives that did not interfere with the device core. A bus notifier was used successfully to keep track of DRIVER_BOUND and DRIVER_UNBIND events. This solved the bind-unbind-bind case in tests, but it can still be defeated with a theoretical corner case where the memory is freed by a .remove while the callback is in use. The notifier only helps make sure the driver callbacks are valid, but not that the memory allocated in probe remains valid while the callbacks are invoked. This patch suggests the introduction of a new 'sdw_dev_lock' mutex protecting probe/remove and all driver callbacks. Since this mutex is 'local' to SoundWire only, it does not interfere with existing locks and does not create deadlocks. In addition, this patch removes the 'probe_complete' completion, instead we directly invoke the 'update_status' from the probe routine. That removes any sort of timing dependency and a much better support for the device/driver model, the driver could be bound before the bus started, or eons after the bus started and the hardware would be properly initialized in all cases. BugLink: https://github.com/thesofproject/linux/is ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/250b46505175889c6b5958c3829f610f52199f5f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/432b30f08ca3303d2ebb22352cb04c4b6cfefe65"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8fd6b03646b9a9e16d1ec19bd724cd6bd78e0ea5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd29c00edd0a5dac8b6e7332bb470cd50f92e893"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50145,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:44.527,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dmaengine: sf-pdma: Add multithread support for a DMA channel When we get a DMA channel and try to use it in multiple threads it will cause oops and hanging the system. % echo 64 > /sys/module/dmatest/parameters/threads_per_chan % echo 10000 > /sys/module/dmatest/parameters/iterations % echo 1 > /sys/module/dmatest/parameters/run [ 89.480664] Unable to handle kernel NULL pointer dereference at virtual address 00000000000000a0 [ 89.488725] Oops [#1] [ 89.494708] CPU: 2 PID: 1008 Comm: dma0chan0-copy0 Not tainted 5.17.0-rc5 [ 89.509385] epc : vchan_find_desc+0x32/0x46 [ 89.513553] ra : sf_pdma_tx_status+0xca/0xd6 This happens because of data race. Each thread rewrite channels's descriptor as soon as device_prep_dma_memcpy() is called. It leads to the situation when the driver thinks that it uses right descriptor that actually is freed or substituted for other one. With current fixes a descriptor changes its value only when it has been used. A new descriptor is acquired from vc->desc_issued queue that is already filled with descriptors that are ready to be sent. Threads have no direct access to DMA channel descriptor. Now it is just possible to queue a descriptor for further processing.",,,"[{""url"":""https://git.kernel.org/stable/c/4c7350b1dd8a192af844de32fc99b9e34c876fda"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5ab2782c944e324008ef5d658f2494a9f0e3c5ac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a93b3f1e11971a91b6441b6d47488f4492cc113f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b2cc5c465c2cb8ab697c3fd6583c614e3f6cfbcc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b9b4992f897be9b0b9e3a3b956cab6b75ccc3f11"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50146,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:44.633,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: PCI: dwc: Deallocate EPC memory on dw_pcie_ep_init() errors If dw_pcie_ep_init() fails to perform any action after the EPC memory is initialized and the MSI memory region is allocated, the latter parts won't be undone thus causing a memory leak. Add a cleanup-on-error path to fix these leaks. [bhelgaas: commit log]",,,"[{""url"":""https://git.kernel.org/stable/c/2d546db5c80c45cac3ccd929550244fd58f4ff58"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3b453f5d06d1f1d6b20a75ea51dc7b53ae78f479"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8161e9626b50892eaedbd8070ecb1586ecedb109"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b03a8f1264ea8c363bec9ef6e37b467f27cb04ea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e7599a5974d4c64eaae8009c3f2e47b9e3223e07"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50147,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:44.743,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm/mempolicy: fix get_nodes out of bound access When user specified more nodes than supported, get_nodes will access nmask array out of bounds.",,,"[{""url"":""https://git.kernel.org/stable/c/000eca5d044d1ee23b4ca311793cf3fc528da6c6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/44652154484e7e3d12008802cfb6c28a8aa16d85"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8176f6a0d9c1b06bc7af7c3d6acd4a66448939df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d1b5113674c3e95bb53c601ce2ea4719e851c74d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50148,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:44.857,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: kernfs: fix potential NULL dereference in __kernfs_remove When lockdep is enabled, lockdep_assert_held_write would cause potential NULL pointer dereference. Fix the following smatch warnings: fs/kernfs/dir.c:1353 __kernfs_remove() warn: variable dereferenced before check 'kn' (see line 1346)",,,"[{""url"":""https://git.kernel.org/stable/c/4a9f35b8729c5bf13ea671c908c17ed74c48fc50"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/72b5d5aef246a0387cefa23121dd90901c7a691a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b871986d9d3071f5082664ac274d93f08db257cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50149,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:44.963,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: driver core: fix potential deadlock in __driver_attach In __driver_attach function, There are also AA deadlock problem, like the commit b232b02bf3c2 (""driver core: fix deadlock in __device_attach""). stack like commit b232b02bf3c2 (""driver core: fix deadlock in __device_attach""). list below: In __driver_attach function, The lock holding logic is as follows: ... __driver_attach if (driver_allows_async_probing(drv)) device_lock(dev) // get lock dev async_schedule_dev(__driver_attach_async_helper, dev); // func async_schedule_node async_schedule_node_domain(func) entry = kzalloc(sizeof(struct async_entry), GFP_ATOMIC); /* when fail or work limit, sync to execute func, but __driver_attach_async_helper will get lock dev as will, which will lead to A-A deadlock. */ if (!entry || atomic_read(&entry_count) > MAX_WORK) { func; else queue_work_node(node, system_unbound_wq, &entry->work) device_unlock(dev) As above show, when it is allowed to do async probes, because of out of memory or work limit, async work is not be allowed, to do sync execute instead. it will lead to A-A deadlock because of __driver_attach_async_helper getting lock dev. Reproduce: and it can be reproduce by make the condition (if (!entry || atomic_read(&entry_count) > MAX_WORK)) untenable, like below: [ 370.785650] ""echo 0 > /proc/sys/kernel/hung_task_timeout_secs"" disables this message. [ 370.787154] task:swapper/0 state:D stack: 0 pid: 1 ppid: 0 flags:0x00004000 [ 370.788865] Call Trace: [ 370.789374] <TASK> [ 370.789841] __schedule+0x482/0x1050 [ 370.790613] schedule+0x92/0x1a0 [ 370.791290] schedule_preempt_disabled+0x2c/0x50 [ 370.792256] __mutex_lock.isra.0+0x757/0xec0 [ 370.793158] __mutex_lock_slowpath+0x1f/0x30 [ 370.794079] mutex_lock+0x50/0x60 [ 370.794795] __device_driver_lock+0x2f/0x70 [ 370.795677] ? driver_probe_device+0xd0/0xd0 [ 370.796576] __driver_attach_async_helper+0x1d/0xd0 [ 370.797318] ? driver_probe_device+0xd0/0xd0 [ 370.797957] async_schedule_node_domain+0xa5/0xc0 [ 370.798652] async_schedule_node+0x19/0x30 [ 370.799243] __driver_attach+0x246/0x290 [ 370.799828] ? driver_allows_async_probing+0xa0/0xa0 [ 370.800548] bus_for_each_dev+0x9d/0x130 [ 370.801132] driver_attach+0x22/0x30 [ 370.801666] bus_add_driver+0x290/0x340 [ 370.802246] driver_register+0x88/0x140 [ 370.802817] ? virtio_scsi_init+0x116/0x116 [ 370.803425] scsi_register_driver+0x1a/0x30 [ 370.804057] init_sd+0x184/0x226 [ 370.804533] do_one_initcall+0x71/0x3a0 [ 370.805107] kernel_init_freeable+0x39a/0x43a [ 370.805759] ? rest_init+0x150/0x150 [ 370.806283] kernel_init+0x26/0x230 [ 370.806799] ret_from_fork+0x1f/0x30 To fix the deadlock, move the async_schedule_dev outside device_lock, as we can see, in async_schedule_node_domain, the parameter of queue_work_node is system_unbound_wq, so it can accept concurrent operations. which will also not change the code logic, and will not lead to deadlock.",,,"[{""url"":""https://git.kernel.org/stable/c/37f908038402c9b8325763f306a1c65d88757e15"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/70fe758352cafdee72a7b13bf9db065f9613ced8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/733ab0c19bf17f6ad7c2b580ede006e369d5ab1b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/779b634714c51d05baaeff4868ce2fd9fc7399bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8191b6cd9ada09b675f17446d5872eb1f77685cb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a93f33aeef4e6a94ae9c9d3f5b2f9085ad0572ec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50150,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:45.073,2025-06-18T14:15:24.273,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2022-50151,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:45.190,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: cdns3: fix random warning message when driver load Warning log: [ 4.141392] Unexpected gfp: 0x4 (GFP_DMA32). Fixing up to gfp: 0xa20 (GFP_ATOMIC). Fix your code! [ 4.150340] CPU: 1 PID: 175 Comm: 1-0050 Not tainted 5.15.5-00039-g2fd9ae1b568c #20 [ 4.158010] Hardware name: Freescale i.MX8QXP MEK (DT) [ 4.163155] Call trace: [ 4.165600] dump_backtrace+0x0/0x1b0 [ 4.169286] show_stack+0x18/0x68 [ 4.172611] dump_stack_lvl+0x68/0x84 [ 4.176286] dump_stack+0x18/0x34 [ 4.179613] kmalloc_fix_flags+0x60/0x88 [ 4.183550] new_slab+0x334/0x370 [ 4.186878] ___slab_alloc.part.108+0x4d4/0x748 [ 4.191419] __slab_alloc.isra.109+0x30/0x78 [ 4.195702] kmem_cache_alloc+0x40c/0x420 [ 4.199725] dma_pool_alloc+0xac/0x1f8 [ 4.203486] cdns3_allocate_trb_pool+0xb4/0xd0 pool_alloc_page(struct dma_pool *pool, gfp_t mem_flags) { ... page = kmalloc(sizeof(*page), mem_flags); page->vaddr = dma_alloc_coherent(pool->dev, pool->allocation, &page->dma, mem_flags); ... } kmalloc was called with mem_flags, which is passed down in cdns3_allocate_trb_pool() and have GFP_DMA32 flags. kmall_fix_flags() report warning. GFP_DMA32 is not useful at all. dma_alloc_coherent() will handle DMA memory region correctly by pool->dev. GFP_DMA32 can be removed safely.",,,"[{""url"":""https://git.kernel.org/stable/c/8659ab3d936fcf0084676f98b75b317017aa8f82"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e142744f0e96abc69ccd99e6d6c7eb662267f21"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/960a8a35a6027a08c4b511435bf59609b5d5e5cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50152,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:45.297,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: ohci-nxp: Fix refcount leak in ohci_hcd_nxp_probe of_parse_phandle() returns a node pointer with refcount incremented, we should use of_node_put() on it when not need anymore. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/302970b4cad3ebfda2c05ce06c322ccdc447d17e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4db00c2fa6f8c9876a7e20511dccf43b50be9006"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/50238c4b54c2ac6c2da7a84a4a2b0a570e3da0e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/59026d5cc615da28e0c9806a71bf07065c906464"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/591ab8dbf6c21927f23f83ddb90691f48b86d136"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/65d36ec409b635dfc2f95f0d7c5877c9d0cb7630"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a0fbac3bf26a11f084233519ddf3fd5e5bb28939"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d35903e9650f4fa79426ce390db8678dbf5ac432"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50153,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:45.417,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: host: Fix refcount leak in ehci_hcd_ppc_of_probe of_find_compatible_node() returns a node pointer with refcount incremented, we should use of_node_put() on it when done. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/038453b17fe30ea38f0f3c916e2ae2b7f8cef84e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3a50c917c67dd0bc39c14de4a8b75a1d50fdce66"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/585d22a5624ef2b540c337665c72fea8cd33db50"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8cbc3870ff356366842af3228dd8e7bc278e5edd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e51a512c1079109bec4c80915e647692d583e79"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b5c5b13cb45e2c88181308186b0001992cb41954"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b9c4a480cb0ada07154debf681454cbb55e30b59"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c0a4b454486b23bb4d94ce49f490830ecc354040"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50154,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:45.530,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: PCI: mediatek-gen3: Fix refcount leak in mtk_pcie_init_irq_domains() of_get_child_by_name() returns a node pointer with refcount incremented, so we should use of_node_put() on it when we don't need it anymore. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/0675fe20da7fa69b1ba80c23470c1433a2356c03"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2aa166c39d5a8221e6e22ab1a583656d4c8dc7f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf038503d5fe90189743124233fe7aeb0984e961"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e593e22786edd9eca058cf054d6a2e12c138da67"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50155,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:45.640,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mtd: parsers: ofpart: Fix refcount leak in bcm4908_partitions_fw_offset of_find_node_by_path() returns a node pointer with refcount incremented, we should use of_node_put() on it when not need anymore. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/01bc3840d943cf725dea6ca13e11ffda82bad49a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3193c3a3f4fca65cb06d9d48d07fb96bc1f5b2bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/762475464982b15014f364ec0cf2a843407f5af1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e607879b0da18c451de5e91daf239cc2f2f8ff2d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50156,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:45.747,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: HID: cp2112: prevent a buffer overflow in cp2112_xfer() Smatch warnings: drivers/hid/hid-cp2112.c:793 cp2112_xfer() error: __memcpy() 'data->block[1]' too small (33 vs 255) drivers/hid/hid-cp2112.c:793 cp2112_xfer() error: __memcpy() 'buf' too small (64 vs 255) The 'read_length' variable is provided by 'data->block[0]' which comes from user and it(read_length) can take a value between 0-255. Add an upper bound to 'read_length' variable to prevent a buffer overflow in memcpy().",,,"[{""url"":""https://git.kernel.org/stable/c/26e427ac85c2b8d0d108cc80b6de34d33e2780c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/381583845d19cb4bd21c8193449385f3fefa9caf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3af7d60e9a6c17d6d41c4341f8020511887d372d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/519ff31a6ddd87aa4905bd9bf3b92e8b88801614"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8489a20ac481b08c0391608d81ed3796d373cfdf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e7028944e61014ae915e7fb74963d3835f2f761a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ebda3d6b004bb6127a66a616524a2de152302ca7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50157,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:45.863,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: PCI: microchip: Fix refcount leak in mc_pcie_init_irq_domains() of_get_next_child() returns a node pointer with refcount incremented, so we should use of_node_put() on it when we don't need it anymore. mc_pcie_init_irq_domains() only calls of_node_put() in the normal path, missing it in some error paths. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/6cd5f93b5c6a66c68a91dbc604a78207252ecd43"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/880ece912b958a0c92cc0baa8e906fb9b49a4b53"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c0ad5c7e68d10f6f8ffb0f4329e3c19404fbca58"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f030304fdeb87ec8f1b518c73703214aec6cc24a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50158,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:45.977,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mtd: partitions: Fix refcount leak in parse_redboot_of of_get_child_by_name() returns a node pointer with refcount incremented, we should use of_node_put() on it when not need anymore. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/55d0f7da66dec93c4d53d0886a1555618079a900"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ec48ac18d8f9e002ce9bfbad32741086739e499"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ea607579d300b2f7fc997f3dd20949114565fcd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9f7e62815cf3cbbcb1b8cb21649fb4dfdb3aa016"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e24af43d0cbe9f6aaa413c15ccce50bbbfd61e0e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f3cc27198c5d78cdda60a55ae749f815cd1fe5eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50159,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:46.090,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: of: check previous kernel's ima-kexec-buffer against memory bounds Presently ima_get_kexec_buffer() doesn't check if the previous kernel's ima-kexec-buffer lies outside the addressable memory range. This can result in a kernel panic if the new kernel is booted with 'mem=X' arg and the ima-kexec-buffer was allocated beyond that range by the previous kernel. The panic is usually of the form below: $ sudo kexec --initrd initrd vmlinux --append='mem=16G' <snip> BUG: Unable to handle kernel data access on read at 0xc000c01fff7f0000 Faulting instruction address: 0xc000000000837974 Oops: Kernel access of bad area, sig: 11 [#1] <snip> NIP [c000000000837974] ima_restore_measurement_list+0x94/0x6c0 LR [c00000000083b55c] ima_load_kexec_buffer+0xac/0x160 Call Trace: [c00000000371fa80] [c00000000083b55c] ima_load_kexec_buffer+0xac/0x160 [c00000000371fb00] [c0000000020512c4] ima_init+0x80/0x108 [c00000000371fb70] [c0000000020514dc] init_ima+0x4c/0x120 [c00000000371fbf0] [c000000000012240] do_one_initcall+0x60/0x2c0 [c00000000371fcc0] [c000000002004ad0] kernel_init_freeable+0x344/0x3ec [c00000000371fda0] [c0000000000128a4] kernel_init+0x34/0x1b0 [c00000000371fe10] [c00000000000ce64] ret_from_kernel_thread+0x5c/0x64 Instruction dump: f92100b8 f92100c0 90e10090 910100a0 4182050c 282a0017 3bc00000 40810330 7c0802a6 fb610198 7c9b2378 f80101d0 <a1240000> 2c090001 40820614 e9240010 ---[ end trace 0000000000000000 ]--- Fix this issue by checking returned PFN range of previous kernel's ima-kexec-buffer with page_is_ram() to ensure correct memory bounds.",,,"[{""url"":""https://git.kernel.org/stable/c/1b2263d6c86fca8f30e18231778393bfc287bb27"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/beb5bba5dd132650c073f815c685c60c3e5b783b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cbf9c4b9617b6767886a913705ca14b7600c77db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc3b8525f83ac6bbc885bb24bbb8a76f4622200e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50160,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:46.207,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mtd: maps: Fix refcount leak in ap_flash_init of_find_matching_node() returns a node pointer with refcount incremented, we should use of_node_put() on it when not need anymore. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/77087a04c8fd554134bddcb8a9ff87b21f357926"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/80b1465b2ae81ebb59bbe62bcb7a7f7d4e9ece6f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/941ef6997f9db704fe4fd62fc01e420fdd5048b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/995fb2874bb5696357846a91e59181c600e6aac8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a74322d4b897ddc268b340c4a397f6066c2f945d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/babd7b0124650ab71a6487e38588b8659b3aa2dc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d10855876a6f47add6ff621cef25cc0171dac162"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d5730780e9ea84e5476752a47c749036c6a74af5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50161,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:46.327,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mtd: maps: Fix refcount leak in of_flash_probe_versatile of_find_matching_node_and_match() returns a node pointer with refcount incremented, we should use of_node_put() on it when not need anymore. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/33ec82a6d2b119938f26e5c8040ed5d92378eb54"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3c8de6a838b7e0eb392754ac89dd66e698684342"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4d67c8f74d804b20febf716ec96e9a475457ec60"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/52ae2b14f76ef2d490337ddc0037bc37125be7b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5d5ddd8771fa9cabeb247fba5f6ab60d63f3fbce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/79e57889aa0d92a6d769bad808fb105e7b6ea495"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9124d51e01232a91da4034768a2a8d1688472179"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f516fbb63873ee23cba5b7c3d239677c30f13df8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50162,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:46.440,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: libertas: Fix possible refcount leak in if_usb_probe() usb_get_dev will be called before lbs_get_firmware_async which means that usb_put_dev need to be called when lbs_get_firmware_async fails.",,,"[{""url"":""https://git.kernel.org/stable/c/00d0c4e59c0f8ad1f86874bb64b220394e687028"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c8e2f9ce1428e44cb103035eeced7aeb6b80980"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5b92f406a5199b6b01dc664b9226d824ae2835f0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/61b2ec97487399c58ae2e34f250f4884e671799b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6fd57e1d120bf13d4dc6c200a7cf914e6347a316"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/878e7f39803a9ab5bb9766956a7a04351d4bf99d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/97e5d3e46a3a2100253a9717a4df98d68aeb10b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d7365590d15bbd9008f424ef043d1778ffe29f42"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50163,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:46.560,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ax25: fix incorrect dev_tracker usage While investigating a separate rose issue [1], and enabling CONFIG_NET_DEV_REFCNT_TRACKER=y, Bernard reported an orthogonal ax25 issue [2] An ax25_dev can be used by one (or many) struct ax25_cb. We thus need different dev_tracker, one per struct ax25_cb. After this patch is applied, we are able to focus on rose. [1] https://lore.kernel.org/netdev/fb7544a1-f42e-9254-18cc-c9b071f4ca70@free.fr/ [2] [ 205.798723] reference already released. [ 205.798732] allocated in: [ 205.798734] ax25_bind+0x1a2/0x230 [ax25] [ 205.798747] __sys_bind+0xea/0x110 [ 205.798753] __x64_sys_bind+0x18/0x20 [ 205.798758] do_syscall_64+0x5c/0x80 [ 205.798763] entry_SYSCALL_64_after_hwframe+0x44/0xae [ 205.798768] freed in: [ 205.798770] ax25_release+0x115/0x370 [ax25] [ 205.798778] __sock_release+0x42/0xb0 [ 205.798782] sock_close+0x15/0x20 [ 205.798785] __fput+0x9f/0x260 [ 205.798789] ____fput+0xe/0x10 [ 205.798792] task_work_run+0x64/0xa0 [ 205.798798] exit_to_user_mode_prepare+0x18b/0x190 [ 205.798804] syscall_exit_to_user_mode+0x26/0x40 [ 205.798808] do_syscall_64+0x69/0x80 [ 205.798812] entry_SYSCALL_64_after_hwframe+0x44/0xae [ 205.798827] ------------[ cut here ]------------ [ 205.798829] WARNING: CPU: 2 PID: 2605 at lib/ref_tracker.c:136 ref_tracker_free.cold+0x60/0x81 [ 205.798837] Modules linked in: rose netrom mkiss ax25 rfcomm cmac algif_hash algif_skcipher af_alg bnep snd_hda_codec_hdmi nls_iso8859_1 i915 rtw88_8821ce rtw88_8821c x86_pkg_temp_thermal rtw88_pci intel_powerclamp rtw88_core snd_hda_codec_realtek snd_hda_codec_generic ledtrig_audio coretemp snd_hda_intel kvm_intel snd_intel_dspcfg mac80211 snd_hda_codec kvm i2c_algo_bit drm_buddy drm_dp_helper btusb drm_kms_helper snd_hwdep btrtl snd_hda_core btbcm joydev crct10dif_pclmul btintel crc32_pclmul ghash_clmulni_intel mei_hdcp btmtk intel_rapl_msr aesni_intel bluetooth input_leds snd_pcm crypto_simd syscopyarea processor_thermal_device_pci_legacy sysfillrect cryptd intel_soc_dts_iosf snd_seq sysimgblt ecdh_generic fb_sys_fops rapl libarc4 processor_thermal_device intel_cstate processor_thermal_rfim cec snd_timer ecc snd_seq_device cfg80211 processor_thermal_mbox mei_me processor_thermal_rapl mei rc_core at24 snd intel_pch_thermal intel_rapl_common ttm soundcore int340x_thermal_zone video [ 205.798948] mac_hid acpi_pad sch_fq_codel ipmi_devintf ipmi_msghandler drm msr parport_pc ppdev lp parport ramoops pstore_blk reed_solomon pstore_zone efi_pstore ip_tables x_tables autofs4 hid_generic usbhid hid i2c_i801 i2c_smbus r8169 xhci_pci ahci libahci realtek lpc_ich xhci_pci_renesas [last unloaded: ax25] [ 205.798992] CPU: 2 PID: 2605 Comm: ax25ipd Not tainted 5.18.11-F6BVP #3 [ 205.798996] Hardware name: To be filled by O.E.M. To be filled by O.E.M./CK3, BIOS 5.011 09/16/2020 [ 205.798999] RIP: 0010:ref_tracker_free.cold+0x60/0x81 [ 205.799005] Code: e8 d2 01 9b ff 83 7b 18 00 74 14 48 c7 c7 2f d7 ff 98 e8 10 6e fc ff 8b 7b 18 e8 b8 01 9b ff 4c 89 ee 4c 89 e7 e8 5d fd 07 00 <0f> 0b b8 ea ff ff ff e9 30 05 9b ff 41 0f b6 f7 48 c7 c7 a0 fa 4e [ 205.799008] RSP: 0018:ffffaf5281073958 EFLAGS: 00010286 [ 205.799011] RAX: 0000000080000000 RBX: ffff9a0bd687ebe0 RCX: 0000000000000000 [ 205.799014] RDX: 0000000000000001 RSI: 0000000000000282 RDI: 00000000ffffffff [ 205.799016] RBP: ffffaf5281073a10 R08: 0000000000000003 R09: fffffffffffd5618 [ 205.799019] R10: 0000000000ffff10 R11: 000000000000000f R12: ffff9a0bc53384d0 [ 205.799022] R13: 0000000000000282 R14: 00000000ae000001 R15: 0000000000000001 [ 205.799024] FS: 0000000000000000(0000) GS:ffff9a0d0f300000(0000) knlGS:0000000000000000 [ 205.799028] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 205.799031] CR2: 00007ff6b8311554 CR3: 000000001ac10004 CR4: 00000000001706e0 [ 205.799033] Call Trace: [ 205.799035] <TASK> [ 205.799038] ? ax25_dev_device_down+0xd9/ ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/4294df1374450912b2f64ee3cf575069fc784679"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d08e3d71e5942f77fbff7f3529ed7fc82fbb3dfa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d7c4c9e075f8cc6d88d277bc24e5d99297f03c06"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50164,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:46.677,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: iwlwifi: mvm: fix double list_add at iwl_mvm_mac_wake_tx_queue After successfull station association, if station queues are disabled for some reason, the related lists are not emptied. So if some new element is added to the list in iwl_mvm_mac_wake_tx_queue, it can match with the old one and produce a BUG like this: [ 46.535263] list_add corruption. prev->next should be next (ffff94c1c318a360), but was 0000000000000000. (prev=ffff94c1d02d3388). [ 46.535283] ------------[ cut here ]------------ [ 46.535284] kernel BUG at lib/list_debug.c:26! [ 46.535290] invalid opcode: 0000 [#1] PREEMPT SMP PTI [ 46.585304] CPU: 0 PID: 623 Comm: wpa_supplicant Not tainted 5.19.0-rc3+ #1 [ 46.592380] Hardware name: Dell Inc. Inspiron 660s/0478VN , BIOS A07 08/24/2012 [ 46.600336] RIP: 0010:__list_add_valid.cold+0x3d/0x3f [ 46.605475] Code: f2 4c 89 c1 48 89 fe 48 c7 c7 c8 40 67 93 e8 20 cc fd ff 0f 0b 48 89 d1 4c 89 c6 4c 89 ca 48 c7 c7 70 40 67 93 e8 09 cc fd ff <0f> 0b 48 89 fe 48 c7 c7 00 41 67 93 e8 f8 cb fd ff 0f 0b 48 89 d1 [ 46.624469] RSP: 0018:ffffb20800ab76d8 EFLAGS: 00010286 [ 46.629854] RAX: 0000000000000075 RBX: ffff94c1c318a0e0 RCX: 0000000000000000 [ 46.637105] RDX: 0000000000000201 RSI: ffffffff9365e100 RDI: 00000000ffffffff [ 46.644356] RBP: ffff94c1c5f43370 R08: 0000000000000075 R09: 3064316334396666 [ 46.651607] R10: 3364323064316334 R11: 39666666663d7665 R12: ffff94c1c5f43388 [ 46.658857] R13: ffff94c1d02d3388 R14: ffff94c1c318a360 R15: ffff94c1cf2289c0 [ 46.666108] FS: 00007f65634ff7c0(0000) GS:ffff94c1da200000(0000) knlGS:0000000000000000 [ 46.674331] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 46.680170] CR2: 00007f7dfe984460 CR3: 000000010e894003 CR4: 00000000000606f0 [ 46.687422] Call Trace: [ 46.689906] <TASK> [ 46.691950] iwl_mvm_mac_wake_tx_queue+0xec/0x15c [iwlmvm] [ 46.697601] ieee80211_queue_skb+0x4b3/0x720 [mac80211] [ 46.702973] ? sta_info_get+0x46/0x60 [mac80211] [ 46.707703] ieee80211_tx+0xad/0x110 [mac80211] [ 46.712355] __ieee80211_tx_skb_tid_band+0x71/0x90 [mac80211] ... In order to avoid this problem, we must also remove the related lists when station queues are disabled.",,,"[{""url"":""https://git.kernel.org/stable/c/14a3aacf517a9de725dd3219dbbcf741e31763c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/182d3c1385f44ba7c508bf5b1292a7fe96ad4e9e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/38d71acc15a2e72806b516380af0adb3830d4639"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4a40af2b0b9517fca7ae2a030c9c0a16836303c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5cca5f714fe6cedd2df9d8451ad8df21e6464f62"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff068c25bf90d26f0aee1751553f18076b797e8d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50165,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:46.790,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: wil6210: debugfs: fix uninitialized variable use in `wil_write_file_wmi()` Commit 7a4836560a61 changes simple_write_to_buffer() with memdup_user() but it forgets to change the value to be returned that came from simple_write_to_buffer() call. It results in the following warning: warning: variable 'rc' is uninitialized when used here [-Wuninitialized] return rc; ^~ Remove rc variable and just return the passed in length if the memdup_user() succeeds.",,,"[{""url"":""https://git.kernel.org/stable/c/409bd72e544fdf4809ea0dac337bb5a1f11a25a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/52b11a48cf073e0aab923ae809a765d756cecf13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/689e5caf63e99e15d2f485ec297c1bf9243e0e28"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c5fee83bdbeffe8d607d1ab125122a75f40bd1a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b13c84e877d7a3095bacb14665db304b2c00e95f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c9fde3a44da566d8929070ab6bda4f0dfa9955d0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d4742c886043b69d2d058bfde3998ef333b66595"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d578e0af3a003736f6c440188b156483d451b329"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50166,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:46.907,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: When HCI work queue is drained, only queue chained work The HCI command, event, and data packet processing workqueue is drained to avoid deadlock in commit 76727c02c1e1 (""Bluetooth: Call drain_workqueue() before resetting state""). There is another delayed work, which will queue command to this drained workqueue. Which results in the following error report: Bluetooth: hci2: command 0x040f tx timeout WARNING: CPU: 1 PID: 18374 at kernel/workqueue.c:1438 __queue_work+0xdad/0x1140 Workqueue: events hci_cmd_timeout RIP: 0010:__queue_work+0xdad/0x1140 RSP: 0000:ffffc90002cffc60 EFLAGS: 00010093 RAX: 0000000000000000 RBX: ffff8880b9d3ec00 RCX: 0000000000000000 RDX: ffff888024ba0000 RSI: ffffffff814e048d RDI: ffff8880b9d3ec08 RBP: 0000000000000008 R08: 0000000000000000 R09: 00000000b9d39700 R10: ffffffff814f73c6 R11: 0000000000000000 R12: ffff88807cce4c60 R13: 0000000000000000 R14: ffff8880796d8800 R15: ffff8880796d8800 FS: 0000000000000000(0000) GS:ffff8880b9d00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000000c0174b4000 CR3: 000000007cae9000 CR4: 00000000003506e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ? queue_work_on+0xcb/0x110 ? lockdep_hardirqs_off+0x90/0xd0 queue_work_on+0xee/0x110 process_one_work+0x996/0x1610 ? pwq_dec_nr_in_flight+0x2a0/0x2a0 ? rwlock_bug.part.0+0x90/0x90 ? _raw_spin_lock_irq+0x41/0x50 worker_thread+0x665/0x1080 ? process_one_work+0x1610/0x1610 kthread+0x2e9/0x3a0 ? kthread_complete_and_exit+0x40/0x40 ret_from_fork+0x1f/0x30 </TASK> To fix this, we can add a new HCI_DRAIN_WQ flag, and don't queue the timeout workqueue while command workqueue is draining.",,,"[{""url"":""https://git.kernel.org/stable/c/3b382555706558f5c0587862b6dc03e96a252bba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4bf367fa1fefabdf14938d0ac9ed60020389112e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/877afadad2dce8aae1f2aad8ce47e072d4f6165e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50167,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:47.010,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf: fix potential 32-bit overflow when accessing ARRAY map element If BPF array map is bigger than 4GB, element pointer calculation can overflow because both index and elem_size are u32. Fix this everywhere by forcing 64-bit multiplication. Extract this formula into separate small helper and use it consistently in various places. Speculative-preventing formula utilizing index_mask trick is left as is, but explicit u64 casts are added in both places.",,,"[{""url"":""https://git.kernel.org/stable/c/063e092534d4c6785228e5b1eb6e9329f66ccbe4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3c7256b880b3a5aa1895fd169a34aa4224a11862"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/87ac0d600943994444e24382a87aa19acc4cd3d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50168,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:47.117,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf, x86: fix freeing of not-finalized bpf_prog_pack syzbot reported a few issues with bpf_prog_pack [1], [2]. This only happens with multiple subprogs. In jit_subprogs(), we first call bpf_int_jit_compile() on each sub program. And then, we call it on each sub program again. jit_data is not freed in the first call of bpf_int_jit_compile(). Similarly we don't call bpf_jit_binary_pack_finalize() in the first call of bpf_int_jit_compile(). If bpf_int_jit_compile() failed for one sub program, we will call bpf_jit_binary_pack_finalize() for this sub program. However, we don't have a chance to call it for other sub programs. Then we will hit ""goto out_free"" in jit_subprogs(), and call bpf_jit_free on some subprograms that haven't got bpf_jit_binary_pack_finalize() yet. At this point, bpf_jit_binary_pack_free() is called and the whole 2MB page is freed erroneously. Fix this with a custom bpf_jit_free() for x86_64, which calls bpf_jit_binary_pack_finalize() if necessary. Also, with custom bpf_jit_free(), bpf_prog_aux->use_bpf_prog_pack is not needed any more, remove it. [1] https://syzkaller.appspot.com/bug?extid=2f649ec6d2eea1495a8f [2] https://syzkaller.appspot.com/bug?extid=87f65c75f4a72db05445",,,"[{""url"":""https://git.kernel.org/stable/c/1d5f82d9dd477d5c66e0214a68c3e4f308eadd6d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/60e66074812dde9cde3d99cdd3caa9e40f1a4516"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f91ce608a79c0db3e72bd63c23e011a9ebc31505"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50169,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:47.227,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: wil6210: debugfs: fix info leak in wil_write_file_wmi() The simple_write_to_buffer() function will succeed if even a single byte is initialized. However, we need to initialize the whole buffer to prevent information leaks. Just use memdup_user().",,,"[{""url"":""https://git.kernel.org/stable/c/05ceda14ef7c73104e709c414c3680d8a59f51d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/074e865b37da55aa87baa16d68b96896f85f8adb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4615458db7793fadc6d546ac3564b36819e77a22"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/60c9983425167ec5073c628d83a6875760d18059"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/67470920cd3f3cb38699b1ad23234f96bead4d21"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/789edc1af9c1a2293956e8534bfef3d18d629de9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7a4836560a6198d245d5732e26f94898b12eb760"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c1216e699a1ce83ea005510844bd7508d34c6cef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50170,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:47.340,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: kunit: executor: Fix a memory leak on failure in kunit_filter_tests It's possible that memory allocation for 'filtered' will fail, but for the copy of the suite to succeed. In this case, the copy could be leaked. Properly free 'copy' in the error case for the allocation of 'filtered' failing. Note that there may also have been a similar issue in kunit_filter_subsuites, before it was removed in ""kunit: flatten kunit_suite*** to kunit_suite** in .kunit_test_suites"". This was reported by clang-analyzer via the kernel test robot, here: https://lore.kernel.org/all/c8073b8e-7b9e-0830-4177-87c12f16349c@intel.com/ And by smatch via Dan Carpenter and the kernel test robot: https://lore.kernel.org/all/202207101328.ASjx88yj-lkp@intel.com/",,,"[{""url"":""https://git.kernel.org/stable/c/7d69764fa3442c7615a75c6b5c02eaa1f274bccf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/94681e289bf5d10c9db9db143d1a22d8717205c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a8a7e3ced362b88b659ab54239990196ff975982"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50171,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:47.443,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: crypto: hisilicon/sec - don't sleep when in softirq When kunpeng920 encryption driver is used to deencrypt and decrypt packets during the softirq, it is not allowed to use mutex lock. The kernel will report the following error: BUG: scheduling while atomic: swapper/57/0/0x00000300 Call trace: dump_backtrace+0x0/0x1e4 show_stack+0x20/0x2c dump_stack+0xd8/0x140 __schedule_bug+0x68/0x80 __schedule+0x728/0x840 schedule+0x50/0xe0 schedule_preempt_disabled+0x18/0x24 __mutex_lock.constprop.0+0x594/0x5dc __mutex_lock_slowpath+0x1c/0x30 mutex_lock+0x50/0x60 sec_request_init+0x8c/0x1a0 [hisi_sec2] sec_process+0x28/0x1ac [hisi_sec2] sec_skcipher_crypto+0xf4/0x1d4 [hisi_sec2] sec_skcipher_encrypt+0x1c/0x30 [hisi_sec2] crypto_skcipher_encrypt+0x2c/0x40 crypto_authenc_encrypt+0xc8/0xfc [authenc] crypto_aead_encrypt+0x2c/0x40 echainiv_encrypt+0x144/0x1a0 [echainiv] crypto_aead_encrypt+0x2c/0x40 esp_output_tail+0x348/0x5c0 [esp4] esp_output+0x120/0x19c [esp4] xfrm_output_one+0x25c/0x4d4 xfrm_output_resume+0x6c/0x1fc xfrm_output+0xac/0x3c0 xfrm4_output+0x64/0x130 ip_build_and_send_pkt+0x158/0x20c tcp_v4_send_synack+0xdc/0x1f0 tcp_conn_request+0x7d0/0x994 tcp_v4_conn_request+0x58/0x6c tcp_v6_conn_request+0xf0/0x100 tcp_rcv_state_process+0x1cc/0xd60 tcp_v4_do_rcv+0x10c/0x250 tcp_v4_rcv+0xfc4/0x10a4 ip_protocol_deliver_rcu+0xf4/0x200 ip_local_deliver_finish+0x58/0x70 ip_local_deliver+0x68/0x120 ip_sublist_rcv_finish+0x70/0x94 ip_list_rcv_finish.constprop.0+0x17c/0x1d0 ip_sublist_rcv+0x40/0xb0 ip_list_rcv+0x140/0x1dc __netif_receive_skb_list_core+0x154/0x28c __netif_receive_skb_list+0x120/0x1a0 netif_receive_skb_list_internal+0xe4/0x1f0 napi_complete_done+0x70/0x1f0 gro_cell_poll+0x9c/0xb0 napi_poll+0xcc/0x264 net_rx_action+0xd4/0x21c __do_softirq+0x130/0x358 irq_exit+0x11c/0x13c __handle_domain_irq+0x88/0xf0 gic_handle_irq+0x78/0x2c0 el1_irq+0xb8/0x140 arch_cpu_idle+0x18/0x40 default_idle_call+0x5c/0x1c0 cpuidle_idle_call+0x174/0x1b0 do_idle+0xc8/0x160 cpu_startup_entry+0x30/0x11c secondary_start_kernel+0x158/0x1e4 softirq: huh, entered softirq 3 NET_RX 0000000093774ee4 with preempt_count 00000100, exited with fffffe00?",,,"[{""url"":""https://git.kernel.org/stable/c/02884a4f12de11f54d4ca67a07dd1f111d96fdbd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/16e18a8ac7c9748cf35a8d2f0ba2c6e8850e7568"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4a461ba5b9753352f438824fdd915cba675b1733"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa495dfe71229b9034b59d8072ff0b2325ddd5ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c9be45e4c69fde36522274f04d1aa0d097ae3958"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50172,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:47.550,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mt76: mt76x02u: fix possible memory leak in __mt76x02u_mcu_send_msg Free the skb if mt76u_bulk_msg fails in __mt76x02u_mcu_send_msg routine.",,,"[{""url"":""https://git.kernel.org/stable/c/2f53ba46d8c97aca681adbe5098e1f84580c446d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ad958bc488e3ecb0207d31621c00efb86f17482"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cffd93411575afd987788e2ec3cb8eaff70f0215"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da1ab462b96c5d47a0755aec957bae3d685538c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1609c4f4a21777e081b36596224802b85052ad9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50173,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:47.660,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/msm/mdp5: Fix global state lock backoff We need to grab the lock after the early return for !hwpipe case. Otherwise, we could have hit contention yet still returned 0. Fixes an issue that the new CONFIG_DRM_DEBUG_MODESET_LOCK stuff flagged in CI: WARNING: CPU: 0 PID: 282 at drivers/gpu/drm/drm_modeset_lock.c:296 drm_modeset_lock+0xf8/0x154 Modules linked in: CPU: 0 PID: 282 Comm: kms_cursor_lega Tainted: G W 5.19.0-rc2-15930-g875cc8bc536a #1 Hardware name: Qualcomm Technologies, Inc. DB820c (DT) pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : drm_modeset_lock+0xf8/0x154 lr : drm_atomic_get_private_obj_state+0x84/0x170 sp : ffff80000cfab6a0 x29: ffff80000cfab6a0 x28: 0000000000000000 x27: ffff000083bc4d00 x26: 0000000000000038 x25: 0000000000000000 x24: ffff80000957ca58 x23: 0000000000000000 x22: ffff000081ace080 x21: 0000000000000001 x20: ffff000081acec18 x19: ffff80000cfabb80 x18: 0000000000000038 x17: 0000000000000000 x16: 0000000000000000 x15: fffffffffffea0d0 x14: 0000000000000000 x13: 284e4f5f4e524157 x12: 5f534b434f4c5f47 x11: ffff80000a386aa8 x10: 0000000000000029 x9 : ffff80000cfab610 x8 : 0000000000000029 x7 : 0000000000000014 x6 : 0000000000000000 x5 : 0000000000000001 x4 : ffff8000081ad904 x3 : 0000000000000029 x2 : ffff0000801db4c0 x1 : ffff80000cfabb80 x0 : ffff000081aceb58 Call trace: drm_modeset_lock+0xf8/0x154 drm_atomic_get_private_obj_state+0x84/0x170 mdp5_get_global_state+0x54/0x6c mdp5_pipe_release+0x2c/0xd4 mdp5_plane_atomic_check+0x2ec/0x414 drm_atomic_helper_check_planes+0xd8/0x210 drm_atomic_helper_check+0x54/0xb0 ... ---[ end trace 0000000000000000 ]--- drm_modeset_lock attempting to lock a contended lock without backoff: drm_modeset_lock+0x148/0x154 mdp5_get_global_state+0x30/0x6c mdp5_pipe_release+0x2c/0xd4 mdp5_plane_atomic_check+0x290/0x414 drm_atomic_helper_check_planes+0xd8/0x210 drm_atomic_helper_check+0x54/0xb0 drm_atomic_check_only+0x4b0/0x8f4 drm_atomic_commit+0x68/0xe0 Patchwork: https://patchwork.freedesktop.org/patch/492701/",,,"[{""url"":""https://git.kernel.org/stable/c/0b07f28c23ff50a7fa5dbc3f6b3b6bd53ac9fc70"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/247f2934324f9a18d18df24ea4bfcc7d4631d0ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2e34d6c8180a398de6448a93df25068bf3062042"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2fdf5a54ef9376ff69149a48c5616f1141008c9f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/92ef86ab513593c6329d04146e61f9a670e72fc5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf386c955f35a0a01bef482b6035d40ff2f6cc75"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f4e3a8c7e890049e7ba2b49ad0315dae841dfa55"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50174,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:47.770,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: hinic: avoid kernel hung in hinic_get_stats64() When using hinic device as a bond slave device, and reading device stats of master bond device, the kernel may hung. The kernel panic calltrace as follows: Kernel panic - not syncing: softlockup: hung tasks Call trace: native_queued_spin_lock_slowpath+0x1ec/0x31c dev_get_stats+0x60/0xcc dev_seq_printf_stats+0x40/0x120 dev_seq_show+0x1c/0x40 seq_read_iter+0x3c8/0x4dc seq_read+0xe0/0x130 proc_reg_read+0xa8/0xe0 vfs_read+0xb0/0x1d4 ksys_read+0x70/0xfc __arm64_sys_read+0x20/0x30 el0_svc_common+0x88/0x234 do_el0_svc+0x2c/0x90 el0_svc+0x1c/0x30 el0_sync_handler+0xa8/0xb0 el0_sync+0x148/0x180 And the calltrace of task that actually caused kernel hungs as follows: __switch_to+124 __schedule+548 schedule+72 schedule_timeout+348 __down_common+188 __down+24 down+104 hinic_get_stats64+44 [hinic] dev_get_stats+92 bond_get_stats+172 [bonding] dev_get_stats+92 dev_seq_printf_stats+60 dev_seq_show+24 seq_read_iter+964 seq_read+220 proc_reg_read+164 vfs_read+172 ksys_read+108 __arm64_sys_read+28 el0_svc_common+132 do_el0_svc+40 el0_svc+24 el0_sync_handler+164 el0_sync+324 When getting device stats from bond, kernel will call bond_get_stats(). It first holds the spinlock bond->stats_lock, and then call hinic_get_stats64() to collect hinic device's stats. However, hinic_get_stats64() calls `down(&nic_dev->mgmt_lock)` to protect its critical section, which may schedule current task out. And if system is under high pressure, the task cannot be woken up immediately, which eventually triggers kernel hung panic. Since previous patch has replaced hinic_dev.tx_stats/rx_stats with local variable in hinic_get_stats64(), there is nothing need to be protected by lock, so just removing down()/up() is ok.",,,"[{""url"":""https://git.kernel.org/stable/c/3ba59bbe4f306bb6ee15753db0a40564c0eb7909"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/693f31dc91568e61047fd2980a8235e856cd9ce8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/98f9fcdee35add80505b6c73f72de5f750d5c03c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e74f3097a9c713ce855cda07713393bcc23a005d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fced5bce712122654ec8a20356342698cce104d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50175,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:47.883,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: tw686x: Fix memory leak in tw686x_video_init video_device_alloc() allocates memory for vdev, when video_register_device() fails, it doesn't release the memory and leads to memory leak, call video_device_release() to fix this.",,,"[{""url"":""https://git.kernel.org/stable/c/0597bcf774896a002edcc7934a9cdbb932b66702"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/611f86965df013d6021e6cd0d155b1734ad2cf21"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8b412db51db24dfba22c96948580d4a12f831397"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c142a7531b90c6b0f946c82d3f504b3f36a207df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0b212ec9d8177d6f7c404315293f6a085d6ee42"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50176,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:47.993,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/mcde: Fix refcount leak in mcde_dsi_bind Every iteration of for_each_available_child_of_node() decrements the reference counter of the previous node. There is no decrement when break out from the loop and results in refcount leak. Add missing of_node_put() to fix this.",,,"[{""url"":""https://git.kernel.org/stable/c/3123ae6fdd4013d24a3a4877084b14e917faae5c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/32c827e30bb44ae809950a9efab59e98e44d30e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3a149169e4a2f9127022fec6ef5d71b4e804b3b9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7214902de5b1fb2b632a7b8b3b9540e41aabab38"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/87c35bbefdfa3c5edfb8c80f5c04717aaacc629d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f57699a9b66ea11f000f56d1f1179059239b8690"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50177,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:48.107,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: rcutorture: Fix ksoftirqd boosting timing and iteration The RCU priority boosting can fail in two situations: 1) If (nr_cpus= > maxcpus=), which means if the total number of CPUs is higher than those brought online at boot, then torture_onoff() may later bring up CPUs that weren't online on boot. Now since rcutorture initialization only boosts the ksoftirqds of the CPUs that have been set online on boot, the CPUs later set online by torture_onoff won't benefit from the boost, making RCU priority boosting fail. 2) The ksoftirqd kthreads are boosted after the creation of rcu_torture_boost() kthreads, which opens a window large enough for these rcu_torture_boost() kthreads to wait (despite running at FIFO priority) for ksoftirqds that are still running at SCHED_NORMAL priority. The issues can trigger for example with: ./kvm.sh --configs TREE01 --kconfig ""CONFIG_RCU_BOOST=y"" [ 34.968561] rcu-torture: !!! [ 34.968627] ------------[ cut here ]------------ [ 35.014054] WARNING: CPU: 4 PID: 114 at kernel/rcu/rcutorture.c:1979 rcu_torture_stats_print+0x5ad/0x610 [ 35.052043] Modules linked in: [ 35.069138] CPU: 4 PID: 114 Comm: rcu_torture_sta Not tainted 5.18.0-rc1 #1 [ 35.096424] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.14.0-0-g155821a-rebuilt.opensuse.org 04/01/2014 [ 35.154570] RIP: 0010:rcu_torture_stats_print+0x5ad/0x610 [ 35.198527] Code: 63 1b 02 00 74 02 0f 0b 48 83 3d 35 63 1b 02 00 74 02 0f 0b 48 83 3d 21 63 1b 02 00 74 02 0f 0b 48 83 3d 0d 63 1b 02 00 74 02 <0f> 0b 83 eb 01 0f 8e ba fc ff ff 0f 0b e9 b3 fc ff f82 [ 37.251049] RSP: 0000:ffffa92a0050bdf8 EFLAGS: 00010202 [ 37.277320] rcu: De-offloading 8 [ 37.290367] RAX: 0000000000000000 RBX: 0000000000000001 RCX: 0000000000000001 [ 37.290387] RDX: 0000000000000000 RSI: 00000000ffffbfff RDI: 00000000ffffffff [ 37.290398] RBP: 000000000000007b R08: 0000000000000000 R09: c0000000ffffbfff [ 37.290407] R10: 000000000000002a R11: ffffa92a0050bc18 R12: ffffa92a0050be20 [ 37.290417] R13: ffffa92a0050be78 R14: 0000000000000000 R15: 000000000001bea0 [ 37.290427] FS: 0000000000000000(0000) GS:ffff96045eb00000(0000) knlGS:0000000000000000 [ 37.290448] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 37.290460] CR2: 0000000000000000 CR3: 000000001dc0c000 CR4: 00000000000006e0 [ 37.290470] Call Trace: [ 37.295049] <TASK> [ 37.295065] ? preempt_count_add+0x63/0x90 [ 37.295095] ? _raw_spin_lock_irqsave+0x12/0x40 [ 37.295125] ? rcu_torture_stats_print+0x610/0x610 [ 37.295143] rcu_torture_stats+0x29/0x70 [ 37.295160] kthread+0xe3/0x110 [ 37.295176] ? kthread_complete_and_exit+0x20/0x20 [ 37.295193] ret_from_fork+0x22/0x30 [ 37.295218] </TASK> Fix this with boosting the ksoftirqds kthreads from the boosting hotplug callback itself and before the boosting kthreads are created.",,,"[{""url"":""https://git.kernel.org/stable/c/3002153a91a9732a6d1d0bb95138593c7da15743"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/621595f771a6bd458ffbc40679e222ba5d0a7a1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7e7472c62c6ded322afd9d5ac8bb20a08e7c5674"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e84693621f53bf894af9905a6531e0530402145"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50178,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:48.217,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: rtw89: 8852a: rfk: fix div 0 exception The DPK is a kind of RF calibration whose algorithm is to fine tune parameters and calibrate, and check the result. If the result isn't good enough, it could adjust parameters and try again. This issue is to read and show the result, but it could be a negative calibration result that causes divisor 0 and core dump. So, fix it by phy_div() that does division only if divisor isn't zero; otherwise, zero is adopted. divide error: 0000 [#1] PREEMPT SMP NOPTI CPU: 1 PID: 728 Comm: wpa_supplicant Not tainted 5.10.114-16019-g462a1661811a #1 <HASH:d024 28> RIP: 0010:rtw8852a_dpk+0x14ae/0x288f [rtw89_core] RSP: 0018:ffffa9bb412a7520 EFLAGS: 00010246 RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000 RDX: 0000000000000000 RSI: 00000000000180fc RDI: ffffa141d01023c0 RBP: ffffa9bb412a76a0 R08: 0000000000001319 R09: 00000000ffffff92 R10: ffffffffc0292de3 R11: ffffffffc00d2f51 R12: 0000000000000000 R13: ffffa141d01023c0 R14: ffffffffc0290250 R15: ffffa141d0102638 FS: 00007fa99f5c2740(0000) GS:ffffa142e5e80000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000013e8e010 CR3: 0000000110d2c000 CR4: 0000000000750ee0 PKRU: 55555554 Call Trace: rtw89_core_sta_add+0x95/0x9c [rtw89_core <HASH:d239 29>] rtw89_ops_sta_state+0x5d/0x108 [rtw89_core <HASH:d239 29>] drv_sta_state+0x115/0x66f [mac80211 <HASH:81fe 30>] sta_info_insert_rcu+0x45c/0x713 [mac80211 <HASH:81fe 30>] sta_info_insert+0xf/0x1b [mac80211 <HASH:81fe 30>] ieee80211_prep_connection+0x9d6/0xb0c [mac80211 <HASH:81fe 30>] ieee80211_mgd_auth+0x2aa/0x352 [mac80211 <HASH:81fe 30>] cfg80211_mlme_auth+0x160/0x1f6 [cfg80211 <HASH:00cd 31>] nl80211_authenticate+0x2e5/0x306 [cfg80211 <HASH:00cd 31>] genl_rcv_msg+0x371/0x3a1 ? nl80211_stop_sched_scan+0xe5/0xe5 [cfg80211 <HASH:00cd 31>] ? genl_rcv+0x36/0x36 netlink_rcv_skb+0x8a/0xf9 genl_rcv+0x28/0x36 netlink_unicast+0x27b/0x3a0 netlink_sendmsg+0x2aa/0x469 sock_sendmsg_nosec+0x49/0x4d ____sys_sendmsg+0xe5/0x213 __sys_sendmsg+0xec/0x157 ? syscall_enter_from_user_mode+0xd7/0x116 do_syscall_64+0x43/0x55 entry_SYSCALL_64_after_hwframe+0x44/0xa9 RIP: 0033:0x7fa99f6e689b",,,"[{""url"":""https://git.kernel.org/stable/c/065e83ac83c0c0e615b96947145c85c4bd76c09a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5abc81a138f873ab55223ec674afc3a3f945d60f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/683a4647a7a3044868cfdc14c117525091b9fa0c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50179,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:48.330,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ath9k: fix use-after-free in ath9k_hif_usb_rx_cb Syzbot reported use-after-free Read in ath9k_hif_usb_rx_cb() [0]. The problem was in incorrect htc_handle->drv_priv initialization. Probable call trace which can trigger use-after-free: ath9k_htc_probe_device() /* htc_handle->drv_priv = priv; */ ath9k_htc_wait_for_target() <--- Failed ieee80211_free_hw() <--- priv pointer is freed <IRQ> ... ath9k_hif_usb_rx_cb() ath9k_hif_usb_rx_stream() RX_STAT_INC() <--- htc_handle->drv_priv access In order to not add fancy protection for drv_priv we can move htc_handle->drv_priv initialization at the end of the ath9k_htc_probe_device() and add helper macro to make all *_STAT_* macros NULL safe, since syzbot has reported related NULL deref in that macros [1]",,,"[{""url"":""https://git.kernel.org/stable/c/03ca957c5f7b55660957eda20b5db4110319ac7a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0ac4827f78c7ffe8eef074bc010e7e34bc22f533"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/62bc1ea5c7401d77eaf73d0c6a15f3d2e742856e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6b14ab47937ba441e75e8dbb9fbfc9c55efa41c6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ab7a0ddf5f1cdec63cb21840369873806fc36d80"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b66ebac40f64336ae2d053883bee85261060bd27"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e9e21206b8ea62220b486310c61277e7ebfe7cec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eccd7c3e2596b574241a7670b5b53f5322f470e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50180,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:48.463,2025-06-18T14:15:24.327,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2022-50181,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:48.587,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: virtio-gpu: fix a missing check to avoid NULL dereference 'cache_ent' could be set NULL inside virtio_gpu_cmd_get_capset() and it will lead to a NULL dereference by a lately use of it (i.e., ptr = cache_ent->caps_cache). Fix it with a NULL check. [ kraxel: minor codestyle fixup ]",,,"[{""url"":""https://git.kernel.org/stable/c/259773fc874258606c0121767a4a27466ff337eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/367882a5a9448b5e1ba756125308092d614cb96c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/39caef09666c1d8274abf9472c72bcac236dc5fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/adbdd21983fa292e53aec3eab97306b2961ea887"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd63f11f4c3c46afec07d821f74736161ff6e526"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50182,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:48.700,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: imx-jpeg: Align upwards buffer size The hardware can support any image size WxH, with arbitrary W (image width) and H (image height) dimensions. Align upwards buffer size for both encoder and decoder. and leave the picture resolution unchanged. For decoder, the risk of memory out of bounds can be avoided. For both encoder and decoder, the driver will lift the limitation of resolution alignment. For example, the decoder can support jpeg whose resolution is 227x149 the encoder can support nv12 1080P, won't change it to 1920x1072.",,,"[{""url"":""https://git.kernel.org/stable/c/447795ffb17cd60bb544e0abfc9399e180a14a2f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73d1836ed7911953182b787745cb8c5857a2661c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ae2d729de6350c53a06c57782751d84eb2c08d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9e7aa76cdb02923ee23a0ddd48f38bdc3512f92b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50183,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:48.810,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/meson: encoder_cvbs: Fix refcount leak in meson_encoder_cvbs_init of_graph_get_remote_node() returns remote device nodepointer with refcount incremented, we should use of_node_put() on it when done. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/51c36411ae27bf5f06c43462d2de2d4947ed33ea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d255ddbbf679aa47e041cbf68520fd985ed2279"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bb5ac08d5bd8626c318bd80a5063263daab8fdb6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50184,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:48.917,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/meson: encoder_hdmi: Fix refcount leak in meson_encoder_hdmi_init of_graph_get_remote_node() returns remote device nodepointer with refcount incremented, we should use of_node_put() on it when done. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/013e67e7dd898170cbf54981cf1ed7616f822566"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/275fed7142fff5b27e176e53508196715043de5c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/994bc82df85564d948037f1dfdd47c907e8a084b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d82a5a4aae9d0203234737caed1bf470aa317568"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50185,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:49.030,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/radeon: fix potential buffer overflow in ni_set_mc_special_registers() The last case label can write two buffers 'mc_reg_address[j]' and 'mc_data[j]' with 'j' offset equal to SMC_NISLANDS_MC_REGISTER_ARRAY_SIZE since there are no checks for this value in both case labels after the last 'j++'. Instead of changing '>' to '>=' there, add the bounds check at the start of the second 'case' (the first one already has it). Also, remove redundant last checks for 'j' index bigger than array size. The expression is always false. Moreover, before or after the patch 'table->last' can be equal to SMC_NISLANDS_MC_REGISTER_ARRAY_SIZE and it seems it can be a valid value. Detected using the static analysis tool - Svace.",,,"[{""url"":""https://git.kernel.org/stable/c/136f614931a2bb73616b292cf542da3a18daefd5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1f341053852be76f82610ce47a505d930512f05c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/782e413e38dffd37cc85b08b1ccb982adb4a93ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8508d6d23a247c29792ce2fc0df3f3404d6a6a80"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9faff03617afeced1c4e5daa89e79b3906374342"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/db1a9add3f90ff1c641974d5bb910c16b87af4ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/deb603c5928e546609c0d5798e231d0205748943"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ea73869df6ef386fc0feeb28ff66742ca835b18f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50186,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:49.147,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ath11k: fix missing skb drop on htc_tx_completion error On htc_tx_completion error the skb is not dropped. This is wrong since the completion_handler logic expect the skb to be consumed anyway even when an error is triggered. Not freeing the skb on error is a memory leak since the skb won't be freed anywere else. Correctly free the packet on eid >= ATH11K_HTC_EP_COUNT before returning. Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.5.0.1-01208-QCAHKSWPL_SILICONZ-1",,,"[{""url"":""https://git.kernel.org/stable/c/1f1483361585ae7556492f50f83f038bbdf8c294"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dda25326839d6e6b1fe59e79616149e44ea4eaa4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e5646fe3b7ef739c392e59da7db6adf5e1fdef42"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50187,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:49.267,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ath11k: fix netdev open race Make sure to allocate resources needed before registering the device. This specifically avoids having a racing open() trigger a BUG_ON() in mod_timer() when ath11k_mac_op_start() is called before the mon_reap_timer as been set up. I did not see this issue with next-20220310, but I hit it on every probe with next-20220511. Perhaps some timing changed in between. Here's the backtrace: [ 51.346947] kernel BUG at kernel/time/timer.c:990! [ 51.346958] Internal error: Oops - BUG: 0 [#1] PREEMPT SMP ... [ 51.578225] Call trace: [ 51.583293] __mod_timer+0x298/0x390 [ 51.589518] mod_timer+0x14/0x20 [ 51.595368] ath11k_mac_op_start+0x41c/0x4a0 [ath11k] [ 51.603165] drv_start+0x38/0x60 [mac80211] [ 51.610110] ieee80211_do_open+0x29c/0x7d0 [mac80211] [ 51.617945] ieee80211_open+0x60/0xb0 [mac80211] [ 51.625311] __dev_open+0x100/0x1c0 [ 51.631420] __dev_change_flags+0x194/0x210 [ 51.638214] dev_change_flags+0x24/0x70 [ 51.644646] do_setlink+0x228/0xdb0 [ 51.650723] __rtnl_newlink+0x460/0x830 [ 51.657162] rtnl_newlink+0x4c/0x80 [ 51.663229] rtnetlink_rcv_msg+0x124/0x390 [ 51.669917] netlink_rcv_skb+0x58/0x130 [ 51.676314] rtnetlink_rcv+0x18/0x30 [ 51.682460] netlink_unicast+0x250/0x310 [ 51.688960] netlink_sendmsg+0x19c/0x3e0 [ 51.695458] ____sys_sendmsg+0x220/0x290 [ 51.701938] ___sys_sendmsg+0x7c/0xc0 [ 51.708148] __sys_sendmsg+0x68/0xd0 [ 51.714254] __arm64_sys_sendmsg+0x28/0x40 [ 51.720900] invoke_syscall+0x48/0x120 Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3",,,"[{""url"":""https://git.kernel.org/stable/c/307ce58270b3b50ca21cfcc910568429b06803f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a2c45f8c3d18269e641f0c7da2dde47ef8414034"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/abb7dc8fbb27c15dcc927df56190f3c5ede58bd5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d4ba1ff87b17e81686ada8f429300876f55f95ad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eaff3946a86fc63280a30158a4ae1e141449817c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50188,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:49.383,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/meson: Fix refcount leak in meson_encoder_hdmi_init of_find_device_by_node() takes reference, we should use put_device() to release it when not need anymore. Add missing put_device() in error path to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/50446ac34545580d073ff0dd154b796726772668"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7381076809586528e2a812a709e2758916318a99"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/79b15eb0aa059b3a5bc60364ce82eb2cefac80db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bfcca6234b2a36d213f0cc1c127becc17680f7df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50189,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:49.490,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tools/power turbostat: Fix file pointer leak Currently if a fscanf fails then an early return leaks an open file pointer. Fix this by fclosing the file before the return. Detected using static analysis with cppcheck: tools/power/x86/turbostat/turbostat.c:2039:3: error: Resource leak: fp [resourceLeak]",,,"[{""url"":""https://git.kernel.org/stable/c/2ebf6f5946817f33fb33e613e359229e98164eb3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e5fd36c58d6c820f7292ee492c3731c9a104a41"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50190,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:49.593,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: spi: Fix simplification of devm_spi_register_controller This reverts commit 59ebbe40fb51 (""spi: simplify devm_spi_register_controller""). If devm_add_action() fails in devm_add_action_or_reset(), devm_spi_unregister() will be called, it decreases the refcount of 'ctlr->dev' to 0, then it will cause uaf in the drivers that calling spi_put_controller() in error path.",,,"[{""url"":""https://git.kernel.org/stable/c/34bab623ebfc08398499e463396b81abb4abe01e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3c6bd448442b6c3f6843ac70d57201a13478dd47"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/43cc5a0afe4184a7fafe1eba32b5a11bb69c9ce0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/445fb9c19cf45bd9472fd9babaa31c5e6c7d2720"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50191,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:49.693,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: regulator: of: Fix refcount leak bug in of_get_regulation_constraints() We should call the of_node_put() for the reference returned by of_get_child_by_name() which has increased the refcount.",,,"[{""url"":""https://git.kernel.org/stable/c/11ecb4f8735b0230d54a82c18b21ea778b695d61"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/332e555dca074c4eb2084898021c3676423814c3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/35f9e861d9b9434903a8ede37a3561f78985826d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/66efb665cd5ad69b27dca8571bf89fc6b9c628a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a23098cc32860272dc6c3200ff20c34c65b7b694"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b9ca8585c766616563cf3c062c6878f61f83cf00"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c9df8ff290097aabd5c9200f7f729b0813d37b19"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc7b19f547bc9e622060a0a9a39da2330aa21c53"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50192,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:49.810,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: spi: tegra20-slink: fix UAF in tegra_slink_remove() After calling spi_unregister_master(), the refcount of master will be decrease to 0, and it will be freed in spi_controller_release(), the device data also will be freed, so it will lead a UAF when using 'tspi'. To fix this, get the master before unregister and put it when finish using it.",,,"[{""url"":""https://git.kernel.org/stable/c/415b4ce61308f24583912d887772dfcbf97f1d20"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/67f77172644260482fdafc03b6025847944701e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7e9984d183bb1e99e766c5c2b950ff21f7f7b6c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/800c7767e05d29656713e04532823a752e57e037"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50193,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:49.920,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: erofs: wake up all waiters after z_erofs_lzma_head ready When the user mounts the erofs second times, the decompression thread may hung. The problem happens due to a sequence of steps like the following: 1) Task A called z_erofs_load_lzma_config which obtain all of the node from the z_erofs_lzma_head. 2) At this time, task B called the z_erofs_lzma_decompress and wanted to get a node. But the z_erofs_lzma_head was empty, the Task B had to sleep. 3) Task A release nodes and push nodes into the z_erofs_lzma_head. But task B was still sleeping. One example report when the hung happens: task:kworker/u3:1 state:D stack:14384 pid: 86 ppid: 2 flags:0x00004000 Workqueue: erofs_unzipd z_erofs_decompressqueue_work Call Trace: <TASK> __schedule+0x281/0x760 schedule+0x49/0xb0 z_erofs_lzma_decompress+0x4bc/0x580 ? cpu_core_flags+0x10/0x10 z_erofs_decompress_pcluster+0x49b/0xba0 ? __update_load_avg_se+0x2b0/0x330 ? __update_load_avg_se+0x2b0/0x330 ? update_load_avg+0x5f/0x690 ? update_load_avg+0x5f/0x690 ? set_next_entity+0xbd/0x110 ? _raw_spin_unlock+0xd/0x20 z_erofs_decompress_queue.isra.0+0x2e/0x50 z_erofs_decompressqueue_work+0x30/0x60 process_one_work+0x1d3/0x3a0 worker_thread+0x45/0x3a0 ? process_one_work+0x3a0/0x3a0 kthread+0xe2/0x110 ? kthread_complete_and_exit+0x20/0x20 ret_from_fork+0x22/0x30 </TASK>",,,"[{""url"":""https://git.kernel.org/stable/c/2478e36ec437a27f8a05bea9e4269a68c554e21f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2df7c4bd7c1d2bc5ece5e9ed19dbd386810c2a65"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/96aa2a6a89618d850ef082e4268007e840c28769"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50194,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:50.030,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: soc: qcom: aoss: Fix refcount leak in qmp_cooling_devices_register Every iteration of for_each_available_child_of_node() decrements the reference count of the previous node. When breaking early from a for_each_available_child_of_node() loop, we need to explicitly call of_node_put() on the child node. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/053543ac1d095132fcfd1263805d6e25afbdc6a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/591f0697ccbac33760d3bb1ad96a5ba2b76ae9f0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/97713ed9b6cc4abaa2dcc8357113c56520dc6d7f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bc73c72a856c26df7410ddf15f42257cb4960fe9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca83c61a6ccf3934cf8d01d5ade30a5034993a86"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e6e0951414a314e7db3e9e24fd924b3e15515288"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50195,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:50.140,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ARM: dts: qcom: replace gcc PXO with pxo_board fixed clock Replace gcc PXO phandle to pxo_board fixed clock declared in the dts. gcc driver doesn't provide PXO_SRC as it's a fixed-clock. This cause a kernel panic if any driver actually try to use it.",,,"[{""url"":""https://git.kernel.org/stable/c/0a4fa4ce697987b71eafce17bb198961ed9070bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb9e93937756a05787977875830c0dc482cb57e0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50196,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:50.247,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: soc: qcom: ocmem: Fix refcount leak in of_get_ocmem of_parse_phandle() returns a node pointer with refcount incremented, we should use of_node_put() on it when not need anymore. Add missing of_node_put() to avoid refcount leak. of_node_put() will check NULL pointer.",,,"[{""url"":""https://git.kernel.org/stable/c/07aea6819d569d1e172227486655e4fb5bd4cdb9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/84a928b44cb303d5756e3bff2734921de8dce4f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/92a563fcf14b3093226fb36f12e9b5cf630c5a5d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a1e4243c0dddeafb4ace6d9906d3f5129b81a9fe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ed40a48d0a9166edb22e2b8efafea822e93dd79a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50197,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:50.360,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: cpufreq: zynq: Fix refcount leak in zynq_get_revision of_find_compatible_node() returns a node pointer with refcount incremented, we should use of_node_put() on it when done. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/179034fb108e3655142f2af0c309cef171c34d68"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/22e6d8bcde8e66b64f46bf9bd2d3d0f88d40c39f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3b01353f1825151a29d08e0868b2bf01e1116ab5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a530fa52d4fdffc5f010f90c05ac63019b8ff5f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d1ff2559cef0f6f8d97fba6337b28adb10689e16"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dcbb974254d2a27240c2e50185afdde90f923feb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ecefd22d5db7ccb8bec2646e5d25e058fc33162a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f52c9be1779d70037ae300762d19b08fe3656237"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50198,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:50.470,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ARM: OMAP2+: Fix refcount leak in omap3xxx_prm_late_init of_find_matching_node() returns a node pointer with refcount incremented, we should use of_node_put() on it when not need anymore. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/1bf747824a8ca4008879fd7d2ce6b03d7b428858"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/942228fbf5d4901112178b93d41225be7c0dd9de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c4f92af7fc8cecb8eb426ad187e39c7bcc6679c7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c652e0f51665f3fa575449909bbd9d7b45dfab1c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c9ec7993d00250a394d367c8a19fcfe8211c258b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d294d60dc68550fee0fbbe8a638d798dcd40b2c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e5ab8a4967d68a8e9f8f4559d144207d085a8c02"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50199,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:50.583,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ARM: OMAP2+: Fix refcount leak in omapdss_init_of omapdss_find_dss_of_node() calls of_find_compatible_node() to get device node. of_find_compatible_node() returns a node pointer with refcount incremented, we should use of_node_put() on it when done. Add missing of_node_put() in later error path and normal path.",,,"[{""url"":""https://git.kernel.org/stable/c/14bac0c7035bf920e190a63c7e1b113c72eadbf4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/230ad40a59c9a9ee8f3822b9a7bec09404102ebc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/507159facf002d113c4878fec67f37d62f187887"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/935035cf97c8cd6794044b500fb0a44a6d30ffa1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9705db1eff38d6b9114121f9e253746199b759c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a32dc6829e33c54e751346aa3e08ddb6d0e1a6a0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50200,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:50.697,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: selinux: Add boundary check in put_entry() Just like next_entry(), boundary check is necessary to prevent memory out-of-bound access.",,,"[{""url"":""https://git.kernel.org/stable/c/15ec76fb29be31df2bccb30fc09875274cba2776"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2dabe6a872a5744865372eb30ea51e8ccd21305a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/477722f31ad73aa779154d1d7e00825538389f76"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7363a69d8ca8f0086f8e1196c8ddaf0e168614b1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90bdf50ae70c5571a277b5601e4f5df210831e0a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9605f50157cae00eb299e1189a6d708c84935ad8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/adbfdaacde18faf6cd4e490764045375266b3fbd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dedd558d9765b72c66e5a53948e9f5abc3ece1f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50201,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:50.810,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: selinux: fix memleak in security_read_state_kernel() In this function, it directly returns the result of __security_read_policy without freeing the allocated memory in *data, cause memory leak issue, so free the memory if __security_read_policy failed. [PM: subject line tweak]",,,"[{""url"":""https://git.kernel.org/stable/c/1fc1f72aad2070d34022d0823e4cf09706b53f25"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73de1befcc53a7c68b0c5e76b9b5ac41c517760f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c877c5217145bda8fd95f506bf42f8d981afa57d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f3cd7562c0a6774fc62d79654482014020e574f5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50202,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:50.923,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: PM: hibernate: defer device probing when resuming from hibernation syzbot is reporting hung task at misc_open() [1], for there is a race window of AB-BA deadlock which involves probe_count variable. Currently wait_for_device_probe() from snapshot_open() from misc_open() can sleep forever with misc_mtx held if probe_count cannot become 0. When a device is probed by hub_event() work function, probe_count is incremented before the probe function starts, and probe_count is decremented after the probe function completed. There are three cases that can prevent probe_count from dropping to 0. (a) A device being probed stopped responding (i.e. broken/malicious hardware). (b) A process emulating a USB device using /dev/raw-gadget interface stopped responding for some reason. (c) New device probe requests keeps coming in before existing device probe requests complete. The phenomenon syzbot is reporting is (b). A process which is holding system_transition_mutex and misc_mtx is waiting for probe_count to become 0 inside wait_for_device_probe(), but the probe function which is called from hub_event() work function is waiting for the processes which are blocked at mutex_lock(&misc_mtx) to respond via /dev/raw-gadget interface. This patch mitigates (b) by deferring wait_for_device_probe() from snapshot_open() to snapshot_write() and snapshot_ioctl(). Please note that the possibility of (b) remains as long as any thread which is emulating a USB device via /dev/raw-gadget interface can be blocked by uninterruptible blocking operations (e.g. mutex_lock()). Please also note that (a) and (c) are not addressed. Regarding (c), we should change the code to wait for only one device which contains the image for resuming from hibernation. I don't know how to address (a), for use of timeout for wait_for_device_probe() might result in loss of user data in the image. Maybe we should require the userland to wait for the image device before opening /dev/snapshot interface.",,,"[{""url"":""https://git.kernel.org/stable/c/003a456ae6f70bb97e436e02fc5105be577c1570"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2f0e18e0db42f4f8bc87d3d98333680065ceeff8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3c48d3067eaf878642276f053575a5c642600a50"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a283b59bce72c05c60e9f0fa92a28b5b850d8bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8386c414e27caba8501119948e9551e52b527f59"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c90947e5f1801e6c7120021c6ea0f3ad6a4eb91"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b8e1ae9433d7bd95f2dcc044a7a6f20a4c40d258"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f7042cf9dd40733f387b7cac021e626c74b8856f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50203,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:51.043,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ARM: OMAP2+: display: Fix refcount leak bug In omapdss_init_fbdev(), of_find_node_by_name() will return a node pointer with refcount incremented. We should use of_node_put() when it is not used anymore.",,,"[{""url"":""https://git.kernel.org/stable/c/0b4f96b47ff8dc2fa35d03c4116927248796d9af"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2629d171f3d6451724549d8d10d14ac6da37a7be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3e505298a75f0bbdc96e923e76e5d45d6c8f64a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/496988a19d5c36fabf97c847db39167e42393c74"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/50b87a32a79bca6e275918a711fb8cc55e16d739"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/88d556029a78999b098d26a330bb6a7de166f426"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a89a865dc9f0600fd146224e314775b9efc9d845"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bdbdf69d5b78c5712c60c0004fa6aed12da36e26"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50204,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:51.160,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ARM: OMAP2+: pdata-quirks: Fix refcount leak bug In pdata_quirks_init_clocks(), the loop contains of_find_node_by_name() but without corresponding of_node_put().",,,"[{""url"":""https://git.kernel.org/stable/c/37f0c89778576ce3d52f40c1e9e727fbddedb28e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5cdbab96bab314c6f2f5e4e8b8a019181328bf5f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/75f23d72b6e0a34c8a0e8d275b69ba1e6dd0f15f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ebca6870fc0cb5470dbc058cc94f3c53ea886eaa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50205,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:51.267,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext2: Add more validity checks for inode counts Add checks verifying number of inodes stored in the superblock matches the number computed from number of inodes per group. Also verify we have at least one block worth of inodes per group. This prevents crashes on corrupted filesystems.",,,"[{""url"":""https://git.kernel.org/stable/c/07303a9abe3a997d9864fb4315e34b5acfe8fc25"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0bcdc31094a12b4baf59e241feabc9787cf635fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e63c5fe9123fa76ffaeff26c211308736ec3a07"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7a48fdc88a3c35e046a6a0a38eba00f21c65b16e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/96b18d3a1be0354ccce43f0ef61b5a3d7e432552"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3f423683818cfe15de14d5d9dff44148ff16bbf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d08bb199a406424a8ed0009efdf41710e6d849ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa78f336937240d1bc598db817d638086060e7e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50206,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:51.390,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: arm64: fix oops in concurrently setting insn_emulation sysctls emulation_proc_handler() changes table->data for proc_dointvec_minmax and can generate the following Oops if called concurrently with itself: | Unable to handle kernel NULL pointer dereference at virtual address 0000000000000010 | Internal error: Oops: 96000006 [#1] SMP | Call trace: | update_insn_emulation_mode+0xc0/0x148 | emulation_proc_handler+0x64/0xb8 | proc_sys_call_handler+0x9c/0xf8 | proc_sys_write+0x18/0x20 | __vfs_write+0x20/0x48 | vfs_write+0xe4/0x1d0 | ksys_write+0x70/0xf8 | __arm64_sys_write+0x20/0x28 | el0_svc_common.constprop.0+0x7c/0x1c0 | el0_svc_handler+0x2c/0xa0 | el0_svc+0x8/0x200 To fix this issue, keep the table->data as &insn->current_mode and use container_of() to retrieve the insn pointer. Another mutex is used to protect against the current_mode update but not for retrieving insn_emulation as table->data is no longer changing.",,,"[{""url"":""https://git.kernel.org/stable/c/04549063d5701976034d8c2bfda3d3a8cbf0409f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/07022e07017ee5540f5559b0aeb916e8383c1e1a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/353b4673d01c512303c45cf2346f630cda73b5c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6a2fd114678d7fc1b5a0f8865ae98f1c17787455"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d5fec6ba2e4117d196a8259ab54615ffe562460"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/af483947d472eccb79e42059276c4deed76f99a6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b51881b1da57fe9877125dfdd0aac5172958fcfd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc69ef95988b9ef2fc730ec452a7441efb90ef5e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50207,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:51.503,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ARM: bcm: Fix refcount leak in bcm_kona_smc_init of_find_matching_node() returns a node pointer with refcount incremented, we should use of_node_put() on it when not need anymore. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/02b658bfb26452f2c13e4577a13ab802f89a6642"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5afe042c889437de83f38a9d73d145742fb4f65f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/62d719d31ec667276d7375b64542b080cf187797"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/75866df2b1d673df5b7781e565ada753a7895f04"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/91e7f04f53e680bc72f0a9a5c682ab652100b9c8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bc7f487395f208fd9af69e9a807815e10435aba7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c6964cb9ac7a43bf78e7d60126e2722992de2ea1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cb23389a2458c2e4bfd6c86a513cbbe1c4d35e76"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50208,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:51.620,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: soc: amlogic: Fix refcount leak in meson-secure-pwrc.c In meson_secure_pwrc_probe(), there is a refcount leak in one fail path.",,,"[{""url"":""https://git.kernel.org/stable/c/5509d07a9364b75b28055bf2d89289e4e5269929"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/80c469e63bfa9a5a8114952bffc6a7d241e7497e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d18529a4c12f66d83daac78045ea54063bd43257"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d1fbbb5ded714b6610a16ec3d7e271a55291ccc4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f370fbbd3151c1c87d1e976c8964cb6cc46f2e00"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50209,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:51.727,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: meson-mx-socinfo: Fix refcount leak in meson_mx_socinfo_init of_find_matching_node() returns a node pointer with refcount incremented, we should use of_node_put() on it when not need anymore. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/0c1757480a6a61b8c3164ed371c359edb3928f12"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2691b8780f88e1b8b3578a5bc78a0011741bbd74"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/69a64c77aafcf3c772264a36214937514e31ad82"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6b28bf3e044f12db0fc18c42f58ae7fc3fa0144a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8a4a33b3e898b13c750b1c0c9643516c7bf6473f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a2106f38077e78afcb4bf98fdda3e162118cfb3d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e21744c6a0d4116a2d6ebccd947620ca4c952e92"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50210,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:51.843,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: MIPS: cpuinfo: Fix a warning for CONFIG_CPUMASK_OFFSTACK When CONFIG_CPUMASK_OFFSTACK and CONFIG_DEBUG_PER_CPU_MAPS is selected, cpu_max_bits_warn() generates a runtime warning similar as below while we show /proc/cpuinfo. Fix this by using nr_cpu_ids (the runtime limit) instead of NR_CPUS to iterate CPUs. [ 3.052463] ------------[ cut here ]------------ [ 3.059679] WARNING: CPU: 3 PID: 1 at include/linux/cpumask.h:108 show_cpuinfo+0x5e8/0x5f0 [ 3.070072] Modules linked in: efivarfs autofs4 [ 3.076257] CPU: 0 PID: 1 Comm: systemd Not tainted 5.19-rc5+ #1052 [ 3.084034] Hardware name: Loongson Loongson-3A4000-7A1000-1w-V0.1-CRB/Loongson-LS3A4000-7A1000-1w-EVB-V1.21, BIOS Loongson-UDK2018-V2.0.04082-beta7 04/27 [ 3.099465] Stack : 9000000100157b08 9000000000f18530 9000000000cf846c 9000000100154000 [ 3.109127] 9000000100157a50 0000000000000000 9000000100157a58 9000000000ef7430 [ 3.118774] 90000001001578e8 0000000000000040 0000000000000020 ffffffffffffffff [ 3.128412] 0000000000aaaaaa 1ab25f00eec96a37 900000010021de80 900000000101c890 [ 3.138056] 0000000000000000 0000000000000000 0000000000000000 0000000000aaaaaa [ 3.147711] ffff8000339dc220 0000000000000001 0000000006ab4000 0000000000000000 [ 3.157364] 900000000101c998 0000000000000004 9000000000ef7430 0000000000000000 [ 3.167012] 0000000000000009 000000000000006c 0000000000000000 0000000000000000 [ 3.176641] 9000000000d3de08 9000000001639390 90000000002086d8 00007ffff0080286 [ 3.186260] 00000000000000b0 0000000000000004 0000000000000000 0000000000071c1c [ 3.195868] ... [ 3.199917] Call Trace: [ 3.203941] [<98000000002086d8>] show_stack+0x38/0x14c [ 3.210666] [<9800000000cf846c>] dump_stack_lvl+0x60/0x88 [ 3.217625] [<980000000023d268>] __warn+0xd0/0x100 [ 3.223958] [<9800000000cf3c90>] warn_slowpath_fmt+0x7c/0xcc [ 3.231150] [<9800000000210220>] show_cpuinfo+0x5e8/0x5f0 [ 3.238080] [<98000000004f578c>] seq_read_iter+0x354/0x4b4 [ 3.245098] [<98000000004c2e90>] new_sync_read+0x17c/0x1c4 [ 3.252114] [<98000000004c5174>] vfs_read+0x138/0x1d0 [ 3.258694] [<98000000004c55f8>] ksys_read+0x70/0x100 [ 3.265265] [<9800000000cfde9c>] do_syscall+0x7c/0x94 [ 3.271820] [<9800000000202fe4>] handle_syscall+0xc4/0x160 [ 3.281824] ---[ end trace 8b484262b4b8c24c ]---",,,"[{""url"":""https://git.kernel.org/stable/c/274e44e2123417e0924c90d4b4531913b5f3aa2e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4cb392956ae392aec4aa06e661a0bb9146b0bace"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d305823e02217b29d41fca67e3cef87fd7bd688"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/807adf6ffa8c3beedcd63b20f5a59c7d061df7d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8916ec149c79cb21f5454fa7840ad96f99cf51cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/98aaa511957667ba26d6dabe28dfa210a8f53a63"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3ac4e47510ec0753ebe1e418a334ad202784aa8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e1a534f5d074db45ae5cbac41d8912b98e96a006"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e41db8a9ce696a3382a4f098878fd4d14bccd201"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50211,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:51.970,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: md-raid10: fix KASAN warning There's a KASAN warning in raid10_remove_disk when running the lvm test lvconvert-raid-reshape.sh. We fix this warning by verifying that the value ""number"" is valid. BUG: KASAN: slab-out-of-bounds in raid10_remove_disk+0x61/0x2a0 [raid10] Read of size 8 at addr ffff889108f3d300 by task mdX_raid10/124682 CPU: 3 PID: 124682 Comm: mdX_raid10 Not tainted 5.19.0-rc6 #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x34/0x44 print_report.cold+0x45/0x57a ? __lock_text_start+0x18/0x18 ? raid10_remove_disk+0x61/0x2a0 [raid10] kasan_report+0xa8/0xe0 ? raid10_remove_disk+0x61/0x2a0 [raid10] raid10_remove_disk+0x61/0x2a0 [raid10] Buffer I/O error on dev dm-76, logical block 15344, async page read ? __mutex_unlock_slowpath.constprop.0+0x1e0/0x1e0 remove_and_add_spares+0x367/0x8a0 [md_mod] ? super_written+0x1c0/0x1c0 [md_mod] ? mutex_trylock+0xac/0x120 ? _raw_spin_lock+0x72/0xc0 ? _raw_spin_lock_bh+0xc0/0xc0 md_check_recovery+0x848/0x960 [md_mod] raid10d+0xcf/0x3360 [raid10] ? sched_clock_cpu+0x185/0x1a0 ? rb_erase+0x4d4/0x620 ? var_wake_function+0xe0/0xe0 ? psi_group_change+0x411/0x500 ? preempt_count_sub+0xf/0xc0 ? _raw_spin_lock_irqsave+0x78/0xc0 ? __lock_text_start+0x18/0x18 ? raid10_sync_request+0x36c0/0x36c0 [raid10] ? preempt_count_sub+0xf/0xc0 ? _raw_spin_unlock_irqrestore+0x19/0x40 ? del_timer_sync+0xa9/0x100 ? try_to_del_timer_sync+0xc0/0xc0 ? _raw_spin_lock_irqsave+0x78/0xc0 ? __lock_text_start+0x18/0x18 ? _raw_spin_unlock_irq+0x11/0x24 ? __list_del_entry_valid+0x68/0xa0 ? finish_wait+0xa3/0x100 md_thread+0x161/0x260 [md_mod] ? unregister_md_personality+0xa0/0xa0 [md_mod] ? _raw_spin_lock_irqsave+0x78/0xc0 ? prepare_to_wait_event+0x2c0/0x2c0 ? unregister_md_personality+0xa0/0xa0 [md_mod] kthread+0x148/0x180 ? kthread_complete_and_exit+0x20/0x20 ret_from_fork+0x1f/0x30 </TASK> Allocated by task 124495: kasan_save_stack+0x1e/0x40 __kasan_kmalloc+0x80/0xa0 setup_conf+0x140/0x5c0 [raid10] raid10_run+0x4cd/0x740 [raid10] md_run+0x6f9/0x1300 [md_mod] raid_ctr+0x2531/0x4ac0 [dm_raid] dm_table_add_target+0x2b0/0x620 [dm_mod] table_load+0x1c8/0x400 [dm_mod] ctl_ioctl+0x29e/0x560 [dm_mod] dm_compat_ctl_ioctl+0x7/0x20 [dm_mod] __do_compat_sys_ioctl+0xfa/0x160 do_syscall_64+0x90/0xc0 entry_SYSCALL_64_after_hwframe+0x46/0xb0 Last potentially related work creation: kasan_save_stack+0x1e/0x40 __kasan_record_aux_stack+0x9e/0xc0 kvfree_call_rcu+0x84/0x480 timerfd_release+0x82/0x140 L __fput+0xfa/0x400 task_work_run+0x80/0xc0 exit_to_user_mode_prepare+0x155/0x160 syscall_exit_to_user_mode+0x12/0x40 do_syscall_64+0x42/0xc0 entry_SYSCALL_64_after_hwframe+0x46/0xb0 Second to last potentially related work creation: kasan_save_stack+0x1e/0x40 __kasan_record_aux_stack+0x9e/0xc0 kvfree_call_rcu+0x84/0x480 timerfd_release+0x82/0x140 __fput+0xfa/0x400 task_work_run+0x80/0xc0 exit_to_user_mode_prepare+0x155/0x160 syscall_exit_to_user_mode+0x12/0x40 do_syscall_64+0x42/0xc0 entry_SYSCALL_64_after_hwframe+0x46/0xb0 The buggy address belongs to the object at ffff889108f3d200 which belongs to the cache kmalloc-256 of size 256 The buggy address is located 0 bytes to the right of 256-byte region [ffff889108f3d200, ffff889108f3d300) The buggy address belongs to the physical page: page:000000007ef2a34c refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1108f3c head:000000007ef2a34c order:2 compound_mapcount:0 compound_pincount:0 flags: 0x4000000000010200(slab|head|zone=2) raw: 4000000000010200 0000000000000000 dead000000000001 ffff889100042b40 raw: 0000000000000000 0000000080200020 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffff889108f3d200: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ffff889108f3d280: 00 00 ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/0f4d18cbea4a6e37a05fd8ee2887439f85211110"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5f57843565131bb782388f9d993f9ee8f453dee1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5fd4ffa2372a41361d2bdd27ea5730e4e673240c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/75fbd370a2cec9e92f48285bd90735ed0c837f52"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7a6ccc8fa192fd357c2d5d4c6ce67c834a179e23"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bcbdc26a44aba488d2f7122f2d66801bccb74733"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf30b9ba09b0ac2a10f04dce2b0835ec4d178aa6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce839b9331c11780470f3d727b6fe3c2794a4620"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d17f744e883b2f8d13cca252d71cfe8ace346f7d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50212,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:52.087,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: nf_tables: do not allow CHAIN_ID to refer to another table When doing lookups for chains on the same batch by using its ID, a chain from a different table can be used. If a rule is added to a table but refers to a chain in a different table, it will be linked to the chain in table2, but would have expressions referring to objects in table1. Then, when table1 is removed, the rule will not be removed as its linked to a chain in table2. When expressions in the rule are processed or removed, that will lead to a use-after-free. When looking for chains by ID, use the table that was used for the lookup by name, and only return chains belonging to that same table.",,,"[{""url"":""https://git.kernel.org/stable/c/0f49613a213d918af790c1276f79da741968de11"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/58e863f64ee3d0879297e5e53b646e4b91e59620"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/91501513016903077f91033fa5d2aa26cac399b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/95f466d22364a33d183509629d0879885b4f547e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9e7dcb88ec8e85e4a8ad0ea494ea2f90f32d2583"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50213,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:52.197,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: nf_tables: do not allow SET_ID to refer to another table When doing lookups for sets on the same batch by using its ID, a set from a different table can be used. Then, when the table is removed, a reference to the set may be kept after the set is freed, leading to a potential use-after-free. When looking for sets by ID, use the table that was used for the lookup by name, and only return sets belonging to that same table. This fixes CVE-2022-2586, also reported as ZDI-CAN-17470.",,,"[{""url"":""https://git.kernel.org/stable/c/0d07039397527361850c554c192e749cfc879ea9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1a4b18b1ff11ba26f9a852019d674fde9d1d1cff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/470ee20e069a6d05ae549f7d0ef2bdbcee6a81b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/77d3b5038b7462318f5183e2ad704b01d57215a2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f4fa03410f7c5f5bd8f90e9c11e9a8c4b526ff6f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/faafd9286f1355c76fe9ac3021c280297213330e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fab2f61cc3b0e441b1749f017cfee75f9bbaded7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50214,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:52.310,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: coresight: Clear the connection field properly coresight devices track their connections (output connections) and hold a reference to the fwnode. When a device goes away, we walk through the devices on the coresight bus and make sure that the references are dropped. This happens both ways: a) For all output connections from the device, drop the reference to the target device via coresight_release_platform_data() b) Iterate over all the devices on the coresight bus and drop the reference to fwnode if *this* device is the target of the output connection, via coresight_remove_conns()->coresight_remove_match(). However, the coresight_remove_match() doesn't clear the fwnode field, after dropping the reference, this causes use-after-free and additional refcount drops on the fwnode. e.g., if we have two devices, A and B, with a connection, A -> B. If we remove B first, B would clear the reference on B, from A via coresight_remove_match(). But when A is removed, it still has a connection with fwnode still pointing to B. Thus it tries to drops the reference in coresight_release_platform_data(), raising the bells like : [ 91.990153] ------------[ cut here ]------------ [ 91.990163] refcount_t: addition on 0; use-after-free. [ 91.990212] WARNING: CPU: 0 PID: 461 at lib/refcount.c:25 refcount_warn_saturate+0xa0/0x144 [ 91.990260] Modules linked in: coresight_funnel coresight_replicator coresight_etm4x(-) crct10dif_ce coresight ip_tables x_tables ipv6 [last unloaded: coresight_cpu_debug] [ 91.990398] CPU: 0 PID: 461 Comm: rmmod Tainted: G W T 5.19.0-rc2+ #53 [ 91.990418] Hardware name: ARM LTD ARM Juno Development Platform/ARM Juno Development Platform, BIOS EDK II Feb 1 2019 [ 91.990434] pstate: 600000c5 (nZCv daIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 91.990454] pc : refcount_warn_saturate+0xa0/0x144 [ 91.990476] lr : refcount_warn_saturate+0xa0/0x144 [ 91.990496] sp : ffff80000c843640 [ 91.990509] x29: ffff80000c843640 x28: ffff800009957c28 x27: ffff80000c8439a8 [ 91.990560] x26: ffff00097eff1990 x25: ffff8000092b6ad8 x24: ffff00097eff19a8 [ 91.990610] x23: ffff80000c8439a8 x22: 0000000000000000 x21: ffff80000c8439c2 [ 91.990659] x20: 0000000000000000 x19: ffff00097eff1a10 x18: ffff80000ab99c40 [ 91.990708] x17: 0000000000000000 x16: 0000000000000000 x15: ffff80000abf6fa0 [ 91.990756] x14: 000000000000001d x13: 0a2e656572662d72 x12: 657466612d657375 [ 91.990805] x11: 203b30206e6f206e x10: 6f69746964646120 x9 : ffff8000081aba28 [ 91.990854] x8 : 206e6f206e6f6974 x7 : 69646461203a745f x6 : 746e756f63666572 [ 91.990903] x5 : ffff00097648ec58 x4 : 0000000000000000 x3 : 0000000000000027 [ 91.990952] x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff00080260ba00 [ 91.991000] Call trace: [ 91.991012] refcount_warn_saturate+0xa0/0x144 [ 91.991034] kobject_get+0xac/0xb0 [ 91.991055] of_node_get+0x2c/0x40 [ 91.991076] of_fwnode_get+0x40/0x60 [ 91.991094] fwnode_handle_get+0x3c/0x60 [ 91.991116] fwnode_get_nth_parent+0xf4/0x110 [ 91.991137] fwnode_full_name_string+0x48/0xc0 [ 91.991158] device_node_string+0x41c/0x530 [ 91.991178] pointer+0x320/0x3ec [ 91.991198] vsnprintf+0x23c/0x750 [ 91.991217] vprintk_store+0x104/0x4b0 [ 91.991238] vprintk_emit+0x8c/0x360 [ 91.991257] vprintk_default+0x44/0x50 [ 91.991276] vprintk+0xcc/0xf0 [ 91.991295] _printk+0x68/0x90 [ 91.991315] of_node_release+0x13c/0x14c [ 91.991334] kobject_put+0x98/0x114 [ 91.991354] of_node_put+0x24/0x34 [ 91.991372] of_fwnode_put+0x40/0x5c [ 91.991390] fwnode_handle_put+0x38/0x50 [ 91.991411] coresight_release_platform_data+0x74/0xb0 [coresight] [ 91.991472] coresight_unregister+0x64/0xcc [coresight] [ 91.991525] etm4_remove_dev+0x64/0x78 [coresight_etm4x] [ 91.991563] etm4_remove_amba+0x1c/0x2c [coresight_etm4x] [ 91.991598] amba_remove+0x3c/0x19c ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/2af89ebacf299b7fba5f3087d35e8a286ec33706"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/847b9273dd61567fb77617eabc5fa002594db062"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b49b29ee113a87997bcca0bb0585bb46582846c1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bc57850fcb7e4cb91b6321d0ce83357cefd55c54"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d43e967963c4d1b2b49f894d2f1b12865f87b098"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e9205d8dd1cafb7cff689ef9ddf06276a68f54a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50215,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:52.423,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: sg: Allow waiting for commands to complete on removed device When a SCSI device is removed while in active use, currently sg will immediately return -ENODEV on any attempt to wait for active commands that were sent before the removal. This is problematic for commands that use SG_FLAG_DIRECT_IO since the data buffer may still be in use by the kernel when userspace frees or reuses it after getting ENODEV, leading to corrupted userspace memory (in the case of READ-type commands) or corrupted data being sent to the device (in the case of WRITE-type commands). This has been seen in practice when logging out of a iscsi_tcp session, where the iSCSI driver may still be processing commands after the device has been marked for removal. Change the policy to allow userspace to wait for active sg commands even when the device is being removed. Return -ENODEV only when there are no more responses to read.",,,"[{""url"":""https://git.kernel.org/stable/c/03d8241112d5e3cccce1a01274a221099f07d2e1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3455607fd7be10b449f5135c00dc306b85dc0d21"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/35e60ec39e862159cb92923eefd5230d4a873cb9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/408bfa1489a3cfe7150b81ab0b0df99b23dd5411"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c004b7dbb340c1e5889f5fb9e5baa6f6e5303e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bbc118acf7baf9e93c5e1314d14f481301af4d0f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ed9afd967cbfe7da2dc0d5e52c62a778dfe9f16b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f135c65085eed869d10e4e7923ce1015288618da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f5e61d9b4a699dd16f32d5f39eb1cf98d84c92ed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50216,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:52.540,2025-06-18T14:15:24.390,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2022-50217,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:52.647,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fuse: write inode in fuse_release() A race between write(2) and close(2) allows pages to be dirtied after fuse_flush -> write_inode_now(). If these pages are not flushed from fuse_release(), then there might not be a writable open file later. So any remaining dirty pages must be written back before the file is released. This is a partial revert of the blamed commit.",,,"[{""url"":""https://git.kernel.org/stable/c/035ff33cf4db101250fb980a3941bf078f37a544"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4bd9d5d20f344d015422969302d12653c903c271"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5ccb0420b7c9334ab8122037847101931b899301"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50218,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:52.753,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iio: light: isl29028: Fix the warning in isl29028_remove() The driver use the non-managed form of the register function in isl29028_remove(). To keep the release order as mirroring the ordering in probe, the driver should use non-managed form in probe, too. The following log reveals it: [ 32.374955] isl29028 0-0010: remove [ 32.376861] general protection fault, probably for non-canonical address 0xdffffc0000000006: 0000 [#1] PREEMPT SMP KASAN PTI [ 32.377676] KASAN: null-ptr-deref in range [0x0000000000000030-0x0000000000000037] [ 32.379432] RIP: 0010:kernfs_find_and_get_ns+0x28/0xe0 [ 32.385461] Call Trace: [ 32.385807] sysfs_unmerge_group+0x59/0x110 [ 32.386110] dpm_sysfs_remove+0x58/0xc0 [ 32.386391] device_del+0x296/0xe50 [ 32.386959] cdev_device_del+0x1d/0xd0 [ 32.387231] devm_iio_device_unreg+0x27/0xb0 [ 32.387542] devres_release_group+0x319/0x3d0 [ 32.388162] i2c_device_remove+0x93/0x1f0",,,"[{""url"":""https://git.kernel.org/stable/c/06674fc7c003b9d0aa1d37fef7ab2c24802cc6ad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/359f3b150eab30805fe0e4e9d616887d7257a625"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4f0ebfb4b9bfad2326c0b2c3cc7e37f4b9ee9eba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a1135205b0affd255510775a27df571aca84ab4b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca63d5abf404d2934e2ac03545350de7bb8c8e96"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ed43fb20d3d1fca9d79db0d5faf4321a4dd58c23"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fac589fb764699a4bcd288f6656b8cd0408ea968"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fb1888205c0782f287e5dd4ffff1f665332e868c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50219,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:52.863,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf: Fix KASAN use-after-free Read in compute_effective_progs Syzbot found a Use After Free bug in compute_effective_progs(). The reproducer creates a number of BPF links, and causes a fault injected alloc to fail, while calling bpf_link_detach on them. Link detach triggers the link to be freed by bpf_link_free(), which calls __cgroup_bpf_detach() and update_effective_progs(). If the memory allocation in this function fails, the function restores the pointer to the bpf_cgroup_link on the cgroup list, but the memory gets freed just after it returns. After this, every subsequent call to update_effective_progs() causes this already deallocated pointer to be dereferenced in prog_list_length(), and triggers KASAN UAF error. To fix this issue don't preserve the pointer to the prog or link in the list, but remove it and replace it with a dummy prog without shrinking the table. The subsequent call to __cgroup_bpf_detach() or __cgroup_bpf_detach() will correct it.",,,"[{""url"":""https://git.kernel.org/stable/c/1f8ca9c40e6222ce431e9ba5dae3cccce8ef9443"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3527e3cbb84d8868c4d4e91ba55915f96d39ec3d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c46091ee985ae84c60c5e95055d779fcd291d87"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6336388715afa419cc97d0255bda3bba1b96b7ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be001f9da71eaa3b61e186fb88bde3279728bdca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50220,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:52.973,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usbnet: Fix linkwatch use-after-free on disconnect usbnet uses the work usbnet_deferred_kevent() to perform tasks which may sleep. On disconnect, completion of the work was originally awaited in ->ndo_stop(). But in 2003, that was moved to ->disconnect() by historic commit ""[PATCH] USB: usbnet, prevent exotic rtnl deadlock"": https://git.kernel.org/tglx/history/c/0f138bbfd83c The change was made because back then, the kernel's workqueue implementation did not allow waiting for a single work. One had to wait for completion of *all* work by calling flush_scheduled_work(), and that could deadlock when waiting for usbnet_deferred_kevent() with rtnl_mutex held in ->ndo_stop(). The commit solved one problem but created another: It causes a use-after-free in USB Ethernet drivers aqc111.c, asix_devices.c, ax88179_178a.c, ch9200.c and smsc75xx.c: * If the drivers receive a link change interrupt immediately before disconnect, they raise EVENT_LINK_RESET in their (non-sleepable) ->status() callback and schedule usbnet_deferred_kevent(). * usbnet_deferred_kevent() invokes the driver's ->link_reset() callback, which calls netif_carrier_{on,off}(). * That in turn schedules the work linkwatch_event(). Because usbnet_deferred_kevent() is awaited after unregister_netdev(), netif_carrier_{on,off}() may operate on an unregistered netdev and linkwatch_event() may run after free_netdev(), causing a use-after-free. In 2010, usbnet was changed to only wait for a single instance of usbnet_deferred_kevent() instead of *all* work by commit 23f333a2bfaf (""drivers/net: don't use flush_scheduled_work()""). Unfortunately the commit neglected to move the wait back to ->ndo_stop(). Rectify that omission at long last.",,,"[{""url"":""https://git.kernel.org/stable/c/135199a2edd459d2b123144efcd7f9bcd95128e4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/635fd8953e4309b54ca6a81bed1d4a87668694f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f77dcbc030c2faa6d8e8a594985eeb34018409e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8b4588b8b00b299be16a35be67b331d8fdba03f3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a69e617e533edddf3fa3123149900f36e0a6dc74"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d2d6b530d89b0a912148018027386aa049f0a309"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d49bb8cf9bfaa06aa527eb30f1a52a071da2e32f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/db3b738ae5f726204876f4303c49cfdf4311403f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e2a521a7dcc463c5017b4426ca0804e151faeff7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50221,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:53.090,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/fb-helper: Fix out-of-bounds access Clip memory range to screen-buffer size to avoid out-of-bounds access in fbdev deferred I/O's damage handling. Fbdev's deferred I/O can only track pages. From the range of pages, the damage handler computes the clipping rectangle for the display update. If the fbdev screen buffer ends near the beginning of a page, that page could contain more scanlines. The damage handler would then track these non-existing scanlines as dirty and provoke an out-of-bounds access during the screen update. Hence, clip the maximum memory range to the size of the screen buffer. While at it, rename the variables min/max to min_off/max_off in drm_fb_helper_deferred_io(). This avoids confusion with the macros of the same name.",,,"[{""url"":""https://git.kernel.org/stable/c/9c49ac792c639dbec0728b513329a32461f72253"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ae25885bdf59fde40726863c57fd20e4a0642183"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50222,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:53.193,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tty: vt: initialize unicode screen buffer syzbot reports kernel infoleak at vcs_read() [1], for buffer can be read immediately after resize operation. Initialize buffer using kzalloc(). ---------- #include <fcntl.h> #include <unistd.h> #include <sys/ioctl.h> #include <linux/fb.h> int main(int argc, char *argv[]) { struct fb_var_screeninfo var = { }; const int fb_fd = open(""/dev/fb0"", 3); ioctl(fb_fd, FBIOGET_VSCREENINFO, &var); var.yres = 0x21; ioctl(fb_fd, FBIOPUT_VSCREENINFO, &var); return read(open(""/dev/vcsu"", O_RDONLY), &var, sizeof(var)) == -1; } ----------",,,"[{""url"":""https://git.kernel.org/stable/c/446f123aa6021e5f75a20789f05ff3f7ae51a42f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5c6c65681f39bf71bc72ed589dec3b8b20e75cac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/777a462e1ae50a01fc4a871efa8e34d596a1e17d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/af77c56aa35325daa2bc2bed5c2ebf169be61b86"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc9e874dace0c89ae535230c7da19b764746811e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e02fa87e572bb7d90dcdbce9c0f519f1eb992e96"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0ef23e9b0ad18b9fd3741b0f1ad2282e4a18def"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50223,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:53.303,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: LoongArch: cpuinfo: Fix a warning for CONFIG_CPUMASK_OFFSTACK When CONFIG_CPUMASK_OFFSTACK and CONFIG_DEBUG_PER_CPU_MAPS is selected, cpu_max_bits_warn() generates a runtime warning similar as below while we show /proc/cpuinfo. Fix this by using nr_cpu_ids (the runtime limit) instead of NR_CPUS to iterate CPUs. [ 3.052463] ------------[ cut here ]------------ [ 3.059679] WARNING: CPU: 3 PID: 1 at include/linux/cpumask.h:108 show_cpuinfo+0x5e8/0x5f0 [ 3.070072] Modules linked in: efivarfs autofs4 [ 3.076257] CPU: 0 PID: 1 Comm: systemd Not tainted 5.19-rc5+ #1052 [ 3.084034] Hardware name: Loongson Loongson-3A5000-7A1000-1w-V0.1-CRB/Loongson-LS3A5000-7A1000-1w-EVB-V1.21, BIOS Loongson-UDK2018-V2.0.04082-beta7 04/27 [ 3.099465] Stack : 9000000100157b08 9000000000f18530 9000000000cf846c 9000000100154000 [ 3.109127] 9000000100157a50 0000000000000000 9000000100157a58 9000000000ef7430 [ 3.118774] 90000001001578e8 0000000000000040 0000000000000020 ffffffffffffffff [ 3.128412] 0000000000aaaaaa 1ab25f00eec96a37 900000010021de80 900000000101c890 [ 3.138056] 0000000000000000 0000000000000000 0000000000000000 0000000000aaaaaa [ 3.147711] ffff8000339dc220 0000000000000001 0000000006ab4000 0000000000000000 [ 3.157364] 900000000101c998 0000000000000004 9000000000ef7430 0000000000000000 [ 3.167012] 0000000000000009 000000000000006c 0000000000000000 0000000000000000 [ 3.176641] 9000000000d3de08 9000000001639390 90000000002086d8 00007ffff0080286 [ 3.186260] 00000000000000b0 0000000000000004 0000000000000000 0000000000071c1c [ 3.195868] ... [ 3.199917] Call Trace: [ 3.203941] [<90000000002086d8>] show_stack+0x38/0x14c [ 3.210666] [<9000000000cf846c>] dump_stack_lvl+0x60/0x88 [ 3.217625] [<900000000023d268>] __warn+0xd0/0x100 [ 3.223958] [<9000000000cf3c90>] warn_slowpath_fmt+0x7c/0xcc [ 3.231150] [<9000000000210220>] show_cpuinfo+0x5e8/0x5f0 [ 3.238080] [<90000000004f578c>] seq_read_iter+0x354/0x4b4 [ 3.245098] [<90000000004c2e90>] new_sync_read+0x17c/0x1c4 [ 3.252114] [<90000000004c5174>] vfs_read+0x138/0x1d0 [ 3.258694] [<90000000004c55f8>] ksys_read+0x70/0x100 [ 3.265265] [<9000000000cfde9c>] do_syscall+0x7c/0x94 [ 3.271820] [<9000000000202fe4>] handle_syscall+0xc4/0x160 [ 3.281824] ---[ end trace 8b484262b4b8c24c ]---",,,"[{""url"":""https://git.kernel.org/stable/c/28e112afa44ad0814120d41c68fa72372a2cd2c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/37268c7badd36f5381056d1651a6ee0b63b8ff3c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50224,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:53.410,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: KVM: x86/mmu: Treat NX as a valid SPTE bit for NPT Treat the NX bit as valid when using NPT, as KVM will set the NX bit when the NX huge page mitigation is enabled (mindblowing) and trigger the WARN that fires on reserved SPTE bits being set. KVM has required NX support for SVM since commit b26a71a1a5b9 (""KVM: SVM: Refuse to load kvm_amd if NX support is not available"") for exactly this reason, but apparently it never occurred to anyone to actually test NPT with the mitigation enabled. ------------[ cut here ]------------ spte = 0x800000018a600ee7, level = 2, rsvd bits = 0x800f0000001fe000 WARNING: CPU: 152 PID: 15966 at arch/x86/kvm/mmu/spte.c:215 make_spte+0x327/0x340 [kvm] Hardware name: Google, Inc. Arcadia_IT_80/Arcadia_IT_80, BIOS 10.48.0 01/27/2022 RIP: 0010:make_spte+0x327/0x340 [kvm] Call Trace: <TASK> tdp_mmu_map_handle_target_level+0xc3/0x230 [kvm] kvm_tdp_mmu_map+0x343/0x3b0 [kvm] direct_page_fault+0x1ae/0x2a0 [kvm] kvm_tdp_page_fault+0x7d/0x90 [kvm] kvm_mmu_page_fault+0xfb/0x2e0 [kvm] npf_interception+0x55/0x90 [kvm_amd] svm_invoke_exit_handler+0x31/0xf0 [kvm_amd] svm_handle_exit+0xf6/0x1d0 [kvm_amd] vcpu_enter_guest+0xb6d/0xee0 [kvm] ? kvm_pmu_trigger_event+0x6d/0x230 [kvm] vcpu_run+0x65/0x2c0 [kvm] kvm_arch_vcpu_ioctl_run+0x355/0x610 [kvm] kvm_vcpu_ioctl+0x551/0x610 [kvm] __se_sys_ioctl+0x77/0xc0 __x64_sys_ioctl+0x1d/0x20 do_syscall_64+0x44/0xa0 entry_SYSCALL_64_after_hwframe+0x46/0xb0 </TASK> ---[ end trace 0000000000000000 ]---",,,"[{""url"":""https://git.kernel.org/stable/c/6271f2854b9233702e236e576b885a876dde4889"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c6ab524cfae0799e55c82b2c1d61f1af0156f8d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50225,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:53.517,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: riscv:uprobe fix SR_SPIE set/clear handling In riscv the process of uprobe going to clear spie before exec the origin insn,and set spie after that.But When access the page which origin insn has been placed a page fault may happen and irq was disabled in arch_uprobe_pre_xol function,It cause a WARN as follows. There is no need to clear/set spie in arch_uprobe_pre/post/abort_xol. We can just remove it. [ 31.684157] BUG: sleeping function called from invalid context at kernel/locking/rwsem.c:1488 [ 31.684677] in_atomic(): 0, irqs_disabled(): 1, non_block: 0, pid: 76, name: work [ 31.684929] preempt_count: 0, expected: 0 [ 31.685969] CPU: 2 PID: 76 Comm: work Tainted: G [ 31.686542] Hardware name: riscv-virtio,qemu (DT) [ 31.686797] Call Trace: [ 31.687053] [<ffffffff80006442>] dump_backtrace+0x30/0x38 [ 31.687699] [<ffffffff80812118>] show_stack+0x40/0x4c [ 31.688141] [<ffffffff8081817a>] dump_stack_lvl+0x44/0x5c [ 31.688396] [<ffffffff808181aa>] dump_stack+0x18/0x20 [ 31.688653] [<ffffffff8003e454>] __might_resched+0x114/0x122 [ 31.688948] [<ffffffff8003e4b2>] __might_sleep+0x50/0x7a [ 31.689435] [<ffffffff80822676>] down_read+0x30/0x130 [ 31.689728] [<ffffffff8000b650>] do_page_fault+0x166/x446 [ 31.689997] [<ffffffff80003c0c>] ret_from_exception+0x0/0xc",,,"[{""url"":""https://git.kernel.org/stable/c/3811d51778900064d27d8c9a98f73410fb3b471d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3dbe5829408bc1586f75b4667ef60e5aab0209c7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73fc099eaefd9a92c83b6c07dad066411fd5a192"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c71e000db8536d27ec410abb3e314896a78b4f19"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50226,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:53.633,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: crypto: ccp - Use kzalloc for sev ioctl interfaces to prevent kernel memory leak For some sev ioctl interfaces, input may be passed that is less than or equal to SEV_FW_BLOB_MAX_SIZE, but larger than the data that PSP firmware returns. In this case, kmalloc will allocate memory that is the size of the input rather than the size of the data. Since PSP firmware doesn't fully overwrite the buffer, the sev ioctl interfaces with the issue may return uninitialized slab memory. Currently, all of the ioctl interfaces in the ccp driver are safe, but to prevent future problems, change all ioctl interfaces that allocate memory with kmalloc to use kzalloc and memset the data buffer to zero in sev_ioctl_do_platform_status.",,,"[{""url"":""https://git.kernel.org/stable/c/13dc15a3f5fd7f884e4bfa8c011a0ae868df12ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c5300f6f5e18b11c02a92f136e69b98fddba15e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/caa395aa16e7c9193fd7fa6cde462dd8229d4953"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e11fb0a3a39bb42da35fa662c46ce7391f277436"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f2a920daa780956b987c14b9f23de7c3c8915bf2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50227,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:53.743,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: KVM: x86/xen: Initialize Xen timer only once Add a check for existing xen timers before initializing a new one. Currently kvm_xen_init_timer() is called on every KVM_XEN_VCPU_ATTR_TYPE_TIMER, which is causing the following ODEBUG crash when vcpu->arch.xen.timer is already set. ODEBUG: init active (active state 0) object type: hrtimer hint: xen_timer_callbac0 RIP: 0010:debug_print_object+0x16e/0x250 lib/debugobjects.c:502 Call Trace: __debug_object_init debug_hrtimer_init debug_init hrtimer_init kvm_xen_init_timer kvm_xen_vcpu_set_attr kvm_arch_vcpu_ioctl kvm_vcpu_ioctl vfs_ioctl",,,"[{""url"":""https://git.kernel.org/stable/c/9a9b5771e930f408c3419799000f76a9abaf2278"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/af735db31285fa699384c649be72a9f32ecbb665"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50228,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:53.850,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: KVM: SVM: Don't BUG if userspace injects an interrupt with GIF=0 Don't BUG/WARN on interrupt injection due to GIF being cleared, since it's trivial for userspace to force the situation via KVM_SET_VCPU_EVENTS (even if having at least a WARN there would be correct for KVM internally generated injections). kernel BUG at arch/x86/kvm/svm/svm.c:3386! invalid opcode: 0000 [#1] SMP CPU: 15 PID: 926 Comm: smm_test Not tainted 5.17.0-rc3+ #264 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015 RIP: 0010:svm_inject_irq+0xab/0xb0 [kvm_amd] Code: <0f> 0b 0f 1f 00 0f 1f 44 00 00 80 3d ac b3 01 00 00 55 48 89 f5 53 RSP: 0018:ffffc90000b37d88 EFLAGS: 00010246 RAX: 0000000000000000 RBX: ffff88810a234ac0 RCX: 0000000000000006 RDX: 0000000000000000 RSI: ffffc90000b37df7 RDI: ffff88810a234ac0 RBP: ffffc90000b37df7 R08: ffff88810a1fa410 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000 R13: ffff888109571000 R14: ffff88810a234ac0 R15: 0000000000000000 FS: 0000000001821380(0000) GS:ffff88846fdc0000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f74fc550008 CR3: 000000010a6fe000 CR4: 0000000000350ea0 Call Trace: <TASK> inject_pending_event+0x2f7/0x4c0 [kvm] kvm_arch_vcpu_ioctl_run+0x791/0x17a0 [kvm] kvm_vcpu_ioctl+0x26d/0x650 [kvm] __x64_sys_ioctl+0x82/0xb0 do_syscall_64+0x3b/0xc0 entry_SYSCALL_64_after_hwframe+0x44/0xae </TASK>",,,"[{""url"":""https://git.kernel.org/stable/c/2c49adeb020995236e63722ef6d0bee14372f471"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2eee1dba70f57148fc7f8252613bfae6bd4b04e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3d4e2d884da6312df7c9b85fbf671de49204ead6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/68e1313bb8809e8addcd9431f2bfea0e8ddbca80"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6afe88fbb40eac3291a8728688d61fdc745d8008"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6fcbab82ccbcde915644085f73d3487938bda42d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8bb683490278005b4caf61e22b0828a04d282e86"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c3396c1c8b87510f2ac2a674948156577559d42d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f17c31c48e5cde9895a491d91c424eeeada3e134"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50229,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:53.967,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ALSA: bcd2000: Fix a UAF bug on the error path of probing When the driver fails in snd_card_register() at probe time, it will free the 'bcd2k->midi_out_urb' before killing it, which may cause a UAF bug. The following log can reveal it: [ 50.727020] BUG: KASAN: use-after-free in bcd2000_input_complete+0x1f1/0x2e0 [snd_bcd2000] [ 50.727623] Read of size 8 at addr ffff88810fab0e88 by task swapper/4/0 [ 50.729530] Call Trace: [ 50.732899] bcd2000_input_complete+0x1f1/0x2e0 [snd_bcd2000] Fix this by adding usb_kill_urb() before usb_free_urb().",,,"[{""url"":""https://git.kernel.org/stable/c/05e0bb8c3c4dde3e21b9c1cf9395afb04e8b24db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1d6a246cf97c380f2da76591f03019dd9c9599c3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/348620464a5c127399ac09b266f494f393661952"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4fc41f7ebb7efca282f1740ea934d16f33c1d109"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e7338f4dd92b2f8915a82abfa1dd3ad3464bea0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/64ca7f50ad96c2c65ae390b954925a36eabe04aa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a718eba7e458e2f40531be3c6b6a0028ca7fcace"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b0d4af0a4763ddc02344789ef2a281c494bc330d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ffb2759df7efbc00187bfd9d1072434a13a54139"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50230,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:54.083,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: arm64: set UXN on swapper page tables [ This issue was fixed upstream by accident in c3cee924bd85 (""arm64: head: cover entire kernel image in initial ID map"") as part of a large refactoring of the arm64 boot flow. This simple fix is therefore preferred for -stable backporting ] On a system that implements FEAT_EPAN, read/write access to the idmap is denied because UXN is not set on the swapper PTEs. As a result, idmap_kpti_install_ng_mappings panics the kernel when accessing __idmap_kpti_flag. Fix it by setting UXN on these PTEs.",,,"[{""url"":""https://git.kernel.org/stable/c/9283e708a9b8529e7aafac9ab5c5c79a9fab8846"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50231,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:54.187,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: crypto: arm64/poly1305 - fix a read out-of-bound A kasan error was reported during fuzzing: BUG: KASAN: slab-out-of-bounds in neon_poly1305_blocks.constprop.0+0x1b4/0x250 [poly1305_neon] Read of size 4 at addr ffff0010e293f010 by task syz-executor.5/1646715 CPU: 4 PID: 1646715 Comm: syz-executor.5 Kdump: loaded Not tainted 5.10.0.aarch64 #1 Hardware name: Huawei TaiShan 2280 /BC11SPCD, BIOS 1.59 01/31/2019 Call trace: dump_backtrace+0x0/0x394 show_stack+0x34/0x4c arch/arm64/kernel/stacktrace.c:196 __dump_stack lib/dump_stack.c:77 [inline] dump_stack+0x158/0x1e4 lib/dump_stack.c:118 print_address_description.constprop.0+0x68/0x204 mm/kasan/report.c:387 __kasan_report+0xe0/0x140 mm/kasan/report.c:547 kasan_report+0x44/0xe0 mm/kasan/report.c:564 check_memory_region_inline mm/kasan/generic.c:187 [inline] __asan_load4+0x94/0xd0 mm/kasan/generic.c:252 neon_poly1305_blocks.constprop.0+0x1b4/0x250 [poly1305_neon] neon_poly1305_do_update+0x6c/0x15c [poly1305_neon] neon_poly1305_update+0x9c/0x1c4 [poly1305_neon] crypto_shash_update crypto/shash.c:131 [inline] shash_finup_unaligned+0x84/0x15c crypto/shash.c:179 crypto_shash_finup+0x8c/0x140 crypto/shash.c:193 shash_digest_unaligned+0xb8/0xe4 crypto/shash.c:201 crypto_shash_digest+0xa4/0xfc crypto/shash.c:217 crypto_shash_tfm_digest+0xb4/0x150 crypto/shash.c:229 essiv_skcipher_setkey+0x164/0x200 [essiv] crypto_skcipher_setkey+0xb0/0x160 crypto/skcipher.c:612 skcipher_setkey+0x3c/0x50 crypto/algif_skcipher.c:305 alg_setkey+0x114/0x2a0 crypto/af_alg.c:220 alg_setsockopt+0x19c/0x210 crypto/af_alg.c:253 __sys_setsockopt+0x190/0x2e0 net/socket.c:2123 __do_sys_setsockopt net/socket.c:2134 [inline] __se_sys_setsockopt net/socket.c:2131 [inline] __arm64_sys_setsockopt+0x78/0x94 net/socket.c:2131 __invoke_syscall arch/arm64/kernel/syscall.c:36 [inline] invoke_syscall+0x64/0x100 arch/arm64/kernel/syscall.c:48 el0_svc_common.constprop.0+0x220/0x230 arch/arm64/kernel/syscall.c:155 do_el0_svc+0xb4/0xd4 arch/arm64/kernel/syscall.c:217 el0_svc+0x24/0x3c arch/arm64/kernel/entry-common.c:353 el0_sync_handler+0x160/0x164 arch/arm64/kernel/entry-common.c:369 el0_sync+0x160/0x180 arch/arm64/kernel/entry.S:683 This error can be reproduced by the following code compiled as ko on a system with kasan enabled: #include <linux/module.h> #include <linux/crypto.h> #include <crypto/hash.h> #include <crypto/poly1305.h> char test_data[] = ""\x00\x01\x02\x03\x04\x05\x06\x07"" ""\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"" ""\x10\x11\x12\x13\x14\x15\x16\x17"" ""\x18\x19\x1a\x1b\x1c\x1d\x1e""; int init(void) { struct crypto_shash *tfm = NULL; char *data = NULL, *out = NULL; tfm = crypto_alloc_shash(""poly1305"", 0, 0); data = kmalloc(POLY1305_KEY_SIZE - 1, GFP_KERNEL); out = kmalloc(POLY1305_DIGEST_SIZE, GFP_KERNEL); memcpy(data, test_data, POLY1305_KEY_SIZE - 1); crypto_shash_tfm_digest(tfm, data, POLY1305_KEY_SIZE - 1, out); kfree(data); kfree(out); return 0; } void deinit(void) { } module_init(init) module_exit(deinit) MODULE_LICENSE(""GPL""); The root cause of the bug sits in neon_poly1305_blocks. The logic neon_poly1305_blocks() performed is that if it was called with both s[] and r[] uninitialized, it will first try to initialize them with the data from the first ""block"" that it believed to be 32 bytes in length. First 16 bytes are used as the key and the next 16 bytes for s[]. This would lead to the aforementioned read out-of-bound. However, after calling poly1305_init_arch(), only 16 bytes were deducted from the input and s[] is initialized yet again with the following 16 bytes. The second initialization of s[] is certainly redundent which indicates that the first initialization should be for r[] only. This patch fixes the issue by calling poly1305_init_arm64() instead o ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/3c77292d52b341831cb09c24ca4112a1e4f9e91f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3d4c28475ee352c440b83484b72b1320ff76364a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ae19d422c7da84b5f13bc08b98bd737a08d3a53"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8d25a08599df7ca3093eb7ca731c7cd41cbfbb51"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d069dcffef849b8fd10030fd73007a79612803e6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50232,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-06-18T11:15:54.297,2025-06-18T13:47:40.833,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: arm64: set UXN on swapper page tables [ This issue was fixed upstream by accident in c3cee924bd85 (""arm64: head: cover entire kernel image in initial ID map"") as part of a large refactoring of the arm64 boot flow. This simple fix is therefore preferred for -stable backporting ] On a system that implements FEAT_EPAN, read/write access to the idmap is denied because UXN is not set on the swapper PTEs. As a result, idmap_kpti_install_ng_mappings panics the kernel when accessing __idmap_kpti_flag. Fix it by setting UXN on these PTEs.",,,"[{""url"":""https://git.kernel.org/stable/c/775871d4be0d75e219cca937af843a4a1b60489a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50233,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-08-09T15:15:27.723,2025-08-11T18:32:48.867,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: eir: Fix using strlen with hdev->{dev_name,short_name} Both dev_name and short_name are not guaranteed to be NULL terminated so this instead use strnlen and then attempt to determine if the resulting string needs to be truncated or not.",,,"[{""url"":""https://git.kernel.org/stable/c/dd7b8cdde098cf9f7c8de409b5b7bbb98f97be80"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2022-50237,cve@mitre.org,2025-07-28T02:15:24.540,2025-07-29T14:14:29.590,Awaiting Analysis,[],The ed25519-dalek crate before 2 for Rust allows a double public key signing function oracle attack. The Keypair implementation leads to a simple computation for extracting a private key.,"[{""source"":""cve@mitre.org"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-497""}]}]",,"[{""url"":""https://crates.io/crates/ed25519-dalek"",""source"":""cve@mitre.org""},{""url"":""https://github.com/MystenLabs/ed25519-unsafe-libs"",""source"":""cve@mitre.org""},{""url"":""https://rustsec.org/advisories/RUSTSEC-2022-0093.html"",""source"":""cve@mitre.org""}]","[{""source"":""cve@mitre.org"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:C/C:H/I:N/A:N"",""baseScore"":5.9,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""HIGH"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""CHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""NONE"",""availabilityImpact"":""NONE""},""exploitabilityScore"":1.4,""impactScore"":4.0}]",,,,,,,,
CVE-2022-50238,cve@mitre.org,2025-09-08T15:15:32.370,2025-09-08T16:25:38.810,Awaiting Analysis,"[{""sourceIdentifier"":""cve@mitre.org"",""tags"":[""disputed""]}]","The on-endpoint Microsoft vulnerable driver blocklist is not fully synchronized with the online Microsoft recommended driver block rules. Some entries present on the online list have been excluded from the on-endpoint blocklist longer than the expected periodic monthly Windows updates. It is possible to fully synchronize the driver blocklist using WDAC policies. NOTE: The vendor explains that Windows Update provides a smaller, compatibility-focused driver blocklist for general users, while the full XML list is available for advanced users and organizations to customize at the risk of usability issues.",,,"[{""url"":""https://github.com/wdormann/applywdac"",""source"":""cve@mitre.org""},{""url"":""https://learn.microsoft.com/en-us/windows/security/application-security/application-control/app-control-for-business/design/microsoft-recommended-driver-block-rules"",""source"":""cve@mitre.org""}]",,,,,,,,,
