id,sourceidentifier,published,lastmodified,vulnstatus,cvetags,descriptions,weaknesses,configurations,references,metrics_cvssmetricv31,metrics_cvssmetricv2,metrics_cvssmetricv30,cisaexploitadd,cisaactiondue,cisarequiredaction,cisavulnerabilityname,evaluatorcomment,metrics_cvssmetricv40
CVE-2023-53000,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:48.810,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netlink: prevent potential spectre v1 gadgets Most netlink attributes are parsed and validated from __nla_validate_parse() or validate_nla() u16 type = nla_type(nla); if (type == 0 || type > maxtype) { /* error or continue */ } @type is then used as an array index and can be used as a Spectre v1 gadget. array_index_nospec() can be used to prevent leaking content of kernel memory to malicious users. This should take care of vast majority of netlink uses, but an audit is needed to take care of others where validation is not yet centralized in core netlink functions.",,,"[{""url"":""https://git.kernel.org/stable/c/3e5082b1c66c7783fbcd79b5b178573230e528ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/41b74e95f297ac360ca7ed6bf200100717cb6c45"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/539ca5dcbc91134bbe2c45677811c31d8b030d2d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/992e4ff7116a77968039277b5d6aaa535c2f2184"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f0950402e8c76e7dcb08563f1b4e8000fbc62455"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53001,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:48.927,2025-07-15T16:15:24.997,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53002,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:49.050,2025-04-14T20:52:28.503,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: drm/i915: Fix a memory leak with reused mmap_offset drm_vma_node_allow() and drm_vma_node_revoke() should be called in balanced pairs. We call drm_vma_node_allow() once per-file everytime a user calls mmap_offset, but only call drm_vma_node_revoke once per-file on each mmap_offset. As the mmap_offset is reused by the client, the per-file vm_count may remain non-zero and the rbtree leaked. Call drm_vma_node_allow_once() instead to prevent that memory leak.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-401""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.7"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""C989BC04-67C6-4C21-BD03-48657AD16FFC""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc5:*:*:*:*:*:*"",""matchCriteriaId"":""D34127CC-68F5-4703-A5F6-5006F803E4AE""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/0220e4fe178c3390eb0291cdb34912d66972db8a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/0bdc4b4ba7206c452ee81c82fa66e39d0e1780fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53003,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:49.170,2025-04-01T15:39:21.640,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: EDAC/qcom: Do not pass llcc_driv_data as edac_device_ctl_info's pvt_info The memory for llcc_driv_data is allocated by the LLCC driver. But when it is passed as the private driver info to the EDAC core, it will get freed during the qcom_edac driver release. So when the qcom_edac driver gets probed again, it will try to use the freed data leading to the use-after-free bug. Hence, do not pass llcc_driv_data as pvt_info but rather reference it using the platform_data pointer in the qcom_edac driver.","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-416""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""4.20"",""versionEndExcluding"":""5.4.231"",""matchCriteriaId"":""79CA608C-BC5E-4BB5-9250-771AEC44F412""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.5"",""versionEndExcluding"":""5.10.166"",""matchCriteriaId"":""A44D9D24-661C-40D4-8735-4CEB1C7C02F2""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.11"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""91C2E92D-CC25-4FBD-8824-56A148119D7E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc5:*:*:*:*:*:*"",""matchCriteriaId"":""D34127CC-68F5-4703-A5F6-5006F803E4AE""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/66e10d5f399629ef7877304d9ba2b35d0474e7eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/6f0351d0c311951b8b3064db91e61841e85b2b96"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/76d9ebb7f0bc10fbc78b6d576751552edf743968"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/977c6ba624f24ae20cf0faee871257a39348d4a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/bff5243bd32661cf9ce66f6d9210fc8f89bda145"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":7.8,""baseSeverity"":""HIGH"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":5.9}]",,,,,,,,
CVE-2023-53004,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:49.307,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ovl: fix tmpfile leak Missed an error cleanup.",,,"[{""url"":""https://git.kernel.org/stable/c/baabaa505563362b71f2637aedd7b807d270656c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/caa0ea92503f8afa1941f6ac899e5c4e3f6ec8bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53005,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:49.420,2025-04-14T20:52:39.980,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: trace_events_hist: add check for return value of 'create_hist_field' Function 'create_hist_field' is called recursively at trace_events_hist.c:1954 and can return NULL-value that's why we have to check it to avoid null pointer dereference. Found by Linux Verification Center (linuxtesting.org) with SVACE.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-476""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""4.17"",""versionEndExcluding"":""4.19.272"",""matchCriteriaId"":""9A3B50DB-7519-417C-A0FE-0909D04EC68D""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""4.20"",""versionEndExcluding"":""5.4.231"",""matchCriteriaId"":""79CA608C-BC5E-4BB5-9250-771AEC44F412""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.5"",""versionEndExcluding"":""5.10.166"",""matchCriteriaId"":""A44D9D24-661C-40D4-8735-4CEB1C7C02F2""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.11"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""91C2E92D-CC25-4FBD-8824-56A148119D7E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc5:*:*:*:*:*:*"",""matchCriteriaId"":""D34127CC-68F5-4703-A5F6-5006F803E4AE""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/31b2414abeaa6de0490e85164badc6dcb1bb8ec9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/592ba7116fa620425725ff0972691f352ba3caf6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/886aa449235f478e262bbd5dcdee6ed6bc202949"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/8b152e9150d07a885f95e1fd401fc81af202d9a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/b4e7e81b4fdfcf457daee6b7a61769f62198d840"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/d2d1ada58e7cc100b8d7d6b082d19321ba4a700a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53006,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:49.543,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: cifs: Fix oops due to uncleared server->smbd_conn in reconnect In smbd_destroy(), clear the server->smbd_conn pointer after freeing the smbd_connection struct that it points to so that reconnection doesn't get confused.",,,"[{""url"":""https://git.kernel.org/stable/c/4b83bc6f87eedab4599b0123e572a422689444be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5109607a4ece7cd8536172bf7549eb4dce1f3576"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/91be54849d5392050f5b847b42bd5e6221551ac8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9640c0b268405f2540e8203a545e930ea88bb7d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b7ab9161cf5ddc42a288edf9d1a61f3bdffe17c7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e037baee16e0b9ace7e730888fcae9cec11daff2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53007,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:49.670,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tracing: Make sure trace_printk() can output as soon as it can be used Currently trace_printk() can be used as soon as early_trace_init() is called from start_kernel(). But if a crash happens, and ""ftrace_dump_on_oops"" is set on the kernel command line, all you get will be: [ 0.456075] <idle>-0 0dN.2. 347519us : Unknown type 6 [ 0.456075] <idle>-0 0dN.2. 353141us : Unknown type 6 [ 0.456075] <idle>-0 0dN.2. 358684us : Unknown type 6 This is because the trace_printk() event (type 6) hasn't been registered yet. That gets done via an early_initcall(), which may be early, but not early enough. Instead of registering the trace_printk() event (and other ftrace events, which are not trace events) via an early_initcall(), have them registered at the same time that trace_printk() can be used. This way, if there is a crash before early_initcall(), then the trace_printk()s will actually be useful.",,,"[{""url"":""https://git.kernel.org/stable/c/198c83963f6335ca6d690cff067679560f2a3a22"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3bb06eb6e9acf7c4a3e1b5bc87aed398ff8e2253"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/76b2390fdc80c0a8300e5da5b6b62d201b6fe9ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b0af180514edea6c83dc9a299d9f383009c99f25"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b94d7c7654356860dd7719120c7d15ba38b6162a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de3930a4883ddad2244efd6d349013294c62c75c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f97eb0ab066133483a65c93eb894748de2f6b598"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53008,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:49.797,2025-04-14T20:52:51.587,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: cifs: fix potential memory leaks in session setup Make sure to free cifs_ses::auth_key.response before allocating it as we might end up leaking memory in reconnect or mounting.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-401""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""B217F2F3-06C6-4332-8EE1-0360743FEF08""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/2fe58d977ee05da5bb89ef5dc4f5bf2dc15db46f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/893d45394dbe4b5cbf3723c19e2ccc8b93a6ac9b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53009,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:49.920,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdkfd: Add sync after creating vram bo There will be data corruption on vram allocated by svm if the initialization is not complete and application is writting on the memory. Adding sync to wait for the initialization completion is to resolve this issue.",,,"[{""url"":""https://git.kernel.org/stable/c/92af2d3b57a1afdfdcafb1c6a07ffd89cf3e98fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba029e9991d9be90a28b6a0ceb25e9a6fb348829"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53010,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:50.030,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bnxt: Do not read past the end of test names Test names were being concatenated based on a offset beyond the end of the first name, which tripped the buffer overflow detection logic: detected buffer overflow in strnlen [...] Call Trace: bnxt_ethtool_init.cold+0x18/0x18 Refactor struct hwrm_selftest_qlist_output to use an actual array, and adjust the concatenation to use snprintf() rather than a series of strncat() calls.",,,"[{""url"":""https://git.kernel.org/stable/c/cefa85480ac99c0bef5a09daadb48d65fc28e279"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3e599c090fc6977331150c5f0a69ab8ce87da21"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53011,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:50.157,2025-04-14T20:51:37.577,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: net: stmmac: enable all safety features by default In the original implementation of dwmac5 commit 8bf993a5877e (""net: stmmac: Add support for DWMAC5 and implement Safety Features"") all safety features were enabled by default. Later it seems some implementations didn't have support for all the features, so in commit 5ac712dcdfef (""net: stmmac: enable platform specific safety features"") the safety_feat_cfg structure was added to the callback and defined for some platforms to selectively enable these safety features. The problem is that only certain platforms were given that software support. If the automotive safety package bit is set in the hardware features register the safety feature callback is called for the platform, and for platforms that didn't get a safety_feat_cfg defined this results in the following NULL pointer dereference: [ 7.933303] Call trace: [ 7.935812] dwmac5_safety_feat_config+0x20/0x170 [stmmac] [ 7.941455] __stmmac_open+0x16c/0x474 [stmmac] [ 7.946117] stmmac_open+0x38/0x70 [stmmac] [ 7.950414] __dev_open+0x100/0x1dc [ 7.954006] __dev_change_flags+0x18c/0x204 [ 7.958297] dev_change_flags+0x24/0x6c [ 7.962237] do_setlink+0x2b8/0xfa4 [ 7.965827] __rtnl_newlink+0x4ec/0x840 [ 7.969766] rtnl_newlink+0x50/0x80 [ 7.973353] rtnetlink_rcv_msg+0x12c/0x374 [ 7.977557] netlink_rcv_skb+0x5c/0x130 [ 7.981500] rtnetlink_rcv+0x18/0x2c [ 7.985172] netlink_unicast+0x2e8/0x340 [ 7.989197] netlink_sendmsg+0x1a8/0x420 [ 7.993222] ____sys_sendmsg+0x218/0x280 [ 7.997249] ___sys_sendmsg+0xac/0x100 [ 8.001103] __sys_sendmsg+0x84/0xe0 [ 8.004776] __arm64_sys_sendmsg+0x24/0x30 [ 8.008983] invoke_syscall+0x48/0x114 [ 8.012840] el0_svc_common.constprop.0+0xcc/0xec [ 8.017665] do_el0_svc+0x38/0xb0 [ 8.021071] el0_svc+0x2c/0x84 [ 8.024212] el0t_64_sync_handler+0xf4/0x120 [ 8.028598] el0t_64_sync+0x190/0x194 Go back to the original behavior, if the automotive safety package is found to be supported in hardware enable all the features unless safety_feat_cfg is passed in saying this particular platform only supports a subset of the features.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-476""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.14"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""D7106030-745D-4E41-92EA-B14D4942EE1E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/120b8e527e07c65de7f2b9018dcd9d17e66f2427"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/aebf7e62708ba706ee7bf484c9023b15c214e92a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/fdfc76a116b5e9d3e98e6c96fe83b42d011d21d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53012,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:50.290,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: thermal: core: call put_device() only after device_register() fails put_device() shouldn't be called before a prior call to device_register(). __thermal_cooling_device_register() doesn't follow that properly and needs fixing. Also thermal_cooling_device_destroy_sysfs() is getting called unnecessarily on few error paths. Fix all this by placing the calls at the right place. Based on initial work done by Caleb Connolly.",,,"[{""url"":""https://git.kernel.org/stable/c/2846a7412f6246fd5171f51011bf76dfebcec0ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c54b7bc8a31ce0f7cc7f8deef05067df414f1d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a7d736cc3c6cb0d7498bbfb56515d414e35e9510"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53013,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:50.423,2025-04-14T20:51:49.353,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: ptdma: pt_core_execute_cmd() should use spinlock The interrupt handler (pt_core_irq_handler()) of the ptdma driver can be called from interrupt context. The code flow in this function can lead down to pt_core_execute_cmd() which will attempt to grab a mutex, which is not appropriate in interrupt context and ultimately leads to a kernel panic. The fix here changes this mutex to a spinlock, which has been verified to resolve the issue.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-667""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.15"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""21EEE3D1-0886-406D-BF6E-28331027E3AB""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/13ba563c2c8055ba8a637c9f70bb833b43cb4207"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/95e5fda3b5f9ed8239b145da3fa01e641cf5d53c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/ed0d8f731e0bf1bb12a7a37698ac613db20e2794"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53014,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:50.540,2025-04-15T19:40:48.390,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: dmaengine: tegra: Fix memory leak in terminate_all() Terminate vdesc when terminating an ongoing transfer. This will ensure that the vdesc is present in the desc_terminated list The descriptor will be freed later in desc_free_list(). This fixes the memory leaks which can happen when terminating an ongoing transfer.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-401""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.19"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""A98C4733-A1A4-4186-8224-8DEC21754170""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/567128076d554e41609c61b7d447089094ff72c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/a7a7ee6f5a019ad72852c001abbce50d35e992f2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53015,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:50.757,2025-04-15T19:41:18.383,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: HID: betop: check shape of output reports betopff_init() only checks the total sum of the report counts for each report field to be at least 4, but hid_betopff_play() expects 4 report fields. A device advertising an output report with one field and 4 report counts would pass the check but crash the kernel with a NULL pointer dereference in hid_betopff_play().","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-476""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""4.0"",""versionEndExcluding"":""4.14.305"",""matchCriteriaId"":""C1DBED98-CE57-4144-9FE0-CD02221FF86E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""4.15"",""versionEndExcluding"":""4.19.272"",""matchCriteriaId"":""83C4B95C-BD08-4683-A26E-2A65333F2D15""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""4.20"",""versionEndExcluding"":""5.4.231"",""matchCriteriaId"":""79CA608C-BC5E-4BB5-9250-771AEC44F412""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.5"",""versionEndExcluding"":""5.10.166"",""matchCriteriaId"":""A44D9D24-661C-40D4-8735-4CEB1C7C02F2""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.11"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""91C2E92D-CC25-4FBD-8824-56A148119D7E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/07bc32e53c7bd5c91472cc485231ef6274db9b76"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/1a2a47b85cab50a3c146731bfeaf2d860f5344ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/28fc6095da22dc88433d79578ae1c495ebe8ca43"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/3782c0d6edf658b71354a64d60aa7a296188fc90"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/7317326f685824c7c29bd80841fd18041af6bb73"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/d3065cc56221d1a5eda237e94eaf2a627b88ab79"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/dbab4dba400d6ea9a9697fbbd287adbf7db1dac4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53016,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:50.983,2025-04-15T19:41:27.160,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: Fix possible deadlock in rfcomm_sk_state_change syzbot reports a possible deadlock in rfcomm_sk_state_change [1]. While rfcomm_sock_connect acquires the sk lock and waits for the rfcomm lock, rfcomm_sock_release could have the rfcomm lock and hit a deadlock for acquiring the sk lock. Here's a simplified flow: rfcomm_sock_connect: lock_sock(sk) rfcomm_dlc_open: rfcomm_lock() rfcomm_sock_release: rfcomm_sock_shutdown: rfcomm_lock() __rfcomm_dlc_close: rfcomm_k_state_change: lock_sock(sk) This patch drops the sk lock before calling rfcomm_dlc_open to avoid the possible deadlock and holds sk's reference count to prevent use-after-free after rfcomm_dlc_open completes.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-416""},{""lang"":""en"",""value"":""CWE-667""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.15"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""21EEE3D1-0886-406D-BF6E-28331027E3AB""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/17511bd84871f4a6106cb335616e086880313f3f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/1d80d57ffcb55488f0ec0b77928d4f82d16b6a90"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/98aec50ff7f60cc6f2d6a4396b475c547e58b04d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53017,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:51.103,2025-04-15T19:41:36.207,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: hci_sync: fix memory leak in hci_update_adv_data() When hci_cmd_sync_queue() failed in hci_update_adv_data(), inst_ptr is not freed, which will cause memory leak, convert to use ERR_PTR/PTR_ERR to pass the instance to callback so no memory needs to be allocated.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-401""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.0"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""B9B6FA18-3858-4D81-93A1-B1A601BBAE6E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/1ed8b37cbaf14574c779064ef1372af62e8ba6aa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/8ac6043bd3e5b58d30f50737aedc2e58e8087ad5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53018,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:51.223,2025-04-15T19:41:43.143,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: hci_conn: Fix memory leaks When hci_cmd_sync_queue() failed in hci_le_terminate_big() or hci_le_big_terminate(), the memory pointed by variable d is not freed, which will cause memory leak. Add release process to error path.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-401""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.0"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""B9B6FA18-3858-4D81-93A1-B1A601BBAE6E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/3aa21311f36d8a2730c7ccef37235e951f23927b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/f51a825b9f730a782aa768454906b4468e67b667"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53019,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:51.330,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: mdio: validate parameter addr in mdiobus_get_phy() The caller may pass any value as addr, what may result in an out-of-bounds access to array mdio_map. One existing case is stmmac_init_phy() that may pass -1 as addr. Therefore validate addr before using it.",,,"[{""url"":""https://git.kernel.org/stable/c/1d80c259dfbadefa61b7ea334dfce5cb57f8c72f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4bc5f1f6bc94e695dfd912122af96e7115a0ddb8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7879626296e6ffd838ae0f2af1ab49ee46354973"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/867dbe784c5010a466f00a7d1467c1c5ea569c75"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8a7b9560a3a8eb8724888c426e05926752f73aa0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad67de330d83e8078372b52af18ffe8d39e26c85"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c431a3d642593bbdb99e8a9e3eed608b730db6f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53020,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:51.457,2025-04-15T19:41:50.600,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: l2tp: close all race conditions in l2tp_tunnel_register() The code in l2tp_tunnel_register() is racy in several ways: 1. It modifies the tunnel socket _after_ publishing it. 2. It calls setup_udp_tunnel_sock() on an existing socket without locking. 3. It changes sock lock class on fly, which triggers many syzbot reports. This patch amends all of them by moving socket initialization code before publishing and under sock lock. As suggested by Jakub, the l2tp lockdep class is not necessary as we can just switch to bh_lock_sock_nested().","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-362""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""3.6"",""versionEndExcluding"":""5.10.166"",""matchCriteriaId"":""F62E4A98-1B6C-4EA7-A272-DC5FBC68C570""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.11"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""91C2E92D-CC25-4FBD-8824-56A148119D7E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/0b2c59720e65885a394a017d0cf9cab118914682"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/2d77e5c0ad79004b5ef901895437e9cce6dfcc7e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/77e8ed776cdb1a24b2aab8fe7c6f1f154235e1ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/cef0845b6dcfa2f6c2c832e7f9622551456c741d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":4.7,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""HIGH"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.0,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53021,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:51.580,2025-04-01T15:40:10.120,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: net/sched: sch_taprio: fix possible use-after-free syzbot reported a nasty crash [1] in net_tx_action() which made little sense until we got a repro. This repro installs a taprio qdisc, but providing an invalid TCA_RATE attribute. qdisc_create() has to destroy the just initialized taprio qdisc, and taprio_destroy() is called. However, the hrtimer used by taprio had already fired, therefore advance_sched() called __netif_schedule(). Then net_tx_action was trying to use a destroyed qdisc. We can not undo the __netif_schedule(), so we must wait until one cpu serviced the qdisc before we can proceed. Many thanks to Alexander Potapenko for his help. [1] BUG: KMSAN: uninit-value in queued_spin_trylock include/asm-generic/qspinlock.h:94 [inline] BUG: KMSAN: uninit-value in do_raw_spin_trylock include/linux/spinlock.h:191 [inline] BUG: KMSAN: uninit-value in __raw_spin_trylock include/linux/spinlock_api_smp.h:89 [inline] BUG: KMSAN: uninit-value in _raw_spin_trylock+0x92/0xa0 kernel/locking/spinlock.c:138 queued_spin_trylock include/asm-generic/qspinlock.h:94 [inline] do_raw_spin_trylock include/linux/spinlock.h:191 [inline] __raw_spin_trylock include/linux/spinlock_api_smp.h:89 [inline] _raw_spin_trylock+0x92/0xa0 kernel/locking/spinlock.c:138 spin_trylock include/linux/spinlock.h:359 [inline] qdisc_run_begin include/net/sch_generic.h:187 [inline] qdisc_run+0xee/0x540 include/net/pkt_sched.h:125 net_tx_action+0x77c/0x9a0 net/core/dev.c:5086 __do_softirq+0x1cc/0x7fb kernel/softirq.c:571 run_ksoftirqd+0x2c/0x50 kernel/softirq.c:934 smpboot_thread_fn+0x554/0x9f0 kernel/smpboot.c:164 kthread+0x31b/0x430 kernel/kthread.c:376 ret_from_fork+0x1f/0x30 Uninit was created at: slab_post_alloc_hook mm/slab.h:732 [inline] slab_alloc_node mm/slub.c:3258 [inline] __kmalloc_node_track_caller+0x814/0x1250 mm/slub.c:4970 kmalloc_reserve net/core/skbuff.c:358 [inline] __alloc_skb+0x346/0xcf0 net/core/skbuff.c:430 alloc_skb include/linux/skbuff.h:1257 [inline] nlmsg_new include/net/netlink.h:953 [inline] netlink_ack+0x5f3/0x12b0 net/netlink/af_netlink.c:2436 netlink_rcv_skb+0x55d/0x6c0 net/netlink/af_netlink.c:2507 rtnetlink_rcv+0x30/0x40 net/core/rtnetlink.c:6108 netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline] netlink_unicast+0xf3b/0x1270 net/netlink/af_netlink.c:1345 netlink_sendmsg+0x1288/0x1440 net/netlink/af_netlink.c:1921 sock_sendmsg_nosec net/socket.c:714 [inline] sock_sendmsg net/socket.c:734 [inline] ____sys_sendmsg+0xabc/0xe90 net/socket.c:2482 ___sys_sendmsg+0x2a1/0x3f0 net/socket.c:2536 __sys_sendmsg net/socket.c:2565 [inline] __do_sys_sendmsg net/socket.c:2574 [inline] __se_sys_sendmsg net/socket.c:2572 [inline] __x64_sys_sendmsg+0x367/0x540 net/socket.c:2572 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd CPU: 0 PID: 13 Comm: ksoftirqd/0 Not tainted 6.0.0-rc2-syzkaller-47461-gac3859c02d7f #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 07/22/2022","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-416""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""4.20"",""versionEndExcluding"":""5.4.231"",""matchCriteriaId"":""79CA608C-BC5E-4BB5-9250-771AEC44F412""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.5"",""versionEndExcluding"":""5.10.166"",""matchCriteriaId"":""A44D9D24-661C-40D4-8735-4CEB1C7C02F2""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.11"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""91C2E92D-CC25-4FBD-8824-56A148119D7E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/1200388a0b1c3c6fda48d4d2143db8f7e4ef5348"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/3a415d59c1dbec9d772dbfab2d2520d98360caae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/c53acbf2facfdfabdc6e6984a1a38f5d38b606a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/c60fe70078d6e515f424cb868d07e00411b27fbc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/d3b2d2820a005e43855fa71b80c4a4b194201c60"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":7.8,""baseSeverity"":""HIGH"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":5.9}]",,,,,,,,
CVE-2023-53022,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:51.710,2025-04-15T19:41:54.910,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: net: enetc: avoid deadlock in enetc_tx_onestep_tstamp() This lockdep splat says it better than I could: ================================ WARNING: inconsistent lock state 6.2.0-rc2-07010-ga9b9500ffaac-dirty #967 Not tainted -------------------------------- inconsistent {IN-SOFTIRQ-W} -> {SOFTIRQ-ON-W} usage. kworker/1:3/179 [HC0[0]:SC0[0]:HE1:SE1] takes: ffff3ec4036ce098 (_xmit_ETHER#2){+.?.}-{3:3}, at: netif_freeze_queues+0x5c/0xc0 {IN-SOFTIRQ-W} state was registered at: _raw_spin_lock+0x5c/0xc0 sch_direct_xmit+0x148/0x37c __dev_queue_xmit+0x528/0x111c ip6_finish_output2+0x5ec/0xb7c ip6_finish_output+0x240/0x3f0 ip6_output+0x78/0x360 ndisc_send_skb+0x33c/0x85c ndisc_send_rs+0x54/0x12c addrconf_rs_timer+0x154/0x260 call_timer_fn+0xb8/0x3a0 __run_timers.part.0+0x214/0x26c run_timer_softirq+0x3c/0x74 __do_softirq+0x14c/0x5d8 ____do_softirq+0x10/0x20 call_on_irq_stack+0x2c/0x5c do_softirq_own_stack+0x1c/0x30 __irq_exit_rcu+0x168/0x1a0 irq_exit_rcu+0x10/0x40 el1_interrupt+0x38/0x64 irq event stamp: 7825 hardirqs last enabled at (7825): [<ffffdf1f7200cae4>] exit_to_kernel_mode+0x34/0x130 hardirqs last disabled at (7823): [<ffffdf1f708105f0>] __do_softirq+0x550/0x5d8 softirqs last enabled at (7824): [<ffffdf1f7081050c>] __do_softirq+0x46c/0x5d8 softirqs last disabled at (7811): [<ffffdf1f708166e0>] ____do_softirq+0x10/0x20 other info that might help us debug this: Possible unsafe locking scenario: CPU0 ---- lock(_xmit_ETHER#2); <Interrupt> lock(_xmit_ETHER#2); *** DEADLOCK *** 3 locks held by kworker/1:3/179: #0: ffff3ec400004748 ((wq_completion)events){+.+.}-{0:0}, at: process_one_work+0x1f4/0x6c0 #1: ffff80000a0bbdc8 ((work_completion)(&priv->tx_onestep_tstamp)){+.+.}-{0:0}, at: process_one_work+0x1f4/0x6c0 #2: ffff3ec4036cd438 (&dev->tx_global_lock){+.+.}-{3:3}, at: netif_tx_lock+0x1c/0x34 Workqueue: events enetc_tx_onestep_tstamp Call trace: print_usage_bug.part.0+0x208/0x22c mark_lock+0x7f0/0x8b0 __lock_acquire+0x7c4/0x1ce0 lock_acquire.part.0+0xe0/0x220 lock_acquire+0x68/0x84 _raw_spin_lock+0x5c/0xc0 netif_freeze_queues+0x5c/0xc0 netif_tx_lock+0x24/0x34 enetc_tx_onestep_tstamp+0x20/0x100 process_one_work+0x28c/0x6c0 worker_thread+0x74/0x450 kthread+0x118/0x11c but I'll say it anyway: the enetc_tx_onestep_tstamp() work item runs in process context, therefore with softirqs enabled (i.o.w., it can be interrupted by a softirq). If we hold the netif_tx_lock() when there is an interrupt, and the NET_TX softirq then gets scheduled, this will take the netif_tx_lock() a second time and deadlock the kernel. To solve this, use netif_tx_lock_bh(), which blocks softirqs from running.","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-667""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.13"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""450804D3-1879-4858-A68D-9C0BCBF13142""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/3c463721a73bdb57a913e0d3124677a3758886fc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/8232e5a84d25a84a5cbda0f241a00793fb6eb608"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/e893dced1a18e77b1262f5c10169413f0ece0da7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53023,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:51.847,2025-04-01T15:39:10.740,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: net: nfc: Fix use-after-free in local_cleanup() Fix a use-after-free that occurs in kfree_skb() called from local_cleanup(). This could happen when killing nfc daemon (e.g. neard) after detaching an nfc device. When detaching an nfc device, local_cleanup() called from nfc_llcp_unregister_device() frees local->rx_pending and decreases local->ref by kref_put() in nfc_llcp_local_put(). In the terminating process, nfc daemon releases all sockets and it leads to decreasing local->ref. After the last release of local->ref, local_cleanup() called from local_release() frees local->rx_pending again, which leads to the bug. Setting local->rx_pending to NULL in local_cleanup() could prevent use-after-free when local_cleanup() is called twice. Found by a modified version of syzkaller. BUG: KASAN: use-after-free in kfree_skb() Call Trace: dump_stack_lvl (lib/dump_stack.c:106) print_address_description.constprop.0.cold (mm/kasan/report.c:306) kasan_check_range (mm/kasan/generic.c:189) kfree_skb (net/core/skbuff.c:955) local_cleanup (net/nfc/llcp_core.c:159) nfc_llcp_local_put.part.0 (net/nfc/llcp_core.c:172) nfc_llcp_local_put (net/nfc/llcp_core.c:181) llcp_sock_destruct (net/nfc/llcp_sock.c:959) __sk_destruct (net/core/sock.c:2133) sk_destruct (net/core/sock.c:2181) __sk_free (net/core/sock.c:2192) sk_free (net/core/sock.c:2203) llcp_sock_release (net/nfc/llcp_sock.c:646) __sock_release (net/socket.c:650) sock_close (net/socket.c:1365) __fput (fs/file_table.c:306) task_work_run (kernel/task_work.c:179) ptrace_notify (kernel/signal.c:2354) syscall_exit_to_user_mode_prepare (kernel/entry/common.c:278) syscall_exit_to_user_mode (kernel/entry/common.c:296) do_syscall_64 (arch/x86/entry/common.c:86) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:106) Allocated by task 4719: kasan_save_stack (mm/kasan/common.c:45) __kasan_slab_alloc (mm/kasan/common.c:325) slab_post_alloc_hook (mm/slab.h:766) kmem_cache_alloc_node (mm/slub.c:3497) __alloc_skb (net/core/skbuff.c:552) pn533_recv_response (drivers/nfc/pn533/usb.c:65) __usb_hcd_giveback_urb (drivers/usb/core/hcd.c:1671) usb_giveback_urb_bh (drivers/usb/core/hcd.c:1704) tasklet_action_common.isra.0 (kernel/softirq.c:797) __do_softirq (kernel/softirq.c:571) Freed by task 1901: kasan_save_stack (mm/kasan/common.c:45) kasan_set_track (mm/kasan/common.c:52) kasan_save_free_info (mm/kasan/genericdd.c:518) __kasan_slab_free (mm/kasan/common.c:236) kmem_cache_free (mm/slub.c:3809) kfree_skbmem (net/core/skbuff.c:874) kfree_skb (net/core/skbuff.c:931) local_cleanup (net/nfc/llcp_core.c:159) nfc_llcp_unregister_device (net/nfc/llcp_core.c:1617) nfc_unregister_device (net/nfc/core.c:1179) pn53x_unregister_nfc (drivers/nfc/pn533/pn533.c:2846) pn533_usb_disconnect (drivers/nfc/pn533/usb.c:579) usb_unbind_interface (drivers/usb/core/driver.c:458) device_release_driver_internal (drivers/base/dd.c:1279) bus_remove_device (drivers/base/bus.c:529) device_del (drivers/base/core.c:3665) usb_disable_device (drivers/usb/core/message.c:1420) usb_disconnect (drivers/usb/core.c:2261) hub_event (drivers/usb/core/hub.c:5833) process_one_work (arch/x86/include/asm/jump_label.h:27 include/linux/jump_label.h:212 include/trace/events/workqueue.h:108 kernel/workqueue.c:2281) worker_thread (include/linux/list.h:282 kernel/workqueue.c:2423) kthread (kernel/kthread.c:319) ret_from_fork (arch/x86/entry/entry_64.S:301)","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""description"":[{""lang"":""en"",""value"":""CWE-416""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""3.9"",""versionEndExcluding"":""4.14.305"",""matchCriteriaId"":""10C5A938-FF24-4A9E-9F50-02013C0919F8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""4.15"",""versionEndExcluding"":""4.19.272"",""matchCriteriaId"":""83C4B95C-BD08-4683-A26E-2A65333F2D15""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""4.20"",""versionEndExcluding"":""5.4.231"",""matchCriteriaId"":""79CA608C-BC5E-4BB5-9250-771AEC44F412""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.5"",""versionEndExcluding"":""5.10.166"",""matchCriteriaId"":""A44D9D24-661C-40D4-8735-4CEB1C7C02F2""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.11"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""91C2E92D-CC25-4FBD-8824-56A148119D7E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/4bb4db7f3187c6e3de6b229ffc87cdb30a2d22b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/54f7be61584b8ec4c6df405f479495b9397bae4a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/7f129927feaf7c10b1c38bbce630172e9a08c834"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/a59cdbda3714e11aa3ab579132864c4c8c6d54f9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/ad1baab3a5c03692d22ce446f38596a126377f6a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/b09ae26f08aaf2d85f96ea7f90ddd3387f62216f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/d3605282ec3502ec8847915eb2cf1f340493ff79"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"",""baseScore"":7.8,""baseSeverity"":""HIGH"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""HIGH"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":5.9}]",,,,,,,,
CVE-2023-53024,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:51.980,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf: Fix pointer-leak due to insufficient speculative store bypass mitigation To mitigate Spectre v4, 2039f26f3aca (""bpf: Fix leakage due to insufficient speculative store bypass mitigation"") inserts lfence instructions after 1) initializing a stack slot and 2) spilling a pointer to the stack. However, this does not cover cases where a stack slot is first initialized with a pointer (subject to sanitization) but then overwritten with a scalar (not subject to sanitization because the slot was already initialized). In this case, the second write may be subject to speculative store bypass (SSB) creating a speculative pointer-as-scalar type confusion. This allows the program to subsequently leak the numerical pointer value using, for example, a branch-based cache side channel. To fix this, also sanitize scalars if they write a stack slot that previously contained a pointer. Assuming that pointer-spills are only generated by LLVM on register-pressure, the performance impact on most real-world BPF programs should be small. The following unprivileged BPF bytecode drafts a minimal exploit and the mitigation: [...] // r6 = 0 or 1 (skalar, unknown user input) // r7 = accessible ptr for side channel // r10 = frame pointer (fp), to be leaked // r9 = r10 # fp alias to encourage ssb *(u64 *)(r9 - 8) = r10 // fp[-8] = ptr, to be leaked // lfence added here because of pointer spill to stack. // // Ommitted: Dummy bpf_ringbuf_output() here to train alias predictor // for no r9-r10 dependency. // *(u64 *)(r10 - 8) = r6 // fp[-8] = scalar, overwrites ptr // 2039f26f3aca: no lfence added because stack slot was not STACK_INVALID, // store may be subject to SSB // // fix: also add an lfence when the slot contained a ptr // r8 = *(u64 *)(r9 - 8) // r8 = architecturally a scalar, speculatively a ptr // // leak ptr using branch-based cache side channel: r8 &= 1 // choose bit to leak if r8 == 0 goto SLOW // no mispredict // architecturally dead code if input r6 is 0, // only executes speculatively iff ptr bit is 1 r8 = *(u64 *)(r7 + 0) # encode bit in cache (0: slow, 1: fast) SLOW: [...] After running this, the program can time the access to *(r7 + 0) to determine whether the chosen pointer bit was 0 or 1. Repeat this 64 times to recover the whole address on amd64. In summary, sanitization can only be skipped if one scalar is overwritten with another scalar. Scalar-confusion due to speculative store bypass can not lead to invalid accesses because the pointer bounds deducted during verification are enforced using branchless logic. See 979d63d50c0c (""bpf: prevent out of bounds speculation on pointer arithmetic"") for details. Do not make the mitigation depend on !env->allow_{uninit_stack,ptr_leaks} because speculative leaks are likely unexpected if these were enabled. For example, leaking the address to a protected log file may be acceptable while disabling the mitigation might unintentionally leak the address into the cached-state of a map that is accessible to unprivileged processes.",,,"[{""url"":""https://git.kernel.org/stable/c/01bdcc73dbe7be3ad4d4ee9a59b71e42f461a528"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/81b3374944d201872cfcf82730a7860f8e7c31dd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aae109414a57ab4164218f36e2e4a17f027fcaaa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b0c89ef025562161242a7c19b213bd6b272e93df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da75dec7c6617bddad418159ffebcb133f008262"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e4f4db47794c9f474b184ee1418f42e6a07412b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53025,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:52.117,2025-06-05T15:15:24.170,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53026,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:52.250,2025-04-15T19:42:05.810,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/core: Fix ib block iterator counter overflow When registering a new DMA MR after selecting the best aligned page size for it, we iterate over the given sglist to split each entry to smaller, aligned to the selected page size, DMA blocks. In given circumstances where the sg entry and page size fit certain sizes and the sg entry is not aligned to the selected page size, the total size of the aligned pages we need to cover the sg entry is >= 4GB. Under this circumstances, while iterating page aligned blocks, the counter responsible for counting how much we advanced from the start of the sg entry is overflowed because its type is u32 and we pass 4GB in size. This can lead to an infinite loop inside the iterator function because the overflow prevents the counter to be larger than the size of the sg entry. Fix the presented problem by changing the advancement condition to eliminate overflow. Backtrace: [ 192.374329] efa_reg_user_mr_dmabuf [ 192.376783] efa_register_mr [ 192.382579] pgsz_bitmap 0xfffff000 rounddown 0x80000000 [ 192.386423] pg_sz [0x80000000] umem_length[0xc0000000] [ 192.392657] start 0x0 length 0xc0000000 params.page_shift 31 params.page_num 3 [ 192.399559] hp_cnt[3], pages_in_hp[524288] [ 192.403690] umem->sgt_append.sgt.nents[1] [ 192.407905] number entries: [1], pg_bit: [31] [ 192.411397] biter->__sg_nents [1] biter->__sg [0000000008b0c5d8] [ 192.415601] biter->__sg_advance [665837568] sg_dma_len[3221225472] [ 192.419823] biter->__sg_nents [1] biter->__sg [0000000008b0c5d8] [ 192.423976] biter->__sg_advance [2813321216] sg_dma_len[3221225472] [ 192.428243] biter->__sg_nents [1] biter->__sg [0000000008b0c5d8] [ 192.432397] biter->__sg_advance [665837568] sg_dma_len[3221225472]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-835""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.2"",""versionEndExcluding"":""5.4.231"",""matchCriteriaId"":""CE5CA7CE-9223-4A0E-9EC7-CD255B30BD3B""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.5"",""versionEndExcluding"":""5.10.166"",""matchCriteriaId"":""A44D9D24-661C-40D4-8735-4CEB1C7C02F2""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.11"",""versionEndExcluding"":""5.15.91"",""matchCriteriaId"":""91C2E92D-CC25-4FBD-8824-56A148119D7E""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.16"",""versionEndExcluding"":""6.1.9"",""matchCriteriaId"":""ED5B6045-B1D2-4E03-B194-9005A351BCAE""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc1:*:*:*:*:*:*"",""matchCriteriaId"":""FF501633-2F44-4913-A8EE-B021929F49F6""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc2:*:*:*:*:*:*"",""matchCriteriaId"":""2BDA597B-CAC1-4DF0-86F0-42E142C654E9""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc3:*:*:*:*:*:*"",""matchCriteriaId"":""725C78C9-12CE-406F-ABE8-0813A01D66E8""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:6.2:rc4:*:*:*:*:*:*"",""matchCriteriaId"":""A127C155-689C-4F67-B146-44A57F4BFD85""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/0afec5e9cea732cb47014655685a2a47fb180c31"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/362c9489720b31b6aa7491423ba65a4e98aa9838"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/43811d07ea64366af8ec9e168c558ec51440c39e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/902063a9fea5f8252df392ade746bc9cfd07a5ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/d66c1d4178c219b6e7d7a6f714e3e3656faccc36"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53027,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:52.387,2025-03-28T07:15:37.860,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53028,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:52.507,2025-04-15T19:42:15.790,Analyzed,[],"In the Linux kernel, the following vulnerability has been resolved: Revert ""wifi: mac80211: fix memory leak in ieee80211_if_add()"" This reverts commit 13e5afd3d773c6fc6ca2b89027befaaaa1ea7293. ieee80211_if_free() is already called from free_netdev(ndev) because ndev->priv_destructor == ieee80211_if_free syzbot reported: general protection fault, probably for non-canonical address 0xdffffc0000000004: 0000 [#1] PREEMPT SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000020-0x0000000000000027] CPU: 0 PID: 10041 Comm: syz-executor.0 Not tainted 6.2.0-rc2-syzkaller-00388-g55b98837e37d #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022 RIP: 0010:pcpu_get_page_chunk mm/percpu.c:262 [inline] RIP: 0010:pcpu_chunk_addr_search mm/percpu.c:1619 [inline] RIP: 0010:free_percpu mm/percpu.c:2271 [inline] RIP: 0010:free_percpu+0x186/0x10f0 mm/percpu.c:2254 Code: 80 3c 02 00 0f 85 f5 0e 00 00 48 8b 3b 48 01 ef e8 cf b3 0b 00 48 ba 00 00 00 00 00 fc ff df 48 8d 78 20 48 89 f9 48 c1 e9 03 <80> 3c 11 00 0f 85 3b 0e 00 00 48 8b 58 20 48 b8 00 00 00 00 00 fc RSP: 0018:ffffc90004ba7068 EFLAGS: 00010002 RAX: 0000000000000000 RBX: ffff88823ffe2b80 RCX: 0000000000000004 RDX: dffffc0000000000 RSI: ffffffff81c1f4e7 RDI: 0000000000000020 RBP: ffffe8fffe8fc220 R08: 0000000000000005 R09: 0000000000000000 R10: 0000000000000000 R11: 1ffffffff2179ab2 R12: ffff8880b983d000 R13: 0000000000000003 R14: 0000607f450fc220 R15: ffff88823ffe2988 FS: 00007fcb349de700(0000) GS:ffff8880b9800000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000001b32220000 CR3: 000000004914f000 CR4: 00000000003506f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> netdev_run_todo+0x6bf/0x1100 net/core/dev.c:10352 ieee80211_register_hw+0x2663/0x4040 net/mac80211/main.c:1411 mac80211_hwsim_new_radio+0x2537/0x4d80 drivers/net/wireless/mac80211_hwsim.c:4583 hwsim_new_radio_nl+0xa09/0x10f0 drivers/net/wireless/mac80211_hwsim.c:5176 genl_family_rcv_msg_doit.isra.0+0x1e6/0x2d0 net/netlink/genetlink.c:968 genl_family_rcv_msg net/netlink/genetlink.c:1048 [inline] genl_rcv_msg+0x4ff/0x7e0 net/netlink/genetlink.c:1065 netlink_rcv_skb+0x165/0x440 net/netlink/af_netlink.c:2564 genl_rcv+0x28/0x40 net/netlink/genetlink.c:1076 netlink_unicast_kernel net/netlink/af_netlink.c:1330 [inline] netlink_unicast+0x547/0x7f0 net/netlink/af_netlink.c:1356 netlink_sendmsg+0x91b/0xe10 net/netlink/af_netlink.c:1932 sock_sendmsg_nosec net/socket.c:714 [inline] sock_sendmsg+0xd3/0x120 net/socket.c:734 ____sys_sendmsg+0x712/0x8c0 net/socket.c:2476 ___sys_sendmsg+0x110/0x1b0 net/socket.c:2530 __sys_sendmsg+0xf7/0x1c0 net/socket.c:2559 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-401""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.10.163"",""versionEndExcluding"":""5.10.165"",""matchCriteriaId"":""5D344DEB-2525-4247-81EE-3559A1C4D911""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""5.15.86"",""versionEndExcluding"":""5.15.90"",""matchCriteriaId"":""8FE25AE0-3216-4628-B2DD-2E3F12C5C9F7""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.0.16"",""versionEndExcluding"":""6.1"",""matchCriteriaId"":""6C7522E3-150F-436D-BBD7-96C7B4B795ED""},{""vulnerable"":true,""criteria"":""cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"",""versionStartIncluding"":""6.1.2"",""versionEndExcluding"":""6.1.8"",""matchCriteriaId"":""91C42ED4-1CA5-4338-9DA6-715E64021DFB""}]}]}]","[{""url"":""https://git.kernel.org/stable/c/71e5cd1018d345e649e63f74a56c1897f99db7e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/80f8a66dede0a4b4e9e846765a97809c6fe49ce5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/982c8b1e95c088f5d8f65967ec25be66e961401c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]},{""url"":""https://git.kernel.org/stable/c/effecd8d116d3d3a28b4f628e61bba8d318fdfcf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67"",""tags"":[""Patch""]}]","[{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53029,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:52.627,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: octeontx2-pf: Fix the use of GFP_KERNEL in atomic context on rt The commit 4af1b64f80fb (""octeontx2-pf: Fix lmtst ID used in aura free"") uses the get/put_cpu() to protect the usage of percpu pointer in ->aura_freeptr() callback, but it also unnecessarily disable the preemption for the blockable memory allocation. The commit 87b93b678e95 (""octeontx2-pf: Avoid use of GFP_KERNEL in atomic context"") tried to fix these sleep inside atomic warnings. But it only fix the one for the non-rt kernel. For the rt kernel, we still get the similar warnings like below. BUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:46 in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 1, name: swapper/0 preempt_count: 1, expected: 0 RCU nest depth: 0, expected: 0 3 locks held by swapper/0/1: #0: ffff800009fc5fe8 (rtnl_mutex){+.+.}-{3:3}, at: rtnl_lock+0x24/0x30 #1: ffff000100c276c0 (&mbox->lock){+.+.}-{3:3}, at: otx2_init_hw_resources+0x8c/0x3a4 #2: ffffffbfef6537e0 (&cpu_rcache->lock){+.+.}-{2:2}, at: alloc_iova_fast+0x1ac/0x2ac Preemption disabled at: [<ffff800008b1908c>] otx2_rq_aura_pool_init+0x14c/0x284 CPU: 20 PID: 1 Comm: swapper/0 Tainted: G W 6.2.0-rc3-rt1-yocto-preempt-rt #1 Hardware name: Marvell OcteonTX CN96XX board (DT) Call trace: dump_backtrace.part.0+0xe8/0xf4 show_stack+0x20/0x30 dump_stack_lvl+0x9c/0xd8 dump_stack+0x18/0x34 __might_resched+0x188/0x224 rt_spin_lock+0x64/0x110 alloc_iova_fast+0x1ac/0x2ac iommu_dma_alloc_iova+0xd4/0x110 __iommu_dma_map+0x80/0x144 iommu_dma_map_page+0xe8/0x260 dma_map_page_attrs+0xb4/0xc0 __otx2_alloc_rbuf+0x90/0x150 otx2_rq_aura_pool_init+0x1c8/0x284 otx2_init_hw_resources+0xe4/0x3a4 otx2_open+0xf0/0x610 __dev_open+0x104/0x224 __dev_change_flags+0x1e4/0x274 dev_change_flags+0x2c/0x7c ic_open_devs+0x124/0x2f8 ip_auto_config+0x180/0x42c do_one_initcall+0x90/0x4dc do_basic_setup+0x10c/0x14c kernel_init_freeable+0x10c/0x13c kernel_init+0x2c/0x140 ret_from_fork+0x10/0x20 Of course, we can shuffle the get/put_cpu() to only wrap the invocation of ->aura_freeptr() as what commit 87b93b678e95 does. But there are only two ->aura_freeptr() callbacks, otx2_aura_freeptr() and cn10k_aura_freeptr(). There is no usage of perpcu variable in the otx2_aura_freeptr() at all, so the get/put_cpu() seems redundant to it. We can move the get/put_cpu() into the corresponding callback which really has the percpu variable usage and avoid the sprinkling of get/put_cpu() in several places.",,,"[{""url"":""https://git.kernel.org/stable/c/29e9c67bf3271067735c188e95cf3631ecd64d58"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/55ba18dc62deff5910c0fa64486dea1ff20832ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/659518e013d6bd562bb0f1d2d9f99d0ac54720e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53030,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:52.750,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: octeontx2-pf: Avoid use of GFP_KERNEL in atomic context Using GFP_KERNEL in preemption disable context, causing below warning when CONFIG_DEBUG_ATOMIC_SLEEP is enabled. [ 32.542271] BUG: sleeping function called from invalid context at include/linux/sched/mm.h:274 [ 32.550883] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 1, name: swapper/0 [ 32.558707] preempt_count: 1, expected: 0 [ 32.562710] RCU nest depth: 0, expected: 0 [ 32.566800] CPU: 3 PID: 1 Comm: swapper/0 Tainted: G W 6.2.0-rc2-00269-gae9dcb91c606 #7 [ 32.576188] Hardware name: Marvell CN106XX board (DT) [ 32.581232] Call trace: [ 32.583670] dump_backtrace.part.0+0xe0/0xf0 [ 32.587937] show_stack+0x18/0x30 [ 32.591245] dump_stack_lvl+0x68/0x84 [ 32.594900] dump_stack+0x18/0x34 [ 32.598206] __might_resched+0x12c/0x160 [ 32.602122] __might_sleep+0x48/0xa0 [ 32.605689] __kmem_cache_alloc_node+0x2b8/0x2e0 [ 32.610301] __kmalloc+0x58/0x190 [ 32.613610] otx2_sq_aura_pool_init+0x1a8/0x314 [ 32.618134] otx2_open+0x1d4/0x9d0 To avoid use of GFP_ATOMIC for memory allocation, disable preemption after all memory allocation is done.",,,"[{""url"":""https://git.kernel.org/stable/c/1eb57b87f106c90cee6b2a56a10f2e29c7a25f3e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2827c4eb429db64befdca11362e2b1c5f524f6ba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/87b93b678e95c7d93fe6a55b0e0fbda26d8c7760"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53031,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:52.870,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: powerpc/imc-pmu: Fix use of mutex in IRQs disabled section Current imc-pmu code triggers a WARNING with CONFIG_DEBUG_ATOMIC_SLEEP and CONFIG_PROVE_LOCKING enabled, while running a thread_imc event. Command to trigger the warning: # perf stat -e thread_imc/CPM_CS_FROM_L4_MEM_X_DPTEG/ sleep 5 Performance counter stats for 'sleep 5': 0 thread_imc/CPM_CS_FROM_L4_MEM_X_DPTEG/ 5.002117947 seconds time elapsed 0.000131000 seconds user 0.001063000 seconds sys Below is snippet of the warning in dmesg: BUG: sleeping function called from invalid context at kernel/locking/mutex.c:580 in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 2869, name: perf-exec preempt_count: 2, expected: 0 4 locks held by perf-exec/2869: #0: c00000004325c540 (&sig->cred_guard_mutex){+.+.}-{3:3}, at: bprm_execve+0x64/0xa90 #1: c00000004325c5d8 (&sig->exec_update_lock){++++}-{3:3}, at: begin_new_exec+0x460/0xef0 #2: c0000003fa99d4e0 (&cpuctx_lock){-...}-{2:2}, at: perf_event_exec+0x290/0x510 #3: c000000017ab8418 (&ctx->lock){....}-{2:2}, at: perf_event_exec+0x29c/0x510 irq event stamp: 4806 hardirqs last enabled at (4805): [<c000000000f65b94>] _raw_spin_unlock_irqrestore+0x94/0xd0 hardirqs last disabled at (4806): [<c0000000003fae44>] perf_event_exec+0x394/0x510 softirqs last enabled at (0): [<c00000000013c404>] copy_process+0xc34/0x1ff0 softirqs last disabled at (0): [<0000000000000000>] 0x0 CPU: 36 PID: 2869 Comm: perf-exec Not tainted 6.2.0-rc2-00011-g1247637727f2 #61 Hardware name: 8375-42A POWER9 0x4e1202 opal:v7.0-16-g9b85f7d961 PowerNV Call Trace: dump_stack_lvl+0x98/0xe0 (unreliable) __might_resched+0x2f8/0x310 __mutex_lock+0x6c/0x13f0 thread_imc_event_add+0xf4/0x1b0 event_sched_in+0xe0/0x210 merge_sched_in+0x1f0/0x600 visit_groups_merge.isra.92.constprop.166+0x2bc/0x6c0 ctx_flexible_sched_in+0xcc/0x140 ctx_sched_in+0x20c/0x2a0 ctx_resched+0x104/0x1c0 perf_event_exec+0x340/0x510 begin_new_exec+0x730/0xef0 load_elf_binary+0x3f8/0x1e10 ... do not call blocking ops when !TASK_RUNNING; state=2001 set at [<00000000fd63e7cf>] do_nanosleep+0x60/0x1a0 WARNING: CPU: 36 PID: 2869 at kernel/sched/core.c:9912 __might_sleep+0x9c/0xb0 CPU: 36 PID: 2869 Comm: sleep Tainted: G W 6.2.0-rc2-00011-g1247637727f2 #61 Hardware name: 8375-42A POWER9 0x4e1202 opal:v7.0-16-g9b85f7d961 PowerNV NIP: c000000000194a1c LR: c000000000194a18 CTR: c000000000a78670 REGS: c00000004d2134e0 TRAP: 0700 Tainted: G W (6.2.0-rc2-00011-g1247637727f2) MSR: 9000000000021033 <SF,HV,ME,IR,DR,RI,LE> CR: 48002824 XER: 00000000 CFAR: c00000000013fb64 IRQMASK: 1 The above warning triggered because the current imc-pmu code uses mutex lock in interrupt disabled sections. The function mutex_lock() internally calls __might_resched(), which will check if IRQs are disabled and in case IRQs are disabled, it will trigger the warning. Fix the issue by changing the mutex lock to spinlock. [mpe: Fix comments, trim oops in change log, add reported-by tags]",,,"[{""url"":""https://git.kernel.org/stable/c/424bcb570cb320d1d15238cd4c933522b90f78fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/76d588dddc459fefa1da96e0a081a397c5c8e216"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8cbeb60320ac45a8240b561c8ef466b86c34dedc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a90d339f1f66be4a946769b565668e2bd0686dfa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d0c6d2a31026102d4738b47a610bed4401b9834f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53032,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:52.997,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: ipset: Fix overflow before widen in the bitmap_ip_create() function. When first_ip is 0, last_ip is 0xFFFFFFFF, and netmask is 31, the value of an arithmetic expression 2 << (netmask - mask_bits - 1) is subject to overflow due to a failure casting operands to a larger data type before performing the arithmetic. Note that it's harmless since the value will be checked at the next step. Found by InfoTeCS on behalf of Linux Verification Center (linuxtesting.org) with SVACE.",,,"[{""url"":""https://git.kernel.org/stable/c/4e6a70fd840400e3a2e784a6673968a3eb2431c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/511cf17b2447fc41cfef8d71936e1fa53e395c1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ea4b476cea1b7d461d16dda25ca3c7e616e2d15"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dfd834ccc1b88bbbab81b9046a3a539dd0c2d14f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e137d9bb26bd85ce07323a38e38ceb0b160db841"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e88865876d47c790be0d5e23973499d75d034364"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/feefb33eefa166fc3e0fd17547b0bc0cb3baced9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53033,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-03-27T17:15:53.120,2025-03-28T18:11:40.180,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: nft_payload: incorrect arithmetics when fetching VLAN header bits If the offset + length goes over the ethernet + vlan header, then the length is adjusted to copy the bytes that are within the boundaries of the vlan_ethhdr scratchpad area. The remaining bytes beyond ethernet + vlan header are copied directly from the skbuff data area. Fix incorrect arithmetic operator: subtract, not add, the size of the vlan header in case of double-tagged packets to adjust the length accordingly to address CVE-2023-0179.",,,"[{""url"":""https://git.kernel.org/stable/c/550efeff989b041f3746118c0ddd863c39ddc1aa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/696e1a48b1a1b01edad542a1ef293665864a4dd0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/76ef74d4a379faa451003621a84e3498044e7aa3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a8acfe2c6fb99f9375a9325807a179cd8c32e6e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53034,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-04-16T15:15:52.717,2025-04-17T20:22:16.240,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ntb_hw_switchtec: Fix shift-out-of-bounds in switchtec_ntb_mw_set_trans There is a kernel API ntb_mw_clear_trans() would pass 0 to both addr and size. This would make xlate_pos negative. [ 23.734156] switchtec switchtec0: MW 0: part 0 addr 0x0000000000000000 size 0x0000000000000000 [ 23.734158] ================================================================================ [ 23.734172] UBSAN: shift-out-of-bounds in drivers/ntb/hw/mscc/ntb_hw_switchtec.c:293:7 [ 23.734418] shift exponent -1 is negative Ensuring xlate_pos is a positive or zero before BIT.",,,"[{""url"":""https://git.kernel.org/stable/c/0df2e03e4620548b41891b4e0d1bd9d2e0d8a39a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2429bdf26a0f3950fdd996861e9c1a3873af1dbe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/36d32cfb00d42e865396424bb5d340fc0a28870d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5b6857bb3bfb0dae17fab1e42c1e82c204a508b1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ed22f8d8be26225a78cf5e85b2036421a6bf2d5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c61a3f2df162ba424be0141649a9ef5f28eaccc1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cb153bdc1812a3375639ed6ca5f147eaefb65349"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de203da734fae00e75be50220ba5391e7beecdf9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f56951f211f181410a383d305e8d370993e45294"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53035,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:22.627,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nilfs2: fix kernel-infoleak in nilfs_ioctl_wrap_copy() The ioctl helper function nilfs_ioctl_wrap_copy(), which exchanges a metadata array to/from user space, may copy uninitialized buffer regions to user space memory for read-only ioctl commands NILFS_IOCTL_GET_SUINFO and NILFS_IOCTL_GET_CPINFO. This can occur when the element size of the user space metadata given by the v_size member of the argument nilfs_argv structure is larger than the size of the metadata element (nilfs_suinfo structure or nilfs_cpinfo structure) on the file system side. KMSAN-enabled kernels detect this issue as follows: BUG: KMSAN: kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:121 [inline] BUG: KMSAN: kernel-infoleak in _copy_to_user+0xc0/0x100 lib/usercopy.c:33 instrument_copy_to_user include/linux/instrumented.h:121 [inline] _copy_to_user+0xc0/0x100 lib/usercopy.c:33 copy_to_user include/linux/uaccess.h:169 [inline] nilfs_ioctl_wrap_copy+0x6fa/0xc10 fs/nilfs2/ioctl.c:99 nilfs_ioctl_get_info fs/nilfs2/ioctl.c:1173 [inline] nilfs_ioctl+0x2402/0x4450 fs/nilfs2/ioctl.c:1290 nilfs_compat_ioctl+0x1b8/0x200 fs/nilfs2/ioctl.c:1343 __do_compat_sys_ioctl fs/ioctl.c:968 [inline] __se_compat_sys_ioctl+0x7dd/0x1000 fs/ioctl.c:910 __ia32_compat_sys_ioctl+0x93/0xd0 fs/ioctl.c:910 do_syscall_32_irqs_on arch/x86/entry/common.c:112 [inline] __do_fast_syscall_32+0xa2/0x100 arch/x86/entry/common.c:178 do_fast_syscall_32+0x37/0x80 arch/x86/entry/common.c:203 do_SYSENTER_32+0x1f/0x30 arch/x86/entry/common.c:246 entry_SYSENTER_compat_after_hwframe+0x70/0x82 Uninit was created at: __alloc_pages+0x9f6/0xe90 mm/page_alloc.c:5572 alloc_pages+0xab0/0xd80 mm/mempolicy.c:2287 __get_free_pages+0x34/0xc0 mm/page_alloc.c:5599 nilfs_ioctl_wrap_copy+0x223/0xc10 fs/nilfs2/ioctl.c:74 nilfs_ioctl_get_info fs/nilfs2/ioctl.c:1173 [inline] nilfs_ioctl+0x2402/0x4450 fs/nilfs2/ioctl.c:1290 nilfs_compat_ioctl+0x1b8/0x200 fs/nilfs2/ioctl.c:1343 __do_compat_sys_ioctl fs/ioctl.c:968 [inline] __se_compat_sys_ioctl+0x7dd/0x1000 fs/ioctl.c:910 __ia32_compat_sys_ioctl+0x93/0xd0 fs/ioctl.c:910 do_syscall_32_irqs_on arch/x86/entry/common.c:112 [inline] __do_fast_syscall_32+0xa2/0x100 arch/x86/entry/common.c:178 do_fast_syscall_32+0x37/0x80 arch/x86/entry/common.c:203 do_SYSENTER_32+0x1f/0x30 arch/x86/entry/common.c:246 entry_SYSENTER_compat_after_hwframe+0x70/0x82 Bytes 16-127 of 3968 are uninitialized ... This eliminates the leak issue by initializing the page allocated as buffer using get_zeroed_page().",,,"[{""url"":""https://git.kernel.org/stable/c/003587000276f81d0114b5ce773d80c119d8cb30"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5bb105cc72beb9d51bf12f5c657336d2d35bdc5d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5f33b042f74fc9662eba17f4cd19b07d84bbc6c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8a6550b365c0ce2e65905de57dcbfe1f7d629726"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8f5cbf6a8c0e19b062b829c5b7aca01468bb57f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9c5034e9a0e03db8d5e9eabb176340259b5b97e4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a94932381e8dae4117e9129b3c1282e18aa97b05"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d18db946cc6a394291539e030df32324285648f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53036,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:22.733,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Fix call trace warning and hang when removing amdgpu device On GPUs with RAS enabled, below call trace and hang are observed when shutting down device. v2: use DRM device unplugged flag instead of shutdown flag as the check to prevent memory wipe in shutdown stage. [ +0.000000] RIP: 0010:amdgpu_vram_mgr_fini+0x18d/0x1c0 [amdgpu] [ +0.000001] PKRU: 55555554 [ +0.000001] Call Trace: [ +0.000001] <TASK> [ +0.000002] amdgpu_ttm_fini+0x140/0x1c0 [amdgpu] [ +0.000183] amdgpu_bo_fini+0x27/0xa0 [amdgpu] [ +0.000184] gmc_v11_0_sw_fini+0x2b/0x40 [amdgpu] [ +0.000163] amdgpu_device_fini_sw+0xb6/0x510 [amdgpu] [ +0.000152] amdgpu_driver_release_kms+0x16/0x30 [amdgpu] [ +0.000090] drm_dev_release+0x28/0x50 [drm] [ +0.000016] devm_drm_dev_init_release+0x38/0x60 [drm] [ +0.000011] devm_action_release+0x15/0x20 [ +0.000003] release_nodes+0x40/0xc0 [ +0.000001] devres_release_all+0x9e/0xe0 [ +0.000001] device_unbind_cleanup+0x12/0x80 [ +0.000003] device_release_driver_internal+0xff/0x160 [ +0.000001] driver_detach+0x4a/0x90 [ +0.000001] bus_remove_driver+0x6c/0xf0 [ +0.000001] driver_unregister+0x31/0x50 [ +0.000001] pci_unregister_driver+0x40/0x90 [ +0.000003] amdgpu_exit+0x15/0x120 [amdgpu]",,,"[{""url"":""https://git.kernel.org/stable/c/93bb18d2a873d2fa9625c8ea927723660a868b95"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9a02dae3bbfe2df8e1c81e61a08695709e9588f9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f06b902511ea05526f405ee64da54a8313d91831"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53037,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:22.827,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: mpi3mr: Bad drive in topology results kernel crash When the SAS Transport Layer support is enabled and a device exposed to the OS by the driver fails INQUIRY commands, the driver frees up the memory allocated for an internal HBA port data structure. However, in some places, the reference to the freed memory is not cleared. When the firmware sends the Device Info change event for the same device again, the freed memory is accessed and that leads to memory corruption and OS crash.",,,"[{""url"":""https://git.kernel.org/stable/c/1f822ae8fb2a20fffa71e9bfa9b203c03d72d3ba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e45183978d64699df639e795235433a60f35047"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa11e4b6cdb403b9fdef6939550f6b36dd61624d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53038,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:22.920,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: lpfc: Check kzalloc() in lpfc_sli4_cgn_params_read() If kzalloc() fails in lpfc_sli4_cgn_params_read(), then we rely on lpfc_read_object()'s routine to NULL check pdata. Currently, an early return error is thrown from lpfc_read_object() to protect us from NULL ptr dereference, but the errno code is -ENODEV. Change the errno code to a more appropriate -ENOMEM.",,,"[{""url"":""https://git.kernel.org/stable/c/312320b0e0ec21249a17645683fe5304d796aec1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4829a1e1171536978b240a1438789c2e4d5c9715"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/67b8343998b84418bc5b5206aa01fe9b461a80ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/908dd9a0853a88155a5a36018c7e2b32ccf20379"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53039,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.017,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: HID: intel-ish-hid: ipc: Fix potential use-after-free in work function When a reset notify IPC message is received, the ISR schedules a work function and passes the ISHTP device to it via a global pointer ishtp_dev. If ish_probe() fails, the devm-managed device resources including ishtp_dev are freed, but the work is not cancelled, causing a use-after-free when the work function tries to access ishtp_dev. Use devm_work_autocancel() instead, so that the work is automatically cancelled if probe fails.",,,"[{""url"":""https://git.kernel.org/stable/c/0a594cb490ca6232671fc09e2dc1a0fc7ccbb0b5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ae2f2b0a28416ed2f6d8478ac8b9f7862f36785"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c1d378b8c224fd50247625255f09fc01dcc5836"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3ce3afd9f791dd1b7daedfcf8c396b60af5dec0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53040,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.113,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ca8210: fix mac_len negative array access This patch fixes a buffer overflow access of skb->data if ieee802154_hdr_peek_addrs() fails.",,,"[{""url"":""https://git.kernel.org/stable/c/55d836f75778d2e2cafe37e023f9c106400bad4b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5da4469a7aa011de614c3e2ae383c35a353a382e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c993779ea1d0cccdb3a5d7d45446dd229e610a3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7df72bedbdd1d02bb216e1f6eca0a16900238c4e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/918944526a386f186dd818ea6b0bcbed75d8c16b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d143e327c97241599c958d1ba9fbaa88c37db721"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d2b3bd0d4cadfdb7f3454d2aef9d5d9e8b48aae4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd176a18db96d574d8c4763708abcec4444a08b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53041,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.220,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: qla2xxx: Perform lockless command completion in abort path While adding and removing the controller, the following call trace was observed: WARNING: CPU: 3 PID: 623596 at kernel/dma/mapping.c:532 dma_free_attrs+0x33/0x50 CPU: 3 PID: 623596 Comm: sh Kdump: loaded Not tainted 5.14.0-96.el9.x86_64 #1 RIP: 0010:dma_free_attrs+0x33/0x50 Call Trace: qla2x00_async_sns_sp_done+0x107/0x1b0 [qla2xxx] qla2x00_abort_srb+0x8e/0x250 [qla2xxx] ? ql_dbg+0x70/0x100 [qla2xxx] __qla2x00_abort_all_cmds+0x108/0x190 [qla2xxx] qla2x00_abort_all_cmds+0x24/0x70 [qla2xxx] qla2x00_abort_isp_cleanup+0x305/0x3e0 [qla2xxx] qla2x00_remove_one+0x364/0x400 [qla2xxx] pci_device_remove+0x36/0xa0 __device_release_driver+0x17a/0x230 device_release_driver+0x24/0x30 pci_stop_bus_device+0x68/0x90 pci_stop_and_remove_bus_device_locked+0x16/0x30 remove_store+0x75/0x90 kernfs_fop_write_iter+0x11c/0x1b0 new_sync_write+0x11f/0x1b0 vfs_write+0x1eb/0x280 ksys_write+0x5f/0xe0 do_syscall_64+0x5c/0x80 ? do_user_addr_fault+0x1d8/0x680 ? do_syscall_64+0x69/0x80 ? exc_page_fault+0x62/0x140 ? asm_exc_page_fault+0x8/0x30 entry_SYSCALL_64_after_hwframe+0x44/0xae The command was completed in the abort path during driver unload with a lock held, causing the warning in abort path. Hence complete the command without any lock held.",,,"[{""url"":""https://git.kernel.org/stable/c/0367076b0817d5c75dfb83001ce7ce5c64d803a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/231cfa78ec5badd84a1a2b09465bfad1a926aba1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/415d614344a4f1bbddf55d724fc7eb9ef4b39aad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9189f20b4c5307c0998682bb522e481b4567a8b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd0a1804ac5bab2545ac700c8d0fe9ae9284c567"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d6f7377528d2abf338e504126e44439541be8f7d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53042,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.320,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Do not set DRR on pipe Commit [WHY] Writing to DRR registers such as OTG_V_TOTAL_MIN on the same frame as a pipe commit can cause underflow.",,,"[{""url"":""https://git.kernel.org/stable/c/3c20a098b507020936e02a98f4fbb924deeef44b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/56574f89dbd84004c3fd6485bcaafb5aa9b8be14"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8080f1e300e7abcc03025ec8b5bab69ae98daaa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53043,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.400,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: arm64: dts: qcom: sc7280: Mark PCIe controller as cache coherent If the controller is not marked as cache coherent, then kernel will try to ensure coherency during dma-ops and that may cause data corruption. So, mark the PCIe node as dma-coherent as the devices on PCIe bus are cache coherent.",,,"[{""url"":""https://git.kernel.org/stable/c/267b899375bf38944d915c9654d6eb434edad0ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8a63441e83724fee1ef3fd37b237d40d90780766"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e43bba938e2c9104bb4f8bc417ac4d7bb29755e1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53044,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.490,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dm stats: check for and propagate alloc_percpu failure Check alloc_precpu()'s return value and return an error from dm_stats_init() if it fails. Update alloc_dev() to fail if dm_stats_init() does. Otherwise, a NULL pointer dereference will occur in dm_stats_cleanup() even if dm-stats isn't being actively used.",,,"[{""url"":""https://git.kernel.org/stable/c/0d96bd507ed7e7d565b6d53ebd3874686f123b2e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2287d7b721471a3d58bcd829250336e3cdf1635e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/443c9d522397511a4328dc2ec3c9c63c73049756"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4a32a9a818a895671bd43e0c40351e60e4e9140b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5b66e36a3efd24041b7374432bfa4dec2ff01e95"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a42180dd361584816bfe15c137b665699b994d90"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c68f08cc745675a17894e1b4a5b5b9700ace6da4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3aa3e060c4a80827eb801fc448debc9daa7c46b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53045,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.590,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: gadget: u_audio: don't let userspace block driver unbind In the unbind callback for f_uac1 and f_uac2, a call to snd_card_free() via g_audio_cleanup() will disconnect the card and then wait for all resources to be released, which happens when the refcount falls to zero. Since userspace can keep the refcount incremented by not closing the relevant file descriptor, the call to unbind may block indefinitely. This can cause a deadlock during reboot, as evidenced by the following blocked task observed on my machine: task:reboot state:D stack:0 pid:2827 ppid:569 flags:0x0000000c Call trace: __switch_to+0xc8/0x140 __schedule+0x2f0/0x7c0 schedule+0x60/0xd0 schedule_timeout+0x180/0x1d4 wait_for_completion+0x78/0x180 snd_card_free+0x90/0xa0 g_audio_cleanup+0x2c/0x64 afunc_unbind+0x28/0x60 ... kernel_restart+0x4c/0xac __do_sys_reboot+0xcc/0x1ec __arm64_sys_reboot+0x28/0x30 invoke_syscall+0x4c/0x110 ... The issue can also be observed by opening the card with arecord and then stopping the process through the shell before unbinding: # arecord -D hw:UAC2Gadget -f S32_LE -c 2 -r 48000 /dev/null Recording WAVE '/dev/null' : Signed 32 bit Little Endian, Rate 48000 Hz, Stereo ^Z[1]+ Stopped arecord -D hw:UAC2Gadget -f S32_LE -c 2 -r 48000 /dev/null # echo gadget.0 > /sys/bus/gadget/drivers/configfs-gadget/unbind (observe that the unbind command never finishes) Fix the problem by using snd_card_free_when_closed() instead, which will still disconnect the card as desired, but defer the task of freeing the resources to the core once userspace closes its file descriptor.",,,"[{""url"":""https://git.kernel.org/stable/c/0eda2004f38d95ef5715d62be884cd344260535b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3256e152b645fc1e788ba44c2d8ced690113e3e6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/33f341c1fc60e172a3515c51bdabee11e83d1ee9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3bc7324e4911351e39c54a62e6ca46321cb10faf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3e016ef2e72da93a2ea7afbb45de1b481b44d761"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/43ca70753dfffd517d2af126da28690f8f615605"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c67ed9ad9b83e453e808f9b31a931a20a25629b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b131989797f7287d7fdadb2bababc05a15d44750"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53046,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.697,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: Fix race condition in hci_cmd_sync_clear There is a potential race condition in hci_cmd_sync_work and hci_cmd_sync_clear, and could lead to use-after-free. For instance, hci_cmd_sync_work is added to the 'req_workqueue' after cancel_work_sync The entry of 'cmd_sync_work_list' may be freed in hci_cmd_sync_clear, and causing kernel panic when it is used in 'hci_cmd_sync_work'. Here's the call trace: dump_stack_lvl+0x49/0x63 print_report.cold+0x5e/0x5d3 ? hci_cmd_sync_work+0x282/0x320 kasan_report+0xaa/0x120 ? hci_cmd_sync_work+0x282/0x320 __asan_report_load8_noabort+0x14/0x20 hci_cmd_sync_work+0x282/0x320 process_one_work+0x77b/0x11c0 ? _raw_spin_lock_irq+0x8e/0xf0 worker_thread+0x544/0x1180 ? poll_idle+0x1e0/0x1e0 kthread+0x285/0x320 ? process_one_work+0x11c0/0x11c0 ? kthread_complete_and_exit+0x30/0x30 ret_from_fork+0x22/0x30 </TASK> Allocated by task 266: kasan_save_stack+0x26/0x50 __kasan_kmalloc+0xae/0xe0 kmem_cache_alloc_trace+0x191/0x350 hci_cmd_sync_queue+0x97/0x2b0 hci_update_passive_scan+0x176/0x1d0 le_conn_complete_evt+0x1b5/0x1a00 hci_le_conn_complete_evt+0x234/0x340 hci_le_meta_evt+0x231/0x4e0 hci_event_packet+0x4c5/0xf00 hci_rx_work+0x37d/0x880 process_one_work+0x77b/0x11c0 worker_thread+0x544/0x1180 kthread+0x285/0x320 ret_from_fork+0x22/0x30 Freed by task 269: kasan_save_stack+0x26/0x50 kasan_set_track+0x25/0x40 kasan_set_free_info+0x24/0x40 ____kasan_slab_free+0x176/0x1c0 __kasan_slab_free+0x12/0x20 slab_free_freelist_hook+0x95/0x1a0 kfree+0xba/0x2f0 hci_cmd_sync_clear+0x14c/0x210 hci_unregister_dev+0xff/0x440 vhci_release+0x7b/0xf0 __fput+0x1f3/0x970 ____fput+0xe/0x20 task_work_run+0xd4/0x160 do_exit+0x8b0/0x22a0 do_group_exit+0xba/0x2a0 get_signal+0x1e4a/0x25b0 arch_do_signal_or_restart+0x93/0x1f80 exit_to_user_mode_prepare+0xf5/0x1a0 syscall_exit_to_user_mode+0x26/0x50 ret_from_fork+0x15/0x30",,,"[{""url"":""https://git.kernel.org/stable/c/1c66bee492a5fe00ae3fe890bb693bfc99f994c6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/608901a77c945ac15dea23f6098c9882ef19d9f0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be586211a3ab40a4f4ca60450e0d31606afc55ec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53047,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.790,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tee: amdtee: fix race condition in amdtee_open_session There is a potential race condition in amdtee_open_session that may lead to use-after-free. For instance, in amdtee_open_session() after sess->sess_mask is set, and before setting: sess->session_info[i] = session_info; if amdtee_close_session() closes this same session, then 'sess' data structure will be released, causing kernel panic when 'sess' is accessed within amdtee_open_session(). The solution is to set the bit sess->sess_mask as the last step in amdtee_open_session().",,,"[{""url"":""https://git.kernel.org/stable/c/02b296978a2137d7128151c542e84dc96400bc00"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a63cce9393e4e7dbc5af82dc87e68cb321cb1a78"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3ef9e6fe09f1a132af28c623edcf4d4f39d9f35"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f632a90f8e39db39b322107b9a8d438b826a7f4f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8502fba45bd30e1a6a354d9d898bc99d1a11e6d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53048,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.897,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: typec: tcpm: fix warning when handle discover_identity message Since both source and sink device can send discover_identity message in PD3, kernel may dump below warning: ------------[ cut here ]------------ WARNING: CPU: 0 PID: 169 at drivers/usb/typec/tcpm/tcpm.c:1446 tcpm_queue_vdm+0xe0/0xf0 Modules linked in: CPU: 0 PID: 169 Comm: 1-0050 Not tainted 6.1.1-00038-g6a3c36cf1da2-dirty #567 Hardware name: NXP i.MX8MPlus EVK board (DT) pstate: 20000005 (nzCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : tcpm_queue_vdm+0xe0/0xf0 lr : tcpm_queue_vdm+0x2c/0xf0 sp : ffff80000c19bcd0 x29: ffff80000c19bcd0 x28: 0000000000000001 x27: ffff0000d11c8ab8 x26: ffff0000d11cc000 x25: 0000000000000000 x24: 00000000ff008081 x23: 0000000000000001 x22: 00000000ff00a081 x21: ffff80000c19bdbc x20: 0000000000000000 x19: ffff0000d11c8080 x18: ffffffffffffffff x17: 0000000000000000 x16: 0000000000000000 x15: ffff0000d716f580 x14: 0000000000000001 x13: ffff0000d716f507 x12: 0000000000000001 x11: 0000000000000000 x10: 0000000000000020 x9 : 00000000000ee098 x8 : 00000000ffffffff x7 : 000000000000001c x6 : ffff0000d716f580 x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000 x2 : ffff80000c19bdbc x1 : 00000000ff00a081 x0 : 0000000000000004 Call trace: tcpm_queue_vdm+0xe0/0xf0 tcpm_pd_rx_handler+0x340/0x1ab0 kthread_worker_fn+0xcc/0x18c kthread+0x10c/0x110 ret_from_fork+0x10/0x20 ---[ end trace 0000000000000000 ]--- Below sequences may trigger this warning: tcpm_send_discover_work(work) tcpm_send_vdm(port, USB_SID_PD, CMD_DISCOVER_IDENT, NULL, 0); tcpm_queue_vdm(port, header, data, count); port->vdm_state = VDM_STATE_READY; vdm_state_machine_work(work); <-- received discover_identity from partner vdm_run_state_machine(port); port->vdm_state = VDM_STATE_SEND_MESSAGE; mod_vdm_delayed_work(port, x); tcpm_pd_rx_handler(work); tcpm_pd_data_request(port, msg); tcpm_handle_vdm_request(port, msg->payload, cnt); tcpm_queue_vdm(port, response[0], &response[1], rlen - 1); --> WARN_ON(port->vdm_state > VDM_STATE_DONE); For this case, the state machine could still send out discover identity message later if we skip current discover_identity message. So we should handle the received message firstly and override the pending discover_identity message without warning in this case. Then, a delayed send_discover work will send discover_identity message again.",,,"[{""url"":""https://git.kernel.org/stable/c/abfc4fa28f0160df61c7149567da4f6494dfb488"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bb579b3f75c60bf488a7c36e092e8be583407d53"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d55ca2d2ea1a7ec553213986993fba8c0257381c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e37d2c489d71e94ed4a39529bc9520a7fd983d42"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53049,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:23.990,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: ucsi: Fix NULL pointer deref in ucsi_connector_change() When ucsi_init() fails, ucsi->connector is NULL, yet in case of ucsi_acpi we may still get events which cause the ucs_acpi code to call ucsi_connector_change(), which then derefs the NULL ucsi->connector pointer. Fix this by not setting ucsi->ntfy inside ucsi_init() until ucsi_init() has succeeded, so that ucsi_connector_change() ignores the events because UCSI_ENABLE_NTFY_CONNECTOR_CHANGE is not set in the ntfy mask.",,,"[{""url"":""https://git.kernel.org/stable/c/1c5abcb13491da8c049f20462189c12c753ba978"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7dd27aed9c456670b3882877ef17a48195f21693"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ef0423e43f877a328454059d46763043ce3da44"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6adfe9bbd6ac11e398b54ccd99a0f8eea09f3c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f87fb985452ab2083967103ac00bfd68fb182764"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53050,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:24.093,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: thunderbolt: Fix memory leak in margining Memory for the usb4->margining needs to be relased for the upstream port of the router as well, even though the debugfs directory gets released with the router device removal. Fix this.",,,"[{""url"":""https://git.kernel.org/stable/c/0b357b360e671688f9bf38ff94300515b68bc247"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/acec726473822bc6b585961f4ca2a11fa7f28341"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f390095bbd131ec2dfb29792d9f6fd0f0656bfc0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53051,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:24.180,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dm crypt: add cond_resched() to dmcrypt_write() The loop in dmcrypt_write may be running for unbounded amount of time, thus we need cond_resched() in it. This commit fixes the following warning: [ 3391.153255][ C12] watchdog: BUG: soft lockup - CPU#12 stuck for 23s! [dmcrypt_write/2:2897] ... [ 3391.387210][ C12] Call trace: [ 3391.390338][ C12] blk_attempt_bio_merge.part.6+0x38/0x158 [ 3391.395970][ C12] blk_attempt_plug_merge+0xc0/0x1b0 [ 3391.401085][ C12] blk_mq_submit_bio+0x398/0x550 [ 3391.405856][ C12] submit_bio_noacct+0x308/0x380 [ 3391.410630][ C12] dmcrypt_write+0x1e4/0x208 [dm_crypt] [ 3391.416005][ C12] kthread+0x130/0x138 [ 3391.419911][ C12] ret_from_fork+0x10/0x18",,,"[{""url"":""https://git.kernel.org/stable/c/2c743db1193bf0e76c73d71ede08bd9b96e6c31d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/66ff37993dd7e9954b6446237fe2453b380ce40d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7b9f8efb5fc888dd938d2964e705b8e00f1dc0f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/885c28ceae7dab2b18c2cc0eb95f1f82b1f629d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e87cd83f70504f1cd2e428966f353c007d6d2d7f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb485b7404a281d974bd445ddc5b0b8d5958f371"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f0eb61b493dbbc32529fbd0d2e945b71b0e47306"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fb294b1c0ba982144ca467a75e7d01ff26304e2b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53052,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:24.283,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: cifs: fix use-after-free bug in refresh_cache_worker() The UAF bug occurred because we were putting DFS root sessions in cifs_umount() while DFS cache refresher was being executed. Make DFS root sessions have same lifetime as DFS tcons so we can avoid the use-after-free bug is DFS cache refresher and other places that require IPCs to get new DFS referrals on. Also, get rid of mount group handling in DFS cache as we no longer need it. This fixes below use-after-free bug catched by KASAN [ 379.946955] BUG: KASAN: use-after-free in __refresh_tcon.isra.0+0x10b/0xc10 [cifs] [ 379.947642] Read of size 8 at addr ffff888018f57030 by task kworker/u4:3/56 [ 379.948096] [ 379.948208] CPU: 0 PID: 56 Comm: kworker/u4:3 Not tainted 6.2.0-rc7-lku #23 [ 379.948661] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.0-0-gd239552-rebuilt.opensuse.org 04/01/2014 [ 379.949368] Workqueue: cifs-dfscache refresh_cache_worker [cifs] [ 379.949942] Call Trace: [ 379.950113] <TASK> [ 379.950260] dump_stack_lvl+0x50/0x67 [ 379.950510] print_report+0x16a/0x48e [ 379.950759] ? __virt_addr_valid+0xd8/0x160 [ 379.951040] ? __phys_addr+0x41/0x80 [ 379.951285] kasan_report+0xdb/0x110 [ 379.951533] ? __refresh_tcon.isra.0+0x10b/0xc10 [cifs] [ 379.952056] ? __refresh_tcon.isra.0+0x10b/0xc10 [cifs] [ 379.952585] __refresh_tcon.isra.0+0x10b/0xc10 [cifs] [ 379.953096] ? __pfx___refresh_tcon.isra.0+0x10/0x10 [cifs] [ 379.953637] ? __pfx___mutex_lock+0x10/0x10 [ 379.953915] ? lock_release+0xb6/0x720 [ 379.954167] ? __pfx_lock_acquire+0x10/0x10 [ 379.954443] ? refresh_cache_worker+0x34e/0x6d0 [cifs] [ 379.954960] ? __pfx_wb_workfn+0x10/0x10 [ 379.955239] refresh_cache_worker+0x4ad/0x6d0 [cifs] [ 379.955755] ? __pfx_refresh_cache_worker+0x10/0x10 [cifs] [ 379.956323] ? __pfx_lock_acquired+0x10/0x10 [ 379.956615] ? read_word_at_a_time+0xe/0x20 [ 379.956898] ? lockdep_hardirqs_on_prepare+0x12/0x220 [ 379.957235] process_one_work+0x535/0x990 [ 379.957509] ? __pfx_process_one_work+0x10/0x10 [ 379.957812] ? lock_acquired+0xb7/0x5f0 [ 379.958069] ? __list_add_valid+0x37/0xd0 [ 379.958341] ? __list_add_valid+0x37/0xd0 [ 379.958611] worker_thread+0x8e/0x630 [ 379.958861] ? __pfx_worker_thread+0x10/0x10 [ 379.959148] kthread+0x17d/0x1b0 [ 379.959369] ? __pfx_kthread+0x10/0x10 [ 379.959630] ret_from_fork+0x2c/0x50 [ 379.959879] </TASK>",,,"[{""url"":""https://git.kernel.org/stable/c/396935de145589c8bfe552fa03a5e38604071829"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a89d81c1a3c152837ea204fd29572228e54ce0b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53053,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:24.373,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: erspan: do not use skb_mac_header() in ndo_start_xmit() Drivers should not assume skb_mac_header(skb) == skb->data in their ndo_start_xmit(). Use skb_network_offset() and skb_transport_offset() which better describe what is needed in erspan_fb_xmit() and ip6erspan_tunnel_xmit() syzbot reported: WARNING: CPU: 0 PID: 5083 at include/linux/skbuff.h:2873 skb_mac_header include/linux/skbuff.h:2873 [inline] WARNING: CPU: 0 PID: 5083 at include/linux/skbuff.h:2873 ip6erspan_tunnel_xmit+0x1d9c/0x2d90 net/ipv6/ip6_gre.c:962 Modules linked in: CPU: 0 PID: 5083 Comm: syz-executor406 Not tainted 6.3.0-rc2-syzkaller-00866-gd4671cb96fa3 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/02/2023 RIP: 0010:skb_mac_header include/linux/skbuff.h:2873 [inline] RIP: 0010:ip6erspan_tunnel_xmit+0x1d9c/0x2d90 net/ipv6/ip6_gre.c:962 Code: 04 02 41 01 de 84 c0 74 08 3c 03 0f 8e 1c 0a 00 00 45 89 b4 24 c8 00 00 00 c6 85 77 fe ff ff 01 e9 33 e7 ff ff e8 b4 27 a1 f8 <0f> 0b e9 b6 e7 ff ff e8 a8 27 a1 f8 49 8d bf f0 0c 00 00 48 b8 00 RSP: 0018:ffffc90003b2f830 EFLAGS: 00010293 RAX: 0000000000000000 RBX: 000000000000ffff RCX: 0000000000000000 RDX: ffff888021273a80 RSI: ffffffff88e1bd4c RDI: 0000000000000003 RBP: ffffc90003b2f9d8 R08: 0000000000000003 R09: 000000000000ffff R10: 000000000000ffff R11: 0000000000000000 R12: ffff88802b28da00 R13: 00000000000000d0 R14: ffff88807e25b6d0 R15: ffff888023408000 FS: 0000555556a61300(0000) GS:ffff8880b9800000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000055e5b11eb6e8 CR3: 0000000027c1b000 CR4: 00000000003506f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> __netdev_start_xmit include/linux/netdevice.h:4900 [inline] netdev_start_xmit include/linux/netdevice.h:4914 [inline] __dev_direct_xmit+0x504/0x730 net/core/dev.c:4300 dev_direct_xmit include/linux/netdevice.h:3088 [inline] packet_xmit+0x20a/0x390 net/packet/af_packet.c:285 packet_snd net/packet/af_packet.c:3075 [inline] packet_sendmsg+0x31a0/0x5150 net/packet/af_packet.c:3107 sock_sendmsg_nosec net/socket.c:724 [inline] sock_sendmsg+0xde/0x190 net/socket.c:747 __sys_sendto+0x23a/0x340 net/socket.c:2142 __do_sys_sendto net/socket.c:2154 [inline] __se_sys_sendto net/socket.c:2150 [inline] __x64_sys_sendto+0xe1/0x1b0 net/socket.c:2150 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7f123aaa1039 Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 b1 14 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007ffc15d12058 EFLAGS: 00000246 ORIG_RAX: 000000000000002c RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f123aaa1039 RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000003 RBP: 0000000000000000 R08: 0000000020000040 R09: 0000000000000014 R10: 0000000000000000 R11: 0000000000000246 R12: 00007f123aa648c0 R13: 431bde82d7b634db R14: 0000000000000000 R15: 0000000000000000",,,"[{""url"":""https://git.kernel.org/stable/c/5d4172732f0ee1639a361a6cc5c3114bbb397386"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e50ed774554f93d55426039b27b1e38d7fa64d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9c7d6803689c99d55bbb862260d0ba486ff23c0b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b41f37dbd9cdb60000e3b0dfad6df787591c2265"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b72f453e886af532bde1fd049a2d2421999630d3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/da149daf821a3c05cd04f7c60776c86c5ee9685c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8cec30541f5c5cc218e9a32138d45d227727f2f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53054,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:24.483,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: dwc2: fix a devres leak in hw_enable upon suspend resume Each time the platform goes to low power, PM suspend / resume routines call: __dwc2_lowlevel_hw_enable -> devm_add_action_or_reset(). This adds a new devres each time. This may also happen at runtime, as dwc2_lowlevel_hw_enable() can be called from udc_start(). This can be seen with tracing: - echo 1 > /sys/kernel/debug/tracing/events/dev/devres_log/enable - go to low power - cat /sys/kernel/debug/tracing/trace A new ""ADD"" entry is found upon each low power cycle: ... devres_log: 49000000.usb-otg ADD 82a13bba devm_action_release (8 bytes) ... devres_log: 49000000.usb-otg ADD 49889daf devm_action_release (8 bytes) ... A second issue is addressed here: - regulator_bulk_enable() is called upon each PM cycle (suspend/resume). - regulator_bulk_disable() never gets called. So the reference count for these regulators constantly increase, by one upon each low power cycle, due to missing regulator_bulk_disable() call in __dwc2_lowlevel_hw_disable(). The original fix that introduced the devm_add_action_or_reset() call, fixed an issue during probe, that happens due to other errors in dwc2_driver_probe() -> dwc2_core_reset(). Then the probe fails without disabling regulators, when dr_mode == USB_DR_MODE_PERIPHERAL. Rather fix the error path: disable all the low level hardware in the error path, by using the ""hsotg->ll_hw_enabled"" flag. Checking dr_mode has been introduced to avoid a dual call to dwc2_lowlevel_hw_disable(). ""ll_hw_enabled"" should achieve the same (and is used currently in the remove() routine).",,,"[{""url"":""https://git.kernel.org/stable/c/1f01027c51eb16145e8e07fafea3ca07ef102d06"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6485fc381b6528b6f547ee1ff10bdbcbe31a6e4c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cba76e1fb896b573f09f51aa299223276a77bc90"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f747313249b74f323ddf841a9c8db14d989f296a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ffb8ab6f87bd28d700ab5c20d9d3a7e75067630d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53055,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:24.590,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fscrypt: destroy keyring after security_sb_delete() fscrypt_destroy_keyring() must be called after all potentially-encrypted inodes were evicted; otherwise it cannot safely destroy the keyring. Since inodes that are in-use by the Landlock LSM don't get evicted until security_sb_delete(), this means that fscrypt_destroy_keyring() must be called *after* security_sb_delete(). This fixes a WARN_ON followed by a NULL dereference, only possible if Landlock was being used on encrypted files.",,,"[{""url"":""https://git.kernel.org/stable/c/497ab5d9c7852dfedab2c9de75e41b60e54b7c5d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/992a3f3e8a0c92151dfdf65fc85567c865fd558a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ccb820dc7d2236b1af0d54ae038a27b5b6d5ae5a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d77531fac6a1fd9f1db0195438ba5419d72b96c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53056,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:24.680,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: qla2xxx: Synchronize the IOCB count to be in order A system hang was observed with the following call trace: BUG: kernel NULL pointer dereference, address: 0000000000000000 PGD 0 P4D 0 Oops: 0000 [#1] PREEMPT SMP NOPTI CPU: 15 PID: 86747 Comm: nvme Kdump: loaded Not tainted 6.2.0+ #1 Hardware name: Dell Inc. PowerEdge R6515/04F3CJ, BIOS 2.7.3 03/31/2022 RIP: 0010:__wake_up_common+0x55/0x190 Code: 41 f6 01 04 0f 85 b2 00 00 00 48 8b 43 08 4c 8d 40 e8 48 8d 43 08 48 89 04 24 48 89 c6\ 49 8d 40 18 48 39 c6 0f 84 e9 00 00 00 <49> 8b 40 18 89 6c 24 14 31 ed 4c 8d 60 e8 41 8b 18 f6 c3 04 75 5d RSP: 0018:ffffb05a82afbba0 EFLAGS: 00010082 RAX: 0000000000000000 RBX: ffff8f9b83a00018 RCX: 0000000000000000 RDX: 0000000000000001 RSI: ffff8f9b83a00020 RDI: ffff8f9b83a00018 RBP: 0000000000000001 R08: ffffffffffffffe8 R09: ffffb05a82afbbf8 R10: 70735f7472617473 R11: 5f30307832616c71 R12: 0000000000000001 R13: 0000000000000003 R14: 0000000000000000 R15: 0000000000000000 FS: 00007f815cf4c740(0000) GS:ffff8f9eeed80000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000000 CR3: 000000010633a000 CR4: 0000000000350ee0 Call Trace: <TASK> __wake_up_common_lock+0x83/0xd0 qla_nvme_ls_req+0x21b/0x2b0 [qla2xxx] __nvme_fc_send_ls_req+0x1b5/0x350 [nvme_fc] nvme_fc_xmt_disconnect_assoc+0xca/0x110 [nvme_fc] nvme_fc_delete_association+0x1bf/0x220 [nvme_fc] ? nvme_remove_namespaces+0x9f/0x140 [nvme_core] nvme_do_delete_ctrl+0x5b/0xa0 [nvme_core] nvme_sysfs_delete+0x5f/0x70 [nvme_core] kernfs_fop_write_iter+0x12b/0x1c0 vfs_write+0x2a3/0x3b0 ksys_write+0x5f/0xe0 do_syscall_64+0x5c/0x90 ? syscall_exit_work+0x103/0x130 ? syscall_exit_to_user_mode+0x12/0x30 ? do_syscall_64+0x69/0x90 ? exit_to_user_mode_loop+0xd0/0x130 ? exit_to_user_mode_prepare+0xec/0x100 ? syscall_exit_to_user_mode+0x12/0x30 ? do_syscall_64+0x69/0x90 ? syscall_exit_to_user_mode+0x12/0x30 ? do_syscall_64+0x69/0x90 entry_SYSCALL_64_after_hwframe+0x72/0xdc RIP: 0033:0x7f815cd3eb97 The IOCB counts are out of order and that would block any commands from going out and subsequently hang the system. Synchronize the IOCB count to be in correct order.",,,"[{""url"":""https://git.kernel.org/stable/c/6295b3ec64a3623fa96869ffb7cf17d0b3c92035"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6d57b77d7369ed73836c82b25f785b34923eef84"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3affdeb400f3adc925bd996f3839481f5291839"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ffd7831841d3c56c655531fc8c5acafaaf20e1bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53057,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:24.773,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: HCI: Fix global-out-of-bounds To loop a variable-length array, hci_init_stage_sync(stage) considers that stage[i] is valid as long as stage[i-1].func is valid. Thus, the last element of stage[].func should be intentionally invalid as hci_init0[], le_init2[], and others did. However, amp_init1[] and amp_init2[] have no invalid element, letting hci_init_stage_sync() keep accessing amp_init1[] over its valid range. This patch fixes this by adding {} in the last of amp_init1[] and amp_init2[]. ================================================================== BUG: KASAN: global-out-of-bounds in hci_dev_open_sync ( /v6.2-bzimage/net/bluetooth/hci_sync.c:3154 /v6.2-bzimage/net/bluetooth/hci_sync.c:3343 /v6.2-bzimage/net/bluetooth/hci_sync.c:4418 /v6.2-bzimage/net/bluetooth/hci_sync.c:4609 /v6.2-bzimage/net/bluetooth/hci_sync.c:4689) Read of size 8 at addr ffffffffaed1ab70 by task kworker/u5:0/1032 CPU: 0 PID: 1032 Comm: kworker/u5:0 Not tainted 6.2.0 #3 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04 Workqueue: hci1 hci_power_on Call Trace: <TASK> dump_stack_lvl (/v6.2-bzimage/lib/dump_stack.c:107 (discriminator 1)) print_report (/v6.2-bzimage/mm/kasan/report.c:307 /v6.2-bzimage/mm/kasan/report.c:417) ? hci_dev_open_sync (/v6.2-bzimage/net/bluetooth/hci_sync.c:3154 /v6.2-bzimage/net/bluetooth/hci_sync.c:3343 /v6.2-bzimage/net/bluetooth/hci_sync.c:4418 /v6.2-bzimage/net/bluetooth/hci_sync.c:4609 /v6.2-bzimage/net/bluetooth/hci_sync.c:4689) kasan_report (/v6.2-bzimage/mm/kasan/report.c:184 /v6.2-bzimage/mm/kasan/report.c:519) ? hci_dev_open_sync (/v6.2-bzimage/net/bluetooth/hci_sync.c:3154 /v6.2-bzimage/net/bluetooth/hci_sync.c:3343 /v6.2-bzimage/net/bluetooth/hci_sync.c:4418 /v6.2-bzimage/net/bluetooth/hci_sync.c:4609 /v6.2-bzimage/net/bluetooth/hci_sync.c:4689) hci_dev_open_sync (/v6.2-bzimage/net/bluetooth/hci_sync.c:3154 /v6.2-bzimage/net/bluetooth/hci_sync.c:3343 /v6.2-bzimage/net/bluetooth/hci_sync.c:4418 /v6.2-bzimage/net/bluetooth/hci_sync.c:4609 /v6.2-bzimage/net/bluetooth/hci_sync.c:4689) ? __pfx_hci_dev_open_sync (/v6.2-bzimage/net/bluetooth/hci_sync.c:4635) ? mutex_lock (/v6.2-bzimage/./arch/x86/include/asm/atomic64_64.h:190 /v6.2-bzimage/./include/linux/atomic/atomic-long.h:443 /v6.2-bzimage/./include/linux/atomic/atomic-instrumented.h:1781 /v6.2-bzimage/kernel/locking/mutex.c:171 /v6.2-bzimage/kernel/locking/mutex.c:285) ? __pfx_mutex_lock (/v6.2-bzimage/kernel/locking/mutex.c:282) hci_power_on (/v6.2-bzimage/net/bluetooth/hci_core.c:485 /v6.2-bzimage/net/bluetooth/hci_core.c:984) ? __pfx_hci_power_on (/v6.2-bzimage/net/bluetooth/hci_core.c:969) ? read_word_at_a_time (/v6.2-bzimage/./include/asm-generic/rwonce.h:85) ? strscpy (/v6.2-bzimage/./arch/x86/include/asm/word-at-a-time.h:62 /v6.2-bzimage/lib/string.c:161) process_one_work (/v6.2-bzimage/kernel/workqueue.c:2294) worker_thread (/v6.2-bzimage/./include/linux/list.h:292 /v6.2-bzimage/kernel/workqueue.c:2437) ? __pfx_worker_thread (/v6.2-bzimage/kernel/workqueue.c:2379) kthread (/v6.2-bzimage/kernel/kthread.c:376) ? __pfx_kthread (/v6.2-bzimage/kernel/kthread.c:331) ret_from_fork (/v6.2-bzimage/arch/x86/entry/entry_64.S:314) </TASK> The buggy address belongs to the variable: amp_init1+0x30/0x60 The buggy address belongs to the physical page: page:000000003a157ec6 refcount:1 mapcount:0 mapping:0000000000000000 ia flags: 0x200000000001000(reserved|node=0|zone=2) raw: 0200000000001000 ffffea0005054688 ffffea0005054688 000000000000000 raw: 0000000000000000 0000000000000000 00000001ffffffff 000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffffffffaed1aa00: f9 f9 f9 f9 00 00 00 00 f9 f9 f9 f9 00 00 00 00 ffffffffaed1aa80: 00 00 00 00 f9 f9 f9 f9 00 00 00 00 00 00 00 00 >ffffffffaed1ab00: 00 f9 f9 f9 f9 f9 f9 f9 00 00 00 00 00 00 f9 f9 ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/8497222b22b591c6b2d106e0e3c1672ffe4e10e0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3168abd24245aa0775c5a387dcf94d36ca7e738"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bce56405201111807cc8e4f47c6de3e10b17c1ac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53058,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:24.867,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/mlx5: E-Switch, Fix an Oops in error handling code The error handling dereferences ""vport"". There is nothing we can do if it is an error pointer except returning the error code.",,,"[{""url"":""https://git.kernel.org/stable/c/1a9853a7437a22fd849347008fb3c85087906b56"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/388188fb58bef9e7f3ca4f8970f03d493b66909f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5eadc80328298ef7beaaf0cd96791667d3b485ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/640fcdbcf27fc62de9223f958ceb4e897a00e791"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c4c977935b2fc60084b3735737d17a06e7ba1bd0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53059,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:24.963,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: platform/chrome: cros_ec_chardev: fix kernel data leak from ioctl It is possible to peep kernel page's data by providing larger `insize` in struct cros_ec_command[1] when invoking EC host commands. Fix it by using zeroed memory. [1]: https://elixir.bootlin.com/linux/v6.2/source/include/linux/platform_data/cros_ec_proto.h#L74",,,"[{""url"":""https://git.kernel.org/stable/c/13493ad6a220cb3f6f3552a16b4f2753a118b633"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a0d8644784f73fa39f57f72f374eefaba2bf48a0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b20cf3f89c56b5f6a38b7f76a8128bf9f291bbd3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eab28bfafcd1245a3510df9aa9eb940589956ea6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ebea2e16504f40d2c2bac42ad5c5a3de5ce034b4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f86ff88a1548ccf5a13960c0e7625ca787ea0993"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53060,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:25.060,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: igb: revert rtnl_lock() that causes deadlock The commit 6faee3d4ee8b (""igb: Add lock to avoid data race"") adds rtnl_lock to eliminate a false data race shown below (FREE from device detaching) | (USE from netdev core) igb_remove | igb_ndo_get_vf_config igb_disable_sriov | vf >= adapter->vfs_allocated_count? kfree(adapter->vf_data) | adapter->vfs_allocated_count = 0 | | memcpy(... adapter->vf_data[vf] The above race will never happen and the extra rtnl_lock causes deadlock below [ 141.420169] <TASK> [ 141.420672] __schedule+0x2dd/0x840 [ 141.421427] schedule+0x50/0xc0 [ 141.422041] schedule_preempt_disabled+0x11/0x20 [ 141.422678] __mutex_lock.isra.13+0x431/0x6b0 [ 141.423324] unregister_netdev+0xe/0x20 [ 141.423578] igbvf_remove+0x45/0xe0 [igbvf] [ 141.423791] pci_device_remove+0x36/0xb0 [ 141.423990] device_release_driver_internal+0xc1/0x160 [ 141.424270] pci_stop_bus_device+0x6d/0x90 [ 141.424507] pci_stop_and_remove_bus_device+0xe/0x20 [ 141.424789] pci_iov_remove_virtfn+0xba/0x120 [ 141.425452] sriov_disable+0x2f/0xf0 [ 141.425679] igb_disable_sriov+0x4e/0x100 [igb] [ 141.426353] igb_remove+0xa0/0x130 [igb] [ 141.426599] pci_device_remove+0x36/0xb0 [ 141.426796] device_release_driver_internal+0xc1/0x160 [ 141.427060] driver_detach+0x44/0x90 [ 141.427253] bus_remove_driver+0x55/0xe0 [ 141.427477] pci_unregister_driver+0x2a/0xa0 [ 141.428296] __x64_sys_delete_module+0x141/0x2b0 [ 141.429126] ? mntput_no_expire+0x4a/0x240 [ 141.429363] ? syscall_trace_enter.isra.19+0x126/0x1a0 [ 141.429653] do_syscall_64+0x5b/0x80 [ 141.429847] ? exit_to_user_mode_prepare+0x14d/0x1c0 [ 141.430109] ? syscall_exit_to_user_mode+0x12/0x30 [ 141.430849] ? do_syscall_64+0x67/0x80 [ 141.431083] ? syscall_exit_to_user_mode_prepare+0x183/0x1b0 [ 141.431770] ? syscall_exit_to_user_mode+0x12/0x30 [ 141.432482] ? do_syscall_64+0x67/0x80 [ 141.432714] ? exc_page_fault+0x64/0x140 [ 141.432911] entry_SYSCALL_64_after_hwframe+0x72/0xdc Since the igb_disable_sriov() will call pci_disable_sriov() before releasing any resources, the netdev core will synchronize the cleanup to avoid any races. This patch removes the useless rtnl_(un)lock to guarantee correctness.",,,"[{""url"":""https://git.kernel.org/stable/c/0dabb72b923e17cb3b4ac99ea1adc9ef35116930"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4d2626e10709ff8474ffd1a9db3cf4647569e89c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/62a64645749926f9d75af82a96440941f22b046f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/65f69851e44d71248b952a687e44759a7abb5016"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/66e5577cabc3d463eea540332727929d0ace41c6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d845e9a485f287181ff81567c3900a8e7ad1e28"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd1e320ac0958298c2774605ad050483f33a21f2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de91528d8ba274c614a2265077d695c61e31fd43"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53061,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:25.163,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix possible refcount leak in smb2_open() Reference count of acls will leak when memory allocation fails. Fix this by adding the missing posix_acl_release().",,,"[{""url"":""https://git.kernel.org/stable/c/2624b445544ffc1472ccabfb6ec867c199d4c95c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/303f8e58cc3ace744801dcdcabfc06ffc72ed62d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a22c49a05e5e7aa2c414fbc42c49c4c01a5c9a78"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c33344b7972225b232966f95d31f6312dcc6273d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53062,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:25.257,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: usb: smsc95xx: Limit packet length to skb->len Packet length retrieved from descriptor may be larger than the actual socket buffer length. In such case the cloned skb passed up the network stack will leak kernel memory contents.",,,"[{""url"":""https://git.kernel.org/stable/c/33d1603a38e05886c538129ddfe00bd52d347e7b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/70eb25c6a6cde149affe8a587371a3a8ad295ba0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/733580e268a53db1cd01f2251419da91866378f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba6c40227108f8ee428e42eb0337b48ed3001e65"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3c145a4d24b752c9a1314d5a595014d51471418"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e041bef1adee02999cf24f9a2e15ed452bc363fe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f2111c791d885211714db85f9a06188571c57dd0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff821092cf02a70c2bccd2d19269f01e29aa52cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53063,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:25.377,2025-05-10T15:15:58.530,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53064,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:25.480,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iavf: fix hang on reboot with ice When a system with E810 with existing VFs gets rebooted the following hang may be observed. Pid 1 is hung in iavf_remove(), part of a network driver: PID: 1 TASK: ffff965400e5a340 CPU: 24 COMMAND: ""systemd-shutdow"" #0 [ffffaad04005fa50] __schedule at ffffffff8b3239cb #1 [ffffaad04005fae8] schedule at ffffffff8b323e2d #2 [ffffaad04005fb00] schedule_hrtimeout_range_clock at ffffffff8b32cebc #3 [ffffaad04005fb80] usleep_range_state at ffffffff8b32c930 #4 [ffffaad04005fbb0] iavf_remove at ffffffffc12b9b4c [iavf] #5 [ffffaad04005fbf0] pci_device_remove at ffffffff8add7513 #6 [ffffaad04005fc10] device_release_driver_internal at ffffffff8af08baa #7 [ffffaad04005fc40] pci_stop_bus_device at ffffffff8adcc5fc #8 [ffffaad04005fc60] pci_stop_and_remove_bus_device at ffffffff8adcc81e #9 [ffffaad04005fc70] pci_iov_remove_virtfn at ffffffff8adf9429 #10 [ffffaad04005fca8] sriov_disable at ffffffff8adf98e4 #11 [ffffaad04005fcc8] ice_free_vfs at ffffffffc04bb2c8 [ice] #12 [ffffaad04005fd10] ice_remove at ffffffffc04778fe [ice] #13 [ffffaad04005fd38] ice_shutdown at ffffffffc0477946 [ice] #14 [ffffaad04005fd50] pci_device_shutdown at ffffffff8add58f1 #15 [ffffaad04005fd70] device_shutdown at ffffffff8af05386 #16 [ffffaad04005fd98] kernel_restart at ffffffff8a92a870 #17 [ffffaad04005fda8] __do_sys_reboot at ffffffff8a92abd6 #18 [ffffaad04005fee0] do_syscall_64 at ffffffff8b317159 #19 [ffffaad04005ff08] __context_tracking_enter at ffffffff8b31b6fc #20 [ffffaad04005ff18] syscall_exit_to_user_mode at ffffffff8b31b50d #21 [ffffaad04005ff28] do_syscall_64 at ffffffff8b317169 #22 [ffffaad04005ff50] entry_SYSCALL_64_after_hwframe at ffffffff8b40009b RIP: 00007f1baa5c13d7 RSP: 00007fffbcc55a98 RFLAGS: 00000202 RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f1baa5c13d7 RDX: 0000000001234567 RSI: 0000000028121969 RDI: 00000000fee1dead RBP: 00007fffbcc55ca0 R8: 0000000000000000 R9: 00007fffbcc54e90 R10: 00007fffbcc55050 R11: 0000000000000202 R12: 0000000000000005 R13: 0000000000000000 R14: 00007fffbcc55af0 R15: 0000000000000000 ORIG_RAX: 00000000000000a9 CS: 0033 SS: 002b During reboot all drivers PM shutdown callbacks are invoked. In iavf_shutdown() the adapter state is changed to __IAVF_REMOVE. In ice_shutdown() the call chain above is executed, which at some point calls iavf_remove(). However iavf_remove() expects the VF to be in one of the states __IAVF_RUNNING, __IAVF_DOWN or __IAVF_INIT_FAILED. If that's not the case it sleeps forever. So if iavf_shutdown() gets invoked before iavf_remove() the system will hang indefinitely because the adapter is already in state __IAVF_REMOVE. Fix this by returning from iavf_remove() if the state is __IAVF_REMOVE, as we already went through iavf_shutdown().",,,"[{""url"":""https://git.kernel.org/stable/c/4e264be98b88a6d6f476c11087fe865696e8bef5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/502b898235f06130750c91512c86dd0e9efe28e6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7a29799fc141ba9e6cf921fc8e958e3398ad1a4f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f752ace58867de3c063512b21e0f1694fc27f043"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53065,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:25.580,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: perf/core: Fix perf_output_begin parameter is incorrectly invoked in perf_event_bpf_output syzkaller reportes a KASAN issue with stack-out-of-bounds. The call trace is as follows: dump_stack+0x9c/0xd3 print_address_description.constprop.0+0x19/0x170 __kasan_report.cold+0x6c/0x84 kasan_report+0x3a/0x50 __perf_event_header__init_id+0x34/0x290 perf_event_header__init_id+0x48/0x60 perf_output_begin+0x4a4/0x560 perf_event_bpf_output+0x161/0x1e0 perf_iterate_sb_cpu+0x29e/0x340 perf_iterate_sb+0x4c/0xc0 perf_event_bpf_event+0x194/0x2c0 __bpf_prog_put.constprop.0+0x55/0xf0 __cls_bpf_delete_prog+0xea/0x120 [cls_bpf] cls_bpf_delete_prog_work+0x1c/0x30 [cls_bpf] process_one_work+0x3c2/0x730 worker_thread+0x93/0x650 kthread+0x1b8/0x210 ret_from_fork+0x1f/0x30 commit 267fb27352b6 (""perf: Reduce stack usage of perf_output_begin()"") use on-stack struct perf_sample_data of the caller function. However, perf_event_bpf_output uses incorrect parameter to convert small-sized data (struct perf_bpf_event) into large-sized data (struct perf_sample_data), which causes memory overwriting occurs in __perf_event_header__init_id.",,,"[{""url"":""https://git.kernel.org/stable/c/3a776fddb4e5598c8bfcd4ad094fba34f9856fc9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac5f88642cb211152041f84a985309e9af4baf59"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ddcf8320003638a06eb1e46412e045d0c5701575"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb81a2ed4f52be831c9fb879752d89645a312c13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff8137727a2af4ad5f6e6c8b9f7ec5e8db9da86c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53066,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:25.673,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: qed/qed_sriov: guard against NULL derefs from qed_iov_get_vf_info We have to make sure that the info returned by the helper is valid before using it. Found by Linux Verification Center (linuxtesting.org) with the SVACE static analysis tool.",,,"[{""url"":""https://git.kernel.org/stable/c/25143b6a01d0cc5319edd3de22ffa2578b045550"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/39c3b9dd481c3afce9439b29bafe00444cb4406b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/42d72c6d1edc9dc09a5d6f6695d257fa9e9cc270"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7742c08e012eb65405e8304d100641638c5ff882"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7bd0037822fd04da13721f77a42ee5a077d4c5fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/97ea704f39b5ded96f071e98701aa543f6f89683"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b224b0cab3a66e93d414825065a2e667a1d28c32"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e42d3bde4ec03c863259878dddaef5c351cca7ad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53067,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:25.777,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: LoongArch: Only call get_timer_irq() once in constant_clockevent_init() Under CONFIG_DEBUG_ATOMIC_SLEEP=y and CONFIG_DEBUG_PREEMPT=y, we can see the following messages on LoongArch, this is because using might_sleep() in preemption disable context. [ 0.001127] smp: Bringing up secondary CPUs ... [ 0.001222] Booting CPU#1... [ 0.001244] 64-bit Loongson Processor probed (LA464 Core) [ 0.001247] CPU1 revision is: 0014c012 (Loongson-64bit) [ 0.001250] FPU1 revision is: 00000000 [ 0.001252] BUG: sleeping function called from invalid context at kernel/locking/mutex.c:283 [ 0.001255] in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 0, name: swapper/1 [ 0.001257] preempt_count: 1, expected: 0 [ 0.001258] RCU nest depth: 0, expected: 0 [ 0.001259] Preemption disabled at: [ 0.001261] [<9000000000223800>] arch_dup_task_struct+0x20/0x110 [ 0.001272] CPU: 1 PID: 0 Comm: swapper/1 Not tainted 6.2.0-rc7+ #43 [ 0.001275] Hardware name: Loongson Loongson-3A5000-7A1000-1w-A2101/Loongson-LS3A5000-7A1000-1w-A2101, BIOS vUDK2018-LoongArch-V4.0.05132-beta10 12/13/202 [ 0.001277] Stack : 0072617764726148 0000000000000000 9000000000222f1c 90000001001e0000 [ 0.001286] 90000001001e3be0 90000001001e3be8 0000000000000000 0000000000000000 [ 0.001292] 90000001001e3be8 0000000000000040 90000001001e3cb8 90000001001e3a50 [ 0.001297] 9000000001642000 90000001001e3be8 be694d10ce4139dd 9000000100174500 [ 0.001303] 0000000000000001 0000000000000001 00000000ffffe0a2 0000000000000020 [ 0.001309] 000000000000002f 9000000001354116 00000000056b0000 ffffffffffffffff [ 0.001314] 0000000000000000 0000000000000000 90000000014f6e90 9000000001642000 [ 0.001320] 900000000022b69c 0000000000000001 0000000000000000 9000000001736a90 [ 0.001325] 9000000100038000 0000000000000000 9000000000222f34 0000000000000000 [ 0.001331] 00000000000000b0 0000000000000004 0000000000000000 0000000000070000 [ 0.001337] ... [ 0.001339] Call Trace: [ 0.001342] [<9000000000222f34>] show_stack+0x5c/0x180 [ 0.001346] [<90000000010bdd80>] dump_stack_lvl+0x60/0x88 [ 0.001352] [<9000000000266418>] __might_resched+0x180/0x1cc [ 0.001356] [<90000000010c742c>] mutex_lock+0x20/0x64 [ 0.001359] [<90000000002a8ccc>] irq_find_matching_fwspec+0x48/0x124 [ 0.001364] [<90000000002259c4>] constant_clockevent_init+0x68/0x204 [ 0.001368] [<900000000022acf4>] start_secondary+0x40/0xa8 [ 0.001371] [<90000000010c0124>] smpboot_entry+0x60/0x64 Here are the complete call chains: smpboot_entry() start_secondary() constant_clockevent_init() get_timer_irq() irq_find_matching_fwnode() irq_find_matching_fwspec() mutex_lock() might_sleep() __might_sleep() __might_resched() In order to avoid the above issue, we should break the call chains, using timer_irq_installed variable as check condition to only call get_timer_irq() once in constant_clockevent_init() is a simple and proper way.",,,"[{""url"":""https://git.kernel.org/stable/c/acadbd058fa12b510fbecca11eae22bd6f654250"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b9c379e1d7e141b102f41858c9b8f6f36e7c89a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bb7a78e343468873bf00b2b181fcfd3c02d8cb56"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53068,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:25.870,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: usb: lan78xx: Limit packet length to skb->len Packet length retrieved from descriptor may be larger than the actual socket buffer length. In such case the cloned skb passed up the network stack will leak kernel memory contents. Additionally prevent integer underflow when size is less than ETH_FCS_LEN.",,,"[{""url"":""https://git.kernel.org/stable/c/44b9ed73369fc5ec85dd2ee487e986301792a82d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7f247f5a2c18b3f21206cdd51193df4f38e1b9f5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/83de34967473ed31d276381373713cc2869a42e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53069,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:25.960,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: octeontx2-vf: Add missing free for alloc_percpu Add the free_percpu for the allocated ""vf->hw.lmt_info"" in order to avoid memory leak, same as the ""pf->hw.lmt_info"" in `drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c`.",,,"[{""url"":""https://git.kernel.org/stable/c/813b590840771890c738ce6dbfd0c5938a1bafb9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/840631bcf21f58c0a3f01378a54d79e9ce86b226"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90874b76e5f82eaa3309714d72ff2cd8bb8d1b02"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f038f3917baf04835ba2b7bcf2a04ac93fbf8a9c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53070,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:26.050,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ACPI: PPTT: Fix to avoid sleep in the atomic context when PPTT is absent Commit 0c80f9e165f8 (""ACPI: PPTT: Leave the table mapped for the runtime usage"") enabled to map PPTT once on the first invocation of acpi_get_pptt() and never unmapped the same allowing it to be used at runtime with out the hassle of mapping and unmapping the table. This was needed to fetch LLC information from the PPTT in the cpuhotplug path which is executed in the atomic context as the acpi_get_table() might sleep waiting for a mutex. However it missed to handle the case when there is no PPTT on the system which results in acpi_get_pptt() being called from all the secondary CPUs attempting to fetch the LLC information in the atomic context without knowing the absence of PPTT resulting in the splat like below: | BUG: sleeping function called from invalid context at kernel/locking/semaphore.c:164 | in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 0, name: swapper/1 | preempt_count: 1, expected: 0 | RCU nest depth: 0, expected: 0 | no locks held by swapper/1/0. | irq event stamp: 0 | hardirqs last enabled at (0): 0x0 | hardirqs last disabled at (0): copy_process+0x61c/0x1b40 | softirqs last enabled at (0): copy_process+0x61c/0x1b40 | softirqs last disabled at (0): 0x0 | CPU: 1 PID: 0 Comm: swapper/1 Not tainted 6.3.0-rc1 #1 | Call trace: | dump_backtrace+0xac/0x138 | show_stack+0x30/0x48 | dump_stack_lvl+0x60/0xb0 | dump_stack+0x18/0x28 | __might_resched+0x160/0x270 | __might_sleep+0x58/0xb0 | down_timeout+0x34/0x98 | acpi_os_wait_semaphore+0x7c/0xc0 | acpi_ut_acquire_mutex+0x58/0x108 | acpi_get_table+0x40/0xe8 | acpi_get_pptt+0x48/0xa0 | acpi_get_cache_info+0x38/0x140 | init_cache_level+0xf4/0x118 | detect_cache_attributes+0x2e4/0x640 | update_siblings_masks+0x3c/0x330 | store_cpu_topology+0x88/0xf0 | secondary_start_kernel+0xd0/0x168 | __secondary_switched+0xb8/0xc0 Update acpi_get_pptt() to consider the fact that PPTT is once checked and is not available on the system and return NULL avoiding any attempts to fetch PPTT and thereby avoiding any possible sleep waiting for a mutex in the atomic context.",,,"[{""url"":""https://git.kernel.org/stable/c/1318a07706bb2f8c65f88f39a16c2b5260bcdcd4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/91d7b60a65d9f71230ea09b86d2058a884a3c2af"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0c1106d51b9abc8eae03c5522b20649b6a55f6e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53071,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:26.140,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: do not run mt76_unregister_device() on unregistered hw Trying to probe a mt7921e pci card without firmware results in a successful probe where ieee80211_register_hw hasn't been called. When removing the driver, ieee802111_unregister_hw is called unconditionally leading to a kernel NULL pointer dereference. Fix the issue running mt76_unregister_device routine just for registered hw.",,,"[{""url"":""https://git.kernel.org/stable/c/2d34f27714c97a9786a30b3bb54944d6d8ed612f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/41130c32f3a18fcc930316da17f3a5f3bc326aa1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dffe86df26aee01a5fc56a175b7a7f157961e370"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53072,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:26.237,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mptcp: use the workqueue to destroy unaccepted sockets Christoph reported a UaF at token lookup time after having refactored the passive socket initialization part: BUG: KASAN: use-after-free in __token_bucket_busy+0x253/0x260 Read of size 4 at addr ffff88810698d5b0 by task syz-executor653/3198 CPU: 1 PID: 3198 Comm: syz-executor653 Not tainted 6.2.0-rc59af4eaa31c1f6c00c8f1e448ed99a45c66340dd5 #6 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x6e/0x91 print_report+0x16a/0x46f kasan_report+0xad/0x130 __token_bucket_busy+0x253/0x260 mptcp_token_new_connect+0x13d/0x490 mptcp_connect+0x4ed/0x860 __inet_stream_connect+0x80e/0xd90 tcp_sendmsg_fastopen+0x3ce/0x710 mptcp_sendmsg+0xff1/0x1a20 inet_sendmsg+0x11d/0x140 __sys_sendto+0x405/0x490 __x64_sys_sendto+0xdc/0x1b0 do_syscall_64+0x3b/0x90 entry_SYSCALL_64_after_hwframe+0x72/0xdc We need to properly clean-up all the paired MPTCP-level resources and be sure to release the msk last, even when the unaccepted subflow is destroyed by the TCP internals via inet_child_forget(). We can re-use the existing MPTCP_WORK_CLOSE_SUBFLOW infra, explicitly checking that for the critical scenario: the closed subflow is the MPC one, the msk is not accepted and eventually going through full cleanup. With such change, __mptcp_destroy_sock() is always called on msk sockets, even on accepted ones. We don't need anymore to transiently drop one sk reference at msk clone time. Please note this commit depends on the parent one: mptcp: refactor passive socket initialization",,,"[{""url"":""https://git.kernel.org/stable/c/2827f099b3fb9a59263c997400e9182f5d423e84"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/804cf487fb0031f3c74755b78d8663333f0ba636"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b6985b9b82954caa53f862d6059d06c0526254f0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53073,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:26.330,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: perf/x86/amd/core: Always clear status for idx The variable 'status' (which contains the unhandled overflow bits) is not being properly masked in some cases, displaying the following warning: WARNING: CPU: 156 PID: 475601 at arch/x86/events/amd/core.c:972 amd_pmu_v2_handle_irq+0x216/0x270 This seems to be happening because the loop is being continued before the status bit being unset, in case x86_perf_event_set_period() returns 0. This is also causing an inconsistency because the ""handled"" counter is incremented, but the status bit is not cleaned. Move the bit cleaning together above, together when the ""handled"" counter is incremented.",,,"[{""url"":""https://git.kernel.org/stable/c/263f5ecaf7080513efc248ec739b6d9e00f4129f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d4c7b1f12e101d6d6253092588b127416ddfb6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ab33a8f7649b0324639a336e1081aaea51a4523e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53074,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:26.420,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: fix ttm_bo calltrace warning in psp_hw_fini The call trace occurs when the amdgpu is removed after the mode1 reset. During mode1 reset, from suspend to resume, there is no need to reinitialize the ta firmware buffer which caused the bo pin_count increase redundantly. [ 489.885525] Call Trace: [ 489.885525] <TASK> [ 489.885526] amdttm_bo_put+0x34/0x50 [amdttm] [ 489.885529] amdgpu_bo_free_kernel+0xe8/0x130 [amdgpu] [ 489.885620] psp_free_shared_bufs+0xb7/0x150 [amdgpu] [ 489.885720] psp_hw_fini+0xce/0x170 [amdgpu] [ 489.885815] amdgpu_device_fini_hw+0x2ff/0x413 [amdgpu] [ 489.885960] ? blocking_notifier_chain_unregister+0x56/0xb0 [ 489.885962] amdgpu_driver_unload_kms+0x51/0x60 [amdgpu] [ 489.886049] amdgpu_pci_remove+0x5a/0x140 [amdgpu] [ 489.886132] ? __pm_runtime_resume+0x60/0x90 [ 489.886134] pci_device_remove+0x3e/0xb0 [ 489.886135] __device_release_driver+0x1ab/0x2a0 [ 489.886137] driver_detach+0xf3/0x140 [ 489.886138] bus_remove_driver+0x6c/0xf0 [ 489.886140] driver_unregister+0x31/0x60 [ 489.886141] pci_unregister_driver+0x40/0x90 [ 489.886142] amdgpu_exit+0x15/0x451 [amdgpu]",,,"[{""url"":""https://git.kernel.org/stable/c/23f4a2d29ba57bf88095f817de5809d427fcbe7e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/55a7c647ebf6e376c45d8322568dd6eb71937139"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7be9a2f8c5179520a7d5570e648e0c97d09e4fae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53075,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:26.510,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ftrace: Fix invalid address access in lookup_rec() when index is 0 KASAN reported follow problem: BUG: KASAN: use-after-free in lookup_rec Read of size 8 at addr ffff000199270ff0 by task modprobe CPU: 2 Comm: modprobe Call trace: kasan_report __asan_load8 lookup_rec ftrace_location arch_check_ftrace_location check_kprobe_address_safe register_kprobe When checking pg->records[pg->index - 1].ip in lookup_rec(), it can get a pg which is newly added to ftrace_pages_start in ftrace_process_locs(). Before the first pg->index++, index is 0 and accessing pg->records[-1].ip will cause this problem. Don't check the ip when pg->index is 0.",,,"[{""url"":""https://git.kernel.org/stable/c/2a0d71fabfeb349216d33f001a6421b1768bd3a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2de28e5ce34b22b73b833a21e2c45ae3aade3964"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4f84f31f63416b0f02fc146ffdc4ab32723eb7e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7569ee04b0e3b32df79f64db3a7138573edad9bc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/83c3b2f4e7c61367c7b24551f4c6eb94bbdda283"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac58b88ccbbb8e9fb83e137cee04a856b1ea6635"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee92fa443358f4fc0017c1d0d325c27b37802504"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1bd8b7fd890d87d0dc4dedc6287ea34dd07c0b4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53076,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:26.610,2025-05-05T15:15:53.393,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53077,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:26.720,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: fix shift-out-of-bounds in CalculateVMAndRowBytes [WHY] When PTEBufferSizeInRequests is zero, UBSAN reports the following warning because dml_log2 returns an unexpected negative value: shift exponent 4294966273 is too large for 32-bit type 'int' [HOW] In the case PTEBufferSizeInRequests is zero, skip the dml_log2() and assign the result directly.",,,"[{""url"":""https://git.kernel.org/stable/c/031f196d1b1b6d5dfcb0533b431e3ab1750e6189"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7257070be70e19a9138f39009c1a26c83a8a7cfa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a16394b5d661afec9a264fecac3abd87aea439ea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bec1bea2fa974e63f6059c33edde669c7894d0bc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e12b95680821b9880cd9992c0f3555389363604f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53078,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:26.820,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: scsi_dh_alua: Fix memleak for 'qdata' in alua_activate() If alua_rtpg_queue() failed from alua_activate(), then 'qdata' is not freed, which will cause following memleak: unreferenced object 0xffff88810b2c6980 (size 32): comm ""kworker/u16:2"", pid 635322, jiffies 4355801099 (age 1216426.076s) hex dump (first 32 bytes): 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 40 39 24 c1 ff ff ff ff 00 f8 ea 0a 81 88 ff ff @9$............. backtrace: [<0000000098f3a26d>] alua_activate+0xb0/0x320 [<000000003b529641>] scsi_dh_activate+0xb2/0x140 [<000000007b296db3>] activate_path_work+0xc6/0xe0 [dm_multipath] [<000000007adc9ace>] process_one_work+0x3c5/0x730 [<00000000c457a985>] worker_thread+0x93/0x650 [<00000000cb80e628>] kthread+0x1ba/0x210 [<00000000a1e61077>] ret_from_fork+0x22/0x30 Fix the problem by freeing 'qdata' in error path.",,,"[{""url"":""https://git.kernel.org/stable/c/0d89254a4320eb7de0970c478172f764125c6355"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/123483df146492ca22b503ae6dacc2ce7c3a3974"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1c55982beb80c7d3c30278fc6cfda8496a31dbe6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5c4d71424df34fc23dc5336d09394ce68c849542"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9311e7a554dffd3823499e309a8b86a5cd1540e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a13faca032acbf2699293587085293bdfaafc8ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c09cdf6eb815ee35e55d6c50ac7f63db58bd20b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c110051d335ef7f62ad33474b0c23997fee5bfb5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53079,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:26.923,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/mlx5: Fix steering rules cleanup vport's mc, uc and multicast rules are not deleted in teardown path when EEH happens. Since the vport's promisc settings(uc, mc and all) in firmware are reset after EEH, mlx5 driver will try to delete the above rules in the initialization path. This cause kernel crash because these software rules are no longer valid. Fix by nullifying these rules right after delete to avoid accessing any dangling pointers. Call Trace: __list_del_entry_valid+0xcc/0x100 (unreliable) tree_put_node+0xf4/0x1b0 [mlx5_core] tree_remove_node+0x30/0x70 [mlx5_core] mlx5_del_flow_rules+0x14c/0x1f0 [mlx5_core] esw_apply_vport_rx_mode+0x10c/0x200 [mlx5_core] esw_update_vport_rx_mode+0xb4/0x180 [mlx5_core] esw_vport_change_handle_locked+0x1ec/0x230 [mlx5_core] esw_enable_vport+0x130/0x260 [mlx5_core] mlx5_eswitch_enable_sriov+0x2a0/0x2f0 [mlx5_core] mlx5_device_enable_sriov+0x74/0x440 [mlx5_core] mlx5_load_one+0x114c/0x1550 [mlx5_core] mlx5_pci_resume+0x68/0xf0 [mlx5_core] eeh_report_resume+0x1a4/0x230 eeh_pe_dev_traverse+0x98/0x170 eeh_handle_normal_event+0x3e4/0x640 eeh_handle_event+0x4c/0x370 eeh_event_handler+0x14c/0x210 kthread+0x168/0x1b0 ret_from_kernel_thread+0x5c/0x84",,,"[{""url"":""https://git.kernel.org/stable/c/18cead61e437f4c7898acca0a5f3df12f801d97f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4df1f2d36bdc9a368650bf14b9097c555e95f71d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/63546395a0e6ac264f78f65218086ce6014b4494"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6f5780536181d1d0d09a11a1bc92f22e143447e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/922f56e9a795d6f3dd72d3428ebdd7ee040fa855"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53080,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.020,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: xsk: Add missing overflow check in xdp_umem_reg The number of chunks can overflow u32. Make sure to return -EINVAL on overflow. Also remove a redundant u32 cast assigning umem->npgs.",,,"[{""url"":""https://git.kernel.org/stable/c/3cfc3564411acf96bf2fb791f706a1aa4f872c1d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/580634b03a55f04a3c1968bcbd97736c079c6601"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a069909acc4435eeb41d05ccc03baa447cc01b7e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bb2e3bfb2a79db0c2057c6f701b782954394c67f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c7df4813b149362248d6ef7be41a311e27bf75fe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53081,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.117,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ocfs2: fix data corruption after failed write When buffered write fails to copy data into underlying page cache page, ocfs2_write_end_nolock() just zeroes out and dirties the page. This can leave dirty page beyond EOF and if page writeback tries to write this page before write succeeds and expands i_size, page gets into inconsistent state where page dirty bit is clear but buffer dirty bits stay set resulting in page data never getting written and so data copied to the page is lost. Fix the problem by invalidating page beyond EOF after failed write.",,,"[{""url"":""https://git.kernel.org/stable/c/1629f6f522b2d058019710466a84b240683bbee3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/205759c6c18f54659b0b5976b14a52d1b3eb9f57"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/47eb055ad3588fc96d34e9e1dd87b210ce62906b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c24eb49ab44351424ac8fe8567f91ea48a06089"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90410bcf873cf05f54a32183afff0161f44f9715"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/91d7a4bd5656552d6259e2d0f8859f9e8cc5ef68"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9e53869cb43c96d6d851c491fd4e26430ab6ba6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c26f3ff4c0be590c1250f945ac2e4fc5fcdc5f45"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53082,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.220,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: vp_vdpa: fix the crash in hot unplug with vp_vdpa While unplugging the vp_vdpa device, it triggers a kernel panic The root cause is: vdpa_mgmtdev_unregister() will accesses modern devices which will cause a use after free. So need to change the sequence in vp_vdpa_remove [ 195.003359] BUG: unable to handle page fault for address: ff4e8beb80199014 [ 195.004012] #PF: supervisor read access in kernel mode [ 195.004486] #PF: error_code(0x0000) - not-present page [ 195.004960] PGD 100000067 P4D 1001b6067 PUD 1001b7067 PMD 1001b8067 PTE 0 [ 195.005578] Oops: 0000 1 PREEMPT SMP PTI [ 195.005968] CPU: 13 PID: 164 Comm: kworker/u56:10 Kdump: loaded Not tainted 5.14.0-252.el9.x86_64 #1 [ 195.006792] Hardware name: Red Hat KVM/RHEL, BIOS edk2-20221207gitfff6d81270b5-2.el9 unknown [ 195.007556] Workqueue: kacpi_hotplug acpi_hotplug_work_fn [ 195.008059] RIP: 0010:ioread8+0x31/0x80 [ 195.008418] Code: 77 28 48 81 ff 00 00 01 00 76 0b 89 fa ec 0f b6 c0 c3 cc cc cc cc 8b 15 ad 72 93 01 b8 ff 00 00 00 85 d2 75 0f c3 cc cc cc cc <8a> 07 0f b6 c0 c3 cc cc cc cc 83 ea 01 48 83 ec 08 48 89 fe 48 c7 [ 195.010104] RSP: 0018:ff4e8beb8067bab8 EFLAGS: 00010292 [ 195.010584] RAX: ffffffffc05834a0 RBX: ffffffffc05843c0 RCX: ff4e8beb8067bae0 [ 195.011233] RDX: ff1bcbd580f88000 RSI: 0000000000000246 RDI: ff4e8beb80199014 [ 195.011881] RBP: ff1bcbd587e39000 R08: ffffffff916fa2d0 R09: ff4e8beb8067ba68 [ 195.012527] R10: 000000000000001c R11: 0000000000000000 R12: ff1bcbd5a3de9120 [ 195.013179] R13: ffffffffc062d000 R14: 0000000000000080 R15: ff1bcbe402bc7805 [ 195.013826] FS: 0000000000000000(0000) GS:ff1bcbe402740000(0000) knlGS:0000000000000000 [ 195.014564] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 195.015093] CR2: ff4e8beb80199014 CR3: 0000000107dea002 CR4: 0000000000771ee0 [ 195.015741] PKRU: 55555554 [ 195.016001] Call Trace: [ 195.016233] <TASK> [ 195.016434] vp_modern_get_status+0x12/0x20 [ 195.016823] vp_vdpa_reset+0x1b/0x50 [vp_vdpa] [ 195.017238] virtio_vdpa_reset+0x3c/0x48 [virtio_vdpa] [ 195.017709] remove_vq_common+0x1f/0x3a0 [virtio_net] [ 195.018178] virtnet_remove+0x5d/0x70 [virtio_net] [ 195.018618] virtio_dev_remove+0x3d/0x90 [ 195.018986] device_release_driver_internal+0x1aa/0x230 [ 195.019466] bus_remove_device+0xd8/0x150 [ 195.019841] device_del+0x18b/0x3f0 [ 195.020167] ? kernfs_find_ns+0x35/0xd0 [ 195.020526] device_unregister+0x13/0x60 [ 195.020894] unregister_virtio_device+0x11/0x20 [ 195.021311] device_release_driver_internal+0x1aa/0x230 [ 195.021790] bus_remove_device+0xd8/0x150 [ 195.022162] device_del+0x18b/0x3f0 [ 195.022487] device_unregister+0x13/0x60 [ 195.022852] ? vdpa_dev_remove+0x30/0x30 [vdpa] [ 195.023270] vp_vdpa_dev_del+0x12/0x20 [vp_vdpa] [ 195.023694] vdpa_match_remove+0x2b/0x40 [vdpa] [ 195.024115] bus_for_each_dev+0x78/0xc0 [ 195.024471] vdpa_mgmtdev_unregister+0x65/0x80 [vdpa] [ 195.024937] vp_vdpa_remove+0x23/0x40 [vp_vdpa] [ 195.025353] pci_device_remove+0x36/0xa0 [ 195.025719] device_release_driver_internal+0x1aa/0x230 [ 195.026201] pci_stop_bus_device+0x6c/0x90 [ 195.026580] pci_stop_and_remove_bus_device+0xe/0x20 [ 195.027039] disable_slot+0x49/0x90 [ 195.027366] acpiphp_disable_and_eject_slot+0x15/0x90 [ 195.027832] hotplug_event+0xea/0x210 [ 195.028171] ? hotplug_event+0x210/0x210 [ 195.028535] acpiphp_hotplug_notify+0x22/0x80 [ 195.028942] ? hotplug_event+0x210/0x210 [ 195.029303] acpi_device_hotplug+0x8a/0x1d0 [ 195.029690] acpi_hotplug_work_fn+0x1a/0x30 [ 195.030077] process_one_work+0x1e8/0x3c0 [ 195.030451] worker_thread+0x50/0x3b0 [ 195.030791] ? rescuer_thread+0x3a0/0x3a0 [ 195.031165] kthread+0xd9/0x100 [ 195.031459] ? kthread_complete_and_exit+0x20/0x20 [ 195.031899] ret_from_fork+0x22/0x30 [ 195.032233] </TASK>",,,"[{""url"":""https://git.kernel.org/stable/c/aed8efddd39b3434c96718d39009285c52b1cafc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/baafa2960731211837d8fc04ff3873ecb7440464"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa1f327f93c9a7310cce9d2fcda28b7af91f7437"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53083,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.310,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nfsd: don't replace page in rq_pages if it's a continuation of last page The splice read calls nfsd_splice_actor to put the pages containing file data into the svc_rqst->rq_pages array. It's possible however to get a splice result that only has a partial page at the end, if (e.g.) the filesystem hands back a short read that doesn't cover the whole page. nfsd_splice_actor will plop the partial page into its rq_pages array and return. Then later, when nfsd_splice_actor is called again, the remainder of the page may end up being filled out. At this point, nfsd_splice_actor will put the page into the array _again_ corrupting the reply. If this is done enough times, rq_next_page will overrun the array and corrupt the trailing fields -- the rq_respages and rq_next_page pointers themselves. If we've already added the page to the array in the last pass, don't add it to the array a second time when dealing with a splice continuation. This was originally handled properly in nfsd_splice_actor, but commit 91e23b1c3982 (""NFSD: Clean up nfsd_splice_actor()"") removed the check for it.",,,"[{""url"":""https://git.kernel.org/stable/c/0101067f376eb7b9afd00279270f25d5111a091d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/12eca509234acb6b666802edf77408bb70d7bfca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/27c934dd8832dd40fd34776f916dc201e18b319b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/51ddb84baff6f09ad62b5999ece3ec172e4e3568"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8235cd619db6e67f1d7d26c55f1f3e4e575c947d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53084,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.403,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/shmem-helper: Remove another errant put in error path drm_gem_shmem_mmap() doesn't own reference in error code path, resulting in the dma-buf shmem GEM object getting prematurely freed leading to a later use-after-free.",,,"[{""url"":""https://git.kernel.org/stable/c/5cfb617967b05f8f27e862c97db1fabd8485f4db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/684c7372bbd6447c2e86a2a84e97a1478604d21f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/77d26c824aa5a7e0681ef1d5b75fe538d746addc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dede8c14a37a7ac458f9add56154a074ed78e7cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee9adb7a45516cfa536ca92253d7ae59d56db9e4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53085,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.493,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/edid: fix info leak when failing to get panel id Make sure to clear the transfer buffer before fetching the EDID to avoid leaking slab data to the logs on errors that leave the buffer unchanged.",,,"[{""url"":""https://git.kernel.org/stable/c/4d8457fe0eb9c80ff7795cf8a30962128b71d853"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/598c42c78919117dc0d235ae22d17ad642377483"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53086,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.580,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: connac: do not check WED status for non-mmio devices WED is supported just for mmio devices, so do not check it for usb or sdio devices. This patch fixes the crash reported below: [ 21.946627] wlp0s3u1i3: authenticate with c4:41:1e:f5:2b:1d [ 22.525298] wlp0s3u1i3: send auth to c4:41:1e:f5:2b:1d (try 1/3) [ 22.548274] wlp0s3u1i3: authenticate with c4:41:1e:f5:2b:1d [ 22.557694] wlp0s3u1i3: send auth to c4:41:1e:f5:2b:1d (try 1/3) [ 22.565885] wlp0s3u1i3: authenticated [ 22.569502] wlp0s3u1i3: associate with c4:41:1e:f5:2b:1d (try 1/3) [ 22.578966] wlp0s3u1i3: RX AssocResp from c4:41:1e:f5:2b:1d (capab=0x11 status=30 aid=3) [ 22.579113] wlp0s3u1i3: c4:41:1e:f5:2b:1d rejected association temporarily; comeback duration 1000 TU (1024 ms) [ 23.649518] wlp0s3u1i3: associate with c4:41:1e:f5:2b:1d (try 2/3) [ 23.752528] wlp0s3u1i3: RX AssocResp from c4:41:1e:f5:2b:1d (capab=0x11 status=0 aid=3) [ 23.797450] wlp0s3u1i3: associated [ 24.959527] kernel tried to execute NX-protected page - exploit attempt? (uid: 0) [ 24.959640] BUG: unable to handle page fault for address: ffff88800c223200 [ 24.959706] #PF: supervisor instruction fetch in kernel mode [ 24.959788] #PF: error_code(0x0011) - permissions violation [ 24.959846] PGD 2c01067 P4D 2c01067 PUD 2c02067 PMD c2a8063 PTE 800000000c223163 [ 24.959957] Oops: 0011 [#1] PREEMPT SMP [ 24.960009] CPU: 0 PID: 391 Comm: wpa_supplicant Not tainted 6.2.0-kvm #18 [ 24.960089] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.1-2.fc37 04/01/2014 [ 24.960191] RIP: 0010:0xffff88800c223200 [ 24.960446] RSP: 0018:ffffc90000ff7698 EFLAGS: 00010282 [ 24.960513] RAX: ffff888028397010 RBX: ffff88800c26e630 RCX: 0000000000000058 [ 24.960598] RDX: ffff88800c26f844 RSI: 0000000000000006 RDI: ffff888028397010 [ 24.960682] RBP: ffff88800ea72f00 R08: 18b873fbab2b964c R09: be06b38235f3c63c [ 24.960766] R10: 18b873fbab2b964c R11: be06b38235f3c63c R12: 0000000000000001 [ 24.960853] R13: ffff88800c26f84c R14: ffff8880063f0ff8 R15: ffff88800c26e644 [ 24.960950] FS: 00007effcea327c0(0000) GS:ffff88807dc00000(0000) knlGS:0000000000000000 [ 24.961036] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 24.961106] CR2: ffff88800c223200 CR3: 000000000eaa2000 CR4: 00000000000006b0 [ 24.961190] Call Trace: [ 24.961219] <TASK> [ 24.961245] ? mt76_connac_mcu_add_key+0x2cf/0x310 [ 24.961313] ? mt7921_set_key+0x150/0x200 [ 24.961365] ? drv_set_key+0xa9/0x1b0 [ 24.961418] ? ieee80211_key_enable_hw_accel+0xd9/0x240 [ 24.961485] ? ieee80211_key_replace+0x3f3/0x730 [ 24.961541] ? crypto_shash_setkey+0x89/0xd0 [ 24.961597] ? ieee80211_key_link+0x2d7/0x3a0 [ 24.961664] ? crypto_aead_setauthsize+0x31/0x50 [ 24.961730] ? sta_info_hash_lookup+0xa6/0xf0 [ 24.961785] ? ieee80211_add_key+0x1fc/0x250 [ 24.961842] ? rdev_add_key+0x41/0x140 [ 24.961882] ? nl80211_parse_key+0x6c/0x2f0 [ 24.961940] ? nl80211_new_key+0x24a/0x290 [ 24.961984] ? genl_rcv_msg+0x36c/0x3a0 [ 24.962036] ? rdev_mod_link_station+0xe0/0xe0 [ 24.962102] ? nl80211_set_key+0x410/0x410 [ 24.962143] ? nl80211_pre_doit+0x200/0x200 [ 24.962187] ? genl_bind+0xc0/0xc0 [ 24.962217] ? netlink_rcv_skb+0xaa/0xd0 [ 24.962259] ? genl_rcv+0x24/0x40 [ 24.962300] ? netlink_unicast+0x224/0x2f0 [ 24.962345] ? netlink_sendmsg+0x30b/0x3d0 [ 24.962388] ? ____sys_sendmsg+0x109/0x1b0 [ 24.962388] ? ____sys_sendmsg+0x109/0x1b0 [ 24.962440] ? __import_iovec+0x2e/0x110 [ 24.962482] ? ___sys_sendmsg+0xbe/0xe0 [ 24.962525] ? mod_objcg_state+0x25c/0x330 [ 24.962576] ? __dentry_kill+0x19e/0x1d0 [ 24.962618] ? call_rcu+0x18f/0x270 [ 24.962660] ? __dentry_kill+0x19e/0x1d0 [ 24.962702] ? __x64_sys_sendmsg+0x70/0x90 [ 24.962744] ? do_syscall_64+0x3d/0x80 [ 24.962796] ? exit_to_user_mode_prepare+0x1b/0x70 [ 24.962852] ? entry_SYSCA ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/53edfda851dd1ce41ac049ce2f195dc41dd27cc1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5683e1488aa9b0805a9403d215e48fed29d6d923"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53087,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.667,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/i915/active: Fix misuse of non-idle barriers as fence trackers Users reported oopses on list corruptions when using i915 perf with a number of concurrently running graphics applications. Root cause analysis pointed at an issue in barrier processing code -- a race among perf open / close replacing active barriers with perf requests on kernel context and concurrent barrier preallocate / acquire operations performed during user context first pin / last unpin. When adding a request to a composite tracker, we try to reuse an existing fence tracker, already allocated and registered with that composite. The tracker we obtain may already track another fence, may be an idle barrier, or an active barrier. If the tracker we get occurs a non-idle barrier then we try to delete that barrier from a list of barrier tasks it belongs to. However, while doing that we don't respect return value from a function that performs the barrier deletion. Should the deletion ever fail, we would end up reusing the tracker still registered as a barrier task. Since the same structure field is reused with both fence callback lists and barrier tasks list, list corruptions would likely occur. Barriers are now deleted from a barrier tasks list by temporarily removing the list content, traversing that content with skip over the node to be deleted, then populating the list back with the modified content. Should that intentionally racy concurrent deletion attempts be not serialized, one or more of those may fail because of the list being temporary empty. Related code that ignores the results of barrier deletion was initially introduced in v5.4 by commit d8af05ff38ae (""drm/i915: Allow sharing the idle-barrier from other kernel requests""). However, all users of the barrier deletion routine were apparently serialized at that time, then the issue didn't exhibit itself. Results of git bisect with help of a newly developed igt@gem_barrier_race@remote-request IGT test indicate that list corruptions might start to appear after commit 311770173fac (""drm/i915/gt: Schedule request retirement when timeline idles""), introduced in v5.5. Respect results of barrier deletion attempts -- mark the barrier as idle only if successfully deleted from the list. Then, before proceeding with setting our fence as the one currently tracked, make sure that the tracker we've got is not a non-idle barrier. If that check fails then don't use that tracker but go back and try to acquire a new, usable one. v3: use unlikely() to document what outcome we expect (Andi), - fix bad grammar in commit description. v2: no code changes, - blame commit 311770173fac (""drm/i915/gt: Schedule request retirement when timeline idles""), v5.5, not commit d8af05ff38ae (""drm/i915: Allow sharing the idle-barrier from other kernel requests""), v5.4, - reword commit description. (cherry picked from commit 506006055769b10d1b2b4e22f636f3b45e0e9fc7)",,,"[{""url"":""https://git.kernel.org/stable/c/5c7591b8574c52c56b3994c2fbef1a3a311b5715"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e784a7d07af42057c0576fb647b482f4cb0dc2c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6ab7d33617559cced63d467928f478ea5c459021"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9159db27fb19bbf1c91b5c9d5285e66cc96cc5ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0e6b416b25ee14716f3549e0cbec1011b193809"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53088,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.760,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mptcp: fix UaF in listener shutdown As reported by Christoph after having refactored the passive socket initialization, the mptcp listener shutdown path is prone to an UaF issue. BUG: KASAN: use-after-free in _raw_spin_lock_bh+0x73/0xe0 Write of size 4 at addr ffff88810cb23098 by task syz-executor731/1266 CPU: 1 PID: 1266 Comm: syz-executor731 Not tainted 6.2.0-rc59af4eaa31c1f6c00c8f1e448ed99a45c66340dd5 #6 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x6e/0x91 print_report+0x16a/0x46f kasan_report+0xad/0x130 kasan_check_range+0x14a/0x1a0 _raw_spin_lock_bh+0x73/0xe0 subflow_error_report+0x6d/0x110 sk_error_report+0x3b/0x190 tcp_disconnect+0x138c/0x1aa0 inet_child_forget+0x6f/0x2e0 inet_csk_listen_stop+0x209/0x1060 __mptcp_close_ssk+0x52d/0x610 mptcp_destroy_common+0x165/0x640 mptcp_destroy+0x13/0x80 __mptcp_destroy_sock+0xe7/0x270 __mptcp_close+0x70e/0x9b0 mptcp_close+0x2b/0x150 inet_release+0xe9/0x1f0 __sock_release+0xd2/0x280 sock_close+0x15/0x20 __fput+0x252/0xa20 task_work_run+0x169/0x250 exit_to_user_mode_prepare+0x113/0x120 syscall_exit_to_user_mode+0x1d/0x40 do_syscall_64+0x48/0x90 entry_SYSCALL_64_after_hwframe+0x72/0xdc The msk grace period can legitly expire in between the last reference count dropped in mptcp_subflow_queue_clean() and the later eventual access in inet_csk_listen_stop() After the previous patch we don't need anymore special-casing msk listener socket cleanup: the mptcp worker will process each of the unaccepted msk sockets. Just drop the now unnecessary code. Please note this commit depends on the two parent ones: mptcp: refactor passive socket initialization mptcp: use the workqueue to destroy unaccepted sockets",,,"[{""url"":""https://git.kernel.org/stable/c/0a3f4f1f9c27215e4ddcd312558342e57b93e518"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0f4f4cf5d32f10543deb946a37111e714579511e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5564be74a22a61855f8b8c100d8c4abb003bb792"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53089,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.853,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: fix task hung in ext4_xattr_delete_inode Syzbot reported a hung task problem: ================================================================== INFO: task syz-executor232:5073 blocked for more than 143 seconds. Not tainted 6.2.0-rc2-syzkaller-00024-g512dee0c00ad #0 ""echo 0 > /proc/sys/kernel/hung_task_timeout_secs"" disables this message. task:syz-exec232 state:D stack:21024 pid:5073 ppid:5072 flags:0x00004004 Call Trace: <TASK> context_switch kernel/sched/core.c:5244 [inline] __schedule+0x995/0xe20 kernel/sched/core.c:6555 schedule+0xcb/0x190 kernel/sched/core.c:6631 __wait_on_freeing_inode fs/inode.c:2196 [inline] find_inode_fast+0x35a/0x4c0 fs/inode.c:950 iget_locked+0xb1/0x830 fs/inode.c:1273 __ext4_iget+0x22e/0x3ed0 fs/ext4/inode.c:4861 ext4_xattr_inode_iget+0x68/0x4e0 fs/ext4/xattr.c:389 ext4_xattr_inode_dec_ref_all+0x1a7/0xe50 fs/ext4/xattr.c:1148 ext4_xattr_delete_inode+0xb04/0xcd0 fs/ext4/xattr.c:2880 ext4_evict_inode+0xd7c/0x10b0 fs/ext4/inode.c:296 evict+0x2a4/0x620 fs/inode.c:664 ext4_orphan_cleanup+0xb60/0x1340 fs/ext4/orphan.c:474 __ext4_fill_super fs/ext4/super.c:5516 [inline] ext4_fill_super+0x81cd/0x8700 fs/ext4/super.c:5644 get_tree_bdev+0x400/0x620 fs/super.c:1282 vfs_get_tree+0x88/0x270 fs/super.c:1489 do_new_mount+0x289/0xad0 fs/namespace.c:3145 do_mount fs/namespace.c:3488 [inline] __do_sys_mount fs/namespace.c:3697 [inline] __se_sys_mount+0x2d3/0x3c0 fs/namespace.c:3674 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7fa5406fd5ea RSP: 002b:00007ffc7232f968 EFLAGS: 00000202 ORIG_RAX: 00000000000000a5 RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007fa5406fd5ea RDX: 0000000020000440 RSI: 0000000020000000 RDI: 00007ffc7232f970 RBP: 00007ffc7232f970 R08: 00007ffc7232f9b0 R09: 0000000000000432 R10: 0000000000804a03 R11: 0000000000000202 R12: 0000000000000004 R13: 0000555556a7a2c0 R14: 00007ffc7232f9b0 R15: 0000000000000000 </TASK> ================================================================== The problem is that the inode contains an xattr entry with ea_inum of 15 when cleaning up an orphan inode <15>. When evict inode <15>, the reference counting of the corresponding EA inode is decreased. When EA inode <15> is found by find_inode_fast() in __ext4_iget(), it is found that the EA inode holds the I_FREEING flag and waits for the EA inode to complete deletion. As a result, when inode <15> is being deleted, we wait for inode <15> to complete the deletion, resulting in an infinite loop and triggering Hung Task. To solve this problem, we only need to check whether the ino of EA inode and parent is the same before getting EA inode.",,,"[{""url"":""https://git.kernel.org/stable/c/0f7bfd6f8164be32dbbdf36aa1e5d00485c53cd7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1aec41c98cce61d19ce89650895e51b9f3cdef13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2c96c52aeaa6fd9163cfacdd98778b4a0398ef18"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/64b72f5e7574020dea62ab733d88a54d903c42a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73f7987fe1b82596f1a380e85cd0097ebaae7e01"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/94fd091576b12540924f6316ebc0678e84cb2800"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a98160d8f3e6242ca9b7f443f26e7ef3a61ba684"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/efddc7e106fdf8d1f62d45e79de78f63b7c04fba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53090,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:27.957,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdkfd: Fix an illegal memory access In the kfd_wait_on_events() function, the kfd_event_waiter structure is allocated by alloc_event_waiters(), but the event field of the waiter structure is not initialized; When copy_from_user() fails in the kfd_wait_on_events() function, it will enter exception handling to release the previously allocated memory of the waiter structure; Due to the event field of the waiters structure being accessed in the free_waiters() function, this results in illegal memory access and system crash, here is the crash log: localhost kernel: RIP: 0010:native_queued_spin_lock_slowpath+0x185/0x1e0 localhost kernel: RSP: 0018:ffffaa53c362bd60 EFLAGS: 00010082 localhost kernel: RAX: ff3d3d6bff4007cb RBX: 0000000000000282 RCX: 00000000002c0000 localhost kernel: RDX: ffff9e855eeacb80 RSI: 000000000000279c RDI: ffffe7088f6a21d0 localhost kernel: RBP: ffffe7088f6a21d0 R08: 00000000002c0000 R09: ffffaa53c362be64 localhost kernel: R10: ffffaa53c362bbd8 R11: 0000000000000001 R12: 0000000000000002 localhost kernel: R13: ffff9e7ead15d600 R14: 0000000000000000 R15: ffff9e7ead15d698 localhost kernel: FS: 0000152a3d111700(0000) GS:ffff9e855ee80000(0000) knlGS:0000000000000000 localhost kernel: CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 localhost kernel: CR2: 0000152938000010 CR3: 000000044d7a4000 CR4: 00000000003506e0 localhost kernel: Call Trace: localhost kernel: _raw_spin_lock_irqsave+0x30/0x40 localhost kernel: remove_wait_queue+0x12/0x50 localhost kernel: kfd_wait_on_events+0x1b6/0x490 [hydcu] localhost kernel: ? ftrace_graph_caller+0xa0/0xa0 localhost kernel: kfd_ioctl+0x38c/0x4a0 [hydcu] localhost kernel: ? kfd_ioctl_set_trap_handler+0x70/0x70 [hydcu] localhost kernel: ? kfd_ioctl_create_queue+0x5a0/0x5a0 [hydcu] localhost kernel: ? ftrace_graph_caller+0xa0/0xa0 localhost kernel: __x64_sys_ioctl+0x8e/0xd0 localhost kernel: ? syscall_trace_enter.isra.18+0x143/0x1b0 localhost kernel: do_syscall_64+0x33/0x80 localhost kernel: entry_SYSCALL_64_after_hwframe+0x44/0xa9 localhost kernel: RIP: 0033:0x152a4dff68d7 Allocate the structure with kcalloc, and remove redundant 0-initialization and a redundant loop condition check.",,,"[{""url"":""https://git.kernel.org/stable/c/2fece63b55c5d74cd6f5de51159e2cde37e10555"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4fc8fff378b2f2039f2a666d9f8c570f4e58352c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a3fb3b745af0ce46ec2e0c8e507bae45b937334"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/61f306f8df0d5559659c5578cf6d95236bcdcb25"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6936525142a015e854d0a23e9ad9ea0a28b3843d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bbf5eada4334a96e3a204b2307ff5b14dc380b0b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d9923e7214a870b312bf61f6a89c7554d0966985"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53091,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:28.073,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: update s_journal_inum if it changes after journal replay When mounting a crafted ext4 image, s_journal_inum may change after journal replay, which is obviously unreasonable because we have successfully loaded and replayed the journal through the old s_journal_inum. And the new s_journal_inum bypasses some of the checks in ext4_get_journal(), which may trigger a null pointer dereference problem. So if s_journal_inum changes after the journal replay, we ignore the change, and rewrite the current journal_inum to the superblock.",,,"[{""url"":""https://git.kernel.org/stable/c/3039d8b8692408438a618fac2776b629852663c3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/499fef2030fb754c68b1c7cb3a799a3bc1d0d925"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/70e66bdeae4d0f7c8e87762f425b68aedd5e8955"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ee0c5277d4fab920bd31345c49e193ecede9ecef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53092,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:28.180,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: interconnect: exynos: fix node leak in probe PM QoS error path Make sure to add the newly allocated interconnect node to the provider before adding the PM QoS request so that the node is freed on errors.",,,"[{""url"":""https://git.kernel.org/stable/c/3aab264875bf3c915ea2517fae1eec213e0b4987"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b71dd43bd49bd68186c1d19dbeedee219e003149"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c479e4ac4a3d1485a48599e66ce46547c1367828"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd4738ae1a0c216d25360a98e835967b06d6a253"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53093,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:28.270,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tracing: Do not let histogram values have some modifiers Histogram values can not be strings, stacktraces, graphs, symbols, syscalls, or grouped in buckets or log. Give an error if a value is set to do so. Note, the histogram code was not prepared to handle these modifiers for histograms and caused a bug. Mark Rutland reported: # echo 'p:copy_to_user __arch_copy_to_user n=$arg2' >> /sys/kernel/tracing/kprobe_events # echo 'hist:keys=n:vals=hitcount.buckets=8:sort=hitcount' > /sys/kernel/tracing/events/kprobes/copy_to_user/trigger # cat /sys/kernel/tracing/events/kprobes/copy_to_user/hist [ 143.694628] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000 [ 143.695190] Mem abort info: [ 143.695362] ESR = 0x0000000096000004 [ 143.695604] EC = 0x25: DABT (current EL), IL = 32 bits [ 143.695889] SET = 0, FnV = 0 [ 143.696077] EA = 0, S1PTW = 0 [ 143.696302] FSC = 0x04: level 0 translation fault [ 143.702381] Data abort info: [ 143.702614] ISV = 0, ISS = 0x00000004 [ 143.702832] CM = 0, WnR = 0 [ 143.703087] user pgtable: 4k pages, 48-bit VAs, pgdp=00000000448f9000 [ 143.703407] [0000000000000000] pgd=0000000000000000, p4d=0000000000000000 [ 143.704137] Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP [ 143.704714] Modules linked in: [ 143.705273] CPU: 0 PID: 133 Comm: cat Not tainted 6.2.0-00003-g6fc512c10a7c #3 [ 143.706138] Hardware name: linux,dummy-virt (DT) [ 143.706723] pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 143.707120] pc : hist_field_name.part.0+0x14/0x140 [ 143.707504] lr : hist_field_name.part.0+0x104/0x140 [ 143.707774] sp : ffff800008333a30 [ 143.707952] x29: ffff800008333a30 x28: 0000000000000001 x27: 0000000000400cc0 [ 143.708429] x26: ffffd7a653b20260 x25: 0000000000000000 x24: ffff10d303ee5800 [ 143.708776] x23: ffffd7a6539b27b0 x22: ffff10d303fb8c00 x21: 0000000000000001 [ 143.709127] x20: ffff10d303ec2000 x19: 0000000000000000 x18: 0000000000000000 [ 143.709478] x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000 [ 143.709824] x14: 0000000000000000 x13: 203a6f666e692072 x12: 6567676972742023 [ 143.710179] x11: 0a230a6d6172676f x10: 000000000000002c x9 : ffffd7a6521e018c [ 143.710584] x8 : 000000000000002c x7 : 7f7f7f7f7f7f7f7f x6 : 000000000000002c [ 143.710915] x5 : ffff10d303b0103e x4 : ffffd7a653b20261 x3 : 000000000000003d [ 143.711239] x2 : 0000000000020001 x1 : 0000000000000001 x0 : 0000000000000000 [ 143.711746] Call trace: [ 143.712115] hist_field_name.part.0+0x14/0x140 [ 143.712642] hist_field_name.part.0+0x104/0x140 [ 143.712925] hist_field_print+0x28/0x140 [ 143.713125] event_hist_trigger_print+0x174/0x4d0 [ 143.713348] hist_show+0xf8/0x980 [ 143.713521] seq_read_iter+0x1bc/0x4b0 [ 143.713711] seq_read+0x8c/0xc4 [ 143.713876] vfs_read+0xc8/0x2a4 [ 143.714043] ksys_read+0x70/0xfc [ 143.714218] __arm64_sys_read+0x24/0x30 [ 143.714400] invoke_syscall+0x50/0x120 [ 143.714587] el0_svc_common.constprop.0+0x4c/0x100 [ 143.714807] do_el0_svc+0x44/0xd0 [ 143.714970] el0_svc+0x2c/0x84 [ 143.715134] el0t_64_sync_handler+0xbc/0x140 [ 143.715334] el0t_64_sync+0x190/0x194 [ 143.715742] Code: a9bd7bfd 910003fd a90153f3 aa0003f3 (f9400000) [ 143.716510] ---[ end trace 0000000000000000 ]--- Segmentation fault",,,"[{""url"":""https://git.kernel.org/stable/c/2fc0ee435c9264cdb7c5e872f76cd9bb97640227"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/39cd75f2f3a43c0e2f95749eb6dd6420c553f87d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0213434fe3e4a0d118923dc98d31e7ff1cd9e45"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53094,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:28.363,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tty: serial: fsl_lpuart: fix race on RX DMA shutdown From time to time DMA completion can come in the middle of DMA shutdown: <process ctx>: <IRQ>: lpuart32_shutdown() lpuart_dma_shutdown() del_timer_sync() lpuart_dma_rx_complete() lpuart_copy_rx_to_tty() mod_timer() lpuart_dma_rx_free() When the timer fires a bit later, sport->dma_rx_desc is NULL: Unable to handle kernel NULL pointer dereference at virtual address 0000000000000004 pc : lpuart_copy_rx_to_tty+0xcc/0x5bc lr : lpuart_timer_func+0x1c/0x2c Call trace: lpuart_copy_rx_to_tty lpuart_timer_func call_timer_fn __run_timers.part.0 run_timer_softirq __do_softirq __irq_exit_rcu irq_exit handle_domain_irq gic_handle_irq call_on_irq_stack do_interrupt_handler ... To fix this fold del_timer_sync() into lpuart_dma_rx_free() after dmaengine_terminate_sync() to make sure timer will not be re-started in lpuart_copy_rx_to_tty() <= lpuart_dma_rx_complete().",,,"[{""url"":""https://git.kernel.org/stable/c/19a98d56dfedafb25652bdb9cd48a4e73ceba702"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1be6f2b15f902c02e055ae0b419ca789200473c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2a36b444cace9580380467fd1183bb5e85bcc80a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90530e7214c8a04dcdde57502d93fa96af288c38"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/954fc9931f0aabf272b5674cf468affdd88d3a36"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53095,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:28.453,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/ttm: Fix a NULL pointer dereference The LRU mechanism may look up a resource in the process of being removed from an object. The locking rules here are a bit unclear but it looks currently like res->bo assignment is protected by the LRU lock, whereas bo->resource is protected by the object lock, while *clearing* of bo->resource is also protected by the LRU lock. This means that if we check that bo->resource points to the LRU resource under the LRU lock we should be safe. So perform that check before deciding to swap out a bo. That avoids dereferencing a NULL bo->resource in ttm_bo_swapout().",,,"[{""url"":""https://git.kernel.org/stable/c/9a9a8fe26751334b7739193a94eba741073b8a55"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ba1720f6c4a0f13c3f3cb5c28132ee75555d04f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d9b1f9f7a72d83ebf173534e76b246349f32374"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53096,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:28.543,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: interconnect: fix mem leak when freeing nodes The node link array is allocated when adding links to a node but is not deallocated when nodes are destroyed.",,,"[{""url"":""https://git.kernel.org/stable/c/2e0b13a1827229a02abef97b50ffaf89ba25370a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3167306455d0fbbbcf08cb25651acc527a86a95e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a5904f415e1af72fa8fe6665aa4f554dc2099a95"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c1722e4113281fb34e5b4fb5c5387b17cd39a537"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/efae80ca13faa94457208852825731da44a788ad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1e3a20c60196c37a402c584d0c9de306ba988ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53097,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:28.643,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: powerpc/iommu: fix memory leak with using debugfs_lookup() When calling debugfs_lookup() the result must have dput() called on it, otherwise the memory will leak over time. To make things simpler, just call debugfs_lookup_and_remove() instead which handles all of the logic at once.",,,"[{""url"":""https://git.kernel.org/stable/c/24c1bd1cd0d1ff821fd7d2f01a1e648c7882dfc2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4050498c0ae3946c223fc63e9dd7b878b76611e0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b505063910c134778202dfad9332dfcecb76bab3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3a62a35f903fd8be5b44542fe3901ec45f16757"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53098,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:28.733,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: rc: gpio-ir-recv: add remove function In case runtime PM is enabled, do runtime PM clean up to remove cpu latency qos request, otherwise driver removal may have below kernel dump: [ 19.463299] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000048 [ 19.472161] Mem abort info: [ 19.474985] ESR = 0x0000000096000004 [ 19.478754] EC = 0x25: DABT (current EL), IL = 32 bits [ 19.484081] SET = 0, FnV = 0 [ 19.487149] EA = 0, S1PTW = 0 [ 19.490361] FSC = 0x04: level 0 translation fault [ 19.495256] Data abort info: [ 19.498149] ISV = 0, ISS = 0x00000004 [ 19.501997] CM = 0, WnR = 0 [ 19.504977] user pgtable: 4k pages, 48-bit VAs, pgdp=0000000049f81000 [ 19.511432] [0000000000000048] pgd=0000000000000000, p4d=0000000000000000 [ 19.518245] Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP [ 19.524520] Modules linked in: gpio_ir_recv(+) rc_core [last unloaded: rc_core] [ 19.531845] CPU: 0 PID: 445 Comm: insmod Not tainted 6.2.0-rc1-00028-g2c397a46d47c #72 [ 19.531854] Hardware name: FSL i.MX8MM EVK board (DT) [ 19.531859] pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 19.551777] pc : cpu_latency_qos_remove_request+0x20/0x110 [ 19.557277] lr : gpio_ir_recv_runtime_suspend+0x18/0x30 [gpio_ir_recv] [ 19.557294] sp : ffff800008ce3740 [ 19.557297] x29: ffff800008ce3740 x28: 0000000000000000 x27: ffff800008ce3d50 [ 19.574270] x26: ffffc7e3e9cea100 x25: 00000000000f4240 x24: ffffc7e3f9ef0e30 [ 19.574284] x23: 0000000000000000 x22: ffff0061803820f4 x21: 0000000000000008 [ 19.574296] x20: ffffc7e3fa75df30 x19: 0000000000000020 x18: ffffffffffffffff [ 19.588570] x17: 0000000000000000 x16: ffffc7e3f9efab70 x15: ffffffffffffffff [ 19.595712] x14: ffff800008ce37b8 x13: ffff800008ce37aa x12: 0000000000000001 [ 19.602853] x11: 0000000000000001 x10: ffffcbe3ec0dff87 x9 : 0000000000000008 [ 19.609991] x8 : 0101010101010101 x7 : 0000000000000000 x6 : 000000000f0bfe9f [ 19.624261] x5 : 00ffffffffffffff x4 : 0025ab8e00000000 x3 : ffff006180382010 [ 19.631405] x2 : ffffc7e3e9ce8030 x1 : ffffc7e3fc3eb810 x0 : 0000000000000020 [ 19.638548] Call trace: [ 19.640995] cpu_latency_qos_remove_request+0x20/0x110 [ 19.646142] gpio_ir_recv_runtime_suspend+0x18/0x30 [gpio_ir_recv] [ 19.652339] pm_generic_runtime_suspend+0x2c/0x44 [ 19.657055] __rpm_callback+0x48/0x1dc [ 19.660807] rpm_callback+0x6c/0x80 [ 19.664301] rpm_suspend+0x10c/0x640 [ 19.667880] rpm_idle+0x250/0x2d0 [ 19.671198] update_autosuspend+0x38/0xe0 [ 19.675213] pm_runtime_set_autosuspend_delay+0x40/0x60 [ 19.680442] gpio_ir_recv_probe+0x1b4/0x21c [gpio_ir_recv] [ 19.685941] platform_probe+0x68/0xc0 [ 19.689610] really_probe+0xc0/0x3dc [ 19.693189] __driver_probe_device+0x7c/0x190 [ 19.697550] driver_probe_device+0x3c/0x110 [ 19.701739] __driver_attach+0xf4/0x200 [ 19.705578] bus_for_each_dev+0x70/0xd0 [ 19.709417] driver_attach+0x24/0x30 [ 19.712998] bus_add_driver+0x17c/0x240 [ 19.716834] driver_register+0x78/0x130 [ 19.720676] __platform_driver_register+0x28/0x34 [ 19.725386] gpio_ir_recv_driver_init+0x20/0x1000 [gpio_ir_recv] [ 19.731404] do_one_initcall+0x44/0x2ac [ 19.735243] do_init_module+0x48/0x1d0 [ 19.739003] load_module+0x19fc/0x2034 [ 19.742759] __do_sys_finit_module+0xac/0x12c [ 19.747124] __arm64_sys_finit_module+0x20/0x30 [ 19.751664] invoke_syscall+0x48/0x114 [ 19.755420] el0_svc_common.constprop.0+0xcc/0xec [ 19.760132] do_el0_svc+0x38/0xb0 [ 19.763456] el0_svc+0x2c/0x84 [ 19.766516] el0t_64_sync_handler+0xf4/0x120 [ 19.770789] el0t_64_sync+0x190/0x194 [ 19.774460] Code: 910003fd a90153f3 aa0003f3 91204021 (f9401400) [ 19.780556] ---[ end trace 0000000000000000 ]---",,,"[{""url"":""https://git.kernel.org/stable/c/00e81f191bc00cb6faabf468960e96ebf0404a6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2ece4d2f7eac1cb51dc0e9859e09bfdb00faa28e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/30040818b338b8ebc956ce0ebd198f8d593586a6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/513572bb89e8075f5d2a2bb4c89f1152e44da9d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a5c140d88a69eb43de2a030f1d7ff7b16bff3b1a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53099,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:28.830,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: firmware: xilinx: don't make a sleepable memory allocation from an atomic context The following issue was discovered using lockdep: [ 6.691371] BUG: sleeping function called from invalid context at include/linux/sched/mm.h:209 [ 6.694602] in_atomic(): 1, irqs_disabled(): 128, non_block: 0, pid: 1, name: swapper/0 [ 6.702431] 2 locks held by swapper/0/1: [ 6.706300] #0: ffffff8800f6f188 (&dev->mutex){....}-{3:3}, at: __device_driver_lock+0x4c/0x90 [ 6.714900] #1: ffffffc009a2abb8 (enable_lock){....}-{2:2}, at: clk_enable_lock+0x4c/0x140 [ 6.723156] irq event stamp: 304030 [ 6.726596] hardirqs last enabled at (304029): [<ffffffc008d17ee0>] _raw_spin_unlock_irqrestore+0xc0/0xd0 [ 6.736142] hardirqs last disabled at (304030): [<ffffffc00876bc5c>] clk_enable_lock+0xfc/0x140 [ 6.744742] softirqs last enabled at (303958): [<ffffffc0080904f0>] _stext+0x4f0/0x894 [ 6.752655] softirqs last disabled at (303951): [<ffffffc0080e53b8>] irq_exit+0x238/0x280 [ 6.760744] CPU: 1 PID: 1 Comm: swapper/0 Tainted: G U 5.15.36 #2 [ 6.768048] Hardware name: xlnx,zynqmp (DT) [ 6.772179] Call trace: [ 6.774584] dump_backtrace+0x0/0x300 [ 6.778197] show_stack+0x18/0x30 [ 6.781465] dump_stack_lvl+0xb8/0xec [ 6.785077] dump_stack+0x1c/0x38 [ 6.788345] ___might_sleep+0x1a8/0x2a0 [ 6.792129] __might_sleep+0x6c/0xd0 [ 6.795655] kmem_cache_alloc_trace+0x270/0x3d0 [ 6.800127] do_feature_check_call+0x100/0x220 [ 6.804513] zynqmp_pm_invoke_fn+0x8c/0xb0 [ 6.808555] zynqmp_pm_clock_getstate+0x90/0xe0 [ 6.813027] zynqmp_pll_is_enabled+0x8c/0x120 [ 6.817327] zynqmp_pll_enable+0x38/0xc0 [ 6.821197] clk_core_enable+0x144/0x400 [ 6.825067] clk_core_enable+0xd4/0x400 [ 6.828851] clk_core_enable+0xd4/0x400 [ 6.832635] clk_core_enable+0xd4/0x400 [ 6.836419] clk_core_enable+0xd4/0x400 [ 6.840203] clk_core_enable+0xd4/0x400 [ 6.843987] clk_core_enable+0xd4/0x400 [ 6.847771] clk_core_enable+0xd4/0x400 [ 6.851555] clk_core_enable_lock+0x24/0x50 [ 6.855683] clk_enable+0x24/0x40 [ 6.858952] fclk_probe+0x84/0xf0 [ 6.862220] platform_probe+0x8c/0x110 [ 6.865918] really_probe+0x110/0x5f0 [ 6.869530] __driver_probe_device+0xcc/0x210 [ 6.873830] driver_probe_device+0x64/0x140 [ 6.877958] __driver_attach+0x114/0x1f0 [ 6.881828] bus_for_each_dev+0xe8/0x160 [ 6.885698] driver_attach+0x34/0x50 [ 6.889224] bus_add_driver+0x228/0x300 [ 6.893008] driver_register+0xc0/0x1e0 [ 6.896792] __platform_driver_register+0x44/0x60 [ 6.901436] fclk_driver_init+0x1c/0x28 [ 6.905220] do_one_initcall+0x104/0x590 [ 6.909091] kernel_init_freeable+0x254/0x2bc [ 6.913390] kernel_init+0x24/0x130 [ 6.916831] ret_from_fork+0x10/0x20 Fix it by passing the GFP_ATOMIC gfp flag for the corresponding memory allocation.",,,"[{""url"":""https://git.kernel.org/stable/c/162049c31eb64308afa22e341a257a723526eb5c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/38ed310c22e7a0fc978b1f8292136a4a4a8b3051"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/86afb633beaa02ee95b5126a14c9f22cfade4fd9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9bbab2843f2d1337a268499a1c02b435d2985a17"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b37d3ccbd549494890672136a0e623eb010d46a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53100,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:28.923,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: fix WARNING in ext4_update_inline_data Syzbot found the following issue: EXT4-fs (loop0): mounted filesystem 00000000-0000-0000-0000-000000000000 without journal. Quota mode: none. fscrypt: AES-256-CTS-CBC using implementation ""cts-cbc-aes-aesni"" fscrypt: AES-256-XTS using implementation ""xts-aes-aesni"" ------------[ cut here ]------------ WARNING: CPU: 0 PID: 5071 at mm/page_alloc.c:5525 __alloc_pages+0x30a/0x560 mm/page_alloc.c:5525 Modules linked in: CPU: 1 PID: 5071 Comm: syz-executor263 Not tainted 6.2.0-rc1-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022 RIP: 0010:__alloc_pages+0x30a/0x560 mm/page_alloc.c:5525 RSP: 0018:ffffc90003c2f1c0 EFLAGS: 00010246 RAX: ffffc90003c2f220 RBX: 0000000000000014 RCX: 0000000000000000 RDX: 0000000000000028 RSI: 0000000000000000 RDI: ffffc90003c2f248 RBP: ffffc90003c2f2d8 R08: dffffc0000000000 R09: ffffc90003c2f220 R10: fffff52000785e49 R11: 1ffff92000785e44 R12: 0000000000040d40 R13: 1ffff92000785e40 R14: dffffc0000000000 R15: 1ffff92000785e3c FS: 0000555556c0d300(0000) GS:ffff8880b9800000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f95d5e04138 CR3: 00000000793aa000 CR4: 00000000003506f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> __alloc_pages_node include/linux/gfp.h:237 [inline] alloc_pages_node include/linux/gfp.h:260 [inline] __kmalloc_large_node+0x95/0x1e0 mm/slab_common.c:1113 __do_kmalloc_node mm/slab_common.c:956 [inline] __kmalloc+0xfe/0x190 mm/slab_common.c:981 kmalloc include/linux/slab.h:584 [inline] kzalloc include/linux/slab.h:720 [inline] ext4_update_inline_data+0x236/0x6b0 fs/ext4/inline.c:346 ext4_update_inline_dir fs/ext4/inline.c:1115 [inline] ext4_try_add_inline_entry+0x328/0x990 fs/ext4/inline.c:1307 ext4_add_entry+0x5a4/0xeb0 fs/ext4/namei.c:2385 ext4_add_nondir+0x96/0x260 fs/ext4/namei.c:2772 ext4_create+0x36c/0x560 fs/ext4/namei.c:2817 lookup_open fs/namei.c:3413 [inline] open_last_lookups fs/namei.c:3481 [inline] path_openat+0x12ac/0x2dd0 fs/namei.c:3711 do_filp_open+0x264/0x4f0 fs/namei.c:3741 do_sys_openat2+0x124/0x4e0 fs/open.c:1310 do_sys_open fs/open.c:1326 [inline] __do_sys_openat fs/open.c:1342 [inline] __se_sys_openat fs/open.c:1337 [inline] __x64_sys_openat+0x243/0x290 fs/open.c:1337 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd Above issue happens as follows: ext4_iget ext4_find_inline_data_nolock ->i_inline_off=164 i_inline_size=60 ext4_try_add_inline_entry __ext4_mark_inode_dirty ext4_expand_extra_isize_ea ->i_extra_isize=32 s_want_extra_isize=44 ext4_xattr_shift_entries ->after shift i_inline_off is incorrect, actually is change to 176 ext4_try_add_inline_entry ext4_update_inline_dir get_max_inline_xattr_value_size if (EXT4_I(inode)->i_inline_off) entry = (struct ext4_xattr_entry *)((void *)raw_inode + EXT4_I(inode)->i_inline_off); free += EXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size)); ->As entry is incorrect, then 'free' may be negative ext4_update_inline_data value = kzalloc(len, GFP_NOFS); -> len is unsigned int, maybe very large, then trigger warning when 'kzalloc()' To resolve the above issue we need to update 'i_inline_off' after 'ext4_xattr_shift_entries()'. We do not need to set EXT4_STATE_MAY_INLINE_DATA flag here, since ext4_mark_inode_dirty() already sets this flag if needed. Setting EXT4_STATE_MAY_INLINE_DATA when it is needed may trigger a BUG_ON in ext4_writepages().",,,"[{""url"":""https://git.kernel.org/stable/c/2b96b4a5d9443ca4cad58b0040be455803c05a42"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/35161cec76772f74526f5886ad4082ec48511d5c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/39c5df2ca544368b44b59d0f6d80131e90763371"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74d775083e9f3d9dadf9e3b5f3e0028d1ad0bd5c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/92eee6a82a9a6f9f83559e17a2b6b935e1a5cd25"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9bd94f67b27739bbe8583c52256502bd4cc7e83"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c5aa102b433b1890e1ccaa40c06826c77dda1665"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca500cf2eceb5a8e93bf71ab97b5f7a18ecabce2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53101,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:29.023,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: zero i_disksize when initializing the bootloader inode If the boot loader inode has never been used before, the EXT4_IOC_SWAP_BOOT inode will initialize it, including setting the i_size to 0. However, if the ""never before used"" boot loader has a non-zero i_size, then i_disksize will be non-zero, and the inconsistency between i_size and i_disksize can trigger a kernel warning: WARNING: CPU: 0 PID: 2580 at fs/ext4/file.c:319 CPU: 0 PID: 2580 Comm: bb Not tainted 6.3.0-rc1-00004-g703695902cfa RIP: 0010:ext4_file_write_iter+0xbc7/0xd10 Call Trace: vfs_write+0x3b1/0x5c0 ksys_write+0x77/0x160 __x64_sys_write+0x22/0x30 do_syscall_64+0x39/0x80 Reproducer: 1. create corrupted image and mount it: mke2fs -t ext4 /tmp/foo.img 200 debugfs -wR ""sif <5> size 25700"" /tmp/foo.img mount -t ext4 /tmp/foo.img /mnt cd /mnt echo 123 > file 2. Run the reproducer program: posix_memalign(&buf, 1024, 1024) fd = open(""file"", O_RDWR | O_DIRECT); ioctl(fd, EXT4_IOC_SWAP_BOOT); write(fd, buf, 1024); Fix this by setting i_disksize as well as i_size to zero when initiaizing the boot loader inode.",,,"[{""url"":""https://git.kernel.org/stable/c/01a821aacc64d4b05dafd239dbc9b7856686002f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0d8a6c9a6415999fee1259ccf1796480c026b7d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f00c476da8fe7c4c34ea16abb55d74127120413"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/59eee0cdf8c036f554add97a4da7c06d7a9ff34a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9cb27b1e76f0cc886ac09055bc41c0ab3f205167"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9e9a4cc5486356158554f6ad73027d8635a48b34"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d6c1447e483c05dbcfb3ff77ac04237a82070b8c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f5361da1e60d54ec81346aee8e3d8baf1be0b762"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53102,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:29.127,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ice: xsk: disable txq irq before flushing hw ice_qp_dis() intends to stop a given queue pair that is a target of xsk pool attach/detach. One of the steps is to disable interrupts on these queues. It currently is broken in a way that txq irq is turned off *after* HW flush which in turn takes no effect. ice_qp_dis(): -> ice_qvec_dis_irq() --> disable rxq irq --> flush hw -> ice_vsi_stop_tx_ring() -->disable txq irq Below splat can be triggered by following steps: - start xdpsock WITHOUT loading xdp prog - run xdp_rxq_info with XDP_TX action on this interface - start traffic - terminate xdpsock [ 256.312485] BUG: kernel NULL pointer dereference, address: 0000000000000018 [ 256.319560] #PF: supervisor read access in kernel mode [ 256.324775] #PF: error_code(0x0000) - not-present page [ 256.329994] PGD 0 P4D 0 [ 256.332574] Oops: 0000 [#1] PREEMPT SMP NOPTI [ 256.337006] CPU: 3 PID: 32 Comm: ksoftirqd/3 Tainted: G OE 6.2.0-rc5+ #51 [ 256.345218] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0008.031920191559 03/19/2019 [ 256.355807] RIP: 0010:ice_clean_rx_irq_zc+0x9c/0x7d0 [ice] [ 256.361423] Code: b7 8f 8a 00 00 00 66 39 ca 0f 84 f1 04 00 00 49 8b 47 40 4c 8b 24 d0 41 0f b7 45 04 66 25 ff 3f 66 89 04 24 0f 84 85 02 00 00 <49> 8b 44 24 18 0f b7 14 24 48 05 00 01 00 00 49 89 04 24 49 89 44 [ 256.380463] RSP: 0018:ffffc900088bfd20 EFLAGS: 00010206 [ 256.385765] RAX: 000000000000003c RBX: 0000000000000035 RCX: 000000000000067f [ 256.393012] RDX: 0000000000000775 RSI: 0000000000000000 RDI: ffff8881deb3ac80 [ 256.400256] RBP: 000000000000003c R08: ffff889847982710 R09: 0000000000010000 [ 256.407500] R10: ffffffff82c060c0 R11: 0000000000000004 R12: 0000000000000000 [ 256.414746] R13: ffff88811165eea0 R14: ffffc9000d255000 R15: ffff888119b37600 [ 256.421990] FS: 0000000000000000(0000) GS:ffff8897e0cc0000(0000) knlGS:0000000000000000 [ 256.430207] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 256.436036] CR2: 0000000000000018 CR3: 0000000005c0a006 CR4: 00000000007706e0 [ 256.443283] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 256.450527] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [ 256.457770] PKRU: 55555554 [ 256.460529] Call Trace: [ 256.463015] <TASK> [ 256.465157] ? ice_xmit_zc+0x6e/0x150 [ice] [ 256.469437] ice_napi_poll+0x46d/0x680 [ice] [ 256.473815] ? _raw_spin_unlock_irqrestore+0x1b/0x40 [ 256.478863] __napi_poll+0x29/0x160 [ 256.482409] net_rx_action+0x136/0x260 [ 256.486222] __do_softirq+0xe8/0x2e5 [ 256.489853] ? smpboot_thread_fn+0x2c/0x270 [ 256.494108] run_ksoftirqd+0x2a/0x50 [ 256.497747] smpboot_thread_fn+0x1c1/0x270 [ 256.501907] ? __pfx_smpboot_thread_fn+0x10/0x10 [ 256.506594] kthread+0xea/0x120 [ 256.509785] ? __pfx_kthread+0x10/0x10 [ 256.513597] ret_from_fork+0x29/0x50 [ 256.517238] </TASK> In fact, irqs were not disabled and napi managed to be scheduled and run while xsk_pool pointer was still valid, but SW ring of xdp_buff pointers was already freed. To fix this, call ice_qvec_dis_irq() after ice_vsi_stop_tx_ring(). Also while at it, remove redundant ice_clean_rx_ring() call - this is handled in ice_qp_clean_rings().",,,"[{""url"":""https://git.kernel.org/stable/c/243cde8de10894d7812c8a6b62653bf04d8f9700"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2ecc6e44959382f95c9d427cd8da85121a9cecda"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b830c9642386867863ac64295185f896ff2928ac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b89a453c6918e0f346fb0562e8c7812b94d28c73"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cccba1ff0798a27f7b8d0c06762ef977400a2afb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53103,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:29.223,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bonding: restore bond's IFF_SLAVE flag if a non-eth dev enslave fails syzbot reported a warning[1] where the bond device itself is a slave and we try to enslave a non-ethernet device as the first slave which fails but then in the error path when ether_setup() restores the bond device it also clears all flags. In my previous fix[2] I restored the IFF_MASTER flag, but I didn't consider the case that the bond device itself might also be a slave with IFF_SLAVE set, so we need to restore that flag as well. Use the bond_ether_setup helper which does the right thing and restores the bond's flags properly. Steps to reproduce using a nlmon dev: $ ip l add nlmon0 type nlmon $ ip l add bond1 type bond $ ip l add bond2 type bond $ ip l set bond1 master bond2 $ ip l set dev nlmon0 master bond1 $ ip -d l sh dev bond1 22: bond1: <BROADCAST,MULTICAST,MASTER> mtu 1500 qdisc noqueue master bond2 state DOWN mode DEFAULT group default qlen 1000 (now bond1's IFF_SLAVE flag is gone and we'll hit a warning[3] if we try to delete it) [1] https://syzkaller.appspot.com/bug?id=391c7b1f6522182899efba27d891f1743e8eb3ef [2] commit 7d5cd2ce5292 (""bonding: correctly handle bonding type change on enslave failure"") [3] example warning: [ 27.008664] bond1: (slave nlmon0): The slave device specified does not support setting the MAC address [ 27.008692] bond1: (slave nlmon0): Error -95 calling set_mac_address [ 32.464639] bond1 (unregistering): Released all slaves [ 32.464685] ------------[ cut here ]------------ [ 32.464686] WARNING: CPU: 1 PID: 2004 at net/core/dev.c:10829 unregister_netdevice_many+0x72a/0x780 [ 32.464694] Modules linked in: br_netfilter bridge bonding virtio_net [ 32.464699] CPU: 1 PID: 2004 Comm: ip Kdump: loaded Not tainted 5.18.0-rc3+ #47 [ 32.464703] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.1-2.fc37 04/01/2014 [ 32.464704] RIP: 0010:unregister_netdevice_many+0x72a/0x780 [ 32.464707] Code: 99 fd ff ff ba 90 1a 00 00 48 c7 c6 f4 02 66 96 48 c7 c7 20 4d 35 96 c6 05 fa c7 2b 02 01 e8 be 6f 4a 00 0f 0b e9 73 fd ff ff <0f> 0b e9 5f fd ff ff 80 3d e3 c7 2b 02 00 0f 85 3b fd ff ff ba 59 [ 32.464710] RSP: 0018:ffffa006422d7820 EFLAGS: 00010206 [ 32.464712] RAX: ffff8f6e077140a0 RBX: ffffa006422d7888 RCX: 0000000000000000 [ 32.464714] RDX: ffff8f6e12edbe58 RSI: 0000000000000296 RDI: ffffffff96d4a520 [ 32.464716] RBP: ffff8f6e07714000 R08: ffffffff96d63600 R09: ffffa006422d7728 [ 32.464717] R10: 0000000000000ec0 R11: ffffffff9698c988 R12: ffff8f6e12edb140 [ 32.464719] R13: dead000000000122 R14: dead000000000100 R15: ffff8f6e12edb140 [ 32.464723] FS: 00007f297c2f1740(0000) GS:ffff8f6e5d900000(0000) knlGS:0000000000000000 [ 32.464725] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 32.464726] CR2: 00007f297bf1c800 CR3: 00000000115e8000 CR4: 0000000000350ee0 [ 32.464730] Call Trace: [ 32.464763] <TASK> [ 32.464767] rtnl_dellink+0x13e/0x380 [ 32.464776] ? cred_has_capability.isra.0+0x68/0x100 [ 32.464780] ? __rtnl_unlock+0x33/0x60 [ 32.464783] ? bpf_lsm_capset+0x10/0x10 [ 32.464786] ? security_capable+0x36/0x50 [ 32.464790] rtnetlink_rcv_msg+0x14e/0x3b0 [ 32.464792] ? _copy_to_iter+0xb1/0x790 [ 32.464796] ? post_alloc_hook+0xa0/0x160 [ 32.464799] ? rtnl_calcit.isra.0+0x110/0x110 [ 32.464802] netlink_rcv_skb+0x50/0xf0 [ 32.464806] netlink_unicast+0x216/0x340 [ 32.464809] netlink_sendmsg+0x23f/0x480 [ 32.464812] sock_sendmsg+0x5e/0x60 [ 32.464815] ____sys_sendmsg+0x22c/0x270 [ 32.464818] ? import_iovec+0x17/0x20 [ 32.464821] ? sendmsg_copy_msghdr+0x59/0x90 [ 32.464823] ? do_set_pte+0xa0/0xe0 [ 32.464828] ___sys_sendmsg+0x81/0xc0 [ 32.464832] ? mod_objcg_state+0xc6/0x300 [ 32.464835] ? refill_obj_stock+0xa9/0x160 [ 32.464838] ? memcg_slab_free_hook+0x1a5/0x1f0 [ 32.464842] __sys_sendm ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/0276813b8ab08d9bf5ca4159f301d0829ecf13fc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/93c8cbeb1b2b8ff670b3dfd01b3abd843995c80f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e667d469098671261d558be0cd93dca4d285ce1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ecb1b5135bd3f232d5335b3935e2c2ac11bfa02f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53104,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:29.317,2025-05-08T11:15:51.903,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53105,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:29.430,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/mlx5e: Fix cleanup null-ptr deref on encap lock During module is unloaded while a peer tc flow is still offloaded, first the peer uplink rep profile is changed to a nic profile, and so neigh encap lock is destroyed. Next during unload, the VF reps netdevs are unregistered which causes the original non-peer tc flow to be deleted, which deletes the peer flow. The peer flow deletion detaches the encap entry and try to take the already destroyed encap lock, causing the below trace. Fix this by clearing peer flows during tc eswitch cleanup (mlx5e_tc_esw_cleanup()). Relevant trace: [ 4316.837128] BUG: kernel NULL pointer dereference, address: 00000000000001d8 [ 4316.842239] RIP: 0010:__mutex_lock+0xb5/0xc40 [ 4316.851897] Call Trace: [ 4316.852481] <TASK> [ 4316.857214] mlx5e_rep_neigh_entry_release+0x93/0x790 [mlx5_core] [ 4316.858258] mlx5e_rep_encap_entry_detach+0xa7/0xf0 [mlx5_core] [ 4316.859134] mlx5e_encap_dealloc+0xa3/0xf0 [mlx5_core] [ 4316.859867] clean_encap_dests.part.0+0x5c/0xe0 [mlx5_core] [ 4316.860605] mlx5e_tc_del_fdb_flow+0x32a/0x810 [mlx5_core] [ 4316.862609] __mlx5e_tc_del_fdb_peer_flow+0x1a2/0x250 [mlx5_core] [ 4316.863394] mlx5e_tc_del_flow+0x(/0x630 [mlx5_core] [ 4316.864090] mlx5e_flow_put+0x5f/0x100 [mlx5_core] [ 4316.864771] mlx5e_delete_flower+0x4de/0xa40 [mlx5_core] [ 4316.865486] tc_setup_cb_reoffload+0x20/0x80 [ 4316.865905] fl_reoffload+0x47c/0x510 [cls_flower] [ 4316.869181] tcf_block_playback_offloads+0x91/0x1d0 [ 4316.869649] tcf_block_unbind+0xe7/0x1b0 [ 4316.870049] tcf_block_offload_cmd.isra.0+0x1ee/0x270 [ 4316.879266] tcf_block_offload_unbind+0x61/0xa0 [ 4316.879711] __tcf_block_put+0xa4/0x310",,,"[{""url"":""https://git.kernel.org/stable/c/01fdaea410787fe372daeaeda93a29ed0606d334"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b7350f8dbe0c2a1d4d3ad7c35b610abd3cb91750"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c9668f0b1d28570327dbba189f2c61f6f9e43ae7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53106,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:29.520,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nfc: st-nci: Fix use after free bug in ndlc_remove due to race condition This bug influences both st_nci_i2c_remove and st_nci_spi_remove. Take st_nci_i2c_remove as an example. In st_nci_i2c_probe, it called ndlc_probe and bound &ndlc->sm_work with llt_ndlc_sm_work. When it calls ndlc_recv or timeout handler, it will finally call schedule_work to start the work. When we call st_nci_i2c_remove to remove the driver, there may be a sequence as follows: Fix it by finishing the work before cleanup in ndlc_remove CPU0 CPU1 |llt_ndlc_sm_work st_nci_i2c_remove | ndlc_remove | st_nci_remove | nci_free_device| kfree(ndev) | //free ndlc->ndev | |llt_ndlc_rcv_queue |nci_recv_frame |//use ndlc->ndev",,,"[{""url"":""https://git.kernel.org/stable/c/2156490c4b7cacda9a18ec99929940b8376dc0e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3405eb641dafcc8b28d174784b203c1622c121bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/43aa468df246175207a7d5d7d6d31b231f15b49c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5000fe6c27827a61d8250a7e4a1d26c3298ef4f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e331022b448fbc5e76f24349cd0246844dcad25"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/84dd9cc34014e3a3dcce0eb6d54b8a067e97676b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b0c202a8dc63008205a5d546559736507a9aae66"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f589e5b56c562d99ea74e05b1c3f0eab78aa17a3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53107,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:29.620,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: veth: Fix use after free in XDP_REDIRECT Commit 718a18a0c8a6 (""veth: Rework veth_xdp_rcv_skb in order to accept non-linear skb"") introduced a bug where it tried to use pskb_expand_head() if the headroom was less than XDP_PACKET_HEADROOM. This however uses kmalloc to expand the head, which will later allow consume_skb() to free the skb while is it still in use by AF_XDP. Previously if the headroom was less than XDP_PACKET_HEADROOM we continued on to allocate a new skb from pages so this restores that behavior. BUG: KASAN: use-after-free in __xsk_rcv+0x18d/0x2c0 Read of size 78 at addr ffff888976250154 by task napi/iconduit-g/148640 CPU: 5 PID: 148640 Comm: napi/iconduit-g Kdump: loaded Tainted: G O 6.1.4-cloudflare-kasan-2023.1.2 #1 Hardware name: Quanta Computer Inc. QuantaPlex T41S-2U/S2S-MB, BIOS S2S_3B10.03 06/21/2018 Call Trace: <TASK> dump_stack_lvl+0x34/0x48 print_report+0x170/0x473 ? __xsk_rcv+0x18d/0x2c0 kasan_report+0xad/0x130 ? __xsk_rcv+0x18d/0x2c0 kasan_check_range+0x149/0x1a0 memcpy+0x20/0x60 __xsk_rcv+0x18d/0x2c0 __xsk_map_redirect+0x1f3/0x490 ? veth_xdp_rcv_skb+0x89c/0x1ba0 [veth] xdp_do_redirect+0x5ca/0xd60 veth_xdp_rcv_skb+0x935/0x1ba0 [veth] ? __netif_receive_skb_list_core+0x671/0x920 ? veth_xdp+0x670/0x670 [veth] veth_xdp_rcv+0x304/0xa20 [veth] ? do_xdp_generic+0x150/0x150 ? veth_xdp_rcv_one+0xde0/0xde0 [veth] ? _raw_spin_lock_bh+0xe0/0xe0 ? newidle_balance+0x887/0xe30 ? __perf_event_task_sched_in+0xdb/0x800 veth_poll+0x139/0x571 [veth] ? veth_xdp_rcv+0xa20/0xa20 [veth] ? _raw_spin_unlock+0x39/0x70 ? finish_task_switch.isra.0+0x17e/0x7d0 ? __switch_to+0x5cf/0x1070 ? __schedule+0x95b/0x2640 ? io_schedule_timeout+0x160/0x160 __napi_poll+0xa1/0x440 napi_threaded_poll+0x3d1/0x460 ? __napi_poll+0x440/0x440 ? __kthread_parkme+0xc6/0x1f0 ? __napi_poll+0x440/0x440 kthread+0x2a2/0x340 ? kthread_complete_and_exit+0x20/0x20 ret_from_fork+0x22/0x30 </TASK> Freed by task 148640: kasan_save_stack+0x23/0x50 kasan_set_track+0x21/0x30 kasan_save_free_info+0x2a/0x40 ____kasan_slab_free+0x169/0x1d0 slab_free_freelist_hook+0xd2/0x190 __kmem_cache_free+0x1a1/0x2f0 skb_release_data+0x449/0x600 consume_skb+0x9f/0x1c0 veth_xdp_rcv_skb+0x89c/0x1ba0 [veth] veth_xdp_rcv+0x304/0xa20 [veth] veth_poll+0x139/0x571 [veth] __napi_poll+0xa1/0x440 napi_threaded_poll+0x3d1/0x460 kthread+0x2a2/0x340 ret_from_fork+0x22/0x30 The buggy address belongs to the object at ffff888976250000 which belongs to the cache kmalloc-2k of size 2048 The buggy address is located 340 bytes inside of 2048-byte region [ffff888976250000, ffff888976250800) The buggy address belongs to the physical page: page:00000000ae18262a refcount:2 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x976250 head:00000000ae18262a order:3 compound_mapcount:0 compound_pincount:0 flags: 0x2ffff800010200(slab|head|node=0|zone=2|lastcpupid=0x1ffff) raw: 002ffff800010200 0000000000000000 dead000000000122 ffff88810004cf00 raw: 0000000000000000 0000000080080008 00000002ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffff888976250000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ffff888976250080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb > ffff888976250100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ^ ffff888976250180: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ffff888976250200: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb",,,"[{""url"":""https://git.kernel.org/stable/c/6e755b56896df48b0fae0db275e148f8d8aa7d6f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/717d20710596b5b26595ede454d1105fa176f4a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c10131803e45269ddc6c817f19ed649110f3cae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53108,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:29.713,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/iucv: Fix size of interrupt data iucv_irq_data needs to be 4 bytes larger. These bytes are not used by the iucv module, but written by the z/VM hypervisor in case a CPU is deconfigured. Reported as: BUG dma-kmalloc-64 (Not tainted): kmalloc Redzone overwritten ----------------------------------------------------------------------------- 0x0000000000400564-0x0000000000400567 @offset=1380. First byte 0x80 instead of 0xcc Allocated in iucv_cpu_prepare+0x44/0xd0 age=167839 cpu=2 pid=1 __kmem_cache_alloc_node+0x166/0x450 kmalloc_node_trace+0x3a/0x70 iucv_cpu_prepare+0x44/0xd0 cpuhp_invoke_callback+0x156/0x2f0 cpuhp_issue_call+0xf0/0x298 __cpuhp_setup_state_cpuslocked+0x136/0x338 __cpuhp_setup_state+0xf4/0x288 iucv_init+0xf4/0x280 do_one_initcall+0x78/0x390 do_initcalls+0x11a/0x140 kernel_init_freeable+0x25e/0x2a0 kernel_init+0x2e/0x170 __ret_from_fork+0x3c/0x58 ret_from_fork+0xa/0x40 Freed in iucv_init+0x92/0x280 age=167839 cpu=2 pid=1 __kmem_cache_free+0x308/0x358 iucv_init+0x92/0x280 do_one_initcall+0x78/0x390 do_initcalls+0x11a/0x140 kernel_init_freeable+0x25e/0x2a0 kernel_init+0x2e/0x170 __ret_from_fork+0x3c/0x58 ret_from_fork+0xa/0x40 Slab 0x0000037200010000 objects=32 used=30 fp=0x0000000000400640 flags=0x1ffff00000010200(slab|head|node=0|zone=0| Object 0x0000000000400540 @offset=1344 fp=0x0000000000000000 Redzone 0000000000400500: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc ................ Redzone 0000000000400510: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc ................ Redzone 0000000000400520: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc ................ Redzone 0000000000400530: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc ................ Object 0000000000400540: 00 01 00 03 00 00 00 00 00 00 00 00 00 00 00 00 ................ Object 0000000000400550: f3 86 81 f2 f4 82 f8 82 f0 f0 f0 f0 f0 f0 f0 f2 ................ Object 0000000000400560: 00 00 00 00 80 00 00 00 cc cc cc cc cc cc cc cc ................ Object 0000000000400570: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc ................ Redzone 0000000000400580: cc cc cc cc cc cc cc cc ........ Padding 00000000004005d4: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a ZZZZZZZZZZZZZZZZ Padding 00000000004005e4: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a ZZZZZZZZZZZZZZZZ Padding 00000000004005f4: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a ZZZZZZZZZZZZ CPU: 6 PID: 121030 Comm: 116-pai-crypto. Not tainted 6.3.0-20230221.rc0.git4.99b8246b2d71.300.fc37.s390x+debug #1 Hardware name: IBM 3931 A01 704 (z/VM 7.3.0) Call Trace: [<000000032aa034ec>] dump_stack_lvl+0xac/0x100 [<0000000329f5a6cc>] check_bytes_and_report+0x104/0x140 [<0000000329f5aa78>] check_object+0x370/0x3c0 [<0000000329f5ede6>] free_debug_processing+0x15e/0x348 [<0000000329f5f06a>] free_to_partial_list+0x9a/0x2f0 [<0000000329f5f4a4>] __slab_free+0x1e4/0x3a8 [<0000000329f61768>] __kmem_cache_free+0x308/0x358 [<000000032a91465c>] iucv_cpu_dead+0x6c/0x88 [<0000000329c2fc66>] cpuhp_invoke_callback+0x156/0x2f0 [<000000032aa062da>] _cpu_down.constprop.0+0x22a/0x5e0 [<0000000329c3243e>] cpu_device_down+0x4e/0x78 [<000000032a61dee0>] device_offline+0xc8/0x118 [<000000032a61e048>] online_store+0x60/0xe0 [<000000032a08b6b0>] kernfs_fop_write_iter+0x150/0x1e8 [<0000000329fab65c>] vfs_write+0x174/0x360 [<0000000329fab9fc>] ksys_write+0x74/0x100 [<000000032aa03a5a>] __do_syscall+0x1da/0x208 [<000000032aa177b2>] system_call+0x82/0xb0 INFO: lockdep is turned off. FIX dma-kmalloc-64: Restoring kmalloc Redzone 0x0000000000400564-0x0000000000400567=0xcc FIX dma-kmalloc-64: Object at 0x0000000000400540 not freed",,,"[{""url"":""https://git.kernel.org/stable/c/3cfdefdaaa4b2a77e84d0db5e0a47a7aa3bb615a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3d87debb8ed2649608ff432699e7c961c0c6f03b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/71da5991b6438ad6da13ceb25465ee2760a1c52f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/93a970494881004c348d8feb38463ee72496e99a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a908eae0f71811afee86be7088692f1aa5855c3b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b0d2bb5e31a693ebc8888eb407f8a257a3680efa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd2e78462ae18484e55ae4d285df2c86b86bdd12"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c78f1345db4e4b3b78f9b768f4074ebd60abe966"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53109,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:29.823,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: tunnels: annotate lockless accesses to dev->needed_headroom IP tunnels can apparently update dev->needed_headroom in their xmit path. This patch takes care of three tunnels xmit, and also the core LL_RESERVED_SPACE() and LL_RESERVED_SPACE_EXTRA() helpers. More changes might be needed for completeness. BUG: KCSAN: data-race in ip_tunnel_xmit / ip_tunnel_xmit read to 0xffff88815b9da0ec of 2 bytes by task 888 on cpu 1: ip_tunnel_xmit+0x1270/0x1730 net/ipv4/ip_tunnel.c:803 __gre_xmit net/ipv4/ip_gre.c:469 [inline] ipgre_xmit+0x516/0x570 net/ipv4/ip_gre.c:661 __netdev_start_xmit include/linux/netdevice.h:4881 [inline] netdev_start_xmit include/linux/netdevice.h:4895 [inline] xmit_one net/core/dev.c:3580 [inline] dev_hard_start_xmit+0x127/0x400 net/core/dev.c:3596 __dev_queue_xmit+0x1007/0x1eb0 net/core/dev.c:4246 dev_queue_xmit include/linux/netdevice.h:3051 [inline] neigh_direct_output+0x17/0x20 net/core/neighbour.c:1623 neigh_output include/net/neighbour.h:546 [inline] ip_finish_output2+0x740/0x840 net/ipv4/ip_output.c:228 ip_finish_output+0xf4/0x240 net/ipv4/ip_output.c:316 NF_HOOK_COND include/linux/netfilter.h:291 [inline] ip_output+0xe5/0x1b0 net/ipv4/ip_output.c:430 dst_output include/net/dst.h:444 [inline] ip_local_out+0x64/0x80 net/ipv4/ip_output.c:126 iptunnel_xmit+0x34a/0x4b0 net/ipv4/ip_tunnel_core.c:82 ip_tunnel_xmit+0x1451/0x1730 net/ipv4/ip_tunnel.c:813 __gre_xmit net/ipv4/ip_gre.c:469 [inline] ipgre_xmit+0x516/0x570 net/ipv4/ip_gre.c:661 __netdev_start_xmit include/linux/netdevice.h:4881 [inline] netdev_start_xmit include/linux/netdevice.h:4895 [inline] xmit_one net/core/dev.c:3580 [inline] dev_hard_start_xmit+0x127/0x400 net/core/dev.c:3596 __dev_queue_xmit+0x1007/0x1eb0 net/core/dev.c:4246 dev_queue_xmit include/linux/netdevice.h:3051 [inline] neigh_direct_output+0x17/0x20 net/core/neighbour.c:1623 neigh_output include/net/neighbour.h:546 [inline] ip_finish_output2+0x740/0x840 net/ipv4/ip_output.c:228 ip_finish_output+0xf4/0x240 net/ipv4/ip_output.c:316 NF_HOOK_COND include/linux/netfilter.h:291 [inline] ip_output+0xe5/0x1b0 net/ipv4/ip_output.c:430 dst_output include/net/dst.h:444 [inline] ip_local_out+0x64/0x80 net/ipv4/ip_output.c:126 iptunnel_xmit+0x34a/0x4b0 net/ipv4/ip_tunnel_core.c:82 ip_tunnel_xmit+0x1451/0x1730 net/ipv4/ip_tunnel.c:813 __gre_xmit net/ipv4/ip_gre.c:469 [inline] ipgre_xmit+0x516/0x570 net/ipv4/ip_gre.c:661 __netdev_start_xmit include/linux/netdevice.h:4881 [inline] netdev_start_xmit include/linux/netdevice.h:4895 [inline] xmit_one net/core/dev.c:3580 [inline] dev_hard_start_xmit+0x127/0x400 net/core/dev.c:3596 __dev_queue_xmit+0x1007/0x1eb0 net/core/dev.c:4246 dev_queue_xmit include/linux/netdevice.h:3051 [inline] neigh_direct_output+0x17/0x20 net/core/neighbour.c:1623 neigh_output include/net/neighbour.h:546 [inline] ip_finish_output2+0x740/0x840 net/ipv4/ip_output.c:228 ip_finish_output+0xf4/0x240 net/ipv4/ip_output.c:316 NF_HOOK_COND include/linux/netfilter.h:291 [inline] ip_output+0xe5/0x1b0 net/ipv4/ip_output.c:430 dst_output include/net/dst.h:444 [inline] ip_local_out+0x64/0x80 net/ipv4/ip_output.c:126 iptunnel_xmit+0x34a/0x4b0 net/ipv4/ip_tunnel_core.c:82 ip_tunnel_xmit+0x1451/0x1730 net/ipv4/ip_tunnel.c:813 __gre_xmit net/ipv4/ip_gre.c:469 [inline] ipgre_xmit+0x516/0x570 net/ipv4/ip_gre.c:661 __netdev_start_xmit include/linux/netdevice.h:4881 [inline] netdev_start_xmit include/linux/netdevice.h:4895 [inline] xmit_one net/core/dev.c:3580 [inline] dev_hard_start_xmit+0x127/0x400 net/core/dev.c:3596 __dev_queue_xmit+0x1007/0x1eb0 net/core/dev.c:4246 dev_queue_xmit include/linux/netdevice.h:3051 [inline] neigh_direct_output+0x17/0x20 net/core/neighbour.c:1623 neigh_output include/net/neighbour.h:546 [inline] ip_finish_output2+0x740/0x840 net/ipv4/ip_output.c:228 ip_finish_output+0xf4/0x240 net/ipv4/ip_output.c:316 NF_HOOK_COND include/linux/netfilter.h:291 [inline] ip_output+0xe5/0x1b0 net/i ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/4b397c06cb987935b1b097336532aa6b4210e091"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/51f3bd3765bc5ca4583af07a00833da00d2ace1d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5aaab217c8f5387b9c5fff9e940d80f135e04366"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e206f66d824b3b28a7f9ee1366dfc79a937bb46"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9b86a8702b042ee4e15d2d46375be873a6a8834f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a69b72b57b7d269e833e520ba7500d556e8189b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be59b87ee4aed81db7c10e44f603866a0ac3ca5d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e0a557fc1daf5c1086e47150a4571aebadbb62be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53110,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:29.930,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/smc: fix NULL sndbuf_desc in smc_cdc_tx_handler() When performing a stress test on SMC-R by rmmod mlx5_ib driver during the wrk/nginx test, we found that there is a probability of triggering a panic while terminating all link groups. This issue dues to the race between smc_smcr_terminate_all() and smc_buf_create(). smc_smcr_terminate_all smc_buf_create /* init */ conn->sndbuf_desc = NULL; ... __smc_lgr_terminate smc_conn_kill smc_close_abort smc_cdc_get_slot_and_msg_send __softirqentry_text_start smc_wr_tx_process_cqe smc_cdc_tx_handler READ(conn->sndbuf_desc->len); /* panic dues to NULL sndbuf_desc */ conn->sndbuf_desc = xxx; This patch tries to fix the issue by always to check the sndbuf_desc before send any cdc msg, to make sure that no null pointer is seen during cqe processing.",,,"[{""url"":""https://git.kernel.org/stable/c/22a825c541d775c1dbe7b2402786025acad6727b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/31817c530768b0199771ec6019571b4f0ddbf230"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3c270435db8aa34929263dddae8fd050f5216ecb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ebac7cf0a184a8102821a7a00203f02bebda83c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b108bd9e6be000492ebebe867daa699285978a10"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53111,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:30.027,2025-05-05T20:54:45.973,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: loop: Fix use-after-free issues do_req_filebacked() calls blk_mq_complete_request() synchronously or asynchronously when using asynchronous I/O unless memory allocation fails. Hence, modify loop_handle_cmd() such that it does not dereference 'cmd' nor 'rq' after do_req_filebacked() finished unless we are sure that the request has not yet been completed. This patch fixes the following kernel crash: Unable to handle kernel NULL pointer dereference at virtual address 0000000000000054 Call trace: css_put.42938+0x1c/0x1ac loop_process_work+0xc8c/0xfd4 loop_rootcg_workfn+0x24/0x34 process_one_work+0x244/0x558 worker_thread+0x400/0x8fc kthread+0x16c/0x1e0 ret_from_fork+0x10/0x20",,,"[{""url"":""https://git.kernel.org/stable/c/407badf73ec9fb0d5744bf2ca1745c1818aa222f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6917395c4667cfb607ed8bf1826205a59414657c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9b0cb770f5d7b1ff40bea7ca385438ee94570eec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3fda704903f6d1fc351412f1bc6620333959ada"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53112,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:30.140,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/i915/sseu: fix max_subslices array-index-out-of-bounds access It seems that commit bc3c5e0809ae (""drm/i915/sseu: Don't try to store EU mask internally in UAPI format"") exposed a potential out-of-bounds access, reported by UBSAN as following on a laptop with a gen 11 i915 card: UBSAN: array-index-out-of-bounds in drivers/gpu/drm/i915/gt/intel_sseu.c:65:27 index 6 is out of range for type 'u16 [6]' CPU: 2 PID: 165 Comm: systemd-udevd Not tainted 6.2.0-9-generic #9-Ubuntu Hardware name: Dell Inc. XPS 13 9300/077Y9N, BIOS 1.11.0 03/22/2022 Call Trace: <TASK> show_stack+0x4e/0x61 dump_stack_lvl+0x4a/0x6f dump_stack+0x10/0x18 ubsan_epilogue+0x9/0x3a __ubsan_handle_out_of_bounds.cold+0x42/0x47 gen11_compute_sseu_info+0x121/0x130 [i915] intel_sseu_info_init+0x15d/0x2b0 [i915] intel_gt_init_mmio+0x23/0x40 [i915] i915_driver_mmio_probe+0x129/0x400 [i915] ? intel_gt_probe_all+0x91/0x2e0 [i915] i915_driver_probe+0xe1/0x3f0 [i915] ? drm_privacy_screen_get+0x16d/0x190 [drm] ? acpi_dev_found+0x64/0x80 i915_pci_probe+0xac/0x1b0 [i915] ... According to the definition of sseu_dev_info, eu_mask->hsw is limited to a maximum of GEN_MAX_SS_PER_HSW_SLICE (6) sub-slices, but gen11_sseu_info_init() can potentially set 8 sub-slices, in the !IS_JSL_EHL(gt->i915) case. Fix this by reserving up to 8 slots for max_subslices in the eu_mask struct. (cherry picked from commit 3cba09a6ac86ea1d456909626eb2685596c07822)",,,"[{""url"":""https://git.kernel.org/stable/c/193c41926d152761764894f46e23b53c00186a82"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1a1682abf7399318ac074b1f2ac6a8c992b5b3da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/36b076ab6247cf0d2135b2ad6bb337617c3b5a1b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53113,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:30.407,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: nl80211: fix NULL-ptr deref in offchan check If, e.g. in AP mode, the link was already created by userspace but not activated yet, it has a chandef but the chandef isn't valid and has no channel. Check for this and ignore this link.",,,"[{""url"":""https://git.kernel.org/stable/c/201a836c2385fdd2b9d0a8e7737bba5b26f1863a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/87e80ea4fbc9ce2f2005905fdbcd38baaa47463a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f624bb6fad23df3270580b4fcef415c6e7bf7705"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53114,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:30.493,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: i40e: Fix kernel crash during reboot when adapter is in recovery mode If the driver detects during probe that firmware is in recovery mode then i40e_init_recovery_mode() is called and the rest of probe function is skipped including pci_set_drvdata(). Subsequent i40e_shutdown() called during shutdown/reboot dereferences NULL pointer as pci_get_drvdata() returns NULL. To fix call pci_set_drvdata() also during entering to recovery mode. Reproducer: 1) Lets have i40e NIC with firmware in recovery mode 2) Run reboot Result: [ 139.084698] i40e: Intel(R) Ethernet Connection XL710 Network Driver [ 139.090959] i40e: Copyright (c) 2013 - 2019 Intel Corporation. [ 139.108438] i40e 0000:02:00.0: Firmware recovery mode detected. Limiting functionality. [ 139.116439] i40e 0000:02:00.0: Refer to the Intel(R) Ethernet Adapters and Devices User Guide for details on firmware recovery mode. [ 139.129499] i40e 0000:02:00.0: fw 8.3.64775 api 1.13 nvm 8.30 0x8000b78d 1.3106.0 [8086:1583] [15d9:084a] [ 139.215932] i40e 0000:02:00.0 enp2s0f0: renamed from eth0 [ 139.223292] i40e 0000:02:00.1: Firmware recovery mode detected. Limiting functionality. [ 139.231292] i40e 0000:02:00.1: Refer to the Intel(R) Ethernet Adapters and Devices User Guide for details on firmware recovery mode. [ 139.244406] i40e 0000:02:00.1: fw 8.3.64775 api 1.13 nvm 8.30 0x8000b78d 1.3106.0 [8086:1583] [15d9:084a] [ 139.329209] i40e 0000:02:00.1 enp2s0f1: renamed from eth0 ... [ 156.311376] BUG: kernel NULL pointer dereference, address: 00000000000006c2 [ 156.318330] #PF: supervisor write access in kernel mode [ 156.323546] #PF: error_code(0x0002) - not-present page [ 156.328679] PGD 0 P4D 0 [ 156.331210] Oops: 0002 [#1] PREEMPT SMP NOPTI [ 156.335567] CPU: 26 PID: 15119 Comm: reboot Tainted: G E 6.2.0+ #1 [ 156.343126] Hardware name: Abacus electric, s.r.o. - servis@abacus.cz Super Server/H12SSW-iN, BIOS 2.4 04/13/2022 [ 156.353369] RIP: 0010:i40e_shutdown+0x15/0x130 [i40e] [ 156.358430] Code: c1 fc ff ff 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 0f 1f 44 00 00 55 48 89 fd 53 48 8b 9f 48 01 00 00 <f0> 80 8b c2 06 00 00 04 f0 80 8b c0 06 00 00 08 48 8d bb 08 08 00 [ 156.377168] RSP: 0018:ffffb223c8447d90 EFLAGS: 00010282 [ 156.382384] RAX: ffffffffc073ee70 RBX: 0000000000000000 RCX: 0000000000000001 [ 156.389510] RDX: 0000000080000001 RSI: 0000000000000246 RDI: ffff95db49988000 [ 156.396634] RBP: ffff95db49988000 R08: ffffffffffffffff R09: ffffffff8bd17d40 [ 156.403759] R10: 0000000000000001 R11: ffffffff8a5e3d28 R12: ffff95db49988000 [ 156.410882] R13: ffffffff89a6fe17 R14: ffff95db49988150 R15: 0000000000000000 [ 156.418007] FS: 00007fe7c0cc3980(0000) GS:ffff95ea8ee80000(0000) knlGS:0000000000000000 [ 156.426083] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 156.431819] CR2: 00000000000006c2 CR3: 00000003092fc005 CR4: 0000000000770ee0 [ 156.438944] PKRU: 55555554 [ 156.441647] Call Trace: [ 156.444096] <TASK> [ 156.446199] pci_device_shutdown+0x38/0x60 [ 156.450297] device_shutdown+0x163/0x210 [ 156.454215] kernel_restart+0x12/0x70 [ 156.457872] __do_sys_reboot+0x1ab/0x230 [ 156.461789] ? vfs_writev+0xa6/0x1a0 [ 156.465362] ? __pfx_file_free_rcu+0x10/0x10 [ 156.469635] ? __call_rcu_common.constprop.85+0x109/0x5a0 [ 156.475034] do_syscall_64+0x3e/0x90 [ 156.478611] entry_SYSCALL_64_after_hwframe+0x72/0xdc [ 156.483658] RIP: 0033:0x7fe7bff37ab7",,,"[{""url"":""https://git.kernel.org/stable/c/3cbecb1c9085a00155639404f7addbcbfc987ba3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4ff82695266576a0b4f1077a7100b2451e476df4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6e18f66b704bd725196508c1db93bf7338cdc8de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7e4f8a0c495413a50413e8c9f1032ce1bc633bae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3826fb3ea14646b3d4e6309bfc384b349f36eb6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c703362a66ea971905b9dc153fc54d1b6ac05423"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53115,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:30.590,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: mpi3mr: Fix memory leaks in mpi3mr_init_ioc() Don't allocate memory again when IOC is being reinitialized.",,,"[{""url"":""https://git.kernel.org/stable/c/5aab9342f12f980b64617a034d121efbbf09100a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7277b4eec2f25a0653646ba95b1f25fa16be1d6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c798304470cab88723d895726d17fcb96472e0e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53116,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:30.680,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nvmet: avoid potential UAF in nvmet_req_complete() An nvme target ->queue_response() operation implementation may free the request passed as argument. Such implementation potentially could result in a use after free of the request pointer when percpu_ref_put() is called in nvmet_req_complete(). Avoid such problem by using a local variable to save the sq pointer before calling __nvmet_req_complete(), thus avoiding dereferencing the req pointer after that function call.",,,"[{""url"":""https://git.kernel.org/stable/c/04c394208831d5e0d5cfee46722eb0f033cd4083"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6173a77b7e9d3e202bdb9897b23f2a8afe7bf286"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ed9813871038b25a934b21ab76b5b7dbf44fc3a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6317235da8aa7cb97529ebc8121cc2a4c4c437a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bcd535f07c58342302a2cd2bdd8894fe0872c8a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e5d99b29012bbf0e86929403209723b2806500c1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f1d5888a5efe345b63c430b256e95acb0a475642"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fafcb4b26393870c45462f9af6a48e581dbbcf7e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53117,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:30.783,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fs: prevent out-of-bounds array speculation when closing a file descriptor Google-Bug-Id: 114199369",,,"[{""url"":""https://git.kernel.org/stable/c/3d5d9501b634fd268eb56428cda92cd317752d69"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/609d54441493c99f21c1823dfd66fa7f4c512ff4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6631c8da02cfad96c53b217cf647b511c7f34faf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a759905de9cd6ec9ca08ceadf0920272772ed830"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cec08b7d1ebcd3138d4658b3868ce26aeb1e8e06"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eea8e4e056a5ffbeb539a13854c017d5d62c756a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f31cd5da636682caea424fa1c22679016cbfc16b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8cd8754a03a3748384ee438c572423643c9c315"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53118,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:30.880,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: core: Fix a procfs host directory removal regression scsi_proc_hostdir_rm() decreases a reference counter and hence must only be called once per host that is removed. This change does not require a scsi_add_host_with_dma() change since scsi_add_host_with_dma() will return 0 (success) if scsi_proc_host_add() is called.",,,"[{""url"":""https://git.kernel.org/stable/c/2a764d55e938743efa7c2cba7305633bcf227f09"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/68c665bb185037e7eb66fb792c61da9d7151e99c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73f030d4ef6d1ad17f824a0a2eb637ef7a9c7d51"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7e0ae8667fcdd99d1756922e1140cac75f5fa279"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/88c3d3bb6469cea929ac68fd326bdcbefcdfdd83"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be03df3d4bfe7e8866d4aa43d62e648ffe884f5f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53119,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:30.980,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nfc: pn533: initialize struct pn533_out_arg properly struct pn533_out_arg used as a temporary context for out_urb is not initialized properly. Its uninitialized 'phy' field can be dereferenced in error cases inside pn533_out_complete() callback function. It causes the following failure: general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007] CPU: 1 PID: 0 Comm: swapper/1 Not tainted 6.2.0-rc3-next-20230110-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022 RIP: 0010:pn533_out_complete.cold+0x15/0x44 drivers/nfc/pn533/usb.c:441 Call Trace: <IRQ> __usb_hcd_giveback_urb+0x2b6/0x5c0 drivers/usb/core/hcd.c:1671 usb_hcd_giveback_urb+0x384/0x430 drivers/usb/core/hcd.c:1754 dummy_timer+0x1203/0x32d0 drivers/usb/gadget/udc/dummy_hcd.c:1988 call_timer_fn+0x1da/0x800 kernel/time/timer.c:1700 expire_timers+0x234/0x330 kernel/time/timer.c:1751 __run_timers kernel/time/timer.c:2022 [inline] __run_timers kernel/time/timer.c:1995 [inline] run_timer_softirq+0x326/0x910 kernel/time/timer.c:2035 __do_softirq+0x1fb/0xaf6 kernel/softirq.c:571 invoke_softirq kernel/softirq.c:445 [inline] __irq_exit_rcu+0x123/0x180 kernel/softirq.c:650 irq_exit_rcu+0x9/0x20 kernel/softirq.c:662 sysvec_apic_timer_interrupt+0x97/0xc0 arch/x86/kernel/apic/apic.c:1107 Initialize the field with the pn533_usb_phy currently used. Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",,,"[{""url"":""https://git.kernel.org/stable/c/0f9c1f26d434c32520dfe33326b28c5954bc4299"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2703da78849c47b6b5b4471edb35fc7b7f91dead"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2bd1ed6d607d7013ed4959e86990a04f028543ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2bee84369b76f6c9ef71938069c65a6ebd1a12f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2cbd4213baf7be5d87d183e2032c54003de0790f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/484b7059796e3bc1cb527caa61dfc60da649b4f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4c20a07ed26a71a8ccc9c6d935fc181573f5462e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a97ef110c491b72c138111a595a3a3af56cbc94c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53120,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.083,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: mpi3mr: Fix config page DMA memory leak A fix for: DMA-API: pci 0000:83:00.0: device driver has pending DMA allocations while released from device [count=1]",,,"[{""url"":""https://git.kernel.org/stable/c/5fc4d698ed4b6507be2eb36d040a678adcb89da4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7d2b02172b6a2ae6aecd7ef6480b9c4bf3dc59f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dca06ccf13de14e144d34f158f73ae0032f80e63"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53121,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.173,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tcp: tcp_make_synack() can be called from process context tcp_rtx_synack() now could be called in process context as explained in 0a375c822497 (""tcp: tcp_rtx_synack() can be called from process context""). tcp_rtx_synack() might call tcp_make_synack(), which will touch per-CPU variables with preemption enabled. This causes the following BUG: BUG: using __this_cpu_add() in preemptible [00000000] code: ThriftIO1/5464 caller is tcp_make_synack+0x841/0xac0 Call Trace: <TASK> dump_stack_lvl+0x10d/0x1a0 check_preemption_disabled+0x104/0x110 tcp_make_synack+0x841/0xac0 tcp_v6_send_synack+0x5c/0x450 tcp_rtx_synack+0xeb/0x1f0 inet_rtx_syn_ack+0x34/0x60 tcp_check_req+0x3af/0x9e0 tcp_rcv_state_process+0x59b/0x2030 tcp_v6_do_rcv+0x5f5/0x700 release_sock+0x3a/0xf0 tcp_sendmsg+0x33/0x40 ____sys_sendmsg+0x2f2/0x490 __sys_sendmsg+0x184/0x230 do_syscall_64+0x3d/0x90 Avoid calling __TCP_INC_STATS() with will touch per-cpu variables. Use TCP_INC_STATS() which is safe to be called from context switch.",,,"[{""url"":""https://git.kernel.org/stable/c/442aa78ed70188b21ccd8669738448702c0a3281"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7613cde8c0c1f02a7ec2e1d536c01b65b135fc1c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/77ad58bca0119e8cc3e0e9d91a3f22caa66e4dfa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9180aa4622a720b433e842b4d3aa34d73eec577a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad07290d63ff6689f50565b02f5b6f34ec15a5ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bced3f7db95ff2e6ca29dc4d1c9751ab5e736a09"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d493d4fe88195a144d6a277a90062a7534ed2192"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e23ca307745be3df7fe9762f3e2a7e311a57852e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53122,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.270,2025-05-08T11:15:52.123,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53123,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.360,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: PCI: s390: Fix use-after-free of PCI resources with per-function hotplug On s390 PCI functions may be hotplugged individually even when they belong to a multi-function device. In particular on an SR-IOV device VFs may be removed and later re-added. In commit a50297cf8235 (""s390/pci: separate zbus creation from scanning"") it was missed however that struct pci_bus and struct zpci_bus's resource list retained a reference to the PCI functions MMIO resources even though those resources are released and freed on hot-unplug. These stale resources may subsequently be claimed when the PCI function re-appears resulting in use-after-free. One idea of fixing this use-after-free in s390 specific code that was investigated was to simply keep resources around from the moment a PCI function first appeared until the whole virtual PCI bus created for a multi-function device disappears. The problem with this however is that due to the requirement of artificial MMIO addreesses (address cookies) extra logic is then needed to keep the address cookies compatible on re-plug. At the same time the MMIO resources semantically belong to the PCI function so tying their lifecycle to the function seems more logical. Instead a simpler approach is to remove the resources of an individually hot-unplugged PCI function from the PCI bus's resource list while keeping the resources of other PCI functions on the PCI bus untouched. This is done by introducing pci_bus_remove_resource() to remove an individual resource. Similarly the resource also needs to be removed from the struct zpci_bus's resource list. It turns out however, that there is really no need to add the MMIO resources to the struct zpci_bus's resource list at all and instead we can simply use the zpci_bar_struct's resource pointer directly.",,,"[{""url"":""https://git.kernel.org/stable/c/437bb839e36cc9f35adc6d2a2bf113b7a0fc9985"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a2410d0c3d2d714ed968a135dfcbed6aa3ff7027"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ab909509850b27fd39b8ba99e44cda39dbc3858c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b99ebf4b62774e690e73a551cf5fbf6f219bdd96"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53124,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.453,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: mpt3sas: Fix NULL pointer access in mpt3sas_transport_port_add() Port is allocated by sas_port_alloc_num() and rphy is allocated by either sas_end_device_alloc() or sas_expander_alloc(), all of which may return NULL. So we need to check the rphy to avoid possible NULL pointer access. If sas_rphy_add() returned with failure, rphy is set to NULL. We would access the rphy in the following lines which would also result NULL pointer access.",,,"[{""url"":""https://git.kernel.org/stable/c/090305c36185c0547e4441d4c08f1cf096b32134"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6f0c2f70d9929208d8427ec72c3ed91e2251e289"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9937f784a608944107dcc2ba9a9c3333f8330b9e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a26c775ccc4cfe46f9b718b51bd24313053c7e0b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b5e5bbb3fa5f8412e96c5eda7f4a4af6241d6bd3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3c57724f1569311e4b81e98fad0931028b9bdcd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53125,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.547,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: usb: smsc75xx: Limit packet length to skb->len Packet length retrieved from skb data may be larger than the actual socket buffer length (up to 9026 bytes). In such case the cloned skb passed up the network stack will leak kernel memory contents.",,,"[{""url"":""https://git.kernel.org/stable/c/105db6574281e1e03fcbf87983f4fee111682306"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4a4de0a68b18485c68ab4f0cfa665b1633c6d277"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/53966d572d056d6b234cfe76a5f9d60049d3c178"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ee5df9c039e37b9d8eb5e3de08bfb7f53d31cb6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9fabdd79051a9fe51388df099aff6e4b660fedd2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c7bdc137ca163b90917c1eeba4f1937684bd4f8b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d8b228318935044dafe3a5bc07ee71a1f1424b8d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e294f0aa47e4844f3d3c8766c02accd5a76a7d4e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53126,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.643,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: mpi3mr: Fix sas_hba.phy memory leak in mpi3mr_remove() Free mrioc->sas_hba.phy at .remove.",,,"[{""url"":""https://git.kernel.org/stable/c/480aae2f30637b5140e9c7a9b10298e538df2b5e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c60a7c7508645a9f36e4a18a5f548fb79378acd1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d4caa1a4255cc44be56bcab3db2c97c632e6cc10"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53127,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.730,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: mpi3mr: Fix expander node leak in mpi3mr_remove() Add a missing resource clean up in .remove.",,,"[{""url"":""https://git.kernel.org/stable/c/0023972a7593720f8878aed06c03ac9e541078be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce756daa36e1ba271bb3334267295e447aa57a5c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cf9777be5683c5e55680c089df02ee27d2226aa8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53128,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.820,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: mpi3mr: Fix throttle_groups memory leak Add a missing kfree().",,,"[{""url"":""https://git.kernel.org/stable/c/574cc10edaa7dba833764efed8c57ee0e6bf7574"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/85349a227eb4a56520adc190c666075f80d4ae70"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f305a7b6ca21a665e8d0cf70b5936991a298c93c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53129,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.907,2025-05-08T11:15:52.333,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53130,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:31.997,2025-05-08T11:15:52.570,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53131,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:32.087,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: SUNRPC: Fix a server shutdown leak Fix a race where kthread_stop() may prevent the threadfn from ever getting called. If that happens the svc_rqst will not be cleaned up.",,,"[{""url"":""https://git.kernel.org/stable/c/7a3720361068ab520aed4608bad31ea9a6cc7fe7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ca6705d9d609441d34f8b853e1e4a6369b3b171"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad7e40ee157ba33950a4ccdc284334580da3638d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce7dd61e004002bc1c48d1ca47c887f3f3cc7370"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f74b3286859463cd63cc9d4aeaabd8b0c640182a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53132,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:32.170,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: mpi3mr: Fix mpi3mr_hba_port memory leak in mpi3mr_remove() Free mpi3mr_hba_port at .remove.",,,"[{""url"":""https://git.kernel.org/stable/c/6322569273071745f2dd0c541b154b9666ae7767"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d0f3c3728da8af76dfe435f7f0cfa2b9d9e43ef0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f28bdab9e208792212c52b0c232a13bba84cf048"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53133,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:32.260,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf, sockmap: Fix an infinite loop error when len is 0 in tcp_bpf_recvmsg_parser() When the buffer length of the recvmsg system call is 0, we got the flollowing soft lockup problem: watchdog: BUG: soft lockup - CPU#3 stuck for 27s! [a.out:6149] CPU: 3 PID: 6149 Comm: a.out Kdump: loaded Not tainted 6.2.0+ #30 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.15.0-1 04/01/2014 RIP: 0010:remove_wait_queue+0xb/0xc0 Code: 5e 41 5f c3 cc cc cc cc 0f 1f 80 00 00 00 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 0f 1f 44 00 00 41 57 <41> 56 41 55 41 54 55 48 89 fd 53 48 89 f3 4c 8d 6b 18 4c 8d 73 20 RSP: 0018:ffff88811b5978b8 EFLAGS: 00000246 RAX: 0000000000000000 RBX: ffff88811a7d3780 RCX: ffffffffb7a4d768 RDX: dffffc0000000000 RSI: ffff88811b597908 RDI: ffff888115408040 RBP: 1ffff110236b2f1b R08: 0000000000000000 R09: ffff88811a7d37e7 R10: ffffed10234fa6fc R11: 0000000000000001 R12: ffff88811179b800 R13: 0000000000000001 R14: ffff88811a7d38a8 R15: ffff88811a7d37e0 FS: 00007f6fb5398740(0000) GS:ffff888237180000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000020000000 CR3: 000000010b6ba002 CR4: 0000000000370ee0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> tcp_msg_wait_data+0x279/0x2f0 tcp_bpf_recvmsg_parser+0x3c6/0x490 inet_recvmsg+0x280/0x290 sock_recvmsg+0xfc/0x120 ____sys_recvmsg+0x160/0x3d0 ___sys_recvmsg+0xf0/0x180 __sys_recvmsg+0xea/0x1a0 do_syscall_64+0x3f/0x90 entry_SYSCALL_64_after_hwframe+0x72/0xdc The logic in tcp_bpf_recvmsg_parser is as follows: msg_bytes_ready: copied = sk_msg_recvmsg(sk, psock, msg, len, flags); if (!copied) { wait data; goto msg_bytes_ready; } In this case, ""copied"" always is 0, the infinite loop occurs. According to the Linux system call man page, 0 should be returned in this case. Therefore, in tcp_bpf_recvmsg_parser(), if the length is 0, directly return. Also modify several other functions with the same problem.",,,"[{""url"":""https://git.kernel.org/stable/c/4a476285f6d2921c3c9faa494eab83b78f78fc55"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf0579989de64d36e177c0611c685dc4a91457a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d900f3d20cc3169ce42ec72acc850e662a4d4db2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f45cf3ae3068e70e2c7f3e24a7f8e8aa99511f03"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53134,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:32.353,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bnxt_en: Avoid order-5 memory allocation for TPA data The driver needs to keep track of all the possible concurrent TPA (GRO/LRO) completions on the aggregation ring. On P5 chips, the maximum number of concurrent TPA is 256 and the amount of memory we allocate is order-5 on systems using 4K pages. Memory allocation failure has been reported: NetworkManager: page allocation failure: order:5, mode:0x40dc0(GFP_KERNEL|__GFP_COMP|__GFP_ZERO), nodemask=(null),cpuset=/,mems_allowed=0-1 CPU: 15 PID: 2995 Comm: NetworkManager Kdump: loaded Not tainted 5.10.156 #1 Hardware name: Dell Inc. PowerEdge R660/0M1CC5, BIOS 0.2.25 08/12/2022 Call Trace: dump_stack+0x57/0x6e warn_alloc.cold.120+0x7b/0xdd ? _cond_resched+0x15/0x30 ? __alloc_pages_direct_compact+0x15f/0x170 __alloc_pages_slowpath.constprop.108+0xc58/0xc70 __alloc_pages_nodemask+0x2d0/0x300 kmalloc_order+0x24/0xe0 kmalloc_order_trace+0x19/0x80 bnxt_alloc_mem+0x1150/0x15c0 [bnxt_en] ? bnxt_get_func_stat_ctxs+0x13/0x60 [bnxt_en] __bnxt_open_nic+0x12e/0x780 [bnxt_en] bnxt_open+0x10b/0x240 [bnxt_en] __dev_open+0xe9/0x180 __dev_change_flags+0x1af/0x220 dev_change_flags+0x21/0x60 do_setlink+0x35c/0x1100 Instead of allocating this big chunk of memory and dividing it up for the concurrent TPA instances, allocate each small chunk separately for each TPA instance. This will reduce it to order-0 allocations.",,,"[{""url"":""https://git.kernel.org/stable/c/16f3aae1aa2dd89bc8d073a67f190af580386ae9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/20fd0607acbf9770db9b99e3418dd75614f80b6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/accd7e23693aaaa9aa0d3e9eca0ae77d1be80ab3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad529d1fae1565d38f929479d4ea8aea90054bd2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d16701a385b54f44bf41ff1d7485e7a11080deb3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fcae40e65802547def39b4deaa2ae38a29864d81"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53135,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:32.447,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: riscv: Use READ_ONCE_NOCHECK in imprecise unwinding stack mode When CONFIG_FRAME_POINTER is unset, the stack unwinding function walk_stackframe randomly reads the stack and then, when KASAN is enabled, it can lead to the following backtrace: [ 0.000000] ================================================================== [ 0.000000] BUG: KASAN: stack-out-of-bounds in walk_stackframe+0xa6/0x11a [ 0.000000] Read of size 8 at addr ffffffff81807c40 by task swapper/0 [ 0.000000] [ 0.000000] CPU: 0 PID: 0 Comm: swapper Not tainted 6.2.0-12919-g24203e6db61f #43 [ 0.000000] Hardware name: riscv-virtio,qemu (DT) [ 0.000000] Call Trace: [ 0.000000] [<ffffffff80007ba8>] walk_stackframe+0x0/0x11a [ 0.000000] [<ffffffff80099ecc>] init_param_lock+0x26/0x2a [ 0.000000] [<ffffffff80007c4a>] walk_stackframe+0xa2/0x11a [ 0.000000] [<ffffffff80c49c80>] dump_stack_lvl+0x22/0x36 [ 0.000000] [<ffffffff80c3783e>] print_report+0x198/0x4a8 [ 0.000000] [<ffffffff80099ecc>] init_param_lock+0x26/0x2a [ 0.000000] [<ffffffff80007c4a>] walk_stackframe+0xa2/0x11a [ 0.000000] [<ffffffff8015f68a>] kasan_report+0x9a/0xc8 [ 0.000000] [<ffffffff80007c4a>] walk_stackframe+0xa2/0x11a [ 0.000000] [<ffffffff80007c4a>] walk_stackframe+0xa2/0x11a [ 0.000000] [<ffffffff8006e99c>] desc_make_final+0x80/0x84 [ 0.000000] [<ffffffff8009a04e>] stack_trace_save+0x88/0xa6 [ 0.000000] [<ffffffff80099fc2>] filter_irq_stacks+0x72/0x76 [ 0.000000] [<ffffffff8006b95e>] devkmsg_read+0x32a/0x32e [ 0.000000] [<ffffffff8015ec16>] kasan_save_stack+0x28/0x52 [ 0.000000] [<ffffffff8006e998>] desc_make_final+0x7c/0x84 [ 0.000000] [<ffffffff8009a04a>] stack_trace_save+0x84/0xa6 [ 0.000000] [<ffffffff8015ec52>] kasan_set_track+0x12/0x20 [ 0.000000] [<ffffffff8015f22e>] __kasan_slab_alloc+0x58/0x5e [ 0.000000] [<ffffffff8015e7ea>] __kmem_cache_create+0x21e/0x39a [ 0.000000] [<ffffffff80e133ac>] create_boot_cache+0x70/0x9c [ 0.000000] [<ffffffff80e17ab2>] kmem_cache_init+0x6c/0x11e [ 0.000000] [<ffffffff80e00fd6>] mm_init+0xd8/0xfe [ 0.000000] [<ffffffff80e011d8>] start_kernel+0x190/0x3ca [ 0.000000] [ 0.000000] The buggy address belongs to stack of task swapper/0 [ 0.000000] and is located at offset 0 in frame: [ 0.000000] stack_trace_save+0x0/0xa6 [ 0.000000] [ 0.000000] This frame has 1 object: [ 0.000000] [32, 56) 'c' [ 0.000000] [ 0.000000] The buggy address belongs to the physical page: [ 0.000000] page:(____ptrval____) refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x81a07 [ 0.000000] flags: 0x1000(reserved|zone=0) [ 0.000000] raw: 0000000000001000 ff600003f1e3d150 ff600003f1e3d150 0000000000000000 [ 0.000000] raw: 0000000000000000 0000000000000000 00000001ffffffff [ 0.000000] page dumped because: kasan: bad access detected [ 0.000000] [ 0.000000] Memory state around the buggy address: [ 0.000000] ffffffff81807b00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 0.000000] ffffffff81807b80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 0.000000] >ffffffff81807c00: 00 00 00 00 00 00 00 00 f1 f1 f1 f1 00 00 00 f3 [ 0.000000] ^ [ 0.000000] ffffffff81807c80: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00 [ 0.000000] ffffffff81807d00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 0.000000] ================================================================== Fix that by using READ_ONCE_NOCHECK when reading the stack in imprecise mode.",,,"[{""url"":""https://git.kernel.org/stable/c/17fa90ffba20743c946920fbb0afe160d0ead8c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/324912d6c0c4006711054d389faa2239c1655e1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3a9418d2c93c1c86ce4d0595112d91c7a8e70c2c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3de277af481ab931fab9e295ad8762692920732a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/76950340cf03b149412fe0d5f0810e52ac1df8cb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a99a61d9e1bfca2fc37d223a6a185c0eb66aba02"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53136,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:32.540,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: af_unix: fix struct pid leaks in OOB support syzbot reported struct pid leak [1]. Issue is that queue_oob() calls maybe_add_creds() which potentially holds a reference on a pid. But skb->destructor is not set (either directly or by calling unix_scm_to_skb()) This means that subsequent kfree_skb() or consume_skb() would leak this reference. In this fix, I chose to fully support scm even for the OOB message. [1] BUG: memory leak unreferenced object 0xffff8881053e7f80 (size 128): comm ""syz-executor242"", pid 5066, jiffies 4294946079 (age 13.220s) hex dump (first 32 bytes): 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ backtrace: [<ffffffff812ae26a>] alloc_pid+0x6a/0x560 kernel/pid.c:180 [<ffffffff812718df>] copy_process+0x169f/0x26c0 kernel/fork.c:2285 [<ffffffff81272b37>] kernel_clone+0xf7/0x610 kernel/fork.c:2684 [<ffffffff812730cc>] __do_sys_clone+0x7c/0xb0 kernel/fork.c:2825 [<ffffffff849ad699>] do_syscall_x64 arch/x86/entry/common.c:50 [inline] [<ffffffff849ad699>] do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80 [<ffffffff84a0008b>] entry_SYSCALL_64_after_hwframe+0x63/0xcd",,,"[{""url"":""https://git.kernel.org/stable/c/2aab4b96900272885bc157f8b236abf1cdc02e08"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a59d6306263c38e5c0592ea4451ca26a0778c947"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac1968ac399205fda9ee3b18f7de7416cb3a5d0d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f3969427fb06a2c3cd6efd7faab63505cfa76e76"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53137,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:32.633,2025-09-05T20:15:32.140,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53138,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:32.720,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: caif: Fix use-after-free in cfusbl_device_notify() syzbot reported use-after-free in cfusbl_device_notify() [1]. This causes a stack trace like below: BUG: KASAN: use-after-free in cfusbl_device_notify+0x7c9/0x870 net/caif/caif_usb.c:138 Read of size 8 at addr ffff88807ac4e6f0 by task kworker/u4:6/1214 CPU: 0 PID: 1214 Comm: kworker/u4:6 Not tainted 5.19.0-rc3-syzkaller-00146-g92f20ff72066 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: netns cleanup_net Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106 print_address_description.constprop.0.cold+0xeb/0x467 mm/kasan/report.c:313 print_report mm/kasan/report.c:429 [inline] kasan_report.cold+0xf4/0x1c6 mm/kasan/report.c:491 cfusbl_device_notify+0x7c9/0x870 net/caif/caif_usb.c:138 notifier_call_chain+0xb5/0x200 kernel/notifier.c:87 call_netdevice_notifiers_info+0xb5/0x130 net/core/dev.c:1945 call_netdevice_notifiers_extack net/core/dev.c:1983 [inline] call_netdevice_notifiers net/core/dev.c:1997 [inline] netdev_wait_allrefs_any net/core/dev.c:10227 [inline] netdev_run_todo+0xbc0/0x10f0 net/core/dev.c:10341 default_device_exit_batch+0x44e/0x590 net/core/dev.c:11334 ops_exit_list+0x125/0x170 net/core/net_namespace.c:167 cleanup_net+0x4ea/0xb00 net/core/net_namespace.c:594 process_one_work+0x996/0x1610 kernel/workqueue.c:2289 worker_thread+0x665/0x1080 kernel/workqueue.c:2436 kthread+0x2e9/0x3a0 kernel/kthread.c:376 ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:302 </TASK> When unregistering a net device, unregister_netdevice_many_notify() sets the device's reg_state to NETREG_UNREGISTERING, calls notifiers with NETDEV_UNREGISTER, and adds the device to the todo list. Later on, devices in the todo list are processed by netdev_run_todo(). netdev_run_todo() waits devices' reference count become 1 while rebdoadcasting NETDEV_UNREGISTER notification. When cfusbl_device_notify() is called with NETDEV_UNREGISTER multiple times, the parent device might be freed. This could cause UAF. Processing NETDEV_UNREGISTER multiple times also causes inbalance of reference count for the module. This patch fixes the issue by accepting only first NETDEV_UNREGISTER notification.",,,"[{""url"":""https://git.kernel.org/stable/c/1793da97a23e31c5bf06631f3f3e5a25f368fd64"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/287027d8a567168a5d8ce5cb0cba16a34791a48c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f14457e1584224f4296af613bbd99deb60b5d91"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/68a45c3cf0e2242a533657f4f535d9b6a7447a79"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9781e98a97110f5e76999058368b4be76a788484"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9dc16be373b382ddd4c274052a6e870a95e76c01"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c3aaec463a632cf4187dc017e421bfa69d7834a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d1a11bbdbb5ea9f172019c5a4a3e9d8eabd72179"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53139,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:32.817,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nfc: fdp: add null check of devm_kmalloc_array in fdp_nci_i2c_read_device_properties devm_kmalloc_array may fails, *fw_vsc_cfg might be null and cause out-of-bounds write in device_property_read_u8_array later.",,,"[{""url"":""https://git.kernel.org/stable/c/0a3664a1058d4b2b1ea2112cc275ca47fba7fc08"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/11f180a5d62a51b484e9648f9b310e1bd50b1a57"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/27824b2f98818215adc9661e563252c48dab1a13"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4357bbb921fe9e81d0fd9f70d669d1f177d8380e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/80be62358fa5507cefbaa067c7e6648401f2c3da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/98f49e693e02c1dafd5786be3468657840dd6f06"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad11b872bc9b5d27e56183c6b01f9218c85395d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce93f1afc05941a572f5a69e2ed4012af905a693"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53140,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:32.920,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: core: Remove the /proc/scsi/${proc_name} directory earlier Remove the /proc/scsi/${proc_name} directory earlier to fix a race condition between unloading and reloading kernel modules. This fixes a bug introduced in 2009 by commit 77c019768f06 (""[SCSI] fix /proc memory leak in the SCSI core""). Fix the following kernel warning: proc_dir_entry 'scsi/scsi_debug' already registered WARNING: CPU: 19 PID: 27986 at fs/proc/generic.c:376 proc_register+0x27d/0x2e0 Call Trace: proc_mkdir+0xb5/0xe0 scsi_proc_hostdir_add+0xb5/0x170 scsi_host_alloc+0x683/0x6c0 sdebug_driver_probe+0x6b/0x2d0 [scsi_debug] really_probe+0x159/0x540 __driver_probe_device+0xdc/0x230 driver_probe_device+0x4f/0x120 __device_attach_driver+0xef/0x180 bus_for_each_drv+0xe5/0x130 __device_attach+0x127/0x290 device_initial_probe+0x17/0x20 bus_probe_device+0x110/0x130 device_add+0x673/0xc80 device_register+0x1e/0x30 sdebug_add_host_helper+0x1a7/0x3b0 [scsi_debug] scsi_debug_init+0x64f/0x1000 [scsi_debug] do_one_initcall+0xd7/0x470 do_init_module+0xe7/0x330 load_module+0x122a/0x12c0 __do_sys_finit_module+0x124/0x1a0 __x64_sys_finit_module+0x46/0x50 do_syscall_64+0x38/0x80 entry_SYSCALL_64_after_hwframe+0x46/0xb0",,,"[{""url"":""https://git.kernel.org/stable/c/13daafe1e209b03e9bda16ff2bd2b2da145a139b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/17e98a5ede81b7696bec421f7afa2dfe467f5e6b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1ec363599f8346d5a8d08c71a0d9860d6c420ec0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6b223e32d66ca9db1f252f433514783d8b22a8e1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/891a3cba425cf483d96facca55aebd6ff1da4338"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e471e928de97b00f297ad1015cc14f9459765713"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc663711b94468f4e1427ebe289c9f05669699c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53141,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:33.023,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ila: do not generate empty messages in ila_xlat_nl_cmd_get_mapping() ila_xlat_nl_cmd_get_mapping() generates an empty skb, triggerring a recent sanity check [1]. Instead, return an error code, so that user space can get it. [1] skb_assert_len WARNING: CPU: 0 PID: 5923 at include/linux/skbuff.h:2527 skb_assert_len include/linux/skbuff.h:2527 [inline] WARNING: CPU: 0 PID: 5923 at include/linux/skbuff.h:2527 __dev_queue_xmit+0x1bc0/0x3488 net/core/dev.c:4156 Modules linked in: CPU: 0 PID: 5923 Comm: syz-executor269 Not tainted 6.2.0-syzkaller-18300-g2ebd1fbb946d #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/21/2023 pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : skb_assert_len include/linux/skbuff.h:2527 [inline] pc : __dev_queue_xmit+0x1bc0/0x3488 net/core/dev.c:4156 lr : skb_assert_len include/linux/skbuff.h:2527 [inline] lr : __dev_queue_xmit+0x1bc0/0x3488 net/core/dev.c:4156 sp : ffff80001e0d6c40 x29: ffff80001e0d6e60 x28: dfff800000000000 x27: ffff0000c86328c0 x26: dfff800000000000 x25: ffff0000c8632990 x24: ffff0000c8632a00 x23: 0000000000000000 x22: 1fffe000190c6542 x21: ffff0000c8632a10 x20: ffff0000c8632a00 x19: ffff80001856e000 x18: ffff80001e0d5fc0 x17: 0000000000000000 x16: ffff80001235d16c x15: 0000000000000000 x14: 0000000000000000 x13: 0000000000000001 x12: 0000000000000001 x11: ff80800008353a30 x10: 0000000000000000 x9 : 21567eaf25bfb600 x8 : 21567eaf25bfb600 x7 : 0000000000000001 x6 : 0000000000000001 x5 : ffff80001e0d6558 x4 : ffff800015c74760 x3 : ffff800008596744 x2 : 0000000000000001 x1 : 0000000100000000 x0 : 000000000000000e Call trace: skb_assert_len include/linux/skbuff.h:2527 [inline] __dev_queue_xmit+0x1bc0/0x3488 net/core/dev.c:4156 dev_queue_xmit include/linux/netdevice.h:3033 [inline] __netlink_deliver_tap_skb net/netlink/af_netlink.c:307 [inline] __netlink_deliver_tap+0x45c/0x6f8 net/netlink/af_netlink.c:325 netlink_deliver_tap+0xf4/0x174 net/netlink/af_netlink.c:338 __netlink_sendskb net/netlink/af_netlink.c:1283 [inline] netlink_sendskb+0x6c/0x154 net/netlink/af_netlink.c:1292 netlink_unicast+0x334/0x8d4 net/netlink/af_netlink.c:1380 nlmsg_unicast include/net/netlink.h:1099 [inline] genlmsg_unicast include/net/genetlink.h:433 [inline] genlmsg_reply include/net/genetlink.h:443 [inline] ila_xlat_nl_cmd_get_mapping+0x620/0x7d0 net/ipv6/ila/ila_xlat.c:493 genl_family_rcv_msg_doit net/netlink/genetlink.c:968 [inline] genl_family_rcv_msg net/netlink/genetlink.c:1048 [inline] genl_rcv_msg+0x938/0xc1c net/netlink/genetlink.c:1065 netlink_rcv_skb+0x214/0x3c4 net/netlink/af_netlink.c:2574 genl_rcv+0x38/0x50 net/netlink/genetlink.c:1076 netlink_unicast_kernel net/netlink/af_netlink.c:1339 [inline] netlink_unicast+0x660/0x8d4 net/netlink/af_netlink.c:1365 netlink_sendmsg+0x800/0xae0 net/netlink/af_netlink.c:1942 sock_sendmsg_nosec net/socket.c:714 [inline] sock_sendmsg net/socket.c:734 [inline] ____sys_sendmsg+0x558/0x844 net/socket.c:2479 ___sys_sendmsg net/socket.c:2533 [inline] __sys_sendmsg+0x26c/0x33c net/socket.c:2562 __do_sys_sendmsg net/socket.c:2571 [inline] __se_sys_sendmsg net/socket.c:2569 [inline] __arm64_sys_sendmsg+0x80/0x94 net/socket.c:2569 __invoke_syscall arch/arm64/kernel/syscall.c:38 [inline] invoke_syscall+0x98/0x2c0 arch/arm64/kernel/syscall.c:52 el0_svc_common+0x138/0x258 arch/arm64/kernel/syscall.c:142 do_el0_svc+0x64/0x198 arch/arm64/kernel/syscall.c:193 el0_svc+0x58/0x168 arch/arm64/kernel/entry-common.c:637 el0t_64_sync_handler+0x84/0xf0 arch/arm64/kernel/entry-common.c:655 el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S:591 irq event stamp: 136484 hardirqs last enabled at (136483): [<ffff800008350244>] __up_console_sem+0x60/0xb4 kernel/printk/printk.c:345 hardirqs last disabled at (136484): [<ffff800012358d60>] el1_dbg+0x24/0x80 arch/arm64/kernel/entry-common.c:405 softirqs last enabled at (136418): [<ffff800008020ea8>] softirq_ha ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/25b54f247ea060aeb85ec88a82c75060fca03521"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/42d9ed4e5dc5f87fbd67c232e2e4a9b88ceeb47f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/60fe7cb483c8c5dcadaeeac867251d6e59c7badc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/693aa2c0d9b6d5b1f2745d31b6e70d09dbbaf06e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/783f218940b3c7b872e4111d0145000f26ecbdf6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/91aceb3844d4aec555c7f423f9fd843eff5835e9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b26bc5861505f04dea933ca3e522772b20fa086f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c631e52aea0fc8d4deea06e439f5810a8b40ad0f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53142,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:33.137,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ice: copy last block omitted in ice_get_module_eeprom() ice_get_module_eeprom() is broken since commit e9c9692c8a81 (""ice: Reimplement module reads used by ethtool"") In this refactor, ice_get_module_eeprom() reads the eeprom in blocks of size 8. But the condition that should protect the buffer overflow ignores the last block. The last block always contains zeros. Bug uncovered by ethtool upstream commit 9538f384b535 (""netlink: eeprom: Defer page requests to individual parsers"") After this commit, ethtool reads a block with length = 1; to read the SFF-8024 identifier value. unpatched driver: $ ethtool -m enp65s0f0np0 offset 0x90 length 8 Offset Values ------ ------ 0x0090: 00 00 00 00 00 00 00 00 $ ethtool -m enp65s0f0np0 offset 0x90 length 12 Offset Values ------ ------ 0x0090: 00 00 01 a0 4d 65 6c 6c 00 00 00 00 $ $ ethtool -m enp65s0f0np0 Offset Values ------ ------ 0x0000: 11 06 06 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0060: 00 00 00 00 00 00 00 00 00 00 00 00 00 01 08 00 0x0070: 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 patched driver: $ ethtool -m enp65s0f0np0 offset 0x90 length 8 Offset Values ------ ------ 0x0090: 00 00 01 a0 4d 65 6c 6c $ ethtool -m enp65s0f0np0 offset 0x90 length 12 Offset Values ------ ------ 0x0090: 00 00 01 a0 4d 65 6c 6c 61 6e 6f 78 $ ethtool -m enp65s0f0np0 Identifier : 0x11 (QSFP28) Extended identifier : 0x00 Extended identifier description : 1.5W max. Power consumption Extended identifier description : No CDR in TX, No CDR in RX Extended identifier description : High Power Class (> 3.5 W) not enabled Connector : 0x23 (No separable connector) Transceiver codes : 0x88 0x00 0x00 0x00 0x00 0x00 0x00 0x00 Transceiver type : 40G Ethernet: 40G Base-CR4 Transceiver type : 25G Ethernet: 25G Base-CR CA-N Encoding : 0x05 (64B/66B) BR, Nominal : 25500Mbps Rate identifier : 0x00 Length (SMF,km) : 0km Length (OM3 50um) : 0m Length (OM2 50um) : 0m Length (OM1 62.5um) : 0m Length (Copper or Active cable) : 1m Transmitter technology : 0xa0 (Copper cable unequalized) Attenuation at 2.5GHz : 4db Attenuation at 5.0GHz : 5db Attenuation at 7.0GHz : 7db Attenuation at 12.9GHz : 10db ........ ....",,,"[{""url"":""https://git.kernel.org/stable/c/84cba1840e68430325ac133a11be06bfb2f7acd8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8cfbdda65588e75bfbd93e5ee847efcb4796ad09"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90b40ab29298db3a4879c1d3c4e685184386bce6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c813f7a3161481483ae2077651b21bc217c419e0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53143,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:33.240,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: fix another off-by-one fsmap error on 1k block filesystems Apparently syzbot figured out that issuing this FSMAP call: struct fsmap_head cmd = { .fmh_count = ...; .fmh_keys = { { .fmr_device = /* ext4 dev */, .fmr_physical = 0, }, { .fmr_device = /* ext4 dev */, .fmr_physical = 0, }, }, ... }; ret = ioctl(fd, FS_IOC_GETFSMAP, &cmd); Produces this crash if the underlying filesystem is a 1k-block ext4 filesystem: kernel BUG at fs/ext4/ext4.h:3331! invalid opcode: 0000 [#1] PREEMPT SMP CPU: 3 PID: 3227965 Comm: xfs_io Tainted: G W O 6.2.0-rc8-achx Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.15.0-1 04/01/2014 RIP: 0010:ext4_mb_load_buddy_gfp+0x47c/0x570 [ext4] RSP: 0018:ffffc90007c03998 EFLAGS: 00010246 RAX: ffff888004978000 RBX: ffffc90007c03a20 RCX: ffff888041618000 RDX: 0000000000000000 RSI: 00000000000005a4 RDI: ffffffffa0c99b11 RBP: ffff888012330000 R08: ffffffffa0c2b7d0 R09: 0000000000000400 R10: ffffc90007c03950 R11: 0000000000000000 R12: 0000000000000001 R13: 00000000ffffffff R14: 0000000000000c40 R15: ffff88802678c398 FS: 00007fdf2020c880(0000) GS:ffff88807e100000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007ffd318a5fe8 CR3: 000000007f80f001 CR4: 00000000001706e0 Call Trace: <TASK> ext4_mballoc_query_range+0x4b/0x210 [ext4 dfa189daddffe8fecd3cdfd00564e0f265a8ab80] ext4_getfsmap_datadev+0x713/0x890 [ext4 dfa189daddffe8fecd3cdfd00564e0f265a8ab80] ext4_getfsmap+0x2b7/0x330 [ext4 dfa189daddffe8fecd3cdfd00564e0f265a8ab80] ext4_ioc_getfsmap+0x153/0x2b0 [ext4 dfa189daddffe8fecd3cdfd00564e0f265a8ab80] __ext4_ioctl+0x2a7/0x17e0 [ext4 dfa189daddffe8fecd3cdfd00564e0f265a8ab80] __x64_sys_ioctl+0x82/0xa0 do_syscall_64+0x2b/0x80 entry_SYSCALL_64_after_hwframe+0x46/0xb0 RIP: 0033:0x7fdf20558aff RSP: 002b:00007ffd318a9e30 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 00000000000200c0 RCX: 00007fdf20558aff RDX: 00007fdf1feb2010 RSI: 00000000c0c0583b RDI: 0000000000000003 RBP: 00005625c0634be0 R08: 00005625c0634c40 R09: 0000000000000001 R10: 0000000000000000 R11: 0000000000000246 R12: 00007fdf1feb2010 R13: 00005625be70d994 R14: 0000000000000800 R15: 0000000000000000 For GETFSMAP calls, the caller selects a physical block device by writing its block number into fsmap_head.fmh_keys[01].fmr_device. To query mappings for a subrange of the device, the starting byte of the range is written to fsmap_head.fmh_keys[0].fmr_physical and the last byte of the range goes in fsmap_head.fmh_keys[1].fmr_physical. IOWs, to query what mappings overlap with bytes 3-14 of /dev/sda, you'd set the inputs as follows: fmh_keys[0] = { .fmr_device = major(8, 0), .fmr_physical = 3}, fmh_keys[1] = { .fmr_device = major(8, 0), .fmr_physical = 14}, Which would return you whatever is mapped in the 12 bytes starting at physical offset 3. The crash is due to insufficient range validation of keys[1] in ext4_getfsmap_datadev. On 1k-block filesystems, block 0 is not part of the filesystem, which means that s_first_data_block is nonzero. ext4_get_group_no_and_offset subtracts this quantity from the blocknr argument before cracking it into a group number and a block number within a group. IOWs, block group 0 spans blocks 1-8192 (1-based) instead of 0-8191 (0-based) like what happens with larger blocksizes. The net result of this encoding is that blocknr < s_first_data_block is not a valid input to this function. The end_fsb variable is set from the keys that are copied from userspace, which means that in the above example, its value is zero. That leads to an underflow here: blocknr = blocknr - le32_to_cpu(es->s_first_data_block); The division then operates on -1: offset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >> EXT4_SB(sb)->s_cluster_bits; Leaving an impossibly large group number (2^32-1) in blocknr. ext4_getfsmap_check_keys checked that keys[0 ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/15ebade3266b300da9cd1edce4004fe8fd6a2b88"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1d2366624b4c19a2ba6baf67fe57f4a1b0f67c05"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a70b49dc7eee5dbe3775a650ce598e3557ff5475"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c24f838493792b5e78a3596b4ca96375aa0af4c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c5d7c31e17224d847a330180ec1b03bf390632b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c993799baf9c5861f8df91beb80e1611b12efcbd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb3a695aa71a514f2e7f5778e05faba3733b70a0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f16054ac1774915160ca4e1c73ff7a269465a1b9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53144,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-02T16:15:33.357,2025-05-05T20:54:19.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: erofs: fix wrong kunmap when using LZMA on HIGHMEM platforms As the call trace shown, the root cause is kunmap incorrect pages: BUG: kernel NULL pointer dereference, address: 00000000 CPU: 1 PID: 40 Comm: kworker/u5:0 Not tainted 6.2.0-rc5 #4 Workqueue: erofs_worker z_erofs_decompressqueue_work EIP: z_erofs_lzma_decompress+0x34b/0x8ac z_erofs_decompress+0x12/0x14 z_erofs_decompress_queue+0x7e7/0xb1c z_erofs_decompressqueue_work+0x32/0x60 process_one_work+0x24b/0x4d8 ? process_one_work+0x1a4/0x4d8 worker_thread+0x14c/0x3fc kthread+0xe6/0x10c ? rescuer_thread+0x358/0x358 ? kthread_complete_and_exit+0x18/0x18 ret_from_fork+0x1c/0x28 ---[ end trace 0000000000000000 ]--- The bug is trivial and should be fixed now. It has no impact on !HIGHMEM platforms.",,,"[{""url"":""https://git.kernel.org/stable/c/28aea8ae6cf212a5bf3ed962b27921e2029ad754"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8f121dfb15f7b4ab345992ce96003eb63fd608f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa4056781ac067b5946c6811459e1a36842047fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53145,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-10T15:15:58.587,2025-05-12T17:32:32.760,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: btsdio: fix use after free bug in btsdio_remove due to race condition In btsdio_probe, the data->work is bound with btsdio_work. It will be started in btsdio_send_frame. If the btsdio_remove runs with a unfinished work, there may be a race condition that hdev is freed but used in btsdio_work. Fix it by canceling the work before do cleanup in btsdio_remove.",,,"[{""url"":""https://git.kernel.org/stable/c/179c65828593aff1f444e15debd40a477cb23cf4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3efcbf25e5ab4d4ad1b7e6ba0869ff85540e3f6e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c3653627397a0d6eab19b20a59423e118985a6b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73f7b171b7c09139eb3c6a5677c200dc1be5f318"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/746b363bef41cc159c051c47f9e30800bc6b520d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a5c2a467e9e789ae0891de55b766daac52e3b7b3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6650d27ab2c12a8ee750f396edb5ac8b4558b2e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53146,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-05-14T13:15:47.083,2025-05-16T14:43:56.797,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: dw2102: Fix null-ptr-deref in dw2102_i2c_transfer() In dw2102_i2c_transfer, msg is controlled by user. When msg[i].buf is null and msg[i].len is zero, former checks on msg[i].buf would be passed. Malicious data finally reach dw2102_i2c_transfer. If accessing msg[i].buf[0] without sanity check, null ptr deref would happen. We add check on msg[i].len to prevent crash. Similar commit: commit 950e252cb469 (""[media] dw2102: limit messages to buffer size"")",,,"[{""url"":""https://git.kernel.org/stable/c/08dfcbd03b2b7f918c4f87c6ff637054e510df74"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5ae544d94abc8ff77b1b9bf8774def3fa5689b5b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/77cbd42d29de9ffc93d5529bab8813cde53af14c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/903566208ae6bb9c0e7e54355ce75bf6cf72485d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/97fdbdb750342cbc204befde976872fedb406ee6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/beb9550494e7349f92b9eaa283256a5ad9b1c9be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ecbe6d011b95c7da59f014f8d26cb7245ed1e11e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fb28afab113a82b89ffec48c8155ec05b4f8cb5e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53147,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:37.133,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: xfrm: add NULL check in xfrm_update_ae_params Normally, x->replay_esn and x->preplay_esn should be allocated at xfrm_alloc_replay_state_esn(...) in xfrm_state_construct(...), hence the xfrm_update_ae_params(...) is okay to update them. However, the current implementation of xfrm_new_ae(...) allows a malicious user to directly dereference a NULL pointer and crash the kernel like below. BUG: kernel NULL pointer dereference, address: 0000000000000000 PGD 8253067 P4D 8253067 PUD 8e0e067 PMD 0 Oops: 0002 [#1] PREEMPT SMP KASAN NOPTI CPU: 0 PID: 98 Comm: poc.npd Not tainted 6.4.0-rc7-00072-gdad9774deaf1 #8 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.o4 RIP: 0010:memcpy_orig+0xad/0x140 Code: e8 4c 89 5f e0 48 8d 7f e0 73 d2 83 c2 20 48 29 d6 48 29 d7 83 fa 10 72 34 4c 8b 06 4c 8b 4e 08 c RSP: 0018:ffff888008f57658 EFLAGS: 00000202 RAX: 0000000000000000 RBX: ffff888008bd0000 RCX: ffffffff8238e571 RDX: 0000000000000018 RSI: ffff888007f64844 RDI: 0000000000000000 RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000000 R12: ffff888008f57818 R13: ffff888007f64aa4 R14: 0000000000000000 R15: 0000000000000000 FS: 00000000014013c0(0000) GS:ffff88806d600000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000000 CR3: 00000000054d8000 CR4: 00000000000006f0 Call Trace: <TASK> ? __die+0x1f/0x70 ? page_fault_oops+0x1e8/0x500 ? __pfx_is_prefetch.constprop.0+0x10/0x10 ? __pfx_page_fault_oops+0x10/0x10 ? _raw_spin_unlock_irqrestore+0x11/0x40 ? fixup_exception+0x36/0x460 ? _raw_spin_unlock_irqrestore+0x11/0x40 ? exc_page_fault+0x5e/0xc0 ? asm_exc_page_fault+0x26/0x30 ? xfrm_update_ae_params+0xd1/0x260 ? memcpy_orig+0xad/0x140 ? __pfx__raw_spin_lock_bh+0x10/0x10 xfrm_update_ae_params+0xe7/0x260 xfrm_new_ae+0x298/0x4e0 ? __pfx_xfrm_new_ae+0x10/0x10 ? __pfx_xfrm_new_ae+0x10/0x10 xfrm_user_rcv_msg+0x25a/0x410 ? __pfx_xfrm_user_rcv_msg+0x10/0x10 ? __alloc_skb+0xcf/0x210 ? stack_trace_save+0x90/0xd0 ? filter_irq_stacks+0x1c/0x70 ? __stack_depot_save+0x39/0x4e0 ? __kasan_slab_free+0x10a/0x190 ? kmem_cache_free+0x9c/0x340 ? netlink_recvmsg+0x23c/0x660 ? sock_recvmsg+0xeb/0xf0 ? __sys_recvfrom+0x13c/0x1f0 ? __x64_sys_recvfrom+0x71/0x90 ? do_syscall_64+0x3f/0x90 ? entry_SYSCALL_64_after_hwframe+0x72/0xdc ? copyout+0x3e/0x50 netlink_rcv_skb+0xd6/0x210 ? __pfx_xfrm_user_rcv_msg+0x10/0x10 ? __pfx_netlink_rcv_skb+0x10/0x10 ? __pfx_sock_has_perm+0x10/0x10 ? mutex_lock+0x8d/0xe0 ? __pfx_mutex_lock+0x10/0x10 xfrm_netlink_rcv+0x44/0x50 netlink_unicast+0x36f/0x4c0 ? __pfx_netlink_unicast+0x10/0x10 ? netlink_recvmsg+0x500/0x660 netlink_sendmsg+0x3b7/0x700 This Null-ptr-deref bug is assigned CVE-2023-3772. And this commit adds additional NULL check in xfrm_update_ae_params to fix the NPD.",,,"[{""url"":""https://git.kernel.org/stable/c/00374d9b6d9f932802b55181be9831aa948e5b7c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/075448a2eb753f813fe873cfa52853e9fef8eedb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/44f69c96f8a147413c23c68cda4d6fb5e23137cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/53df4be4f5221e90dc7aa9ce745a9a21bb7024f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8046beb890ebc83c5820188c650073e1c6066e67"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/87b655f4936b6fc01f3658aa88a22c923b379ebd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd30aa9c7febb6e709670cd5154194189ca3b7b5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ed1cba039309c80b49719fcff3e3d7cdddb73d96"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53148,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:37.270,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: igb: Fix igb_down hung on surprise removal In a setup where a Thunderbolt hub connects to Ethernet and a display through USB Type-C, users may experience a hung task timeout when they remove the cable between the PC and the Thunderbolt hub. This is because the igb_down function is called multiple times when the Thunderbolt hub is unplugged. For example, the igb_io_error_detected triggers the first call, and the igb_remove triggers the second call. The second call to igb_down will block at napi_synchronize. Here's the call trace: __schedule+0x3b0/0xddb ? __mod_timer+0x164/0x5d3 schedule+0x44/0xa8 schedule_timeout+0xb2/0x2a4 ? run_local_timers+0x4e/0x4e msleep+0x31/0x38 igb_down+0x12c/0x22a [igb 6615058754948bfde0bf01429257eb59f13030d4] __igb_close+0x6f/0x9c [igb 6615058754948bfde0bf01429257eb59f13030d4] igb_close+0x23/0x2b [igb 6615058754948bfde0bf01429257eb59f13030d4] __dev_close_many+0x95/0xec dev_close_many+0x6e/0x103 unregister_netdevice_many+0x105/0x5b1 unregister_netdevice_queue+0xc2/0x10d unregister_netdev+0x1c/0x23 igb_remove+0xa7/0x11c [igb 6615058754948bfde0bf01429257eb59f13030d4] pci_device_remove+0x3f/0x9c device_release_driver_internal+0xfe/0x1b4 pci_stop_bus_device+0x5b/0x7f pci_stop_bus_device+0x30/0x7f pci_stop_bus_device+0x30/0x7f pci_stop_and_remove_bus_device+0x12/0x19 pciehp_unconfigure_device+0x76/0xe9 pciehp_disable_slot+0x6e/0x131 pciehp_handle_presence_or_link_change+0x7a/0x3f7 pciehp_ist+0xbe/0x194 irq_thread_fn+0x22/0x4d ? irq_thread+0x1fd/0x1fd irq_thread+0x17b/0x1fd ? irq_forced_thread_fn+0x5f/0x5f kthread+0x142/0x153 ? __irq_get_irqchip_state+0x46/0x46 ? kthread_associate_blkcg+0x71/0x71 ret_from_fork+0x1f/0x30 In this case, igb_io_error_detected detaches the network interface and requests a PCIE slot reset, however, the PCIE reset callback is not being invoked and thus the Ethernet connection breaks down. As the PCIE error in this case is a non-fatal one, requesting a slot reset can be avoided. This patch fixes the task hung issue and preserves Ethernet connection by ignoring non-fatal PCIE errors.",,,"[{""url"":""https://git.kernel.org/stable/c/004d25060c78fc31f66da0fa439c544dda1ac9d5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/124e39a734cb90658b8f0dc110847bbfc6e33792"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/39695e87d86f0e7d897fba1d2559f825aa20caeb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/41f63b72a01c0e0ac59ab83fd2d921fcce0f602d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/994c2ceb70ea99264ccc6f09e6703ca267dad63c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c2312e1d12b1c3ee4100c173131b102e2aed4d04"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c9f56f3c7bc908caa772112d3ae71cdd5d18c257"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa92c463eba75dcedbd8d689ffdcb83293aaa0c3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53149,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:37.393,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: avoid deadlock in fs reclaim with page writeback Ext4 has a filesystem wide lock protecting ext4_writepages() calls to avoid races with switching of journalled data flag or inode format. This lock can however cause a deadlock like: CPU0 CPU1 ext4_writepages() percpu_down_read(sbi->s_writepages_rwsem); ext4_change_inode_journal_flag() percpu_down_write(sbi->s_writepages_rwsem); - blocks, all readers block from now on ext4_do_writepages() ext4_init_io_end() kmem_cache_zalloc(io_end_cachep, GFP_KERNEL) fs_reclaim frees dentry... dentry_unlink_inode() iput() - last ref => iput_final() - inode dirty => write_inode_now()... ext4_writepages() tries to acquire sbi->s_writepages_rwsem and blocks forever Make sure we cannot recurse into filesystem reclaim from writeback code to avoid the deadlock.",,,"[{""url"":""https://git.kernel.org/stable/c/00d873c17e29cc32d90ca852b82685f1673acaa5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2ec97dc90df40c50e509809dc9a198638a7e18b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4b4340bf04ce9a52061f15000ecedd126abc093c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53150,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:37.510,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: qla2xxx: Pointer may be dereferenced Klocwork tool reported pointer 'rport' returned from call to function fc_bsg_to_rport() may be NULL and will be dereferenced. Add a fix to validate rport before dereferencing.",,,"[{""url"":""https://git.kernel.org/stable/c/005961bd8f066fe931104f67c34ebfcc7f240099"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/00eca15319d9ce8c31cdf22f32a3467775423df4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0715da51391d223bf4981e28346770edea7eeb74"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/22b1d7c8bb59c3376430a8bad5840194b12bf29a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f22f9ddbb29dba369daddb084be3bacf1587529"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5addd62586a94a572359418464ce0ae12fa46187"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a69125a3ce88d9a386872034e7664b30cc4bcbed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b06d1b525364bbcf4929b4b35d81945b10dc9883"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53151,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:37.630,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: md/raid10: prevent soft lockup while flush writes Currently, there is no limit for raid1/raid10 plugged bio. While flushing writes, raid1 has cond_resched() while raid10 doesn't, and too many writes can cause soft lockup. Follow up soft lockup can be triggered easily with writeback test for raid10 with ramdisks: watchdog: BUG: soft lockup - CPU#10 stuck for 27s! [md0_raid10:1293] Call Trace: <TASK> call_rcu+0x16/0x20 put_object+0x41/0x80 __delete_object+0x50/0x90 delete_object_full+0x2b/0x40 kmemleak_free+0x46/0xa0 slab_free_freelist_hook.constprop.0+0xed/0x1a0 kmem_cache_free+0xfd/0x300 mempool_free_slab+0x1f/0x30 mempool_free+0x3a/0x100 bio_free+0x59/0x80 bio_put+0xcf/0x2c0 free_r10bio+0xbf/0xf0 raid_end_bio_io+0x78/0xb0 one_write_done+0x8a/0xa0 raid10_end_write_request+0x1b4/0x430 bio_endio+0x175/0x320 brd_submit_bio+0x3b9/0x9b7 [brd] __submit_bio+0x69/0xe0 submit_bio_noacct_nocheck+0x1e6/0x5a0 submit_bio_noacct+0x38c/0x7e0 flush_pending_writes+0xf0/0x240 raid10d+0xac/0x1ed0 Fix the problem by adding cond_resched() to raid10 like what raid1 did. Note that unlimited plugged bio still need to be optimized, for example, in the case of lots of dirty pages writeback, this will take lots of memory and io will spend a long time in plug, hence io latency is bad.",,,"[{""url"":""https://git.kernel.org/stable/c/00ecb6fa67c0f772290c5ea5ae8b46eefd503b83"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/010444623e7f4da6b4a4dd603a7da7469981e293"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1d467e10507167eb6dc2c281a87675b731955d86"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/634daf6b2c81015cc5e28bf694a6a94a50c641cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/84a578961b2566e475bfa8740beaf0abcc781a6f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d0345f7c7dbc5d42e4e6f1db99c1c1879d7b0eb5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f45b2fa7678ab385299de345f7e85d05caea386b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fbf50184190d55f8717bd29aa9530c399be96f30"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53152,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:37.753,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: fix calltrace warning in amddrm_buddy_fini The following call trace is observed when removing the amdgpu driver, which is caused by that BOs allocated for psp are not freed until removing. [61811.450562] RIP: 0010:amddrm_buddy_fini.cold+0x29/0x47 [amddrm_buddy] [61811.450577] Call Trace: [61811.450577] <TASK> [61811.450579] amdgpu_vram_mgr_fini+0x135/0x1c0 [amdgpu] [61811.450728] amdgpu_ttm_fini+0x207/0x290 [amdgpu] [61811.450870] amdgpu_bo_fini+0x27/0xa0 [amdgpu] [61811.451012] gmc_v9_0_sw_fini+0x4a/0x60 [amdgpu] [61811.451166] amdgpu_device_fini_sw+0x117/0x520 [amdgpu] [61811.451306] amdgpu_driver_release_kms+0x16/0x30 [amdgpu] [61811.451447] devm_drm_dev_init_release+0x4d/0x80 [drm] [61811.451466] devm_action_release+0x15/0x20 [61811.451469] release_nodes+0x40/0xb0 [61811.451471] devres_release_all+0x9b/0xd0 [61811.451473] __device_release_driver+0x1bb/0x2a0 [61811.451476] driver_detach+0xf3/0x140 [61811.451479] bus_remove_driver+0x6c/0xf0 [61811.451481] driver_unregister+0x31/0x60 [61811.451483] pci_unregister_driver+0x40/0x90 [61811.451486] amdgpu_exit+0x15/0x447 [amdgpu] For smu v13_0_2, if the GPU supports xgmi, refer to commit f5c7e7797060 (""drm/amdgpu: Adjust removal control flow for smu v13_0_2""), it will run gpu recover in AMDGPU_RESET_FOR_DEVICE_REMOVE mode when removing, which makes all devices in hive list have hw reset but no resume except the basic ip blocks, then other ip blocks will not call .hw_fini according to ip_block.status.hw. Since psp_free_shared_bufs just includes some software operations, so move it to psp_sw_fini.",,,"[{""url"":""https://git.kernel.org/stable/c/01382501509871d0799bab6bd412c228486af5bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/756d674117f5c451f415d1c4046b927052a90c14"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ab6f446c220db0c131f2071846afd835799be0fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53153,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:37.860,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: cfg80211: Fix use after free for wext Key information in wext.connect is not reset on (re)connect and can hold data from a previous connection. Reset key data to avoid that drivers or mac80211 incorrectly detect a WEP connection request and access the freed or already reused memory. Additionally optimize cfg80211_sme_connect() and avoid an useless schedule of conn_work.",,,"[{""url"":""https://git.kernel.org/stable/c/015b8cc5e7c4d7bb671f1984d7b7338c310b185b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/22dfb21bf1cd876616d45cda1bc6daa89eec6747"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2cfe78619b0de6d2da773978bc2d22797212eaa7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/66af4a2ab1d65d556d638cb9555a3b823c2557a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6f1959c17d4cb5b74af6fc31dc787e1dc3e4f6e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a2a92b3e9d8e03ee3f9ee407fc46a9b4bd02d8b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f4b6a138efb8a32507b8946104e32cb926308da7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd081afd21eb35b968b0330700c43ec94986e1c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53154,cve@mitre.org,2025-05-23T16:15:22.080,2025-06-16T18:21:16.333,Analyzed,[],"parse_string in cJSON before 1.7.18 has a heap-based buffer over-read via {""1"":1, with no trailing newline if cJSON_ParseWithLength is called.","[{""source"":""cve@mitre.org"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-125""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:cjson_project:cjson:*:*:*:*:*:*:*:*"",""versionEndExcluding"":""1.7.18"",""matchCriteriaId"":""DB89DBA4-DAFF-437E-B8C7-D9096DDD5D95""}]}]}]","[{""url"":""https://github.com/DaveGamble/cJSON/compare/v1.7.17...v1.7.18"",""source"":""cve@mitre.org"",""tags"":[""Release Notes""]},{""url"":""https://github.com/DaveGamble/cJSON/issues/800"",""source"":""cve@mitre.org"",""tags"":[""Exploit"",""Issue Tracking"",""Vendor Advisory""]},{""url"":""https://github.com/DaveGamble/cJSON/issues/800"",""source"":""134c704f-9b21-4f2e-91b3-4a467353bcc0"",""tags"":[""Exploit"",""Issue Tracking"",""Vendor Advisory""]}]","[{""source"":""cve@mitre.org"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L"",""baseScore"":2.9,""baseSeverity"":""LOW"",""attackVector"":""LOCAL"",""attackComplexity"":""HIGH"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""LOW""},""exploitabilityScore"":1.4,""impactScore"":1.4},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":5.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""LOW"",""privilegesRequired"":""LOW"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":1.8,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53155,cve@mitre.org,2025-07-25T17:15:29.353,2025-07-29T14:14:55.157,Awaiting Analysis,[],goform/formTest in EmbedThis GoAhead 2.5 allows HTML injection via the name parameter.,"[{""source"":""cve@mitre.org"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-79""}]}]",,"[{""url"":""https://www.exploit-db.com/exploits/51762"",""source"":""cve@mitre.org""}]","[{""source"":""cve@mitre.org"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:L/A:N"",""baseScore"":7.2,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""CHANGED"",""confidentialityImpact"":""LOW"",""integrityImpact"":""LOW"",""availabilityImpact"":""NONE""},""exploitabilityScore"":3.9,""impactScore"":2.7}]",,,,,,,,
CVE-2023-53156,cve@mitre.org,2025-07-27T21:15:25.687,2025-08-07T15:08:46.397,Analyzed,[],The transpose crate before 0.2.3 for Rust allows an integer overflow via input_width and input_height arguments.,"[{""source"":""cve@mitre.org"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-190""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:ejmahler:transpose:*:*:*:*:*:rust:*:*"",""versionStartIncluding"":""0.1.0"",""versionEndExcluding"":""0.2.3"",""matchCriteriaId"":""DFD2347F-2C84-44C7-8E54-44EB7317FCAE""}]}]}]","[{""url"":""https://crates.io/crates/transpose"",""source"":""cve@mitre.org"",""tags"":[""Product""]},{""url"":""https://github.com/advisories/GHSA-5gmm-6m36-r7jh"",""source"":""cve@mitre.org"",""tags"":[""Third Party Advisory""]},{""url"":""https://github.com/ejmahler/transpose/issues/11"",""source"":""cve@mitre.org"",""tags"":[""Issue Tracking""]},{""url"":""https://rustsec.org/advisories/RUSTSEC-2023-0080.html"",""source"":""cve@mitre.org"",""tags"":[""Third Party Advisory""]}]","[{""source"":""cve@mitre.org"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:C/C:N/I:L/A:L"",""baseScore"":4.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""HIGH"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""CHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""LOW"",""availabilityImpact"":""LOW""},""exploitabilityScore"":1.4,""impactScore"":2.7},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N"",""baseScore"":5.3,""baseSeverity"":""MEDIUM"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""LOW"",""availabilityImpact"":""NONE""},""exploitabilityScore"":3.9,""impactScore"":1.4}]",,,,,,,,
CVE-2023-53157,cve@mitre.org,2025-07-28T00:15:25.253,2025-08-07T15:21:17.903,Analyzed,[],The rosenpass crate before 0.2.1 for Rust allows remote attackers to cause a denial of service (panic) via a one-byte UDP packet.,"[{""source"":""cve@mitre.org"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-130""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:rosenpass:rosenpass:*:*:*:*:*:rust:*:*"",""versionEndExcluding"":""0.2.1"",""matchCriteriaId"":""8A618F79-D271-4D71-B90E-9AAEAEC8838E""}]}]}]","[{""url"":""https://crates.io/crates/rosenpass"",""source"":""cve@mitre.org"",""tags"":[""Product""]},{""url"":""https://github.com/advisories/GHSA-6ggr-cwv4-g7qg"",""source"":""cve@mitre.org"",""tags"":[""Third Party Advisory""]},{""url"":""https://github.com/rosenpass/rosenpass/commit/93439858d1c44294a7b377f775c4fc897a370bb2"",""source"":""cve@mitre.org"",""tags"":[""Patch""]},{""url"":""https://rustsec.org/advisories/RUSTSEC-2023-0077.html"",""source"":""cve@mitre.org"",""tags"":[""Third Party Advisory""]}]","[{""source"":""cve@mitre.org"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L"",""baseScore"":5.3,""baseSeverity"":""MEDIUM"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""LOW""},""exploitabilityScore"":3.9,""impactScore"":1.4},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"",""baseScore"":7.5,""baseSeverity"":""HIGH"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":3.9,""impactScore"":3.6}]",,,,,,,,
CVE-2023-53158,cve@mitre.org,2025-07-28T01:15:24.837,2025-07-29T14:14:29.590,Awaiting Analysis,[],"The gix-transport crate before 0.36.1 for Rust allows command execution via the ""gix clone 'ssh://-oProxyCommand=open$IFS"" substring. NOTE: this was discovered before CVE-2024-32884, a similar vulnerability (involving a username field) that is more difficult to exploit.","[{""source"":""cve@mitre.org"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-78""}]}]",,"[{""url"":""https://crates.io/crates/gix-transport"",""source"":""cve@mitre.org""},{""url"":""https://github.com/GitoxideLabs/gitoxide/pull/1032"",""source"":""cve@mitre.org""},{""url"":""https://github.com/advisories/GHSA-rrjw-j4m2-mf34"",""source"":""cve@mitre.org""},{""url"":""https://rustsec.org/advisories/RUSTSEC-2023-0064.html"",""source"":""cve@mitre.org""}]","[{""source"":""cve@mitre.org"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:C/C:L/I:L/A:N"",""baseScore"":4.1,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""HIGH"",""privilegesRequired"":""NONE"",""userInteraction"":""REQUIRED"",""scope"":""CHANGED"",""confidentialityImpact"":""LOW"",""integrityImpact"":""LOW"",""availabilityImpact"":""NONE""},""exploitabilityScore"":1.0,""impactScore"":2.7}]",,,,,,,,
CVE-2023-53159,cve@mitre.org,2025-07-28T03:15:23.193,2025-08-07T15:30:41.580,Analyzed,[],The openssl crate before 0.10.55 for Rust allows an out-of-bounds read via an empty string to X509VerifyParamRef::set_host.,"[{""source"":""cve@mitre.org"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-126""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:sfackler:openssl:*:*:*:*:*:rust:*:*"",""versionEndExcluding"":""0.10.55"",""matchCriteriaId"":""57EF18B7-20B6-4EA8-BE0D-732910E67318""}]}]}]","[{""url"":""https://crates.io/crates/openssl"",""source"":""cve@mitre.org"",""tags"":[""Product""]},{""url"":""https://github.com/sfackler/rust-openssl/issues/1965"",""source"":""cve@mitre.org"",""tags"":[""Exploit"",""Patch""]},{""url"":""https://rustsec.org/advisories/RUSTSEC-2023-0044.html"",""source"":""cve@mitre.org"",""tags"":[""Third Party Advisory""]}]","[{""source"":""cve@mitre.org"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:C/C:L/I:N/A:L"",""baseScore"":4.5,""baseSeverity"":""MEDIUM"",""attackVector"":""LOCAL"",""attackComplexity"":""HIGH"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""CHANGED"",""confidentialityImpact"":""LOW"",""integrityImpact"":""NONE"",""availabilityImpact"":""LOW""},""exploitabilityScore"":1.4,""impactScore"":2.7},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H"",""baseScore"":9.1,""baseSeverity"":""CRITICAL"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""HIGH"",""integrityImpact"":""NONE"",""availabilityImpact"":""HIGH""},""exploitabilityScore"":3.9,""impactScore"":5.2}]",,,,,,,,
CVE-2023-53160,cve@mitre.org,2025-07-28T03:15:23.373,2025-08-06T21:15:47.147,Analyzed,[],The sequoia-openpgp crate before 1.16.0 for Rust allows out-of-bounds array access and a panic.,"[{""source"":""cve@mitre.org"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-125""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:sequoia-pgp:sequoia-openpgp:*:*:*:*:*:rust:*:*"",""versionEndExcluding"":""1.1.1"",""matchCriteriaId"":""899EAF37-6EF6-49B0-AE10-38533DABC70C""},{""vulnerable"":true,""criteria"":""cpe:2.3:a:sequoia-pgp:sequoia-openpgp:*:*:*:*:*:rust:*:*"",""versionStartIncluding"":""1.2.0"",""versionEndExcluding"":""1.8.1"",""matchCriteriaId"":""AD15C962-C5C6-4FBF-BE9F-635A85B4617B""},{""vulnerable"":true,""criteria"":""cpe:2.3:a:sequoia-pgp:sequoia-openpgp:*:*:*:*:*:rust:*:*"",""versionStartIncluding"":""1.9.0"",""versionEndExcluding"":""1.16.0"",""matchCriteriaId"":""669DC8B7-70D0-462F-9FA7-3DFACD9B7D3D""}]}]}]","[{""url"":""https://crates.io/crates/sequoia-openpgp"",""source"":""cve@mitre.org"",""tags"":[""Product""]},{""url"":""https://github.com/advisories/GHSA-25mx-8f3v-8wh7"",""source"":""cve@mitre.org"",""tags"":[""Third Party Advisory""]},{""url"":""https://lists.sequoia-pgp.org/hyperkitty/list/announce@lists.sequoia-pgp.org/thread/SN2E3QRT4DMQ5JNEK6VIN6DJ5SH766DI/"",""source"":""cve@mitre.org"",""tags"":[""Patch""]},{""url"":""https://rustsec.org/advisories/RUSTSEC-2023-0038.html"",""source"":""cve@mitre.org"",""tags"":[""Third Party Advisory""]}]","[{""source"":""cve@mitre.org"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L"",""baseScore"":2.9,""baseSeverity"":""LOW"",""attackVector"":""LOCAL"",""attackComplexity"":""HIGH"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""LOW""},""exploitabilityScore"":1.4,""impactScore"":1.4},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L"",""baseScore"":5.3,""baseSeverity"":""MEDIUM"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""LOW""},""exploitabilityScore"":3.9,""impactScore"":1.4}]",,,,,,,,
CVE-2023-53161,cve@mitre.org,2025-07-28T03:15:23.557,2025-08-06T21:16:58.247,Analyzed,[],The buffered-reader crate before 1.1.5 for Rust allows out-of-bounds array access and a panic.,"[{""source"":""cve@mitre.org"",""type"":""Primary"",""description"":[{""lang"":""en"",""value"":""CWE-125""}]}]","[{""nodes"":[{""operator"":""OR"",""negate"":false,""cpeMatch"":[{""vulnerable"":true,""criteria"":""cpe:2.3:a:sequoia-pgp:buffered-reader:*:*:*:*:*:rust:*:*"",""versionEndExcluding"":""1.0.2"",""matchCriteriaId"":""99CAB7B8-E8C3-42A6-96AA-49B4218193C1""},{""vulnerable"":true,""criteria"":""cpe:2.3:a:sequoia-pgp:buffered-reader:*:*:*:*:*:rust:*:*"",""versionStartIncluding"":""1.1.0"",""versionEndExcluding"":""1.1.5"",""matchCriteriaId"":""82601D7A-1269-4BCC-A503-6D1F17906FCA""}]}]}]","[{""url"":""https://crates.io/crates/buffered-reader"",""source"":""cve@mitre.org"",""tags"":[""Product""]},{""url"":""https://github.com/advisories/GHSA-29mf-62xx-28jq"",""source"":""cve@mitre.org"",""tags"":[""Third Party Advisory""]},{""url"":""https://gitlab.com/sequoia-pgp/sequoia/-/tags/buffered-reader%2Fv1.0.2"",""source"":""cve@mitre.org"",""tags"":[""Release Notes""]},{""url"":""https://gitlab.com/sequoia-pgp/sequoia/-/tags/buffered-reader%2Fv1.1.5"",""source"":""cve@mitre.org"",""tags"":[""Release Notes""]},{""url"":""https://lists.sequoia-pgp.org/hyperkitty/list/announce@lists.sequoia-pgp.org/thread/SN2E3QRT4DMQ5JNEK6VIN6DJ5SH766DI/"",""source"":""cve@mitre.org"",""tags"":[""Patch""]},{""url"":""https://rustsec.org/advisories/RUSTSEC-2023-0039.html"",""source"":""cve@mitre.org"",""tags"":[""Third Party Advisory""]}]","[{""source"":""cve@mitre.org"",""type"":""Secondary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L"",""baseScore"":2.9,""baseSeverity"":""LOW"",""attackVector"":""LOCAL"",""attackComplexity"":""HIGH"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""LOW""},""exploitabilityScore"":1.4,""impactScore"":1.4},{""source"":""nvd@nist.gov"",""type"":""Primary"",""cvssData"":{""version"":""3.1"",""vectorString"":""CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L"",""baseScore"":5.3,""baseSeverity"":""MEDIUM"",""attackVector"":""NETWORK"",""attackComplexity"":""LOW"",""privilegesRequired"":""NONE"",""userInteraction"":""NONE"",""scope"":""UNCHANGED"",""confidentialityImpact"":""NONE"",""integrityImpact"":""NONE"",""availabilityImpact"":""LOW""},""exploitabilityScore"":3.9,""impactScore"":1.4}]",,,,,,,,
CVE-2023-53163,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:37.983,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: don't hold ni_lock when calling truncate_setsize() syzbot is reporting hung task at do_user_addr_fault() [1], for there is a silent deadlock between PG_locked bit and ni_lock lock. Since filemap_update_page() calls filemap_read_folio() after calling folio_trylock() which will set PG_locked bit, ntfs_truncate() must not call truncate_setsize() which will wait for PG_locked bit to be cleared when holding ni_lock lock.",,,"[{""url"":""https://git.kernel.org/stable/c/0226635c304cfd5c9db9b78c259cb713819b057e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6bb6b1c6b0c31e36736b87a39dd1cbbd9d5ec22f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73fee7e1e5ea11b51c51c46e0577a197ca3602cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8414983c2e649364d8af29080a0869266b31abb6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53164,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:38.097,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: irqchip/ti-sci: Fix refcount leak in ti_sci_intr_irq_domain_probe of_irq_find_parent() returns a node pointer with refcount incremented, We should use of_node_put() on it when not needed anymore. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/02298b7bae12936ca313975b02e7f98b06670d37"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/07fceab32096c1290b491f2fcaace03f78e2db37"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4ae40c20f1519e1767ba01609abc7e8d6485fc0c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/856fc2195494d1175ada0f1f46f92c5b28ce12eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a0d91a48e1a020fb636f0fcaf44672f123bb0799"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/df8d3536b660c6c6f6b25fa8b157e9b38ad78142"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53165,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:38.220,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: udf: Fix uninitialized array access for some pathnames For filenames that begin with . and are between 2 and 5 characters long, UDF charset conversion code would read uninitialized memory in the output buffer. The only practical impact is that the name may be prepended a ""unification hash"" when it is not actually needed but still it is good to fix this.",,,"[{""url"":""https://git.kernel.org/stable/c/008ae78d1e12efa904dc819b1ec83e2bca6b2c56"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/028f6055c912588e6f72722d89c30b401bbcf013"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f1368af47acf4d0b2a5fb0d2c0d6919d2234b6d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4503f6fc95d6dee85fb2c54785848799e192c51c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4d50988da0db167aed6f38685145cb5cd526c4f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/985f9666698960dfc87a106d6314203fa90fda75"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6824149809395dfbb5bc36bc7057cc3cb84e56d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b37f998d357102e8eb0f8eeb33f03fff22e49cbf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53166,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:38.343,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: power: supply: bq25890: Fix external_power_changed race bq25890_charger_external_power_changed() dereferences bq->charger, which gets sets in bq25890_power_supply_init() like this: bq->charger = devm_power_supply_register(bq->dev, &bq->desc, &psy_cfg); As soon as devm_power_supply_register() has called device_add() the external_power_changed callback can get called. So there is a window where bq25890_charger_external_power_changed() may get called while bq->charger has not been set yet leading to a NULL pointer dereference. This race hits during boot sometimes on a Lenovo Yoga Book 1 yb1-x90f when the cht_wcove_pwrsrc (extcon) power_supply is done with detecting the connected charger-type which happens to exactly hit the small window: BUG: kernel NULL pointer dereference, address: 0000000000000018 <snip> RIP: 0010:__power_supply_is_supplied_by+0xb/0xb0 <snip> Call Trace: <TASK> __power_supply_get_supplier_property+0x19/0x50 class_for_each_device+0xb1/0xe0 power_supply_get_property_from_supplier+0x2e/0x50 bq25890_charger_external_power_changed+0x38/0x1b0 [bq25890_charger] __power_supply_changed_work+0x30/0x40 class_for_each_device+0xb1/0xe0 power_supply_changed_work+0x5f/0xe0 <snip> Fixing this is easy. The external_power_changed callback gets passed the power_supply which will eventually get stored in bq->charger, so bq25890_charger_external_power_changed() can simply directly use the passed in psy argument which is always valid.",,,"[{""url"":""https://git.kernel.org/stable/c/029a443b9b6424170f00f6dd5b7682e682cce92e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/72c28207c19c2c46fab8ae994aff25e197fb2949"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d20fa1982c35697f3f8c4ae0f12791691ae5958"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53167,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:38.457,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tracing: Fix null pointer dereference in tracing_err_log_open() Fix an issue in function 'tracing_err_log_open'. The function doesn't call 'seq_open' if the file is opened only with write permissions, which results in 'file->private_data' being left as null. If we then use 'lseek' on that opened file, 'seq_lseek' dereferences 'file->private_data' in 'mutex_lock(&m->lock)', resulting in a kernel panic. Writing to this node requires root privileges, therefore this bug has very little security impact. Tracefs node: /sys/kernel/tracing/error_log Example Kernel panic: Unable to handle kernel NULL pointer dereference at virtual address 0000000000000038 Call trace: mutex_lock+0x30/0x110 seq_lseek+0x34/0xb8 __arm64_sys_lseek+0x6c/0xb8 invoke_syscall+0x58/0x13c el0_svc_common+0xc4/0x10c do_el0_svc+0x24/0x98 el0_svc+0x24/0x88 el0t_64_sync_handler+0x84/0xe4 el0t_64_sync+0x1b4/0x1b8 Code: d503201f aa0803e0 aa1f03e1 aa0103e9 (c8e97d02) ---[ end trace 561d1b49c12cf8a5 ]--- Kernel panic - not syncing: Oops: Fatal exception",,,"[{""url"":""https://git.kernel.org/stable/c/02b0095e2fbbc060560c1065f86a211d91e27b26"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1e1c9aa9288a46c342f0f2c5c0b1c0876b9b0276"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3b5d9b7b875968a8a8c99dac45cb85b705c44802"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7060e5aac6dc195124c106f49106d653a416323a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/93114cbc7cb169f6f26eeaed5286b91bb86b463b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/938d5b7a75e18264887387ddf9169db6d8aeef98"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53168,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:38.580,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: ucsi_acpi: Increase the command completion timeout Commit 130a96d698d7 (""usb: typec: ucsi: acpi: Increase command completion timeout value"") increased the timeout from 5 seconds to 60 seconds due to issues related to alternate mode discovery. After the alternate mode discovery switch to polled mode the timeout was reduced, but instead of being set back to 5 seconds it was reduced to 1 second. This is causing problems when using a Lenovo ThinkPad X1 yoga gen7 connected over Type-C to a LG 27UL850-W (charging DP over Type-C). When the monitor is already connected at boot the following error is logged: ""PPM init failed (-110)"", /sys/class/typec is empty and on unplugging the NULL pointer deref fixed earlier in this series happens. When the monitor is connected after boot the following error is logged instead: ""GET_CONNECTOR_STATUS failed (-110)"". Setting the timeout back to 5 seconds fixes both cases.",,,"[{""url"":""https://git.kernel.org/stable/c/02d210f434249a7edbc160969b75df030dc6934d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1e8525f37871741a52370627633962f8bdcab15a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8346d21d1d8a63f46f60e6899f4f80b1306acf32"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53169,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:38.693,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: x86/resctrl: Clear staged_config[] before and after it is used As a temporary storage, staged_config[] in rdt_domain should be cleared before and after it is used. The stale value in staged_config[] could cause an MSR access error. Here is a reproducer on a system with 16 usable CLOSIDs for a 15-way L3 Cache (MBA should be disabled if the number of CLOSIDs for MB is less than 16.) : mount -t resctrl resctrl -o cdp /sys/fs/resctrl mkdir /sys/fs/resctrl/p{1..7} umount /sys/fs/resctrl/ mount -t resctrl resctrl /sys/fs/resctrl mkdir /sys/fs/resctrl/p{1..8} An error occurs when creating resource group named p8: unchecked MSR access error: WRMSR to 0xca0 (tried to write 0x00000000000007ff) at rIP: 0xffffffff82249142 (cat_wrmsr+0x32/0x60) Call Trace: <IRQ> __flush_smp_call_function_queue+0x11d/0x170 __sysvec_call_function+0x24/0xd0 sysvec_call_function+0x89/0xc0 </IRQ> <TASK> asm_sysvec_call_function+0x16/0x20 When creating a new resource control group, hardware will be configured by the following process: rdtgroup_mkdir() rdtgroup_mkdir_ctrl_mon() rdtgroup_init_alloc() resctrl_arch_update_domains() resctrl_arch_update_domains() iterates and updates all resctrl_conf_type whose have_new_ctrl is true. Since staged_config[] holds the same values as when CDP was enabled, it will continue to update the CDP_CODE and CDP_DATA configurations. When group p8 is created, get_config_index() called in resctrl_arch_update_domains() will return 16 and 17 as the CLOSIDs for CDP_CODE and CDP_DATA, which will be translated to an invalid register - 0xca0 in this scenario. Fix it by clearing staged_config[] before and after it is used. [reinette: re-order commit tags]",,,"[{""url"":""https://git.kernel.org/stable/c/0424a7dfe9129b93f29b277511a60e87f052ac6b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3fc5941ecc31a495b6b84b465f36155009db99b5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/86db319d25db70cf4af4557e05f6fa6f39c70003"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ecc60ef9318f0d533b866fa421858cc185bccfc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53170,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:38.823,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: dsa: Removed unneeded of_node_put in felix_parse_ports_node Remove unnecessary of_node_put from the continue path to prevent child node from being released twice, which could avoid resource leak or other unexpected issues.",,,"[{""url"":""https://git.kernel.org/stable/c/04499f28b40bfc24f20b0e2331008bb90a54a6cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ead10b44b79ce8bfcd51e749d54e009de5f511a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53171,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:38.940,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: vfio/type1: prevent underflow of locked_vm via exec() When a vfio container is preserved across exec, the task does not change, but it gets a new mm with locked_vm=0, and loses the count from existing dma mappings. If the user later unmaps a dma mapping, locked_vm underflows to a large unsigned value, and a subsequent dma map request fails with ENOMEM in __account_locked_vm. To avoid underflow, grab and save the mm at the time a dma is mapped. Use that mm when adjusting locked_vm, rather than re-acquiring the saved task's mm, which may have changed. If the saved mm is dead, do nothing. locked_vm is incremented for existing mappings in a subsequent patch.",,,"[{""url"":""https://git.kernel.org/stable/c/046eca5018f8a5dd1dc2cedf87fb5843b9ea3026"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a271242716846cc016736fb76be2b40ee49b0c3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a6b2aabe664098d5cf877ae0fd96459464a30e17"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b0790dff0760b7734cf0961f497ad64628ca550b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eafb81c50da899dd80b340c841277acc4a1945b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53172,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:39.057,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fsverity: reject FS_IOC_ENABLE_VERITY on mode 3 fds Commit 56124d6c87fd (""fsverity: support enabling with tree block size < PAGE_SIZE"") changed FS_IOC_ENABLE_VERITY to use __kernel_read() to read the file's data, instead of direct pagecache accesses. An unintended consequence of this is that the 'WARN_ON_ONCE(!(file->f_mode & FMODE_READ))' in __kernel_read() became reachable by fuzz tests. This happens if FS_IOC_ENABLE_VERITY is called on a fd opened with access mode 3, which means ""ioctl access only"". Arguably, FS_IOC_ENABLE_VERITY should work on ioctl-only fds. But ioctl-only fds are a weird Linux extension that is rarely used and that few people even know about. (The documentation for FS_IOC_ENABLE_VERITY even specifically says it requires O_RDONLY.) It's probably not worthwhile to make the ioctl internally open a new fd just to handle this case. Thus, just reject the ioctl on such fds for now.",,,"[{""url"":""https://git.kernel.org/stable/c/04839139213cf60d4c5fc792214a08830e294ff8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/85c039cff3c359967cafe90443c02321e950b216"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53173,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:39.170,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: tty: pcn_uart: fix memory leak with using debugfs_lookup() When calling debugfs_lookup() the result must have dput() called on it, otherwise the memory will leak over time. To make things simpler, just call debugfs_lookup_and_remove() instead which handles all of the logic at once.",,,"[{""url"":""https://git.kernel.org/stable/c/04a189c720aa2b6091442113ce9b9bc93552dff8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/139769c4bd8273b5e3f85ea474aa37018fe7e436"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4459d1e7bd0421b3b6fcd745773d8823f71615ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cf042964c2fa72950bbbf25b2cdd732b873e89db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53174,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:39.283,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: core: Fix possible memory leak if device_add() fails If device_add() returns error, the name allocated by dev_set_name() needs be freed. As the comment of device_add() says, put_device() should be used to decrease the reference count in the error path. So fix this by calling put_device(), then the name can be freed in kobject_cleanp().",,,"[{""url"":""https://git.kernel.org/stable/c/04b5b5cb0136ce970333a9c6cec7e46adba1ea3a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/06c5340858011aa1195aec43a776e3185fbf7f56"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/43c0e16d0c5ec59398b405f4c4aa5a076e656c3f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/63956ad27a6882f01fea7c69e17823090f4c7b3f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6bc7f4c8c27d526f968788b8a985896755b1df35"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa9a76d5ffdecd3b52ac333eb89361b0c9fe04e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b191ff1f075c4875f11271cbf0093e6e044a12aa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e12fac07f61caac9c5b186d827658b3470787619"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53175,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:39.410,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: PCI: hv: Fix a crash in hv_pci_restore_msi_msg() during hibernation When a Linux VM with an assigned PCI device runs on Hyper-V, if the PCI device driver is not loaded yet (i.e. MSI-X/MSI is not enabled on the device yet), doing a VM hibernation triggers a panic in hv_pci_restore_msi_msg() -> msi_lock_descs(&pdev->dev), because pdev->dev.msi.data is still NULL. Avoid the panic by checking if MSI-X/MSI is enabled.",,,"[{""url"":""https://git.kernel.org/stable/c/04bbe863241a9be7d57fb4cf217ee4a72f480e70"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/223fc5352054900f70b8b5e10cfc2f297e70c512"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d0687755407b21d252b98dca6be459153a60c62a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e32fc2168aa6b477290392ddbb73d95f012b050c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53176,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:39.527,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: serial: 8250: Reinit port->pm on port specific driver unbind When we unbind a serial port hardware specific 8250 driver, the generic serial8250 driver takes over the port. After that we see an oops about 10 seconds later. This can produce the following at least on some TI SoCs: Unhandled fault: imprecise external abort (0x1406) Internal error: : 1406 [#1] SMP ARM Turns out that we may still have the serial port hardware specific driver port->pm in use, and serial8250_pm() tries to call it after the port specific driver is gone: serial8250_pm [8250_base] from uart_change_pm+0x54/0x8c [serial_base] uart_change_pm [serial_base] from uart_hangup+0x154/0x198 [serial_base] uart_hangup [serial_base] from __tty_hangup.part.0+0x328/0x37c __tty_hangup.part.0 from disassociate_ctty+0x154/0x20c disassociate_ctty from do_exit+0x744/0xaac do_exit from do_group_exit+0x40/0x8c do_group_exit from __wake_up_parent+0x0/0x1c Let's fix the issue by calling serial8250_set_defaults() in serial8250_unregister_port(). This will set the port back to using the serial8250 default functions, and sets the port->pm to point to serial8250_pm.",,,"[{""url"":""https://git.kernel.org/stable/c/04e82793f068d2f0ffe62fcea03d007a8cdc16a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1ba5594739d858e524ff0f398ee1ebfe0a8b9d41"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2c86a1305c1406f45ea780d06953c484ea1d9e6e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/490bf37eaabb0a857ed1ae8e75d8854e41662f1c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8e596aed5f2f98cf3e6e98d6fe1d689f4a319308"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/af4d6dbb1a92ea424ad1ba1d0c88c7fa2345d872"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c9e080c3005fd183c56ff8f4d75edb5da0765d2c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d5cd2928d31042a7c0a01464f9a8d95be736421d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53177,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:39.670,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: hi846: fix usage of pm_runtime_get_if_in_use() pm_runtime_get_if_in_use() does not only return nonzero values when the device is in use, it can return a negative errno too. And especially during resuming from system suspend, when runtime pm is not yet up again, -EAGAIN is being returned, so the subsequent pm_runtime_put() call results in a refcount underflow. Fix system-resume by handling -EAGAIN of pm_runtime_get_if_in_use().",,,"[{""url"":""https://git.kernel.org/stable/c/04fc06f6dc1592ed5d675311ac50d8fba5db62ab"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/42ec6269f98edd915ee37da3c6456bb6243ea56a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c5dcd7a19f1ed8fe98384f3a9444c7c53befd74e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53178,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:39.803,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mm: fix zswap writeback race condition The zswap writeback mechanism can cause a race condition resulting in memory corruption, where a swapped out page gets swapped in with data that was written to a different page. The race unfolds like this: 1. a page with data A and swap offset X is stored in zswap 2. page A is removed off the LRU by zpool driver for writeback in zswap-shrink work, data for A is mapped by zpool driver 3. user space program faults and invalidates page entry A, offset X is considered free 4. kswapd stores page B at offset X in zswap (zswap could also be full, if so, page B would then be IOed to X, then skip step 5.) 5. entry A is replaced by B in tree->rbroot, this doesn't affect the local reference held by zswap-shrink work 6. zswap-shrink work writes back A at X, and frees zswap entry A 7. swapin of slot X brings A in memory instead of B The fix: Once the swap page cache has been allocated (case ZSWAP_SWAPCACHE_NEW), zswap-shrink work just checks that the local zswap_entry reference is still the same as the one in the tree. If it's not the same it means that it's either been invalidated or replaced, in both cases the writeback is aborted because the local entry contains stale data. Reproducer: I originally found this by running `stress` overnight to validate my work on the zswap writeback mechanism, it manifested after hours on my test machine. The key to make it happen is having zswap writebacks, so whatever setup pumps /sys/kernel/debug/zswap/written_back_pages should do the trick. In order to reproduce this faster on a vm, I setup a system with ~100M of available memory and a 500M swap file, then running `stress --vm 1 --vm-bytes 300000000 --vm-stride 4000` makes it happen in matter of tens of minutes. One can speed things up even more by swinging /sys/module/zswap/parameters/max_pool_percent up and down between, say, 20 and 1; this makes it reproduce in tens of seconds. It's crucial to set `--vm-stride` to something other than 4096 otherwise `stress` won't realize that memory has been corrupted because all pages would have the same data.",,,"[{""url"":""https://git.kernel.org/stable/c/04fc7816089c5a32c29a04ec94b998e219dfb946"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2cab13f500a6333bd2b853783ac76be9e4956f8a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba700ea13bf0105a4773c654f7d3bef8adb64ab2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53179,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:39.920,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: ipset: add the missing IP_SET_HASH_WITH_NET0 macro for ip_set_hash_netportnet.c The missing IP_SET_HASH_WITH_NET0 macro in ip_set_hash_netportnet can lead to the use of wrong `CIDR_POS(c)` for calculating array offsets, which can lead to integer underflow. As a result, it leads to slab out-of-bound access. This patch adds back the IP_SET_HASH_WITH_NET0 macro to ip_set_hash_netportnet to address the issue.",,,"[{""url"":""https://git.kernel.org/stable/c/050d91c03b28ca479df13dfb02bcd2c60dd6a878"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/109e830585e89a03d554bf8ad0e668630d0a6260"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7935b636dd693dfe4483cfef4a1e91366c8103fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ca0706c68adadf86a36b60dca090f5e9481e808"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/83091f8ac03f118086596f17c9a52d31d6ca94b3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9e6142e5f8f6ac7d1bca45c1b2b13b084ea9e14"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d59b6fc405549f7caf31f6aa5da1d6bef746b166"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d95c8420efe684b964e3aa28108e9a354bcd7225"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e632d09dffc68b9602d6893a99bfe3001d36cefc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53180,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:40.057,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: Avoid NULL pointer access during management transmit cleanup Currently 'ar' reference is not added in skb_cb. Though this is generally not used during transmit completion callbacks, on interface removal the remaining idr cleanup callback uses the ar pointer from skb_cb from management txmgmt_idr. Hence fill them during transmit call for proper usage to avoid NULL pointer dereference. Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.0.1-00029-QCAHKSWPL_SILICONZ-1",,,"[{""url"":""https://git.kernel.org/stable/c/054b5580a36e435692c203c19abdcb9f7734320e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7382d02160ef93c806fe1c1d4ef1fec445266747"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53181,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:40.173,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: dma-buf/dma-resv: Stop leaking on krealloc() failure Currently dma_resv_get_fences() will leak the previously allocated array if the fence iteration got restarted and the krealloc_array() fails. Free the old array by hand, and make sure we still clear the returned *fences so the caller won't end up accessing freed memory. Some (but not all) of the callers of dma_resv_get_fences() seem to still trawl through the array even when dma_resv_get_fences() failed. And let's zero out *num_fences as well for good measure.",,,"[{""url"":""https://git.kernel.org/stable/c/05abb3be91d8788328231ee02973ab3d47f5e3d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/19e7b9f1f7e1cb92a4cc53b4c064f7fb4b1f1983"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/819656cc03dec7f7f7800274dfbc8eb49f888e9f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53182,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:40.287,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ACPICA: Avoid undefined behavior: applying zero offset to null pointer ACPICA commit 770653e3ba67c30a629ca7d12e352d83c2541b1e Before this change we see the following UBSAN stack trace in Fuchsia: #0 0x000021e4213b3302 in acpi_ds_init_aml_walk(struct acpi_walk_state*, union acpi_parse_object*, struct acpi_namespace_node*, u8*, u32, struct acpi_evaluate_info*, u8) ../../third_party/acpica/source/components/dispatcher/dswstate.c:682 <platform-bus-x86.so>+0x233302 #1.2 0x000020d0f660777f in ubsan_get_stack_trace() compiler-rt/lib/ubsan/ubsan_diag.cpp:41 <libclang_rt.asan.so>+0x3d77f #1.1 0x000020d0f660777f in maybe_print_stack_trace() compiler-rt/lib/ubsan/ubsan_diag.cpp:51 <libclang_rt.asan.so>+0x3d77f #1 0x000020d0f660777f in ~scoped_report() compiler-rt/lib/ubsan/ubsan_diag.cpp:387 <libclang_rt.asan.so>+0x3d77f #2 0x000020d0f660b96d in handlepointer_overflow_impl() compiler-rt/lib/ubsan/ubsan_handlers.cpp:809 <libclang_rt.asan.so>+0x4196d #3 0x000020d0f660b50d in compiler-rt/lib/ubsan/ubsan_handlers.cpp:815 <libclang_rt.asan.so>+0x4150d #4 0x000021e4213b3302 in acpi_ds_init_aml_walk(struct acpi_walk_state*, union acpi_parse_object*, struct acpi_namespace_node*, u8*, u32, struct acpi_evaluate_info*, u8) ../../third_party/acpica/source/components/dispatcher/dswstate.c:682 <platform-bus-x86.so>+0x233302 #5 0x000021e4213e2369 in acpi_ds_call_control_method(struct acpi_thread_state*, struct acpi_walk_state*, union acpi_parse_object*) ../../third_party/acpica/source/components/dispatcher/dsmethod.c:605 <platform-bus-x86.so>+0x262369 #6 0x000021e421437fac in acpi_ps_parse_aml(struct acpi_walk_state*) ../../third_party/acpica/source/components/parser/psparse.c:550 <platform-bus-x86.so>+0x2b7fac #7 0x000021e4214464d2 in acpi_ps_execute_method(struct acpi_evaluate_info*) ../../third_party/acpica/source/components/parser/psxface.c:244 <platform-bus-x86.so>+0x2c64d2 #8 0x000021e4213aa052 in acpi_ns_evaluate(struct acpi_evaluate_info*) ../../third_party/acpica/source/components/namespace/nseval.c:250 <platform-bus-x86.so>+0x22a052 #9 0x000021e421413dd8 in acpi_ns_init_one_device(acpi_handle, u32, void*, void**) ../../third_party/acpica/source/components/namespace/nsinit.c:735 <platform-bus-x86.so>+0x293dd8 #10 0x000021e421429e98 in acpi_ns_walk_namespace(acpi_object_type, acpi_handle, u32, u32, acpi_walk_callback, acpi_walk_callback, void*, void**) ../../third_party/acpica/source/components/namespace/nswalk.c:298 <platform-bus-x86.so>+0x2a9e98 #11 0x000021e4214131ac in acpi_ns_initialize_devices(u32) ../../third_party/acpica/source/components/namespace/nsinit.c:268 <platform-bus-x86.so>+0x2931ac #12 0x000021e42147c40d in acpi_initialize_objects(u32) ../../third_party/acpica/source/components/utilities/utxfinit.c:304 <platform-bus-x86.so>+0x2fc40d #13 0x000021e42126d603 in acpi::acpi_impl::initialize_acpi(acpi::acpi_impl*) ../../src/devices/board/lib/acpi/acpi-impl.cc:224 <platform-bus-x86.so>+0xed603 Add a simple check that avoids incrementing a pointer by zero, but otherwise behaves as before. Note that our findings are against ACPICA 20221020, but the same code exists on master.",,,"[{""url"":""https://git.kernel.org/stable/c/05bb0167c80b8f93c6a4e0451b7da9b96db990c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/16359bc02c093b0862e31739c07673340a2106a6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3048c6b84a51e4ba4a89385ed218d19a670edd47"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/35465c7a91c6b46e7c14d0c01d0084349a38ce51"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3a7a4aa3958ce0c4938a443d65001debe9a9af9c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a2d0dcb47b16f84880a59571eab8a004e3236d7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/710e09fd116e2fa53e319a416ad4e4f8027682b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c4a7163b7f1495e3cc58bec7a4100de6612cde9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53183,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:40.420,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: exit gracefully if reloc roots don't match [BUG] Syzbot reported a crash that an ASSERT() got triggered inside prepare_to_merge(). [CAUSE] The root cause of the triggered ASSERT() is we can have a race between quota tree creation and relocation. This leads us to create a duplicated quota tree in the btrfs_read_fs_root() path, and since it's treated as fs tree, it would have ROOT_SHAREABLE flag, causing us to create a reloc tree for it. The bug itself is fixed by a dedicated patch for it, but this already taught us the ASSERT() is not something straightforward for developers. [ENHANCEMENT] Instead of using an ASSERT(), let's handle it gracefully and output extra info about the mismatch reloc roots to help debug. Also with the above ASSERT() removed, we can trigger ASSERT(0)s inside merge_reloc_roots() later. Also replace those ASSERT(0)s with WARN_ON()s.",,,"[{""url"":""https://git.kernel.org/stable/c/05d7ce504545f7874529701664c90814ca645c5d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/69dd147de419b04d1d8d2ca67ef424cddd5b8fd5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9d04716e36654275aea00fb93fc9b30b850925e7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a96b6519ac71583835cb46d74bc450de5a13877f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53184,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:40.540,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: arm64/sme: Set new vector length before reallocating As part of fixing the allocation of the buffer for SVE state when changing SME vector length we introduced an immediate reallocation of the SVE state, this is also done when changing the SVE vector length for consistency. Unfortunately this reallocation is done prior to writing the new vector length to the task struct, meaning the allocation is done with the old vector length and can lead to memory corruption due to an undersized buffer being used. Move the update of the vector length before the allocation to ensure that the new vector length is taken into account. For some reason this isn't triggering any problems when running tests on the arm64 fixes branch (even after repeated tries) but is triggering issues very often after merge into mainline.",,,"[{""url"":""https://git.kernel.org/stable/c/05d881b85b48c7ac6a7c92ce00aa916c4a84d052"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/356e711640aea6ed145da9407499388b45264cb4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/807ada0e4aa3c9090c66009a99fa530c462012c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53185,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:40.657,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath9k: don't allow to overwrite ENDPOINT0 attributes A bad USB device is able to construct a service connection response message with target endpoint being ENDPOINT0 which is reserved for HTC_CTRL_RSVD_SVC and should not be modified to be used for any other services. Reject such service connection responses. Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",,,"[{""url"":""https://git.kernel.org/stable/c/061b0cb9327b80d7a0f63a33e7c3e2a91a71f142"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/09740fa9827cfbaf23ecd041e602a426f99be888"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1044187e7249073f719ebbf9e5ffb4f16f99e555"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4dc3560561a08842b4a4c07ccc5a90e5067dbb5b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6a444dffb75238c47d2d852f12cf53f12ad2cba8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/95b4b940f0fb2873dcedad81699e869eb7581c85"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9e3031eea2d45918dc44cbfc6a6029e82882916f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be2a546c30fe8d72efa032bee612363bb75314bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/db8df00cd6d801b3abdb145201c2bdd1c665f585"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53186,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:40.783,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: skbuff: Fix a race between coalescing and releasing SKBs Commit 1effe8ca4e34 (""skbuff: fix coalescing for page_pool fragment recycling"") allowed coalescing to proceed with non page pool page and page pool page when @from is cloned, i.e. to->pp_recycle --> false from->pp_recycle --> true skb_cloned(from) --> true However, it actually requires skb_cloned(@from) to hold true until coalescing finishes in this situation. If the other cloned SKB is released while the merging is in process, from_shinfo->nr_frags will be set to 0 toward the end of the function, causing the increment of frag page _refcount to be unexpectedly skipped resulting in inconsistent reference counts. Later when SKB(@to) is released, it frees the page directly even though the page pool page is still in use, leading to use-after-free or double-free errors. So it should be prohibited. The double-free error message below prompted us to investigate: BUG: Bad page state in process swapper/1 pfn:0e0d1 page:00000000c6548b28 refcount:-1 mapcount:0 mapping:0000000000000000 index:0x2 pfn:0xe0d1 flags: 0xfffffc0000000(node=0|zone=1|lastcpupid=0x1fffff) raw: 000fffffc0000000 0000000000000000 ffffffff00000101 0000000000000000 raw: 0000000000000002 0000000000000000 ffffffffffffffff 0000000000000000 page dumped because: nonzero _refcount CPU: 1 PID: 0 Comm: swapper/1 Tainted: G E 6.2.0+ Call Trace: <IRQ> dump_stack_lvl+0x32/0x50 bad_page+0x69/0xf0 free_pcp_prepare+0x260/0x2f0 free_unref_page+0x20/0x1c0 skb_release_data+0x10b/0x1a0 napi_consume_skb+0x56/0x150 net_rx_action+0xf0/0x350 ? __napi_schedule+0x79/0x90 __do_softirq+0xc8/0x2b1 __irq_exit_rcu+0xb9/0xf0 common_interrupt+0x82/0xa0 </IRQ> <TASK> asm_common_interrupt+0x22/0x40 RIP: 0010:default_idle+0xb/0x20",,,"[{""url"":""https://git.kernel.org/stable/c/0646dc31ca886693274df5749cd0c8c1eaaeb5ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5f692c992a3bb9a8018e3488098b401a4229e7ec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/71850b5af92da21b4862a9bc55bda61091247d00"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/906a6689bb0191ad2a44131a3377006aa098af59"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53187,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:40.907,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: fix use-after-free of new block group that became unused If a task creates a new block group and that block group becomes unused before we finish its creation, at btrfs_create_pending_block_groups(), then when btrfs_mark_bg_unused() is called against the block group, we assume that the block group is currently in the list of block groups to reclaim, and we move it out of the list of new block groups and into the list of unused block groups. This has two consequences: 1) We move it out of the list of new block groups associated to the current transaction. So the block group creation is not finished and if we attempt to delete the bg because it's unused, we will not find the block group item in the extent tree (or the new block group tree), its device extent items in the device tree etc, resulting in the deletion to fail due to the missing items; 2) We don't increment the reference count on the block group when we move it to the list of unused block groups, because we assumed the block group was on the list of block groups to reclaim, and in that case it already has the correct reference count. However the block group was on the list of new block groups, in which case no extra reference was taken because it's local to the current task. This later results in doing an extra reference count decrement when removing the block group from the unused list, eventually leading the reference count to 0. This second case was caught when running generic/297 from fstests, which produced the following assertion failure and stack trace: [589.559] assertion failed: refcount_read(&block_group->refs) == 1, in fs/btrfs/block-group.c:4299 [589.559] ------------[ cut here ]------------ [589.559] kernel BUG at fs/btrfs/block-group.c:4299! [589.560] invalid opcode: 0000 [#1] PREEMPT SMP PTI [589.560] CPU: 8 PID: 2819134 Comm: umount Tainted: G W 6.4.0-rc6-btrfs-next-134+ #1 [589.560] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-0-gea1b7a073390-prebuilt.qemu.org 04/01/2014 [589.560] RIP: 0010:btrfs_free_block_groups+0x449/0x4a0 [btrfs] [589.561] Code: 68 62 da c0 (...) [589.561] RSP: 0018:ffffa55a8c3b3d98 EFLAGS: 00010246 [589.561] RAX: 0000000000000058 RBX: ffff8f030d7f2000 RCX: 0000000000000000 [589.562] RDX: 0000000000000000 RSI: ffffffff953f0878 RDI: 00000000ffffffff [589.562] RBP: ffff8f030d7f2088 R08: 0000000000000000 R09: ffffa55a8c3b3c50 [589.562] R10: 0000000000000001 R11: 0000000000000001 R12: ffff8f05850b4c00 [589.562] R13: ffff8f030d7f2090 R14: ffff8f05850b4cd8 R15: dead000000000100 [589.563] FS: 00007f497fd2e840(0000) GS:ffff8f09dfc00000(0000) knlGS:0000000000000000 [589.563] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [589.563] CR2: 00007f497ff8ec10 CR3: 0000000271472006 CR4: 0000000000370ee0 [589.563] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [589.564] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [589.564] Call Trace: [589.564] <TASK> [589.565] ? __die_body+0x1b/0x60 [589.565] ? die+0x39/0x60 [589.565] ? do_trap+0xeb/0x110 [589.565] ? btrfs_free_block_groups+0x449/0x4a0 [btrfs] [589.566] ? do_error_trap+0x6a/0x90 [589.566] ? btrfs_free_block_groups+0x449/0x4a0 [btrfs] [589.566] ? exc_invalid_op+0x4e/0x70 [589.566] ? btrfs_free_block_groups+0x449/0x4a0 [btrfs] [589.567] ? asm_exc_invalid_op+0x16/0x20 [589.567] ? btrfs_free_block_groups+0x449/0x4a0 [btrfs] [589.567] ? btrfs_free_block_groups+0x449/0x4a0 [btrfs] [589.567] close_ctree+0x35d/0x560 [btrfs] [589.568] ? fsnotify_sb_delete+0x13e/0x1d0 [589.568] ? dispose_list+0x3a/0x50 [589.568] ? evict_inodes+0x151/0x1a0 [589.568] generic_shutdown_super+0x73/0x1a0 [589.569] kill_anon_super+0x14/0x30 [589.569] btrfs_kill_super+0x12/0x20 [btrfs] [589.569] deactivate_locked ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/0657b20c5a76c938612f8409735a8830d257866e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6297644db23f77c02ae7961cc542d162629ae2c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7569c4294ba6ff9f194635b14876198f8a687c4a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53188,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:41.023,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: openvswitch: fix race on port output assume the following setup on a single machine: 1. An openvswitch instance with one bridge and default flows 2. two network namespaces ""server"" and ""client"" 3. two ovs interfaces ""server"" and ""client"" on the bridge 4. for each ovs interface a veth pair with a matching name and 32 rx and tx queues 5. move the ends of the veth pairs to the respective network namespaces 6. assign ip addresses to each of the veth ends in the namespaces (needs to be the same subnet) 7. start some http server on the server network namespace 8. test if a client in the client namespace can reach the http server when following the actions below the host has a chance of getting a cpu stuck in a infinite loop: 1. send a large amount of parallel requests to the http server (around 3000 curls should work) 2. in parallel delete the network namespace (do not delete interfaces or stop the server, just kill the namespace) there is a low chance that this will cause the below kernel cpu stuck message. If this does not happen just retry. Below there is also the output of bpftrace for the functions mentioned in the output. The series of events happening here is: 1. the network namespace is deleted calling `unregister_netdevice_many_notify` somewhere in the process 2. this sets first `NETREG_UNREGISTERING` on both ends of the veth and then runs `synchronize_net` 3. it then calls `call_netdevice_notifiers` with `NETDEV_UNREGISTER` 4. this is then handled by `dp_device_event` which calls `ovs_netdev_detach_dev` (if a vport is found, which is the case for the veth interface attached to ovs) 5. this removes the rx_handlers of the device but does not prevent packages to be sent to the device 6. `dp_device_event` then queues the vport deletion to work in background as a ovs_lock is needed that we do not hold in the unregistration path 7. `unregister_netdevice_many_notify` continues to call `netdev_unregister_kobject` which sets `real_num_tx_queues` to 0 8. port deletion continues (but details are not relevant for this issue) 9. at some future point the background task deletes the vport If after 7. but before 9. a packet is send to the ovs vport (which is not deleted at this point in time) which forwards it to the `dev_queue_xmit` flow even though the device is unregistering. In `skb_tx_hash` (which is called in the `dev_queue_xmit`) path there is a while loop (if the packet has a rx_queue recorded) that is infinite if `dev->real_num_tx_queues` is zero. To prevent this from happening we update `do_output` to handle devices without carrier the same as if the device is not found (which would be the code path after 9. is done). Additionally we now produce a warning in `skb_tx_hash` if we will hit the infinite loop. bpftrace (first word is function name): __dev_queue_xmit server: real_num_tx_queues: 1, cpu: 2, pid: 28024, tid: 28024, skb_addr: 0xffff9edb6f207000, reg_state: 1 netdev_core_pick_tx server: addr: 0xffff9f0a46d4a000 real_num_tx_queues: 1, cpu: 2, pid: 28024, tid: 28024, skb_addr: 0xffff9edb6f207000, reg_state: 1 dp_device_event server: real_num_tx_queues: 1 cpu 9, pid: 21024, tid: 21024, event 2, reg_state: 1 synchronize_rcu_expedited: cpu 9, pid: 21024, tid: 21024 synchronize_rcu_expedited: cpu 9, pid: 21024, tid: 21024 synchronize_rcu_expedited: cpu 9, pid: 21024, tid: 21024 synchronize_rcu_expedited: cpu 9, pid: 21024, tid: 21024 dp_device_event server: real_num_tx_queues: 1 cpu 9, pid: 21024, tid: 21024, event 6, reg_state: 2 ovs_netdev_detach_dev server: real_num_tx_queues: 1 cpu 9, pid: 21024, tid: 21024, reg_state: 2 netdev_rx_handler_unregister server: real_num_tx_queues: 1, cpu: 9, pid: 21024, tid: 21024, reg_state: 2 synchronize_rcu_expedited: cpu 9, pid: 21024, tid: 21024 netdev_rx_handler_unregister ret server: real_num_tx_queues: 1, cpu: 9, pid: 21024, tid: 21024, reg_state: 2 dp_ ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/066b86787fa3d97b7aefb5ac0a99a22dad2d15f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/284be5db6c8d06d247ed056cfc448c4f79bbb16c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/56252da41426f3d01957456f13caf46ce670ea29"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5efcb301523baacd98a47553d4996e924923114d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/644b3051b06ba465bc7401bfae9b14963cbc8c1c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9b0dd09c1ceb35950d2884848099fccc9ec9a123"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53189,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:41.150,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ipv6/addrconf: fix a potential refcount underflow for idev Now in addrconf_mod_rs_timer(), reference idev depends on whether rs_timer is not pending. Then modify rs_timer timeout. There is a time gap in [1], during which if the pending rs_timer becomes not pending. It will miss to hold idev, but the rs_timer is activated. Thus rs_timer callback function addrconf_rs_timer() will be executed and put idev later without holding idev. A refcount underflow issue for idev can be caused by this. if (!timer_pending(&idev->rs_timer)) in6_dev_hold(idev); <--------------[1] mod_timer(&idev->rs_timer, jiffies + when); To fix the issue, hold idev if mod_timer() return 0.",,,"[{""url"":""https://git.kernel.org/stable/c/06a0716949c22e2aefb648526580671197151acc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1f656e483eb4733d62f18dfb206a49b78f60f495"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2ad31ce40e8182860b631e37209e93e543790b7c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/436b7cc7eae7851c184b671ed7a4a64c750b86f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/82abd1c37d3bf2a2658b34772c17a25a6f9cca42"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c6395e32935d35e6f935e7caf1c2dac5a95943b4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c7eeba47058532f6077d6a658e38b6698f6ae71a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/df62fdcd004afa72ecbed0e862ebb983acd3aa57"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53190,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:41.277,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: vxlan: Fix memory leaks in error path The memory allocated by vxlan_vnigroup_init() is not freed in the error path, leading to memory leaks [1]. Fix by calling vxlan_vnigroup_uninit() in the error path. The leaks can be reproduced by annotating gro_cells_init() with ALLOW_ERROR_INJECTION() and then running: # echo ""100"" > /sys/kernel/debug/fail_function/probability # echo ""1"" > /sys/kernel/debug/fail_function/times # echo ""gro_cells_init"" > /sys/kernel/debug/fail_function/inject # printf %#x -12 > /sys/kernel/debug/fail_function/gro_cells_init/retval # ip link add name vxlan0 type vxlan dstport 4789 external vnifilter RTNETLINK answers: Cannot allocate memory [1] unreferenced object 0xffff88810db84a00 (size 512): comm ""ip"", pid 330, jiffies 4295010045 (age 66.016s) hex dump (first 32 bytes): f8 d5 76 0e 81 88 ff ff 01 00 00 00 00 00 00 02 ..v............. 03 00 04 00 48 00 00 00 00 00 00 01 04 00 01 00 ....H........... backtrace: [<ffffffff81a3097a>] kmalloc_trace+0x2a/0x60 [<ffffffff82f049fc>] vxlan_vnigroup_init+0x4c/0x160 [<ffffffff82ecd69e>] vxlan_init+0x1ae/0x280 [<ffffffff836858ca>] register_netdevice+0x57a/0x16d0 [<ffffffff82ef67b7>] __vxlan_dev_create+0x7c7/0xa50 [<ffffffff82ef6ce6>] vxlan_newlink+0xd6/0x130 [<ffffffff836d02ab>] __rtnl_newlink+0x112b/0x18a0 [<ffffffff836d0a8c>] rtnl_newlink+0x6c/0xa0 [<ffffffff836c0ddf>] rtnetlink_rcv_msg+0x43f/0xd40 [<ffffffff83908ce0>] netlink_rcv_skb+0x170/0x440 [<ffffffff839066af>] netlink_unicast+0x53f/0x810 [<ffffffff839072d8>] netlink_sendmsg+0x958/0xe70 [<ffffffff835c319f>] ____sys_sendmsg+0x78f/0xa90 [<ffffffff835cd6da>] ___sys_sendmsg+0x13a/0x1e0 [<ffffffff835cd94c>] __sys_sendmsg+0x11c/0x1f0 [<ffffffff8424da78>] do_syscall_64+0x38/0x80 unreferenced object 0xffff88810e76d5f8 (size 192): comm ""ip"", pid 330, jiffies 4295010045 (age 66.016s) hex dump (first 32 bytes): 04 00 00 00 00 00 00 00 db e1 4f e7 00 00 00 00 ..........O..... 08 d6 76 0e 81 88 ff ff 08 d6 76 0e 81 88 ff ff ..v.......v..... backtrace: [<ffffffff81a3162e>] __kmalloc_node+0x4e/0x90 [<ffffffff81a0e166>] kvmalloc_node+0xa6/0x1f0 [<ffffffff8276e1a3>] bucket_table_alloc.isra.0+0x83/0x460 [<ffffffff8276f18b>] rhashtable_init+0x43b/0x7c0 [<ffffffff82f04a1c>] vxlan_vnigroup_init+0x6c/0x160 [<ffffffff82ecd69e>] vxlan_init+0x1ae/0x280 [<ffffffff836858ca>] register_netdevice+0x57a/0x16d0 [<ffffffff82ef67b7>] __vxlan_dev_create+0x7c7/0xa50 [<ffffffff82ef6ce6>] vxlan_newlink+0xd6/0x130 [<ffffffff836d02ab>] __rtnl_newlink+0x112b/0x18a0 [<ffffffff836d0a8c>] rtnl_newlink+0x6c/0xa0 [<ffffffff836c0ddf>] rtnetlink_rcv_msg+0x43f/0xd40 [<ffffffff83908ce0>] netlink_rcv_skb+0x170/0x440 [<ffffffff839066af>] netlink_unicast+0x53f/0x810 [<ffffffff839072d8>] netlink_sendmsg+0x958/0xe70 [<ffffffff835c319f>] ____sys_sendmsg+0x78f/0xa90",,,"[{""url"":""https://git.kernel.org/stable/c/06bf62944144a92d83dd14fd1378d2a288259561"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5896f55810680391a32652ca2b91245a05c11e22"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/75c1ab900f7cf0485f0be1607c79c55f51faaa90"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53191,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:41.400,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: irqchip/alpine-msi: Fix refcount leak in alpine_msix_init_domains of_irq_find_parent() returns a node pointer with refcount incremented, We should use of_node_put() on it when not needed anymore. Add missing of_node_put() to avoid refcount leak.",,,"[{""url"":""https://git.kernel.org/stable/c/071d068b89e95d1b078aa6bbcb9d0961b77d6aa1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5fbf2cc39b62a4afe44f3d42ee3dcf8f012c1926"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/65e30bd1310d90b794c377bf405394157854aa30"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9e79ac4f70fd51243e1c6108d4b0baf16cfde99c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c9aaf4efe1f02b2fef21a69fb3652f5ad12a5710"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d6c66c46889752fa4962c6388516f7ab66a8d6a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eef04516f0c317ce80502c1d6b0d06235a87cd8f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eef09f786df4b34b97557929287c4e5a83bbf09b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53192,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:41.523,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: vxlan: Fix nexthop hash size The nexthop code expects a 31 bit hash, such as what is returned by fib_multipath_hash() and rt6_multipath_hash(). Passing the 32 bit hash returned by skb_get_hash() can lead to problems related to the fact that 'int hash' is a negative number when the MSB is set. In the case of hash threshold nexthop groups, nexthop_select_path_hthr() will disproportionately select the first nexthop group entry. In the case of resilient nexthop groups, nexthop_select_path_res() may do an out of bounds access in nh_buckets[], for example: hash = -912054133 num_nh_buckets = 2 bucket_index = 65535 which leads to the following panic: BUG: unable to handle page fault for address: ffffc900025910c8 PGD 100000067 P4D 100000067 PUD 10026b067 PMD 0 Oops: 0002 [#1] PREEMPT SMP KASAN NOPTI CPU: 4 PID: 856 Comm: kworker/4:3 Not tainted 6.5.0-rc2+ #34 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014 Workqueue: ipv6_addrconf addrconf_dad_work RIP: 0010:nexthop_select_path+0x197/0xbf0 Code: c1 e4 05 be 08 00 00 00 4c 8b 35 a4 14 7e 01 4e 8d 6c 25 00 4a 8d 7c 25 08 48 01 dd e8 c2 25 15 ff 49 8d 7d 08 e8 39 13 15 ff <4d> 89 75 08 48 89 ef e8 7d 12 15 ff 48 8b 5d 00 e8 14 55 2f 00 85 RSP: 0018:ffff88810c36f260 EFLAGS: 00010246 RAX: 0000000000000000 RBX: 00000000002000c0 RCX: ffffffffaf02dd77 RDX: dffffc0000000000 RSI: 0000000000000008 RDI: ffffc900025910c8 RBP: ffffc900025910c0 R08: 0000000000000001 R09: fffff520004b2219 R10: ffffc900025910cf R11: 31392d2068736168 R12: 00000000002000c0 R13: ffffc900025910c0 R14: 00000000fffef608 R15: ffff88811840e900 FS: 0000000000000000(0000) GS:ffff8881f7000000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: ffffc900025910c8 CR3: 0000000129d00000 CR4: 0000000000750ee0 PKRU: 55555554 Call Trace: <TASK> ? __die+0x23/0x70 ? page_fault_oops+0x1ee/0x5c0 ? __pfx_is_prefetch.constprop.0+0x10/0x10 ? __pfx_page_fault_oops+0x10/0x10 ? search_bpf_extables+0xfe/0x1c0 ? fixup_exception+0x3b/0x470 ? exc_page_fault+0xf6/0x110 ? asm_exc_page_fault+0x26/0x30 ? nexthop_select_path+0x197/0xbf0 ? nexthop_select_path+0x197/0xbf0 ? lock_is_held_type+0xe7/0x140 vxlan_xmit+0x5b2/0x2340 ? __lock_acquire+0x92b/0x3370 ? __pfx_vxlan_xmit+0x10/0x10 ? __pfx___lock_acquire+0x10/0x10 ? __pfx_register_lock_class+0x10/0x10 ? skb_network_protocol+0xce/0x2d0 ? dev_hard_start_xmit+0xca/0x350 ? __pfx_vxlan_xmit+0x10/0x10 dev_hard_start_xmit+0xca/0x350 __dev_queue_xmit+0x513/0x1e20 ? __pfx___dev_queue_xmit+0x10/0x10 ? __pfx_lock_release+0x10/0x10 ? mark_held_locks+0x44/0x90 ? skb_push+0x4c/0x80 ? eth_header+0x81/0xe0 ? __pfx_eth_header+0x10/0x10 ? neigh_resolve_output+0x215/0x310 ? ip6_finish_output2+0x2ba/0xc90 ip6_finish_output2+0x2ba/0xc90 ? lock_release+0x236/0x3e0 ? ip6_mtu+0xbb/0x240 ? __pfx_ip6_finish_output2+0x10/0x10 ? find_held_lock+0x83/0xa0 ? lock_is_held_type+0xe7/0x140 ip6_finish_output+0x1ee/0x780 ip6_output+0x138/0x460 ? __pfx_ip6_output+0x10/0x10 ? __pfx___lock_acquire+0x10/0x10 ? __pfx_ip6_finish_output+0x10/0x10 NF_HOOK.constprop.0+0xc0/0x420 ? __pfx_NF_HOOK.constprop.0+0x10/0x10 ? ndisc_send_skb+0x2c0/0x960 ? __pfx_lock_release+0x10/0x10 ? __local_bh_enable_ip+0x93/0x110 ? lock_is_held_type+0xe7/0x140 ndisc_send_skb+0x4be/0x960 ? __pfx_ndisc_send_skb+0x10/0x10 ? mark_held_locks+0x65/0x90 ? find_held_lock+0x83/0xa0 ndisc_send_ns+0xb0/0x110 ? __pfx_ndisc_send_ns+0x10/0x10 addrconf_dad_work+0x631/0x8e0 ? lock_acquire+0x180/0x3f0 ? __pfx_addrconf_dad_work+0x10/0x10 ? mark_held_locks+0x24/0x90 process_one_work+0x582/0x9c0 ? __pfx_process_one_work+0x10/0x10 ? __pfx_do_raw_spin_lock+0x10/0x10 ? mark_held_locks+0x24/0x90 worker_thread+0x93/0x630 ? __kthread_parkme+0xdc/0x100 ? __pfx_worker_thread+0x10/0x10 kthread+0x1a5/0x1e0 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x34/0x60 ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/0756384fb1bd38adb2ebcfd1307422f433a1d772"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/23c195ce6f4aec86e1c9e1ea1c800381c4b465c7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/32ef2c0c6cf11a076f0280a7866b9abc47821e19"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7b8717658dff8b471cbfc124bf9b5ca4229579ed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c650597647ecb318d02372277bdfd866c6829f78"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53193,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:41.643,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: fix amdgpu_irq_put call trace in gmc_v10_0_hw_fini The gmc.ecc_irq is enabled by firmware per IFWI setting, and the host driver is not privileged to enable/disable the interrupt. So, it is meaningless to use the amdgpu_irq_put function in gmc_v10_0_hw_fini, which also leads to the call trace. [ 82.340264] Call Trace: [ 82.340265] <TASK> [ 82.340269] gmc_v10_0_hw_fini+0x83/0xa0 [amdgpu] [ 82.340447] gmc_v10_0_suspend+0xe/0x20 [amdgpu] [ 82.340623] amdgpu_device_ip_suspend_phase2+0x127/0x1c0 [amdgpu] [ 82.340789] amdgpu_device_ip_suspend+0x3d/0x80 [amdgpu] [ 82.340955] amdgpu_device_pre_asic_reset+0xdd/0x2b0 [amdgpu] [ 82.341122] amdgpu_device_gpu_recover.cold+0x4dd/0xbb2 [amdgpu] [ 82.341359] amdgpu_debugfs_reset_work+0x4c/0x70 [amdgpu] [ 82.341529] process_one_work+0x21d/0x3f0 [ 82.341535] worker_thread+0x1fa/0x3c0 [ 82.341538] ? process_one_work+0x3f0/0x3f0 [ 82.341540] kthread+0xff/0x130 [ 82.341544] ? kthread_complete_and_exit+0x20/0x20 [ 82.341547] ret_from_fork+0x22/0x30",,,"[{""url"":""https://git.kernel.org/stable/c/08c677cb0b436a96a836792bb35a8ec5de4999c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/23febab57e345c0e66f8574c1018707e7eb6ea94"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/59e2439111ac2bd24ea0cecf5825cf06684b2c6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a7e65a1ea871e99115add88ecbcfdbacc2415f07"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53194,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:41.763,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: Add length check in indx_get_root This adds a length check to guarantee the retrieved index root is legit. [ 162.459513] BUG: KASAN: use-after-free in hdr_find_e.isra.0+0x10c/0x320 [ 162.460176] Read of size 2 at addr ffff8880037bca99 by task mount/243 [ 162.460851] [ 162.461252] CPU: 0 PID: 243 Comm: mount Not tainted 6.0.0-rc7 #42 [ 162.461744] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014 [ 162.462609] Call Trace: [ 162.462954] <TASK> [ 162.463276] dump_stack_lvl+0x49/0x63 [ 162.463822] print_report.cold+0xf5/0x689 [ 162.464608] ? unwind_get_return_address+0x3a/0x60 [ 162.465766] ? hdr_find_e.isra.0+0x10c/0x320 [ 162.466975] kasan_report+0xa7/0x130 [ 162.467506] ? _raw_spin_lock_irq+0xc0/0xf0 [ 162.467998] ? hdr_find_e.isra.0+0x10c/0x320 [ 162.468536] __asan_load2+0x68/0x90 [ 162.468923] hdr_find_e.isra.0+0x10c/0x320 [ 162.469282] ? cmp_uints+0xe0/0xe0 [ 162.469557] ? cmp_sdh+0x90/0x90 [ 162.469864] ? ni_find_attr+0x214/0x300 [ 162.470217] ? ni_load_mi+0x80/0x80 [ 162.470479] ? entry_SYSCALL_64_after_hwframe+0x63/0xcd [ 162.470931] ? ntfs_bread_run+0x190/0x190 [ 162.471307] ? indx_get_root+0xe4/0x190 [ 162.471556] ? indx_get_root+0x140/0x190 [ 162.471833] ? indx_init+0x1e0/0x1e0 [ 162.472069] ? fnd_clear+0x115/0x140 [ 162.472363] ? _raw_spin_lock_irqsave+0x100/0x100 [ 162.472731] indx_find+0x184/0x470 [ 162.473461] ? sysvec_apic_timer_interrupt+0x57/0xc0 [ 162.474429] ? indx_find_buffer+0x2d0/0x2d0 [ 162.474704] ? do_syscall_64+0x3b/0x90 [ 162.474962] dir_search_u+0x196/0x2f0 [ 162.475381] ? ntfs_nls_to_utf16+0x450/0x450 [ 162.475661] ? ntfs_security_init+0x3d6/0x440 [ 162.475906] ? is_sd_valid+0x180/0x180 [ 162.476191] ntfs_extend_init+0x13f/0x2c0 [ 162.476496] ? ntfs_fix_post_read+0x130/0x130 [ 162.476861] ? iput.part.0+0x286/0x320 [ 162.477325] ntfs_fill_super+0x11e0/0x1b50 [ 162.477709] ? put_ntfs+0x1d0/0x1d0 [ 162.477970] ? vsprintf+0x20/0x20 [ 162.478258] ? set_blocksize+0x95/0x150 [ 162.478538] get_tree_bdev+0x232/0x370 [ 162.478789] ? put_ntfs+0x1d0/0x1d0 [ 162.479038] ntfs_fs_get_tree+0x15/0x20 [ 162.479374] vfs_get_tree+0x4c/0x130 [ 162.479729] path_mount+0x654/0xfe0 [ 162.480124] ? putname+0x80/0xa0 [ 162.480484] ? finish_automount+0x2e0/0x2e0 [ 162.480894] ? putname+0x80/0xa0 [ 162.481467] ? kmem_cache_free+0x1c4/0x440 [ 162.482280] ? putname+0x80/0xa0 [ 162.482714] do_mount+0xd6/0xf0 [ 162.483264] ? path_mount+0xfe0/0xfe0 [ 162.484782] ? __kasan_check_write+0x14/0x20 [ 162.485593] __x64_sys_mount+0xca/0x110 [ 162.486024] do_syscall_64+0x3b/0x90 [ 162.486543] entry_SYSCALL_64_after_hwframe+0x63/0xcd [ 162.487141] RIP: 0033:0x7f9d374e948a [ 162.488324] Code: 48 8b 0d 11 fa 2a 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 49 89 ca b8 a5 00 00 008 [ 162.489728] RSP: 002b:00007ffe30e73d18 EFLAGS: 00000206 ORIG_RAX: 00000000000000a5 [ 162.490971] RAX: ffffffffffffffda RBX: 0000561cdb43a060 RCX: 00007f9d374e948a [ 162.491669] RDX: 0000561cdb43a260 RSI: 0000561cdb43a2e0 RDI: 0000561cdb442af0 [ 162.492050] RBP: 0000000000000000 R08: 0000561cdb43a280 R09: 0000000000000020 [ 162.492459] R10: 00000000c0ed0000 R11: 0000000000000206 R12: 0000561cdb442af0 [ 162.493183] R13: 0000561cdb43a260 R14: 0000000000000000 R15: 00000000ffffffff [ 162.493644] </TASK> [ 162.493908] [ 162.494214] The buggy address belongs to the physical page: [ 162.494761] page:000000003e38a3d5 refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x37bc [ 162.496064] flags: 0xfffffc0000000(node=0|zone=1|lastcpupid=0x1fffff) [ 162.497278] raw: 000fffffc0000000 ffffea00000df1c8 ffffea00000df008 0000000000000000 [ 162.498928] raw: 0000000000000000 0000000000240000 00000000ffffffff 0000000000000000 [ 162.500542] page dumped becau ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/08e8cf5f2d9ec383a2e339a2711b62a54ff3fba0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0d04e45c65f0785e558b93d2631d58680f263e10"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/85afd3007465f8bc74afffbf5b84ec29f5310b03"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb5b59931d20f3b02076fae49e85282310b12012"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53195,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:41.877,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mlxsw: minimal: fix potential memory leak in mlxsw_m_linecards_init The line cards array is not freed in the error path of mlxsw_m_linecards_init(), which can lead to a memory leak. Fix by freeing the array in the error path, thereby making the error path identical to mlxsw_m_linecards_fini().",,,"[{""url"":""https://git.kernel.org/stable/c/08fc75735fda3be97194bfbf3c899c87abb3d0fe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd716022c968bc6748f23708b986f845b45791b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d4f5b1dd816dccd4ee6bb60b2a81a3d4373636a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53196,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:41.990,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: dwc3: qcom: Fix potential memory leak Function dwc3_qcom_probe() allocates memory for resource structure which is pointed by parent_res pointer. This memory is not freed. This leads to memory leak. Use stack memory to prevent memory leak. Found by Linux Verification Center (linuxtesting.org) with SVACE.",,,"[{""url"":""https://git.kernel.org/stable/c/097fb3ee710d4de83b8d4f5589e8ee13e0f0541e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/134a7d4642f11daed6bbc378f930a54dd0322291"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/648a163cff21ea355c8765e882ba8bf66a870a3e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74f8606ddfa450d2255b4e61472a7632def1e8c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b626cd5e4a87a281629e0c2b07519990077c0fbe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c3b322b84ab5dda7eaca9ded763628b7467734f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53197,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:42.107,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: USB: uhci: fix memory leak with using debugfs_lookup() When calling debugfs_lookup() the result must have dput() called on it, otherwise the memory will leak over time. To make things simpler, just call debugfs_lookup_and_remove() instead which handles all of the logic at once.",,,"[{""url"":""https://git.kernel.org/stable/c/0a3f82c79c86278e7f144564b1cb6cc5c3657144"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9cb88847b8b86f132309030022a23dca895b6f61"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c6af1dbc99ad37bf67c8703982df4d7f12d256c1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e529aeb771aef1402c899b6b405610ef444d5d88"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53198,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T14:15:42.223,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: raw: Fix NULL deref in raw_get_next(). Dae R. Jeong reported a NULL deref in raw_get_next() [0]. It seems that the repro was running these sequences in parallel so that one thread was iterating on a socket that was being freed in another netns. unshare(0x40060200) r0 = syz_open_procfs(0x0, &(0x7f0000002080)='net/raw\x00') socket$inet_icmp_raw(0x2, 0x3, 0x1) pread64(r0, &(0x7f0000000000)=""""/10, 0xa, 0x10000000007f) After commit 0daf07e52709 (""raw: convert raw sockets to RCU""), we use RCU and hlist_nulls_for_each_entry() to iterate over SOCK_RAW sockets. However, we should use spinlock for slow paths to avoid the NULL deref. Also, SOCK_RAW does not use SLAB_TYPESAFE_BY_RCU, and the slab object is not reused during iteration in the grace period. In fact, the lockless readers do not check the nulls marker with get_nulls_value(). So, SOCK_RAW should use hlist instead of hlist_nulls. Instead of adding an unnecessary barrier by sk_nulls_for_each_rcu(), let's convert hlist_nulls to hlist and use sk_for_each_rcu() for fast paths and sk_for_each() and spinlock for /proc/net/raw. [0]: general protection fault, probably for non-canonical address 0xdffffc0000000005: 0000 [#1] PREEMPT SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000028-0x000000000000002f] CPU: 2 PID: 20952 Comm: syz-executor.0 Not tainted 6.2.0-g048ec869bafd-dirty #7 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014 RIP: 0010:read_pnet include/net/net_namespace.h:383 [inline] RIP: 0010:sock_net include/net/sock.h:649 [inline] RIP: 0010:raw_get_next net/ipv4/raw.c:974 [inline] RIP: 0010:raw_get_idx net/ipv4/raw.c:986 [inline] RIP: 0010:raw_seq_start+0x431/0x800 net/ipv4/raw.c:995 Code: ef e8 33 3d 94 f7 49 8b 6d 00 4c 89 ef e8 b7 65 5f f7 49 89 ed 49 83 c5 98 0f 84 9a 00 00 00 48 83 c5 c8 48 89 e8 48 c1 e8 03 <42> 80 3c 30 00 74 08 48 89 ef e8 00 3d 94 f7 4c 8b 7d 00 48 89 ef RSP: 0018:ffffc9001154f9b0 EFLAGS: 00010206 RAX: 0000000000000005 RBX: 1ffff1100302c8fd RCX: 0000000000000000 RDX: 0000000000000028 RSI: ffffc9001154f988 RDI: ffffc9000f77a338 RBP: 0000000000000029 R08: ffffffff8a50ffb4 R09: fffffbfff24b6bd9 R10: fffffbfff24b6bd9 R11: 0000000000000000 R12: ffff88801db73b78 R13: fffffffffffffff9 R14: dffffc0000000000 R15: 0000000000000030 FS: 00007f843ae8e700(0000) GS:ffff888063700000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000055bb9614b35f CR3: 000000003c672000 CR4: 00000000003506e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> seq_read_iter+0x4c6/0x10f0 fs/seq_file.c:225 seq_read+0x224/0x320 fs/seq_file.c:162 pde_read fs/proc/inode.c:316 [inline] proc_reg_read+0x23f/0x330 fs/proc/inode.c:328 vfs_read+0x31e/0xd30 fs/read_write.c:468 ksys_pread64 fs/read_write.c:665 [inline] __do_sys_pread64 fs/read_write.c:675 [inline] __se_sys_pread64 fs/read_write.c:672 [inline] __x64_sys_pread64+0x1e9/0x280 fs/read_write.c:672 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_64+0x4e/0xa0 arch/x86/entry/common.c:82 entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x478d29 Code: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007f843ae8dbe8 EFLAGS: 00000246 ORIG_RAX: 0000000000000011 RAX: ffffffffffffffda RBX: 0000000000791408 RCX: 0000000000478d29 RDX: 000000000000000a RSI: 0000000020000000 RDI: 0000000000000003 RBP: 00000000f477909a R08: 0000000000000000 R09: 0000000000000000 R10: 000010000000007f R11: 0000000000000246 R12: 0000000000791740 R13: 0000000000791414 R14: 0000000000791408 R15: 00007ffc2eb48a50 </TASK> Modules linked in: ---[ end trace 0000000000000000 ]--- RIP: 0010 ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/0a78cf7264d29abeca098eae0b188a10aabc8a32"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/67daeaecd70ef20ab540c21739d3f633734967a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b34056bedf04d08ef24f713a7f93bad1274a838d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53199,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:46.277,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath9k: hif_usb: clean up skbs if ath9k_hif_usb_rx_stream() fails Syzkaller detected a memory leak of skbs in ath9k_hif_usb_rx_stream(). While processing skbs in ath9k_hif_usb_rx_stream(), the already allocated skbs in skb_pool are not freed if ath9k_hif_usb_rx_stream() fails. If we have an incorrect pkt_len or pkt_tag, the input skb is considered invalid and dropped. All the associated packets already in skb_pool should be dropped and freed. Added a comment describing this issue. The patch also makes remain_skb NULL after being processed so that it cannot be referenced after potential free. The initialization of hif_dev fields which are associated with remain_skb (rx_remain_len, rx_transfer_len and rx_pad_len) is moved after a new remain_skb is allocated. Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",,,"[{""url"":""https://git.kernel.org/stable/c/0af54343a76263a12dbae7fafb64eb47c4a6ad38"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3fc6401fafde11712a83089fa2cc874cfd10e2cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/61490d2710277e8a55009b7682456ae22f8087cf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9acdec72787af1bc8ed92711b52118c8e3e638a2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c766e37fccd5a5c5059be7efcd9618bf8a2c17c3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd8316767099920a5d41feed1afab0c482a43e9f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f26dd69f61eff2eedf5df2d199bdd23108309947"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53200,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:46.400,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: x_tables: fix percpu counter block leak on error path when creating new netns Here is the stack where we allocate percpu counter block: +-< __alloc_percpu +-< xt_percpu_counter_alloc +-< find_check_entry # {arp,ip,ip6}_tables.c +-< translate_table And it can be leaked on this code path: +-> ip6t_register_table +-> translate_table # allocates percpu counter block +-> xt_register_table # fails there is no freeing of the counter block on xt_register_table fail. Note: xt_percpu_counter_free should be called to free it like we do in do_replace through cleanup_entry helper (or in __ip6t_unregister_table). Probability of hitting this error path is low AFAICS (xt_register_table can only return ENOMEM here, as it is not replacing anything, as we are creating new netns, and it is hard to imagine that all previous allocations succeeded and after that one in xt_register_table failed). But it's worth fixing even the rare leak.",,,"[{""url"":""https://git.kernel.org/stable/c/0af8c09c896810879387decfba8c942994bb61f5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3cc9610a87b7dde82f7360dd4eb6c2c27940ed57"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/512b6c4b83c91d007301ea7d7f095d16c3aceacd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e306dbee4c98025a9326386023a12ef4d887e9d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53201,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:46.513,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/bnxt_re: wraparound mbox producer index Driver is not handling the wraparound of the mbox producer index correctly. Currently the wraparound happens once u32 max is reached. Bit 31 of the producer index register is special and should be set only once for the first command. Because the producer index overflow setting bit31 after a long time, FW goes to initialization sequence and this causes FW hang. Fix is to wraparound the mbox producer index once it reaches u16 max.",,,"[{""url"":""https://git.kernel.org/stable/c/0af91306e17ef3d18e5f100aa58aa787869118af"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/50d77c3739b2b15e9e1f1c9cbe50037d294800f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/79226176cdd1b65a1e6a90e0e1a2b490f0a9df33"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7bfa0303fbc265c94cfbd17505c55b99848aa4e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9341501e2f7af29f5b5562c2840a7fde40eb7de4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c9be352be9bb15e6b83e40abc4df7f4776b435ba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53202,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:46.627,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: PM: domains: fix memory leak with using debugfs_lookup() When calling debugfs_lookup() the result must have dput() called on it, otherwise the memory will leak over time. To make things simpler, just call debugfs_lookup_and_remove() instead which handles all of the logic at once.",,,"[{""url"":""https://git.kernel.org/stable/c/0b6200e1e9f53dabdc30d0f6c51af9a5f664d32b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/543d7113c37206ed7dae7bfb0b7e50955077770e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cde67cb7d2d1757baa83271c1f0892727e79f52e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dddc132eb0dca3969f9146ef8feac0aa542aa305"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53203,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:46.737,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: mt7996: rely on mt76_connac2_mac_tx_rate_val In order to fix a possible NULL pointer dereference in mt7996_mac_write_txwi() of vif pointer, export mt76_connac2_mac_tx_rate_val utility routine and reuse it in mt7996 driver.",,,"[{""url"":""https://git.kernel.org/stable/c/0765b5b4719f0435bb019370b317d2fb8138eb34"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0b8e2d69467f78a7c9d87b452220e87012435e33"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53204,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:46.847,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: af_unix: Fix data-races around user->unix_inflight. user->unix_inflight is changed under spin_lock(unix_gc_lock), but too_many_unix_fds() reads it locklessly. Let's annotate the write/read accesses to user->unix_inflight. BUG: KCSAN: data-race in unix_attach_fds / unix_inflight write to 0xffffffff8546f2d0 of 8 bytes by task 44798 on cpu 1: unix_inflight+0x157/0x180 net/unix/scm.c:66 unix_attach_fds+0x147/0x1e0 net/unix/scm.c:123 unix_scm_to_skb net/unix/af_unix.c:1827 [inline] unix_dgram_sendmsg+0x46a/0x14f0 net/unix/af_unix.c:1950 unix_seqpacket_sendmsg net/unix/af_unix.c:2308 [inline] unix_seqpacket_sendmsg+0xba/0x130 net/unix/af_unix.c:2292 sock_sendmsg_nosec net/socket.c:725 [inline] sock_sendmsg+0x148/0x160 net/socket.c:748 ____sys_sendmsg+0x4e4/0x610 net/socket.c:2494 ___sys_sendmsg+0xc6/0x140 net/socket.c:2548 __sys_sendmsg+0x94/0x140 net/socket.c:2577 __do_sys_sendmsg net/socket.c:2586 [inline] __se_sys_sendmsg net/socket.c:2584 [inline] __x64_sys_sendmsg+0x45/0x50 net/socket.c:2584 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3b/0x90 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x6e/0xd8 read to 0xffffffff8546f2d0 of 8 bytes by task 44814 on cpu 0: too_many_unix_fds net/unix/scm.c:101 [inline] unix_attach_fds+0x54/0x1e0 net/unix/scm.c:110 unix_scm_to_skb net/unix/af_unix.c:1827 [inline] unix_dgram_sendmsg+0x46a/0x14f0 net/unix/af_unix.c:1950 unix_seqpacket_sendmsg net/unix/af_unix.c:2308 [inline] unix_seqpacket_sendmsg+0xba/0x130 net/unix/af_unix.c:2292 sock_sendmsg_nosec net/socket.c:725 [inline] sock_sendmsg+0x148/0x160 net/socket.c:748 ____sys_sendmsg+0x4e4/0x610 net/socket.c:2494 ___sys_sendmsg+0xc6/0x140 net/socket.c:2548 __sys_sendmsg+0x94/0x140 net/socket.c:2577 __do_sys_sendmsg net/socket.c:2586 [inline] __se_sys_sendmsg net/socket.c:2584 [inline] __x64_sys_sendmsg+0x45/0x50 net/socket.c:2584 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3b/0x90 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x6e/0xd8 value changed: 0x000000000000000c -> 0x000000000000000d Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 44814 Comm: systemd-coredum Not tainted 6.4.0-11989-g6843306689af #6 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014",,,"[{""url"":""https://git.kernel.org/stable/c/03d133dfbcec9d439729cc64706c7eb6d1663a24"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0bc36c0650b21df36fbec8136add83936eaf0607"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9151ed4b006125cba7c06c79df504340ea4e9386"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac92f239a079678a035c0faad9089354a874aede"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/adcf4e069358cdee8593663650ea447215a1c49e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b401d7e485b0a234cf8fe9a6ae99dbcd20863138"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b9cdbb38e030fc2fe97fe27b54cbb6b4fbff250f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/df97b5ea9f3ac9308c3a633524dab382cd59d9e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53205,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:46.977,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: KVM: s390/diag: fix racy access of physical cpu number in diag 9c handler We do check for target CPU == -1, but this might change at the time we are going to use it. Hold the physical target CPU in a local variable to avoid out-of-bound accesses to the cpu arrays.",,,"[{""url"":""https://git.kernel.org/stable/c/0bc380beb78aa352eadbc21d934dd9606fcee808"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/86bfb18bad60fc468e5f112cbbd918462a8dd435"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9ccf140a2a03a0ae82be4bdfbdd17bdaea72ff5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc7e0192c470a53d847c79a2796f9ac429477a26"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53206,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:47.090,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: hwmon: (pmbus_core) Fix NULL pointer dereference Pass i2c_client to _pmbus_is_enabled to drop the assumption that a regulator device is passed in. This will fix the issue of a NULL pointer dereference when called from _pmbus_get_flags.",,,"[{""url"":""https://git.kernel.org/stable/c/0bd66784274a287beada2933c2c0fa3a0ddae0d7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7444253cacd92412bc8d33d1c9b5401f52cdf0e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53207,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:47.203,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ublk: fail to recover device if queue setup is interrupted In ublk_ctrl_end_recovery(), if wait_for_completion_interruptible() is interrupted by signal, queues aren't setup successfully yet, so we have to fail UBLK_CMD_END_USER_RECOVERY, otherwise kernel oops can be triggered.",,,"[{""url"":""https://git.kernel.org/stable/c/0c0cbd4ebc375ceebc75c89df04b74f215fab23a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/84415f934ad4e96f3507fd09b831953d60fb04ec"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b3a1e243a74632f88b22e713f1c7256754017d58"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53208,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:47.320,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: KVM: nSVM: Load L1's TSC multiplier based on L1 state, not L2 state When emulating nested VM-Exit, load L1's TSC multiplier if L1's desired ratio doesn't match the current ratio, not if the ratio L1 is using for L2 diverges from the default. Functionally, the end result is the same as KVM will run L2 with L1's multiplier if L2's multiplier is the default, i.e. checking that L1's multiplier is loaded is equivalent to checking if L2 has a non-default multiplier. However, the assertion that TSC scaling is exposed to L1 is flawed, as userspace can trigger the WARN at will by writing the MSR and then updating guest CPUID to hide the feature (modifying guest CPUID is allowed anytime before KVM_RUN). E.g. hacking KVM's state_test selftest to do vcpu_set_msr(vcpu, MSR_AMD64_TSC_RATIO, 0); vcpu_clear_cpuid_feature(vcpu, X86_FEATURE_TSCRATEMSR); after restoring state in a new VM+vCPU yields an endless supply of: ------------[ cut here ]------------ WARNING: CPU: 10 PID: 206939 at arch/x86/kvm/svm/nested.c:1105 nested_svm_vmexit+0x6af/0x720 [kvm_amd] Call Trace: nested_svm_exit_handled+0x102/0x1f0 [kvm_amd] svm_handle_exit+0xb9/0x180 [kvm_amd] kvm_arch_vcpu_ioctl_run+0x1eab/0x2570 [kvm] kvm_vcpu_ioctl+0x4c9/0x5b0 [kvm] ? trace_hardirqs_off+0x4d/0xa0 __se_sys_ioctl+0x7a/0xc0 __x64_sys_ioctl+0x21/0x30 do_syscall_64+0x41/0x90 entry_SYSCALL_64_after_hwframe+0x63/0xcd Unlike the nested VMRUN path, hoisting the svm->tsc_scaling_enabled check into the if-statement is wrong as KVM needs to ensure L1's multiplier is loaded in the above scenario. Alternatively, the WARN_ON() could simply be deleted, but that would make KVM's behavior even more subtle, e.g. it's not immediately obvious why it's safe to write MSR_AMD64_TSC_RATIO when checking only tsc_ratio_msr.",,,"[{""url"":""https://git.kernel.org/stable/c/0c94e2468491cbf0754f49a5136ab51294a96b69"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5b2b0535fa7adee7e295fed0a3095082131a8d05"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e91c07f6cf7060d2acb3aeee31a6baebe3773d3f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53209,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:47.437,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mac80211_hwsim: Fix possible NULL dereference In a call to mac80211_hwsim_select_tx_link() the sta pointer might be NULL, thus need to check that it is not NULL before accessing it.",,,"[{""url"":""https://git.kernel.org/stable/c/0cc80943ef518a1c51a1111e9346d1daf11dd545"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a8a20fed3e05b3a6866c5c58855deaf3c217ccd6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d0124848c7940aba73492e282506b32a13f2e30e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53210,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:47.547,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: md/raid5-cache: fix null-ptr-deref for r5l_flush_stripe_to_raid() r5l_flush_stripe_to_raid() will check if the list 'flushing_ios' is empty, and then submit 'flush_bio', however, r5l_log_flush_endio() is clearing the list first and then clear the bio, which will cause null-ptr-deref: T1: submit flush io raid5d handle_active_stripes r5l_flush_stripe_to_raid // list is empty // add 'io_end_ios' to the list bio_init submit_bio // io1 T2: io1 is done r5l_log_flush_endio list_splice_tail_init // clear the list T3: submit new flush io ... r5l_flush_stripe_to_raid // list is empty // add 'io_end_ios' to the list bio_init bio_uninit // clear bio->bi_blkg submit_bio // null-ptr-deref Fix this problem by clearing bio before clearing the list in r5l_log_flush_endio().",,,"[{""url"":""https://git.kernel.org/stable/c/0d0bd28c500173bfca78aa840f8f36d261ef1765"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/711fb92606208a8626b785da4f9f23d648a5b6c8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7a8b6d93991bf4b72b3f959baea35397c6c8e521"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e46b2e7be8059d156af8c011dd8d665229b65886"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53211,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:47.670,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: driver core: location: Free struct acpi_pld_info *pld before return false struct acpi_pld_info *pld should be freed before the return of allocation failure, to prevent memory leak, add the ACPI_FREE() to fix it.",,,"[{""url"":""https://git.kernel.org/stable/c/0d150f967e8410e1e6712484543eec709356a65d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a9de90951bbeaed775e4b8d1b16b4d359e82bf5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8fe72b8f59f63ca776bb8a4fcd2f406057a9fc90"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53212,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:47.793,2025-09-15T15:15:47.793,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53213,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:47.900,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: brcmfmac: slab-out-of-bounds read in brcmf_get_assoc_ies() Fix a slab-out-of-bounds read that occurs in kmemdup() called from brcmf_get_assoc_ies(). The bug could occur when assoc_info->req_len, data from a URB provided by a USB device, is bigger than the size of buffer which is defined as WL_EXTRA_BUF_MAX. Add the size check for req_len/resp_len of assoc_info. Found by a modified version of syzkaller. [ 46.592467][ T7] ================================================================== [ 46.594687][ T7] BUG: KASAN: slab-out-of-bounds in kmemdup+0x3e/0x50 [ 46.596572][ T7] Read of size 3014656 at addr ffff888019442000 by task kworker/0:1/7 [ 46.598575][ T7] [ 46.599157][ T7] CPU: 0 PID: 7 Comm: kworker/0:1 Tainted: G O 5.14.0+ #145 [ 46.601333][ T7] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.1-0-ga5cab58e9a3f-prebuilt.qemu.org 04/01/2014 [ 46.604360][ T7] Workqueue: events brcmf_fweh_event_worker [ 46.605943][ T7] Call Trace: [ 46.606584][ T7] dump_stack_lvl+0x8e/0xd1 [ 46.607446][ T7] print_address_description.constprop.0.cold+0x93/0x334 [ 46.608610][ T7] ? kmemdup+0x3e/0x50 [ 46.609341][ T7] kasan_report.cold+0x79/0xd5 [ 46.610151][ T7] ? kmemdup+0x3e/0x50 [ 46.610796][ T7] kasan_check_range+0x14e/0x1b0 [ 46.611691][ T7] memcpy+0x20/0x60 [ 46.612323][ T7] kmemdup+0x3e/0x50 [ 46.612987][ T7] brcmf_get_assoc_ies+0x967/0xf60 [ 46.613904][ T7] ? brcmf_notify_vif_event+0x3d0/0x3d0 [ 46.614831][ T7] ? lock_chain_count+0x20/0x20 [ 46.615683][ T7] ? mark_lock.part.0+0xfc/0x2770 [ 46.616552][ T7] ? lock_chain_count+0x20/0x20 [ 46.617409][ T7] ? mark_lock.part.0+0xfc/0x2770 [ 46.618244][ T7] ? lock_chain_count+0x20/0x20 [ 46.619024][ T7] brcmf_bss_connect_done.constprop.0+0x241/0x2e0 [ 46.620019][ T7] ? brcmf_parse_configure_security.isra.0+0x2a0/0x2a0 [ 46.620818][ T7] ? __lock_acquire+0x181f/0x5790 [ 46.621462][ T7] brcmf_notify_connect_status+0x448/0x1950 [ 46.622134][ T7] ? rcu_read_lock_bh_held+0xb0/0xb0 [ 46.622736][ T7] ? brcmf_cfg80211_join_ibss+0x7b0/0x7b0 [ 46.623390][ T7] ? find_held_lock+0x2d/0x110 [ 46.623962][ T7] ? brcmf_fweh_event_worker+0x19f/0xc60 [ 46.624603][ T7] ? mark_held_locks+0x9f/0xe0 [ 46.625145][ T7] ? lockdep_hardirqs_on_prepare+0x3e0/0x3e0 [ 46.625871][ T7] ? brcmf_cfg80211_join_ibss+0x7b0/0x7b0 [ 46.626545][ T7] brcmf_fweh_call_event_handler.isra.0+0x90/0x100 [ 46.627338][ T7] brcmf_fweh_event_worker+0x557/0xc60 [ 46.627962][ T7] ? brcmf_fweh_call_event_handler.isra.0+0x100/0x100 [ 46.628736][ T7] ? rcu_read_lock_sched_held+0xa1/0xd0 [ 46.629396][ T7] ? rcu_read_lock_bh_held+0xb0/0xb0 [ 46.629970][ T7] ? lockdep_hardirqs_on_prepare+0x273/0x3e0 [ 46.630649][ T7] process_one_work+0x92b/0x1460 [ 46.631205][ T7] ? pwq_dec_nr_in_flight+0x330/0x330 [ 46.631821][ T7] ? rwlock_bug.part.0+0x90/0x90 [ 46.632347][ T7] worker_thread+0x95/0xe00 [ 46.632832][ T7] ? __kthread_parkme+0x115/0x1e0 [ 46.633393][ T7] ? process_one_work+0x1460/0x1460 [ 46.633957][ T7] kthread+0x3a1/0x480 [ 46.634369][ T7] ? set_kthread_struct+0x120/0x120 [ 46.634933][ T7] ret_from_fork+0x1f/0x30 [ 46.635431][ T7] [ 46.635687][ T7] Allocated by task 7: [ 46.636151][ T7] kasan_save_stack+0x1b/0x40 [ 46.636628][ T7] __kasan_kmalloc+0x7c/0x90 [ 46.637108][ T7] kmem_cache_alloc_trace+0x19e/0x330 [ 46.637696][ T7] brcmf_cfg80211_attach+0x4a0/0x4040 [ 46.638275][ T7] brcmf_attach+0x389/0xd40 [ 46.638739][ T7] brcmf_usb_probe+0x12de/0x1690 [ 46.639279][ T7] usb_probe_interface+0x2aa/0x760 [ 46.639820][ T7] really_probe+0x205/0xb70 [ 46.640342][ T7] __driver_probe_device+0 ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/0da40e018fd034d87c9460123fa7f897b69fdee7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/21bee3e649d87f78fe8aef6ae02edd3d6f310fd0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/228186629ea970cc78b7d7d5f593f2d32fddf9f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/39f9bd880abac6068bedb24a4e16e7bd26bf92da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/425eea395f1f5ae349fb55f7fe51d833a5324bfe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/549825602e3e6449927ca1ea1a08fd89868439df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/936a23293bbb3332bdf4cdb9c1496e80cb0bc2c8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac5305e5d227b9af3aae25fa83380d3ff0225b73"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e29661611e6e71027159a3140e818ef3b99f32dd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53214,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:48.027,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to avoid potential memory corruption in __update_iostat_latency() Add iotype sanity check to avoid potential memory corruption. This is to fix the compile error below: fs/f2fs/iostat.c:231 __update_iostat_latency() error: buffer overflow 'io_lat->peak_lat[type]' 3 <= 3 vim +228 fs/f2fs/iostat.c 211 static inline void __update_iostat_latency(struct bio_iostat_ctx *iostat_ctx, 212 enum iostat_lat_type type) 213 { 214 unsigned long ts_diff; 215 unsigned int page_type = iostat_ctx->type; 216 struct f2fs_sb_info *sbi = iostat_ctx->sbi; 217 struct iostat_lat_info *io_lat = sbi->iostat_io_lat; 218 unsigned long flags; 219 220 if (!sbi->iostat_enable) 221 return; 222 223 ts_diff = jiffies - iostat_ctx->submit_ts; 224 if (page_type >= META_FLUSH) ^^^^^^^^^^ 225 page_type = META; 226 227 spin_lock_irqsave(&sbi->iostat_lat_lock, flags); @228 io_lat->sum_lat[type][page_type] += ts_diff; ^^^^^^^^^ Mixup between META_FLUSH and NR_PAGE_TYPE leads to memory corruption.",,,"[{""url"":""https://git.kernel.org/stable/c/0dbbf0fb38d5ec5d4138d1aeaeb43d9217b9a592"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/20b4f3de0f3932f71b4a8daf0671e517a8d98022"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/22ddbbff116ee7dce5431feb1c0f36a507d2d68d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa4d726af72a21732ce120484e0b1240674a13b3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53215,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:48.140,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: sched/fair: Don't balance task to its current running CPU We've run into the case that the balancer tries to balance a migration disabled task and trigger the warning in set_task_cpu() like below: ------------[ cut here ]------------ WARNING: CPU: 7 PID: 0 at kernel/sched/core.c:3115 set_task_cpu+0x188/0x240 Modules linked in: hclgevf xt_CHECKSUM ipt_REJECT nf_reject_ipv4 <...snip> CPU: 7 PID: 0 Comm: swapper/7 Kdump: loaded Tainted: G O 6.1.0-rc4+ #1 Hardware name: Huawei TaiShan 2280 V2/BC82AMDC, BIOS 2280-V2 CS V5.B221.01 12/09/2021 pstate: 604000c9 (nZCv daIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : set_task_cpu+0x188/0x240 lr : load_balance+0x5d0/0xc60 sp : ffff80000803bc70 x29: ffff80000803bc70 x28: ffff004089e190e8 x27: ffff004089e19040 x26: ffff007effcabc38 x25: 0000000000000000 x24: 0000000000000001 x23: ffff80000803be84 x22: 000000000000000c x21: ffffb093e79e2a78 x20: 000000000000000c x19: ffff004089e19040 x18: 0000000000000000 x17: 0000000000001fad x16: 0000000000000030 x15: 0000000000000000 x14: 0000000000000003 x13: 0000000000000000 x12: 0000000000000000 x11: 0000000000000001 x10: 0000000000000400 x9 : ffffb093e4cee530 x8 : 00000000fffffffe x7 : 0000000000ce168a x6 : 000000000000013e x5 : 00000000ffffffe1 x4 : 0000000000000001 x3 : 0000000000000b2a x2 : 0000000000000b2a x1 : ffffb093e6d6c510 x0 : 0000000000000001 Call trace: set_task_cpu+0x188/0x240 load_balance+0x5d0/0xc60 rebalance_domains+0x26c/0x380 _nohz_idle_balance.isra.0+0x1e0/0x370 run_rebalance_domains+0x6c/0x80 __do_softirq+0x128/0x3d8 ____do_softirq+0x18/0x24 call_on_irq_stack+0x2c/0x38 do_softirq_own_stack+0x24/0x3c __irq_exit_rcu+0xcc/0xf4 irq_exit_rcu+0x18/0x24 el1_interrupt+0x4c/0xe4 el1h_64_irq_handler+0x18/0x2c el1h_64_irq+0x74/0x78 arch_cpu_idle+0x18/0x4c default_idle_call+0x58/0x194 do_idle+0x244/0x2b0 cpu_startup_entry+0x30/0x3c secondary_start_kernel+0x14c/0x190 __secondary_switched+0xb0/0xb4 ---[ end trace 0000000000000000 ]--- Further investigation shows that the warning is superfluous, the migration disabled task is just going to be migrated to its current running CPU. This is because that on load balance if the dst_cpu is not allowed by the task, we'll re-select a new_dst_cpu as a candidate. If no task can be balanced to dst_cpu we'll try to balance the task to the new_dst_cpu instead. In this case when the migration disabled task is not on CPU it only allows to run on its current CPU, load balance will select its current CPU as new_dst_cpu and later triggers the warning above. The new_dst_cpu is chosen from the env->dst_grpmask. Currently it contains CPUs in sched_group_span() and if we have overlapped groups it's possible to run into this case. This patch makes env->dst_grpmask of group_balance_mask() which exclude any CPUs from the busiest group and solve the issue. For balancing in a domain with no overlapped groups the behaviour keeps same as before.",,,"[{""url"":""https://git.kernel.org/stable/c/0dd37d6dd33a9c23351e6115ae8cdac7863bc7de"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/32d937f94b7805d4c9028b8727a7d6241547da54"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/34eb902050d473bb2befa15714fb1d30a0991c15"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3cb43222bab8ab328fc91ed30899b3df2efbccfd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6b0c79aa33075b34c3cdcea4132c0afb3fc42d68"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/78a5f711efceb37e32c48cd6b40addb671fea9cc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a5286f4655ce2fa28f477c0b957ea7f323fe2fab"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cec1857b1ea5cc3ea2b600564f1c95d1a6f27ad1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53216,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:48.273,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: arm64: efi: Make efi_rt_lock a raw_spinlock Running a rt-kernel base on 6.2.0-rc3-rt1 on an Ampere Altra outputs the following: BUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:46 in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 9, name: kworker/u320:0 preempt_count: 2, expected: 0 RCU nest depth: 0, expected: 0 3 locks held by kworker/u320:0/9: #0: ffff3fff8c27d128 ((wq_completion)efi_rts_wq){+.+.}-{0:0}, at: process_one_work (./include/linux/atomic/atomic-long.h:41) #1: ffff80000861bdd0 ((work_completion)(&efi_rts_work.work)){+.+.}-{0:0}, at: process_one_work (./include/linux/atomic/atomic-long.h:41) #2: ffffdf7e1ed3e460 (efi_rt_lock){+.+.}-{3:3}, at: efi_call_rts (drivers/firmware/efi/runtime-wrappers.c:101) Preemption disabled at: efi_virtmap_load (./arch/arm64/include/asm/mmu_context.h:248) CPU: 0 PID: 9 Comm: kworker/u320:0 Tainted: G W 6.2.0-rc3-rt1 Hardware name: WIWYNN Mt.Jade Server System B81.03001.0005/Mt.Jade Motherboard, BIOS 1.08.20220218 (SCP: 1.08.20220218) 2022/02/18 Workqueue: efi_rts_wq efi_call_rts Call trace: dump_backtrace (arch/arm64/kernel/stacktrace.c:158) show_stack (arch/arm64/kernel/stacktrace.c:165) dump_stack_lvl (lib/dump_stack.c:107 (discriminator 4)) dump_stack (lib/dump_stack.c:114) __might_resched (kernel/sched/core.c:10134) rt_spin_lock (kernel/locking/rtmutex.c:1769 (discriminator 4)) efi_call_rts (drivers/firmware/efi/runtime-wrappers.c:101) [...] This seems to come from commit ff7a167961d1 (""arm64: efi: Execute runtime services from a dedicated stack"") which adds a spinlock. This spinlock is taken through: efi_call_rts() \-efi_call_virt() \-efi_call_virt_pointer() \-arch_efi_call_virt_setup() Make 'efi_rt_lock' a raw_spinlock to avoid being preempted. [ardb: The EFI runtime services are called with a different set of translation tables, and are permitted to use the SIMD registers. The context switch code preserves/restores neither, and so EFI calls must be made with preemption disabled, rather than only disabling migration.]",,,"[{""url"":""https://git.kernel.org/stable/c/030b1c4217a4f504c7d0795a2bd86b7181e56f11"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0e68b5517d3767562889f1d83fdb828c26adb24f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4e8f7d998b582a99aadedd07ae6086e99b89c97a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6a72729ed6accc86dad5522895e8fa2f96642a2c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8b38969fa01662ec539a0d08a8ea5ec6f31fa4ed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53217,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:48.390,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nubus: Partially revert proc_create_single_data() conversion The conversion to proc_create_single_data() introduced a regression whereby reading a file in /proc/bus/nubus results in a seg fault: # grep -r . /proc/bus/nubus/e/ Data read fault at 0x00000020 in Super Data (pc=0x1074c2) BAD KERNEL BUSERR Oops: 00000000 Modules linked in: PC: [<001074c2>] PDE_DATA+0xc/0x16 SR: 2010 SP: 38284958 a2: 01152370 d0: 00000001 d1: 01013000 d2: 01002790 d3: 00000000 d4: 00000001 d5: 0008ce2e a0: 00000000 a1: 00222a40 Process grep (pid: 45, task=142f8727) Frame format=B ssw=074d isc=2008 isb=4e5e daddr=00000020 dobuf=01199e70 baddr=001074c8 dibuf=ffffffff ver=f Stack from 01199e48: 01199e70 00222a58 01002790 00000000 011a3000 01199eb0 015000c0 00000000 00000000 01199ec0 01199ec0 000d551a 011a3000 00000001 00000000 00018000 d003f000 00000003 00000001 0002800d 01052840 01199fa8 c01f8000 00000000 00000029 0b532b80 00000000 00000000 00000029 0b532b80 01199ee4 00103640 011198c0 d003f000 00018000 01199fa8 00000000 011198c0 00000000 01199f4c 000b3344 011198c0 d003f000 00018000 01199fa8 00000000 00018000 011198c0 Call Trace: [<00222a58>] nubus_proc_rsrc_show+0x18/0xa0 [<000d551a>] seq_read+0xc4/0x510 [<00018000>] fp_fcos+0x2/0x82 [<0002800d>] __sys_setreuid+0x115/0x1c6 [<00103640>] proc_reg_read+0x5c/0xb0 [<00018000>] fp_fcos+0x2/0x82 [<000b3344>] __vfs_read+0x2c/0x13c [<00018000>] fp_fcos+0x2/0x82 [<00018000>] fp_fcos+0x2/0x82 [<000b8aa2>] sys_statx+0x60/0x7e [<000b34b6>] vfs_read+0x62/0x12a [<00018000>] fp_fcos+0x2/0x82 [<00018000>] fp_fcos+0x2/0x82 [<000b39c2>] ksys_read+0x48/0xbe [<00018000>] fp_fcos+0x2/0x82 [<000b3a4e>] sys_read+0x16/0x1a [<00018000>] fp_fcos+0x2/0x82 [<00002b84>] syscall+0x8/0xc [<00018000>] fp_fcos+0x2/0x82 [<0000c016>] not_ext+0xa/0x18 Code: 4e5e 4e75 4e56 0000 206e 0008 2068 ffe8 <2068> 0020 2008 4e5e 4e75 4e56 0000 2f0b 206e 0008 2068 0004 2668 0020 206b ffe8 Disabling lock debugging due to kernel taint Segmentation fault The proc_create_single_data() conversion does not work because single_open(file, nubus_proc_rsrc_show, PDE_DATA(inode)) is not equivalent to the original code.",,,"[{""url"":""https://git.kernel.org/stable/c/0e96647cff9224db564a1cee6efccb13dbe11ee2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/67e3b5230cefed1eca470c460a2035f02986cebb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9877533e1401dbbb2c7da8badda05d196aa07623"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a03f2f4bd49030f57849227be9ba38a3eb1edb61"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c06edf13f4cf7f9e8ff4bc6f7e951e4f074dc105"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f70407e8e0272e00d133c5e039168ff1bae6bcac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53218,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:48.510,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: rxrpc: Make it so that a waiting process can be aborted When sendmsg() creates an rxrpc call, it queues it to wait for a connection and channel to be assigned and then waits before it can start shovelling data as the encrypted DATA packet content includes a summary of the connection parameters. However, sendmsg() may get interrupted before a connection gets assigned and further sendmsg() calls will fail with EBUSY until an assignment is made. Fix this so that the call can at least be aborted without failing on EBUSY. We have to be careful here as sendmsg() mustn't be allowed to start the call timer if the call doesn't yet have a connection assigned as an oops may follow shortly thereafter.",,,"[{""url"":""https://git.kernel.org/stable/c/0eb362d254814ce04848730bf32e75b8ee1a4d6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7161cf61c64e9e9413d790f2fa2b9dada71a2249"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/876d96faacbc407daf4978d7ec95051b68f5344a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53219,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:48.623,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: netup_unidvb: fix use-after-free at del_timer() When Universal DVB card is detaching, netup_unidvb_dma_fini() uses del_timer() to stop dma->timeout timer. But when timer handler netup_unidvb_dma_timeout() is running, del_timer() could not stop it. As a result, the use-after-free bug could happen. The process is shown below: (cleanup routine) | (timer routine) | mod_timer(&dev->tx_sim_timer, ..) netup_unidvb_finidev() | (wait a time) netup_unidvb_dma_fini() | netup_unidvb_dma_timeout() del_timer(&dma->timeout); | | ndev->pci_dev->dev //USE Fix by changing del_timer() to del_timer_sync().",,,"[{""url"":""https://git.kernel.org/stable/c/051af3f0b7d1cd8ab7f3e2523ad8ae1af44caba3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/07821524f67bf920342bc84ae8b3dea2a315a89e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0f5bb36bf9b39a2a96e730bf4455095b50713f63"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1550bcf2983ae1220cc8ab899a39a423fa7cb523"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90229e9ee957d4514425e4a4d82c50ab5d57ac4d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c8f9c05e1ebcc9c7bc211cc8b74d8fb86a8756fc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dd5c77814f290b353917df329f36de1472d47154"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f9982db735a8495eee14267cf193c806b957e942"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53220,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:48.743,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: az6007: Fix null-ptr-deref in az6007_i2c_xfer() In az6007_i2c_xfer, msg is controlled by user. When msg[i].buf is null and msg[i].len is zero, former checks on msg[i].buf would be passed. Malicious data finally reach az6007_i2c_xfer. If accessing msg[i].buf[0] without sanity check, null ptr deref would happen. We add check on msg[i].len to prevent crash. Similar commit: commit 0ed554fd769a (""media: dvb-usb: az6027: fix null-ptr-deref in az6027_i2c_xfer()"")",,,"[{""url"":""https://git.kernel.org/stable/c/1047f9343011f2cedc73c64829686206a7e9fc3f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5b1ea100ad3695025969dc4693f307877fb688d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6ab7ea4e17d6a605d05308adf8f3408924770cba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/991c77fe18c6f374bbf83376f8c42550aa565662"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a1110f19d4940e4185251d072cbb0ff51486a1e7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9def3e9718a4dc756f48db147d42ec41a966240"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/adcb73f8ce9aec48b1f85223f401c1574015d8d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c6763fefa267f6e62595a6ac1f57815d99fc90b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53221,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:48.873,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: bpf: Fix memleak due to fentry attach failure If it fails to attach fentry, the allocated bpf trampoline image will be left in the system. That can be verified by checking /proc/kallsyms. This meamleak can be verified by a simple bpf program as follows: SEC(""fentry/trap_init"") int fentry_run() { return 0; } It will fail to attach trap_init because this function is freed after kernel init, and then we can find the trampoline image is left in the system by checking /proc/kallsyms. $ tail /proc/kallsyms ffffffffc0613000 t bpf_trampoline_6442453466_1 [bpf] ffffffffc06c3000 t bpf_trampoline_6442453466_1 [bpf] $ bpftool btf dump file /sys/kernel/btf/vmlinux | grep ""FUNC 'trap_init'"" [2522] FUNC 'trap_init' type_id=119 linkage=static $ echo $((6442453466 & 0x7fffffff)) 2522 Note that there are two left bpf trampoline images, that is because the libbpf will fallback to raw tracepoint if -EINVAL is returned.",,,"[{""url"":""https://git.kernel.org/stable/c/108598c39eefbedc9882273ac0df96127a629220"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/20109ddd5bea2c24d790debf5d02584ef24c3f5e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6aa27775db63ba8c7c73891c7dfb71ddc230c48d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f72c67d1a82dada7d6d504c806e111e913721a30"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53222,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:48.983,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: jfs: jfs_dmap: Validate db_l2nbperpage while mounting In jfs_dmap.c at line 381, BLKTODMAP is used to get a logical block number inside dbFree(). db_l2nbperpage, which is the log2 number of blocks per page, is passed as an argument to BLKTODMAP which uses it for shifting. Syzbot reported a shift out-of-bounds crash because db_l2nbperpage is too big. This happens because the large value is set without any validation in dbMount() at line 181. Thus, make sure that db_l2nbperpage is correct while mounting. Max number of blocks per page = Page size / Min block size => log2(Max num_block per page) = log2(Page size / Min block size) = log2(Page size) - log2(Min block size) => Max db_l2nbperpage = L2PSIZE - L2MINBLOCKSIZE",,,"[{""url"":""https://git.kernel.org/stable/c/11509910c599cbd04585ec35a6d5e1a0053d84c1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2a03c4e683d33d17b667418eb717b13dda1fac6b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/47b7eaae08e8b2f25bdf37bc14d21be090bcb20f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c1efe3f74a7864461b0dff281c5562154b4aa8e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a4855aeb13e4ad1f23e16753b68212e180f7d848"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c7feb54b113802d2aba98708769d3c33fb017254"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/de984faecddb900fa850af4df574a25b32bb93f5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ef5c205b6e6f8d1f18ef0b4a9832b1b5fa85f7f2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53223,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:49.123,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/msm/dsi: Add missing check for alloc_ordered_workqueue Add check for the return value of alloc_ordered_workqueue as it may return NULL pointer and cause NULL pointer dereference. Patchwork: https://patchwork.freedesktop.org/patch/517646/",,,"[{""url"":""https://git.kernel.org/stable/c/115906ca7b535afb1fe7b5406c566ccd3873f82b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/25a6499b1a53d854eda2b161b5c8a20296515dbe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3a9a4a9725c60f04326b5019a52ce15aee808506"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3e18f157faeeb59034404569e8e07cbe1c0030a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/540c66180afd59309a442d3bf1f2393464c8b4c5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5dfe7a5386fde5a656ca06602b31bf50e26954cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/759ea5677c362fb1e3edc667260ba9f409dc931d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9257974858ee847b2e1fd552691b8ba5c2fc1c7b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53224,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:49.243,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: Fix function prototype mismatch for ext4_feat_ktype With clang's kernel control flow integrity (kCFI, CONFIG_CFI_CLANG), indirect call targets are validated against the expected function pointer prototype to make sure the call target is valid to help mitigate ROP attacks. If they are not identical, there is a failure at run time, which manifests as either a kernel panic or thread getting killed. ext4_feat_ktype was setting the ""release"" handler to ""kfree"", which doesn't have a matching function prototype. Add a simple wrapper with the correct prototype. This was found as a result of Clang's new -Wcast-function-type-strict flag, which is more sensitive than the simpler -Wcast-function-type, which only checks for type width mismatches. Note that this code is only reached when ext4 is a loadable module and it is being unloaded: CFI failure at kobject_put+0xbb/0x1b0 (target: kfree+0x0/0x180; expected type: 0x7c4aa698) ... RIP: 0010:kobject_put+0xbb/0x1b0 ... Call Trace: <TASK> ext4_exit_sysfs+0x14/0x60 [ext4] cleanup_module+0x67/0xedb [ext4]",,,"[{""url"":""https://git.kernel.org/stable/c/0a1394e07c5d6bf1bfc25db8589ff1b1bfb6f46a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/118901ad1f25d2334255b3d50512fa20591531cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1ba10d3640e9783dad811fe4e24d55465c37c64d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2b69cdd9f9a7f596e3dd31f05f9852940d177924"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/94d8de83286fb1827340eba35b61c308f6b46ead"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/99e3fd21f8fc975c95e8cf76fbf6a3d2656f8f71"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c98077f7598a562f51051eec043be0cb3e1b1b5e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53225,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:49.363,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: spi: imx: Don't skip cleanup in remove's error path Returning early in a platform driver's remove callback is wrong. In this case the dma resources are not released in the error path. this is never retried later and so this is a permanent leak. To fix this, only skip hardware disabling if waking the device fails.",,,"[{""url"":""https://git.kernel.org/stable/c/11951c9e3f364d7ae3b568a0e52c8335d43066b5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/57a463226638f1ceabbb029cbd21b0c94640f1b5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6d16305a1535873e0a8a8ae92ea2d9106ec2d7df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa93a46f998a9069368026ac52bba96868c59157"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b64cb3f085fed296103c91f0db6acad30a021b36"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f90822ad63d11301e425311dac0c8e12ca1737b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53226,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:49.480,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mwifiex: Fix OOB and integer underflow when rx packets Make sure mwifiex_process_mgmt_packet, mwifiex_process_sta_rx_packet and mwifiex_process_uap_rx_packet, mwifiex_uap_queue_bridged_pkt and mwifiex_process_rx_packet not out-of-bounds access the skb->data buffer.",,,"[{""url"":""https://git.kernel.org/stable/c/11958528161731c58e105b501ed60b83a91ea941"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/29eca8b7863d1d7de6c5b746b374e3487d14f154"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3975e21d4d01efaf0296ded40d11c06589c49245"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3fe3923d092e22d87d1ed03e2729db444b8c1331"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/650d1bc02fba7b42f476d8b6643324abac5921ed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c54b6fc39eb1aac51cf2945f8a25e2a47fdca02"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8824aa4ab62c800f75d96f48e1883a5f56ec5869"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a7300e3800e9fd5405e88ce67709c1a97783b9c8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f517c97fc129995de77dd06aa5a74f909ebf568f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53227,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:49.603,2025-09-16T10:15:37.437,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53228,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:49.727,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: drop redundant sched job cleanup when cs is aborted Once command submission failed due to userptr invalidation in amdgpu_cs_submit, legacy code will perform cleanup of scheduler job. However, it's not needed at all, as former commit has integrated job cleanup stuff into amdgpu_job_free. Otherwise, because of double free, a NULL pointer dereference will occur in such scenario. Bug: https://gitlab.freedesktop.org/drm/amd/-/issues/2457",,,"[{""url"":""https://git.kernel.org/stable/c/1253685f0d3eb3eab0bfc4bf15ab341a5f3da0c8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c1564d4b105ae535eb3183ecaaa987685b20a888"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec02a29c3c2ef8ad3e15a0e3f96b99a00e5d97b4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53229,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:49.837,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mac80211: fix invalid drv_sta_pre_rcu_remove calls for non-uploaded sta Avoid potential data corruption issues caused by uninitialized driver private data structures.",,,"[{""url"":""https://git.kernel.org/stable/c/022c8320d9eb7394538bd716fa1a07a5ed92621b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/12b220a6171faf10638ab683a975cadcf1a352d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/30c5a016a37a668c1c07442cf94de6e99ea7417a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3fe20515449a80a177526d2ecd13b43f6ee41aeb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73752a39e2a6e38eee3ba90ece2ded598ea88006"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7e68d7c640d41d8a371b8f6c2d2682ea437cbe21"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a3593082e0dadf87f17ea4ca9fa0210caaa2aebf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/db8d32d6b25fdb75c387daee496b96209d477780"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53230,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:49.950,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: smb: client: fix warning in cifs_smb3_do_mount() This fixes the following warning reported by kernel test robot fs/smb/client/cifsfs.c:982 cifs_smb3_do_mount() warn: possible memory leak of 'cifs_sb'",,,"[{""url"":""https://git.kernel.org/stable/c/12c30f33cc6769bf411088a2872843c4f9ea32f9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/945f4a7aff84fde1f825d17a5050880345da3228"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9850867042674361f455ea8901375cff5b800be5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb79f8dfba343667f9a82a252743f4e8f67ce420"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53231,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:50.063,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: erofs: Fix detection of atomic context Current check for atomic context is not sufficient as z_erofs_decompressqueue_endio can be called under rcu lock from blk_mq_flush_plug_list(). See the stacktrace [1] In such case we should hand off the decompression work for async processing rather than trying to do sync decompression in current context. Patch fixes the detection by checking for rcu_read_lock_any_held() and while at it use more appropriate !in_task() check than in_atomic(). Background: Historically erofs would always schedule a kworker for decompression which would incur the scheduling cost regardless of the context. But z_erofs_decompressqueue_endio() may not always be in atomic context and we could actually benefit from doing the decompression in z_erofs_decompressqueue_endio() if we are in thread context, for example when running with dm-verity. This optimization was later added in patch [2] which has shown improvement in performance benchmarks. ============================================== [1] Problem stacktrace [name:core&]BUG: sleeping function called from invalid context at kernel/locking/mutex.c:291 [name:core&]in_atomic(): 0, irqs_disabled(): 0, non_block: 0, pid: 1615, name: CpuMonitorServi [name:core&]preempt_count: 0, expected: 0 [name:core&]RCU nest depth: 1, expected: 0 CPU: 7 PID: 1615 Comm: CpuMonitorServi Tainted: G S W OE 6.1.25-android14-5-maybe-dirty-mainline #1 Hardware name: MT6897 (DT) Call trace: dump_backtrace+0x108/0x15c show_stack+0x20/0x30 dump_stack_lvl+0x6c/0x8c dump_stack+0x20/0x48 __might_resched+0x1fc/0x308 __might_sleep+0x50/0x88 mutex_lock+0x2c/0x110 z_erofs_decompress_queue+0x11c/0xc10 z_erofs_decompress_kickoff+0x110/0x1a4 z_erofs_decompressqueue_endio+0x154/0x180 bio_endio+0x1b0/0x1d8 __dm_io_complete+0x22c/0x280 clone_endio+0xe4/0x280 bio_endio+0x1b0/0x1d8 blk_update_request+0x138/0x3a4 blk_mq_plug_issue_direct+0xd4/0x19c blk_mq_flush_plug_list+0x2b0/0x354 __blk_flush_plug+0x110/0x160 blk_finish_plug+0x30/0x4c read_pages+0x2fc/0x370 page_cache_ra_unbounded+0xa4/0x23c page_cache_ra_order+0x290/0x320 do_sync_mmap_readahead+0x108/0x2c0 filemap_fault+0x19c/0x52c __do_fault+0xc4/0x114 handle_mm_fault+0x5b4/0x1168 do_page_fault+0x338/0x4b4 do_translation_fault+0x40/0x60 do_mem_abort+0x60/0xc8 el0_da+0x4c/0xe0 el0t_64_sync_handler+0xd4/0xfc el0t_64_sync+0x1a0/0x1a4 [2] Link: https://lore.kernel.org/all/20210317035448.13921-1-huangjianan@oppo.com/",,,"[{""url"":""https://git.kernel.org/stable/c/12d0a24afd9ea58e581ea64d64e066f2027b28d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/597fb60c75132719687e173b75cab8f6eb1ca657"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53232,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:50.180,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: mt76: mt7921: fix kernel panic by accessing unallocated eeprom.data The MT7921 driver no longer uses eeprom.data, but the relevant code has not been removed completely since commit 16d98b548365 (""mt76: mt7921: rely on mcu_get_nic_capability""). This could result in potential invalid memory access. To fix the kernel panic issue in mt7921, it is necessary to avoid accessing unallocated eeprom.data which can lead to invalid memory access. Furthermore, it is possible to entirely eliminate the mt7921_mcu_parse_eeprom function and solely depend on mt7921_mcu_parse_response to divide the RxD header. [2.702735] BUG: kernel NULL pointer dereference, address: 0000000000000550 [2.702740] #PF: supervisor write access in kernel mode [2.702741] #PF: error_code(0x0002) - not-present page [2.702743] PGD 0 P4D 0 [2.702747] Oops: 0002 [#1] PREEMPT SMP NOPTI [2.702755] RIP: 0010:mt7921_mcu_parse_response+0x147/0x170 [mt7921_common] [2.702758] RSP: 0018:ffffae7c00fef828 EFLAGS: 00010286 [2.702760] RAX: ffffa367f57be024 RBX: ffffa367cc7bf500 RCX: 0000000000000000 [2.702762] RDX: 0000000000000550 RSI: 0000000000000000 RDI: ffffa367cc7bf500 [2.702763] RBP: ffffae7c00fef840 R08: ffffa367cb167000 R09: 0000000000000005 [2.702764] R10: 0000000000000000 R11: ffffffffc04702e4 R12: ffffa367e8329f40 [2.702766] R13: 0000000000000000 R14: 0000000000000001 R15: ffffa367e8329f40 [2.702768] FS: 000079ee6cf20c40(0000) GS:ffffa36b2f940000(0000) knlGS:0000000000000000 [2.702769] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [2.702775] CR2: 0000000000000550 CR3: 00000001233c6004 CR4: 0000000000770ee0 [2.702776] PKRU: 55555554 [2.702777] Call Trace: [2.702782] mt76_mcu_skb_send_and_get_msg+0xc3/0x11e [mt76 <HASH:1bc4 5>] [2.702785] mt7921_run_firmware+0x241/0x853 [mt7921_common <HASH:6a2f 6>] [2.702789] mt7921e_mcu_init+0x2b/0x56 [mt7921e <HASH:d290 7>] [2.702792] mt7921_register_device+0x2eb/0x5a5 [mt7921_common <HASH:6a2f 6>] [2.702795] ? mt7921_irq_tasklet+0x1d4/0x1d4 [mt7921e <HASH:d290 7>] [2.702797] mt7921_pci_probe+0x2d6/0x319 [mt7921e <HASH:d290 7>] [2.702799] pci_device_probe+0x9f/0x12a",,,"[{""url"":""https://git.kernel.org/stable/c/11181b6c8641cd417935b76ea997d0169f2db262"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/12db28c3ef31f719bd18fa186a40bb152e6a527c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c8ba6780c65f681d217de79e17d63d5d538a239f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ec4d97e8eddcfa9f63f2f62adec5fb4f941ba2ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53233,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:50.297,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net/smc: fix deadlock triggered by cancel_delayed_work_syn() The following LOCKDEP was detected: Workqueue: events smc_lgr_free_work [smc] WARNING: possible circular locking dependency detected 6.1.0-20221027.rc2.git8.56bc5b569087.300.fc36.s390x+debug #1 Not tainted ------------------------------------------------------ kworker/3:0/176251 is trying to acquire lock: 00000000f1467148 ((wq_completion)smc_tx_wq-00000000#2){+.+.}-{0:0}, at: __flush_workqueue+0x7a/0x4f0 but task is already holding lock: 0000037fffe97dc8 ((work_completion)(&(&lgr->free_work)->work)){+.+.}-{0:0}, at: process_one_work+0x232/0x730 which lock already depends on the new lock. the existing dependency chain (in reverse order) is: -> #4 ((work_completion)(&(&lgr->free_work)->work)){+.+.}-{0:0}: __lock_acquire+0x58e/0xbd8 lock_acquire.part.0+0xe2/0x248 lock_acquire+0xac/0x1c8 __flush_work+0x76/0xf0 __cancel_work_timer+0x170/0x220 __smc_lgr_terminate.part.0+0x34/0x1c0 [smc] smc_connect_rdma+0x15e/0x418 [smc] __smc_connect+0x234/0x480 [smc] smc_connect+0x1d6/0x230 [smc] __sys_connect+0x90/0xc0 __do_sys_socketcall+0x186/0x370 __do_syscall+0x1da/0x208 system_call+0x82/0xb0 -> #3 (smc_client_lgr_pending){+.+.}-{3:3}: __lock_acquire+0x58e/0xbd8 lock_acquire.part.0+0xe2/0x248 lock_acquire+0xac/0x1c8 __mutex_lock+0x96/0x8e8 mutex_lock_nested+0x32/0x40 smc_connect_rdma+0xa4/0x418 [smc] __smc_connect+0x234/0x480 [smc] smc_connect+0x1d6/0x230 [smc] __sys_connect+0x90/0xc0 __do_sys_socketcall+0x186/0x370 __do_syscall+0x1da/0x208 system_call+0x82/0xb0 -> #2 (sk_lock-AF_SMC){+.+.}-{0:0}: __lock_acquire+0x58e/0xbd8 lock_acquire.part.0+0xe2/0x248 lock_acquire+0xac/0x1c8 lock_sock_nested+0x46/0xa8 smc_tx_work+0x34/0x50 [smc] process_one_work+0x30c/0x730 worker_thread+0x62/0x420 kthread+0x138/0x150 __ret_from_fork+0x3c/0x58 ret_from_fork+0xa/0x40 -> #1 ((work_completion)(&(&smc->conn.tx_work)->work)){+.+.}-{0:0}: __lock_acquire+0x58e/0xbd8 lock_acquire.part.0+0xe2/0x248 lock_acquire+0xac/0x1c8 process_one_work+0x2bc/0x730 worker_thread+0x62/0x420 kthread+0x138/0x150 __ret_from_fork+0x3c/0x58 ret_from_fork+0xa/0x40 -> #0 ((wq_completion)smc_tx_wq-00000000#2){+.+.}-{0:0}: check_prev_add+0xd8/0xe88 validate_chain+0x70c/0xb20 __lock_acquire+0x58e/0xbd8 lock_acquire.part.0+0xe2/0x248 lock_acquire+0xac/0x1c8 __flush_workqueue+0xaa/0x4f0 drain_workqueue+0xaa/0x158 destroy_workqueue+0x44/0x2d8 smc_lgr_free+0x9e/0xf8 [smc] process_one_work+0x30c/0x730 worker_thread+0x62/0x420 kthread+0x138/0x150 __ret_from_fork+0x3c/0x58 ret_from_fork+0xa/0x40 other info that might help us debug this: Chain exists of: (wq_completion)smc_tx_wq-00000000#2 --> smc_client_lgr_pending --> (work_completion)(&(&lgr->free_work)->work) Possible unsafe locking scenario: CPU0 CPU1 ---- ---- lock((work_completion)(&(&lgr->free_work)->work)); lock(smc_client_lgr_pending); lock((work_completion) (&(&lgr->free_work)->work)); lock((wq_completion)smc_tx_wq-00000000#2); *** DEADLOCK *** 2 locks held by kworker/3:0/176251: #0: 0000000080183548 ((wq_completion)events){+.+.}-{0:0}, at: process_one_work+0x232/0x730 #1: 0000037fffe97dc8 ((work_completion) (&(&lgr->free_work)->work)){+.+.}-{0:0}, at: process_one_work+0x232/0x730 stack backtr ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/13085e1b5cab8ad802904d72e6a6dae85ae0cd20"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3517584cf1b35bd02f4a90267ddf9dcf17bd9c87"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9708efad9ba5095b9bb7916e11a135b3bd66c071"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b615238e5bc01e13dc0610febddc1ca99bab1df6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c9ca2257150272df1b8d9ebe5059197ffea6e913"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53234,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:50.420,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: watchdog: Fix kmemleak in watchdog_cdev_register kmemleak reports memory leaks in watchdog_dev_register, as follows: unreferenced object 0xffff888116233000 (size 2048): comm """"modprobe"""", pid 28147, jiffies 4353426116 (age 61.741s) hex dump (first 32 bytes): 80 fa b9 05 81 88 ff ff 08 30 23 16 81 88 ff ff .........0#..... 08 30 23 16 81 88 ff ff 00 00 00 00 00 00 00 00 .0#............. backtrace: [<000000007f001ffd>] __kmem_cache_alloc_node+0x157/0x220 [<000000006a389304>] kmalloc_trace+0x21/0x110 [<000000008d640eea>] watchdog_dev_register+0x4e/0x780 [watchdog] [<0000000053c9f248>] __watchdog_register_device+0x4f0/0x680 [watchdog] [<00000000b2979824>] watchdog_register_device+0xd2/0x110 [watchdog] [<000000001f730178>] 0xffffffffc10880ae [<000000007a1a8bcc>] do_one_initcall+0xcb/0x4d0 [<00000000b98be325>] do_init_module+0x1ca/0x5f0 [<0000000046d08e7c>] load_module+0x6133/0x70f0 ... unreferenced object 0xffff888105b9fa80 (size 16): comm """"modprobe"""", pid 28147, jiffies 4353426116 (age 61.741s) hex dump (first 16 bytes): 77 61 74 63 68 64 6f 67 31 00 b9 05 81 88 ff ff watchdog1....... backtrace: [<000000007f001ffd>] __kmem_cache_alloc_node+0x157/0x220 [<00000000486ab89b>] __kmalloc_node_track_caller+0x44/0x1b0 [<000000005a39aab0>] kvasprintf+0xb5/0x140 [<0000000024806f85>] kvasprintf_const+0x55/0x180 [<000000009276cb7f>] kobject_set_name_vargs+0x56/0x150 [<00000000a92e820b>] dev_set_name+0xab/0xe0 [<00000000cec812c6>] watchdog_dev_register+0x285/0x780 [watchdog] [<0000000053c9f248>] __watchdog_register_device+0x4f0/0x680 [watchdog] [<00000000b2979824>] watchdog_register_device+0xd2/0x110 [watchdog] [<000000001f730178>] 0xffffffffc10880ae [<000000007a1a8bcc>] do_one_initcall+0xcb/0x4d0 [<00000000b98be325>] do_init_module+0x1ca/0x5f0 [<0000000046d08e7c>] load_module+0x6133/0x70f0 ... The reason is that put_device is not be called if cdev_device_add fails and wdd->id != 0. watchdog_cdev_register wd_data = kzalloc [1] err = dev_set_name [2] .. err = cdev_device_add if (err) { if (wdd->id == 0) { // wdd->id != 0 .. } return err; // [1],[2] would be leaked To fix it, call put_device in all wdd->id cases.",,,"[{""url"":""https://git.kernel.org/stable/c/13721a2ac66b246f5802ba1b75ad8637e53eeecc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/23cc41c3f19c4d858c3708f1c0a06e94958e6c3b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/50808d034e199fe3ff7a9d2068a4eebeb6b4098a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/59e391b3fc507a15b7e8e9d9f4de87cae177c366"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c1655600f4f2839fb844fe8c70b2b65fadc7a56"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ac099d94e0480c937aa9172ab64074981ca1a4d3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf26b0e430ce34261f45959989edaf680b64d538"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c5a21a5501508ae3afa2fe6d5a3e74a37fa48df3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53235,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:50.550,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/tests: helpers: Avoid a driver uaf when using __drm_kunit_helper_alloc_drm_device() the driver may be dereferenced by device-managed resources up until the device is freed, which is typically later than the kunit-managed resource code frees it. Fix this by simply make the driver device-managed as well. In short, the sequence leading to the UAF is as follows: INIT: Code allocates a struct device as a kunit-managed resource. Code allocates a drm driver as a kunit-managed resource. Code allocates a drm device as a device-managed resource. EXIT: Kunit resource cleanup frees the drm driver Kunit resource cleanup puts the struct device, which starts a device-managed resource cleanup device-managed cleanup calls drm_dev_put() drm_dev_put() dereferences the (now freed) drm driver -> Boom. Related KASAN message: [55272.551542] ================================================================== [55272.551551] BUG: KASAN: slab-use-after-free in drm_dev_put.part.0+0xd4/0xe0 [drm] [55272.551603] Read of size 8 at addr ffff888127502828 by task kunit_try_catch/10353 [55272.551612] CPU: 4 PID: 10353 Comm: kunit_try_catch Tainted: G U N 6.5.0-rc7+ #155 [55272.551620] Hardware name: ASUS System Product Name/PRIME B560M-A AC, BIOS 0403 01/26/2021 [55272.551626] Call Trace: [55272.551629] <TASK> [55272.551633] dump_stack_lvl+0x57/0x90 [55272.551639] print_report+0xcf/0x630 [55272.551645] ? _raw_spin_lock_irqsave+0x5f/0x70 [55272.551652] ? drm_dev_put.part.0+0xd4/0xe0 [drm] [55272.551694] kasan_report+0xd7/0x110 [55272.551699] ? drm_dev_put.part.0+0xd4/0xe0 [drm] [55272.551742] drm_dev_put.part.0+0xd4/0xe0 [drm] [55272.551783] devres_release_all+0x15d/0x1f0 [55272.551790] ? __pfx_devres_release_all+0x10/0x10 [55272.551797] device_unbind_cleanup+0x16/0x1a0 [55272.551802] device_release_driver_internal+0x3e5/0x540 [55272.551808] ? kobject_put+0x5d/0x4b0 [55272.551814] bus_remove_device+0x1f1/0x3f0 [55272.551819] device_del+0x342/0x910 [55272.551826] ? __pfx_device_del+0x10/0x10 [55272.551830] ? lock_release+0x339/0x5e0 [55272.551836] ? kunit_remove_resource+0x128/0x290 [kunit] [55272.551845] ? __pfx_lock_release+0x10/0x10 [55272.551851] platform_device_del.part.0+0x1f/0x1e0 [55272.551856] ? _raw_spin_unlock_irqrestore+0x30/0x60 [55272.551863] kunit_remove_resource+0x195/0x290 [kunit] [55272.551871] ? _raw_spin_unlock_irqrestore+0x30/0x60 [55272.551877] kunit_cleanup+0x78/0x120 [kunit] [55272.551885] ? __kthread_parkme+0xc1/0x1f0 [55272.551891] ? __pfx_kunit_try_run_case_cleanup+0x10/0x10 [kunit] [55272.551900] ? __pfx_kunit_generic_run_threadfn_adapter+0x10/0x10 [kunit] [55272.551909] kunit_generic_run_threadfn_adapter+0x4a/0x90 [kunit] [55272.551919] kthread+0x2e7/0x3c0 [55272.551924] ? __pfx_kthread+0x10/0x10 [55272.551929] ret_from_fork+0x2d/0x70 [55272.551935] ? __pfx_kthread+0x10/0x10 [55272.551940] ret_from_fork_asm+0x1b/0x30 [55272.551948] </TASK> [55272.551953] Allocated by task 10351: [55272.551956] kasan_save_stack+0x1c/0x40 [55272.551962] kasan_set_track+0x21/0x30 [55272.551966] __kasan_kmalloc+0x8b/0x90 [55272.551970] __kmalloc+0x5e/0x160 [55272.551976] kunit_kmalloc_array+0x1c/0x50 [kunit] [55272.551984] drm_exec_test_init+0xfa/0x2c0 [drm_exec_test] [55272.551991] kunit_try_run_case+0xdd/0x250 [kunit] [55272.551999] kunit_generic_run_threadfn_adapter+0x4a/0x90 [kunit] [55272.552008] kthread+0x2e7/0x3c0 [55272.552012] ret_from_fork+0x2d/0x70 [55272.552017] ret_from_fork_asm+0x1b/0x30 [55272.552024] Freed by task 10353: [55272.552027] kasan_save_stack+0x1c/0x40 [55272.552032] kasan_set_track+0x21/0x30 [55272.552036] kasan_save_free_info+0x27/0x40 [55272.552041] __kasan_slab_free+0x106/0x180 [55272.552046] slab_free_freelist_hook+0xb3/0x160 [55272.552051] __kmem_cache_free+0xb2/0x290 [55272.552056] kunit_remove_resource+0x195/0x290 [kunit] [55272.552064] kunit_cleanup+0x7 ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/139a27854bf5ce93ff9805f9f7683b88c13074dc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c9d8be0e533738b744abb669263c4750d4830009"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53236,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:50.660,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iommufd: Do not corrupt the pfn list when doing batch carry If batch->end is 0 then setting npfns[0] before computing the new value of pfns will fail to adjust the pfn and result in various page accounting corruptions. It should be ordered after. This seems to result in various kinds of page meta-data corruption related failures: WARNING: CPU: 1 PID: 527 at mm/gup.c:75 try_grab_folio+0x503/0x740 Modules linked in: CPU: 1 PID: 527 Comm: repro Not tainted 6.3.0-rc2-eeac8ede1755+ #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014 RIP: 0010:try_grab_folio+0x503/0x740 Code: e3 01 48 89 de e8 6d c1 dd ff 48 85 db 0f 84 7c fe ff ff e8 4f bf dd ff 49 8d 47 ff 48 89 45 d0 e9 73 fe ff ff e8 3d bf dd ff <0f> 0b 31 db e9 d0 fc ff ff e8 2f bf dd ff 48 8b 5d c8 31 ff 48 89 RSP: 0018:ffffc90000f37908 EFLAGS: 00010046 RAX: 0000000000000000 RBX: 00000000fffffc02 RCX: ffffffff81504c26 RDX: 0000000000000000 RSI: ffff88800d030000 RDI: 0000000000000002 RBP: ffffc90000f37948 R08: 000000000003ca24 R09: 0000000000000008 R10: 000000000003ca00 R11: 0000000000000023 R12: ffffea000035d540 R13: 0000000000000001 R14: 0000000000000000 R15: ffffea000035d540 FS: 00007fecbf659740(0000) GS:ffff88807dd00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00000000200011c3 CR3: 000000000ef66006 CR4: 0000000000770ee0 PKRU: 55555554 Call Trace: <TASK> internal_get_user_pages_fast+0xd32/0x2200 pin_user_pages_fast+0x65/0x90 pfn_reader_user_pin+0x376/0x390 pfn_reader_next+0x14a/0x7b0 pfn_reader_first+0x140/0x1b0 iopt_area_fill_domain+0x74/0x210 iopt_table_add_domain+0x30e/0x6e0 iommufd_device_selftest_attach+0x7f/0x140 iommufd_test+0x10ff/0x16f0 iommufd_fops_ioctl+0x206/0x330 __x64_sys_ioctl+0x10e/0x160 do_syscall_64+0x3b/0x90 entry_SYSCALL_64_after_hwframe+0x72/0xdc",,,"[{""url"":""https://git.kernel.org/stable/c/13a0d1ae7ee6b438f5537711a8c60cba00554943"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6ed5784526ddc0fb58b1798af36ec0c3139a8dca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53237,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:50.770,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: fix amdgpu_irq_put call trace in gmc_v11_0_hw_fini The gmc.ecc_irq is enabled by firmware per IFWI setting, and the host driver is not privileged to enable/disable the interrupt. So, it is meaningless to use the amdgpu_irq_put function in gmc_v11_0_hw_fini, which also leads to the call trace. [ 102.980303] Call Trace: [ 102.980303] <TASK> [ 102.980304] gmc_v11_0_hw_fini+0x54/0x90 [amdgpu] [ 102.980357] gmc_v11_0_suspend+0xe/0x20 [amdgpu] [ 102.980409] amdgpu_device_ip_suspend_phase2+0x240/0x460 [amdgpu] [ 102.980459] amdgpu_device_ip_suspend+0x3d/0x80 [amdgpu] [ 102.980520] amdgpu_device_pre_asic_reset+0xd9/0x490 [amdgpu] [ 102.980573] amdgpu_device_gpu_recover.cold+0x548/0xce6 [amdgpu] [ 102.980687] amdgpu_debugfs_reset_work+0x4c/0x70 [amdgpu] [ 102.980740] process_one_work+0x21f/0x3f0 [ 102.980741] worker_thread+0x200/0x3e0 [ 102.980742] ? process_one_work+0x3f0/0x3f0 [ 102.980743] kthread+0xfd/0x130 [ 102.980743] ? kthread_complete_and_exit+0x20/0x20 [ 102.980744] ret_from_fork+0x22/0x30",,,"[{""url"":""https://git.kernel.org/stable/c/02e6cb9b3aeffc6b0e3955f6e0346293e2415cbc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/13af556104fa93b1945c70bbf8a0a62cd2c92879"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/396401bc035ff5bf0c7b29c67caa10040eb3fb62"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/79038b78af931908d6f5d4e279d3afe32e7c840b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53238,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:50.887,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: phy: hisilicon: Fix an out of bounds check in hisi_inno_phy_probe() The size of array 'priv->ports[]' is INNO_PHY_PORT_NUM. In the for loop, 'i' is used as the index for array 'priv->ports[]' with a check (i > INNO_PHY_PORT_NUM) which indicates that INNO_PHY_PORT_NUM is allowed value for 'i' in the same loop. This > comparison needs to be changed to >=, otherwise it potentially leads to an out of bounds write on the next iteration through the loop",,,"[{""url"":""https://git.kernel.org/stable/c/01cb355bb92e8fcf8306e11a4774d610c5864e39"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/13c088cf3657d70893d75cf116be937f1509cc0f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/195e806b2afb0bad6470c9094f7e45e0cf109ee0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2843a2e703f5cb85c9eeca11b7ee90861635a010"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6d8a71e4c3a2fa4960cc50996e76a42b62fab677"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad249aa3c38f329f91fba8b4b3cd087e79fb0ce8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce69eac840db0b559994dc4290fce3d7c0d7bccd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53239,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:51.010,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/msm/mdp5: Add check for kzalloc As kzalloc may fail and return NULL pointer, it should be better to check the return value in order to avoid the NULL pointer dereference. Patchwork: https://patchwork.freedesktop.org/patch/514154/",,,"[{""url"":""https://git.kernel.org/stable/c/13fcfcb2a9a4787fe4e49841d728f6f2e9fa6911"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/37ff771ed008b9cbffd0eab77985968364694ce3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3975ea6eaffe26aec634b5c473e51dc76e73af62"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/49907c8873826ee771ba0ca1629e809c6479f617"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/82943a0730e00c14b03e25a4b2a1a9477ae89d7b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bc579a2ee8b2e20c152b24b437d094832d8c9c9e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53240,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:51.120,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: xsk: check IFF_UP earlier in Tx path Xsk Tx can be triggered via either sendmsg() or poll() syscalls. These two paths share a call to common function xsk_xmit() which has two sanity checks within. A pseudo code example to show the two paths: __xsk_sendmsg() : xsk_poll(): if (unlikely(!xsk_is_bound(xs))) if (unlikely(!xsk_is_bound(xs))) return -ENXIO; return mask; if (unlikely(need_wait)) (...) return -EOPNOTSUPP; xsk_xmit() mark napi id (...) xsk_xmit() xsk_xmit(): if (unlikely(!(xs->dev->flags & IFF_UP))) return -ENETDOWN; if (unlikely(!xs->tx)) return -ENOBUFS; As it can be observed above, in sendmsg() napi id can be marked on interface that was not brought up and this causes a NULL ptr dereference: [31757.505631] BUG: kernel NULL pointer dereference, address: 0000000000000018 [31757.512710] #PF: supervisor read access in kernel mode [31757.517936] #PF: error_code(0x0000) - not-present page [31757.523149] PGD 0 P4D 0 [31757.525726] Oops: 0000 [#1] PREEMPT SMP NOPTI [31757.530154] CPU: 26 PID: 95641 Comm: xdpsock Not tainted 6.2.0-rc5+ #40 [31757.536871] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0008.031920191559 03/19/2019 [31757.547457] RIP: 0010:xsk_sendmsg+0xde/0x180 [31757.551799] Code: 00 75 a2 48 8b 00 a8 04 75 9b 84 d2 74 69 8b 85 14 01 00 00 85 c0 75 1b 48 8b 85 28 03 00 00 48 8b 80 98 00 00 00 48 8b 40 20 <8b> 40 18 89 85 14 01 00 00 8b bd 14 01 00 00 81 ff 00 01 00 00 0f [31757.570840] RSP: 0018:ffffc90034f27dc0 EFLAGS: 00010246 [31757.576143] RAX: 0000000000000000 RBX: ffffc90034f27e18 RCX: 0000000000000000 [31757.583389] RDX: 0000000000000001 RSI: ffffc90034f27e18 RDI: ffff88984cf3c100 [31757.590631] RBP: ffff88984714a800 R08: ffff88984714a800 R09: 0000000000000000 [31757.597877] R10: 0000000000000001 R11: 0000000000000000 R12: 00000000fffffffa [31757.605123] R13: 0000000000000000 R14: 0000000000000003 R15: 0000000000000000 [31757.612364] FS: 00007fb4c5931180(0000) GS:ffff88afdfa00000(0000) knlGS:0000000000000000 [31757.620571] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [31757.626406] CR2: 0000000000000018 CR3: 000000184b41c003 CR4: 00000000007706e0 [31757.633648] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [31757.640894] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [31757.648139] PKRU: 55555554 [31757.650894] Call Trace: [31757.653385] <TASK> [31757.655524] sock_sendmsg+0x8f/0xa0 [31757.659077] ? sockfd_lookup_light+0x12/0x70 [31757.663416] __sys_sendto+0xfc/0x170 [31757.667051] ? do_sched_setscheduler+0xdb/0x1b0 [31757.671658] __x64_sys_sendto+0x20/0x30 [31757.675557] do_syscall_64+0x38/0x90 [31757.679197] entry_SYSCALL_64_after_hwframe+0x72/0xdc [31757.687969] Code: 8e f6 ff 44 8b 4c 24 2c 4c 8b 44 24 20 41 89 c4 44 8b 54 24 28 48 8b 54 24 18 b8 2c 00 00 00 48 8b 74 24 10 8b 7c 24 08 0f 05 <48> 3d 00 f0 ff ff 77 3a 44 89 e7 48 89 44 24 08 e8 b5 8e f6 ff 48 [31757.707007] RSP: 002b:00007ffd49c73c70 EFLAGS: 00000293 ORIG_RAX: 000000000000002c [31757.714694] RAX: ffffffffffffffda RBX: 000055a996565380 RCX: 00007fb4c5727c16 [31757.721939] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000003 [31757.729184] RBP: 0000000000000040 R08: 0000000000000000 R09: 0000000000000000 [31757.736429] R10: 0000000000000040 R11: 0000000000000293 R12: 0000000000000000 [31757.743673] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000 [31757.754940] </TASK> To fix this, let's make xsk_xmit a function that will be responsible for generic Tx, where RCU is handled accordingly and pull out sanity checks and xs->zc handling. Populate sanity checks to __xsk_sendmsg() and xsk_poll().",,,"[{""url"":""https://git.kernel.org/stable/c/1596dae2f17ec5c6e8c8f0e3fec78c5ae55c1e0b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cecc68559cd57fffb2be50685f262b9af2318e16"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ffe19750e68d0bb21e8110b398346eef20b156a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53241,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:51.230,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nfsd: call op_release, even when op_func returns an error For ops with ""trivial"" replies, nfsd4_encode_operation will shortcut most of the encoding work and skip to just marshalling up the status. One of the things it skips is calling op_release. This could cause a memory leak in the layoutget codepath if there is an error at an inopportune time. Have the compound processing engine always call op_release, even when op_func sets an error in op->status. With this change, we also need nfsd4_block_get_device_info_scsi to set the gd_device pointer to NULL on error to avoid a double free.",,,"[{""url"":""https://git.kernel.org/stable/c/15a8b55dbb1ba154d82627547c5761cac884d810"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3d0dcada384af22dec764c8374a2997870ec86ae"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/65a33135e91e6dd661ecdf1194b9d90c49ae3570"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b11d8162c24af4a351d21e2c804d25ca493305e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b623a8e5d38a69a3ef8644acb1030dd7c7bc28b3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53242,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:51.340,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: thermal/drivers/hisi: Drop second sensor hi3660 The commit 74c8e6bffbe1 (""driver core: Add __alloc_size hint to devm allocators"") exposes a panic ""BRK handler: Fatal exception"" on the hi3660_thermal_probe funciton. This is because the function allocates memory for only one sensors array entry, but tries to fill up a second one. Fix this by removing the unneeded second access.",,,"[{""url"":""https://git.kernel.org/stable/c/15cc25829a97c3957e520e971868aacc84341317"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3cf2181e438f43ed24e12424fe36d156cca233b9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/68e675a9b69cfc34dd915d91a4650e3ee53421f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9f6756cd09889c7201ee31e6f76fbd914fb0b80d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e02bc492883abf751fd1a8d89fc025fbce6744c6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f5aaf140ab1c02889c088e1b1098adad600541af"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53243,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:51.457,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: add handling for RAID1C23/DUP to btrfs_reduce_alloc_profile Callers of `btrfs_reduce_alloc_profile` expect it to return exactly one allocation profile flag, and failing to do so may ultimately result in a WARN_ON and remount-ro when allocating new blocks, like the below transaction abort on 6.1. `btrfs_reduce_alloc_profile` has two ways of determining the profile, first it checks if a conversion balance is currently running and uses the profile we're converting to. If no balance is currently running, it returns the max-redundancy profile which at least one block in the selected block group has. This works by simply checking each known allocation profile bit in redundancy order. However, `btrfs_reduce_alloc_profile` has not been updated as new flags have been added - first with the `DUP` profile and later with the RAID1C34 profiles. Because of the way it checks, if we have blocks with different profiles and at least one is known, that profile will be selected. However, if none are known we may return a flag set with multiple allocation profiles set. This is currently only possible when a balance from one of the three unhandled profiles to another of the unhandled profiles is canceled after allocating at least one block using the new profile. In that case, a transaction abort like the below will occur and the filesystem will need to be mounted with -o skip_balance to get it mounted rw again (but the balance cannot be resumed without a similar abort). [770.648] ------------[ cut here ]------------ [770.648] BTRFS: Transaction aborted (error -22) [770.648] WARNING: CPU: 43 PID: 1159593 at fs/btrfs/extent-tree.c:4122 find_free_extent+0x1d94/0x1e00 [btrfs] [770.648] CPU: 43 PID: 1159593 Comm: btrfs Tainted: G W 6.1.0-0.deb11.7-powerpc64le #1 Debian 6.1.20-2~bpo11+1a~test [770.648] Hardware name: T2P9D01 REV 1.00 POWER9 0x4e1202 opal:skiboot-bc106a0 PowerNV [770.648] NIP: c00800000f6784fc LR: c00800000f6784f8 CTR: c000000000d746c0 [770.648] REGS: c000200089afe9a0 TRAP: 0700 Tainted: G W (6.1.0-0.deb11.7-powerpc64le Debian 6.1.20-2~bpo11+1a~test) [770.648] MSR: 9000000002029033 <SF,HV,VEC,EE,ME,IR,DR,RI,LE> CR: 28848282 XER: 20040000 [770.648] CFAR: c000000000135110 IRQMASK: 0 GPR00: c00800000f6784f8 c000200089afec40 c00800000f7ea800 0000000000000026 GPR04: 00000001004820c2 c000200089afea00 c000200089afe9f8 0000000000000027 GPR08: c000200ffbfe7f98 c000000002127f90 ffffffffffffffd8 0000000026d6a6e8 GPR12: 0000000028848282 c000200fff7f3800 5deadbeef0000122 c00000002269d000 GPR16: c0002008c7797c40 c000200089afef17 0000000000000000 0000000000000000 GPR20: 0000000000000000 0000000000000001 c000200008bc5a98 0000000000000001 GPR24: 0000000000000000 c0000003c73088d0 c000200089afef17 c000000016d3a800 GPR28: c0000003c7308800 c00000002269d000 ffffffffffffffea 0000000000000001 [770.648] NIP [c00800000f6784fc] find_free_extent+0x1d94/0x1e00 [btrfs] [770.648] LR [c00800000f6784f8] find_free_extent+0x1d90/0x1e00 [btrfs] [770.648] Call Trace: [770.648] [c000200089afec40] [c00800000f6784f8] find_free_extent+0x1d90/0x1e00 [btrfs] (unreliable) [770.648] [c000200089afed30] [c00800000f681398] btrfs_reserve_extent+0x1a0/0x2f0 [btrfs] [770.648] [c000200089afeea0] [c00800000f681bf0] btrfs_alloc_tree_block+0x108/0x670 [btrfs] [770.648] [c000200089afeff0] [c00800000f66bd68] __btrfs_cow_block+0x170/0x850 [btrfs] [770.648] [c000200089aff100] [c00800000f66c58c] btrfs_cow_block+0x144/0x288 [btrfs] [770.648] [c000200089aff1b0] [c00800000f67113c] btrfs_search_slot+0x6b4/0xcb0 [btrfs] [770.648] [c000200089aff2a0] [c00800000f679f60] lookup_inline_extent_backref+0x128/0x7c0 [btrfs] [770.648] [c000200089aff3b0] [c00800000f67b338] lookup_extent_backref+0x70/0x190 [btrfs] [770.648] [c000200089aff470] [c00800000f67b54c] __btrfs_free_extent+0xf4/0x1490 [btrfs] [770.648] [ ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/12b6d68498982a053a4a7e561a04387e57ca6f1a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/160fe8f6fdb13da6111677be6263e5d65e875987"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1b532748ba00bd2a1d9b09e0d5e81280582c7770"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4fadf53fa95142f01f215012e97c384529759a72"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a3fbd156bd2cd16e3c64e250ebce33eb9f2ef612"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53244,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:51.570,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: pci: tw68: Fix null-ptr-deref bug in buf prepare and finish When the driver calls tw68_risc_buffer() to prepare the buffer, the function call dma_alloc_coherent may fail, resulting in a empty buffer buf->cpu. Later when we free the buffer or access the buffer, null ptr deref is triggered. This bug is similar to the following one: https://git.linuxtv.org/media_stage.git/commit/?id=2b064d91440b33fba5b452f2d1b31f13ae911d71. We believe the bug can be also dynamically triggered from user side. Similarly, we fix this by checking the return value of tw68_risc_buffer() and the value of buf->cpu before buffer free.",,,"[{""url"":""https://git.kernel.org/stable/c/1634b7adcc5bef645b3666fdd564e5952a9e24e0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3715c5e9a8f96b6ed0dcbea06da443efccac1ecc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3c67f49a6643d973e83968ea35806c7b5ae68b56"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dcf632bca424e6ff8c8eb89c96694e7f05cd29b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53245,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:51.683,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: storvsc: Fix handling of virtual Fibre Channel timeouts Hyper-V provides the ability to connect Fibre Channel LUNs to the host system and present them in a guest VM as a SCSI device. I/O to the vFC device is handled by the storvsc driver. The storvsc driver includes a partial integration with the FC transport implemented in the generic portion of the Linux SCSI subsystem so that FC attributes can be displayed in /sys. However, the partial integration means that some aspects of vFC don't work properly. Unfortunately, a full and correct integration isn't practical because of limitations in what Hyper-V provides to the guest. In particular, in the context of Hyper-V storvsc, the FC transport timeout function fc_eh_timed_out() causes a kernel panic because it can't find the rport and dereferences a NULL pointer. The original patch that added the call from storvsc_eh_timed_out() to fc_eh_timed_out() is faulty in this regard. In many cases a timeout is due to a transient condition, so the situation can be improved by just continuing to wait like with other I/O requests issued by storvsc, and avoiding the guaranteed panic. For a permanent failure, continuing to wait may result in a hung thread instead of a panic, which again may be better. So fix the panic by removing the storvsc call to fc_eh_timed_out(). This allows storvsc to keep waiting for a response. The change has been tested by users who experienced a panic in fc_eh_timed_out() due to transient timeouts, and it solves their problem. In the future we may want to deprecate the vFC functionality in storvsc since it can't be fully fixed. But it has current users for whom it is working well enough, so it should probably stay for a while longer.",,,"[{""url"":""https://git.kernel.org/stable/c/048ebc9a28fb918ee635dd4b2fcf4248eb6e4050"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1678408d08f31a694d5150a56796dd04c9710b22"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/175544ad48cbf56affeef2a679c6a4d4fb1e2881"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/311db605e07f0d4fc0cc7ddb74f1e5692ea2f469"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/763c06565055ae373fe7f89c11e1447bd1ded264"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7a792b3d888aab2c65389f9f4f9f2f6c000b1a0d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd87f4df9865a53807001ed12c0f0420b14ececd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ed70fa5629a8b992a5372d7044d1db1f8fa6de29"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53246,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:51.803,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: cifs: fix DFS traversal oops without CONFIG_CIFS_DFS_UPCALL When compiled with CONFIG_CIFS_DFS_UPCALL disabled, cifs_dfs_d_automount is NULL. cifs.ko logic for mapping CIFS_FATTR_DFS_REFERRAL attributes to S_AUTOMOUNT and corresponding dentry flags is retained regardless of CONFIG_CIFS_DFS_UPCALL, leading to a NULL pointer dereference in VFS follow_automount() when traversing a DFS referral link: BUG: kernel NULL pointer dereference, address: 0000000000000000 ... Call Trace: <TASK> __traverse_mounts+0xb5/0x220 ? cifs_revalidate_mapping+0x65/0xc0 [cifs] step_into+0x195/0x610 ? lookup_fast+0xe2/0xf0 path_lookupat+0x64/0x140 filename_lookup+0xc2/0x140 ? __create_object+0x299/0x380 ? kmem_cache_alloc+0x119/0x220 ? user_path_at_empty+0x31/0x50 user_path_at_empty+0x31/0x50 __x64_sys_chdir+0x2a/0xd0 ? exit_to_user_mode_prepare+0xca/0x100 do_syscall_64+0x42/0x90 entry_SYSCALL_64_after_hwframe+0x72/0xdc This fix adds an inline cifs_dfs_d_automount() {return -EREMOTE} handler when CONFIG_CIFS_DFS_UPCALL is disabled. An alternative would be to avoid flagging S_AUTOMOUNT, etc. without CONFIG_CIFS_DFS_UPCALL. This approach was chosen as it provides more control over the error path.",,,"[{""url"":""https://git.kernel.org/stable/c/179a88a8558bbf42991d361595281f3e45d7edfc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1e144b68208e98fd4602c842a7149ba5f41d87fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/26a32a212bc540f4773cd6af8cf73e967d72569c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/657d7c215ca974d366ab1808213f716e1e3aa950"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8afb1fabcec1929db46977e84baeee0cc0e79242"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8cd7dbc9c46d51e00a0a8372e07cc1cbb8d24a77"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b64305185b76f1d5145ce594ff48f3f0e70695bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b7d854c33ab48e55fc233699bbefe39ec9bb5c05"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53247,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:51.930,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: set_page_extent_mapped after read_folio in btrfs_cont_expand While trying to get the subpage blocksize tests running, I hit the following panic on generic/476 assertion failed: PagePrivate(page) && page->private, in fs/btrfs/subpage.c:229 kernel BUG at fs/btrfs/subpage.c:229! Internal error: Oops - BUG: 00000000f2000800 [#1] SMP CPU: 1 PID: 1453 Comm: fsstress Not tainted 6.4.0-rc7+ #12 Hardware name: QEMU KVM Virtual Machine, BIOS edk2-20230301gitf80f052277c8-26.fc38 03/01/2023 pstate: 61400005 (nZCv daif +PAN -UAO -TCO +DIT -SSBS BTYPE=--) pc : btrfs_subpage_assert+0xbc/0xf0 lr : btrfs_subpage_assert+0xbc/0xf0 Call trace: btrfs_subpage_assert+0xbc/0xf0 btrfs_subpage_clear_checked+0x38/0xc0 btrfs_page_clear_checked+0x48/0x98 btrfs_truncate_block+0x5d0/0x6a8 btrfs_cont_expand+0x5c/0x528 btrfs_write_check.isra.0+0xf8/0x150 btrfs_buffered_write+0xb4/0x760 btrfs_do_write_iter+0x2f8/0x4b0 btrfs_file_write_iter+0x1c/0x30 do_iter_readv_writev+0xc8/0x158 do_iter_write+0x9c/0x210 vfs_iter_write+0x24/0x40 iter_file_splice_write+0x224/0x390 direct_splice_actor+0x38/0x68 splice_direct_to_actor+0x12c/0x260 do_splice_direct+0x90/0xe8 generic_copy_file_range+0x50/0x90 vfs_copy_file_range+0x29c/0x470 __arm64_sys_copy_file_range+0xcc/0x498 invoke_syscall.constprop.0+0x80/0xd8 do_el0_svc+0x6c/0x168 el0_svc+0x50/0x1b0 el0t_64_sync_handler+0x114/0x120 el0t_64_sync+0x194/0x198 This happens because during btrfs_cont_expand we'll get a page, set it as mapped, and if it's not Uptodate we'll read it. However between the read and re-locking the page we could have called release_folio() on the page, but left the page in the file mapping. release_folio() can clear the page private, and thus further down we blow up when we go to modify the subpage bits. Fix this by putting the set_page_extent_mapped() after the read. This is safe because read_folio() will call set_page_extent_mapped() before it does the read, and then if we clear page private but leave it on the mapping we're completely safe re-setting set_page_extent_mapped(). With this patch I can now run generic/476 without panicing.",,,"[{""url"":""https://git.kernel.org/stable/c/0a5e0bc8e8618e32a6ca64450867628eb0a627bf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/17b17fcd6d446b95904a6929c40012ee7f0afc0c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a5880e69cf7fe4a0bb1eabae02205352d1b59b7b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53248,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:52.040,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: install stub fence into potential unused fence pointers When using cpu to update page tables, vm update fences are unused. Install stub fence into these fence pointers instead of NULL to avoid NULL dereference when calling dma_fence_wait() on them.",,,"[{""url"":""https://git.kernel.org/stable/c/187916e6ed9d0c3b3abc27429f7a5f8c936bd1f0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/78b25110eb8c6990f7f5096bc0136c12a2b4cc99"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa9e9ba5748c524eb0925a2ef6984b78793646d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53249,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:52.163,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: clk: imx: clk-imx8mn: fix memory leak in imx8mn_clocks_probe Use devm_of_iomap() instead of of_iomap() to automatically handle the unused ioremap region. If any error occurs, regions allocated by kzalloc() will leak, but using devm_kzalloc() instead will automatically free the memory using devm_kfree().",,,"[{""url"":""https://git.kernel.org/stable/c/188d070de9132667956f5aadd98d2bd87d3eac89"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/294321349bd3b0680847fc2bbe66b9ab3e522fea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/50b5ddde8fad5f0ffd239029d0956af633a0f9b1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9428cf0fbf4be9a24f3e15a0c166b861b12666af"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ba3693b0350b154fdd7830559bbc7b04c067096"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d4fa5e47af1e7bb2bbcaac062b14216c00e92148"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53250,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:52.280,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: firmware: dmi-sysfs: Fix null-ptr-deref in dmi_sysfs_register_handle KASAN reported a null-ptr-deref error: KASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f] CPU: 0 PID: 1373 Comm: modprobe Hardware name: QEMU Standard PC (i440FX + PIIX, 1996) RIP: 0010:dmi_sysfs_entry_release ... Call Trace: <TASK> kobject_put dmi_sysfs_register_handle (drivers/firmware/dmi-sysfs.c:540) dmi_sysfs dmi_decode_table (drivers/firmware/dmi_scan.c:133) dmi_walk (drivers/firmware/dmi_scan.c:1115) dmi_sysfs_init (drivers/firmware/dmi-sysfs.c:149) dmi_sysfs do_one_initcall (init/main.c:1296) ... Kernel panic - not syncing: Fatal exception Kernel Offset: 0x4000000 from 0xffffffff81000000 ---[ end Kernel panic - not syncing: Fatal exception ]--- It is because previous patch added kobject_put() to release the memory which will call dmi_sysfs_entry_release() and list_del(). However, list_add_tail(entry->list) is called after the error block, so the list_head is uninitialized and cannot be deleted. Move error handling to after list_add_tail to fix this.",,,"[{""url"":""https://git.kernel.org/stable/c/18e126e97c961f7a93823795c879d7c085fe5098"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5d0492d1d934642bdfd2057acc1b56f4b57be465"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b4fe158259fb5fead52ff2b55841ec5c39492604"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e851996b32264e78a10863c2ac41a8689d7b9252"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53251,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:52.393,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: iwlwifi: pcie: fix NULL pointer dereference in iwl_pcie_irq_rx_msix_handler() rxq can be NULL only when trans_pcie->rxq is NULL and entry->entry is zero. For the case when entry->entry is not equal to 0, rxq won't be NULL even if trans_pcie->rxq is NULL. Modify checker to check for trans_pcie->rxq.",,,"[{""url"":""https://git.kernel.org/stable/c/1902f1953b8ba100ee8705cb8a6f1a9795550eca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2d690495eb2766d58e25c83676f422219c4fcf18"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/390e44efcf4d390b5053ad112553155d2d097c73"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3b9de981fe7f1c6e07c7b852421ad69be3d4b6c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f71d0fc407dd028416bec002ddcc62f5acb0346a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53252,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:52.503,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: use RCU for hci_conn_params and iterate safely in hci_sync hci_update_accept_list_sync iterates over hdev->pend_le_conns and hdev->pend_le_reports, and waits for controller events in the loop body, without holding hdev lock. Meanwhile, these lists and the items may be modified e.g. by le_scan_cleanup. This can invalidate the list cursor or any other item in the list, resulting to invalid behavior (eg use-after-free). Use RCU for the hci_conn_params action lists. Since the loop bodies in hci_sync block and we cannot use RCU or hdev->lock for the whole loop, copy list items first and then iterate on the copy. Only the flags field is written from elsewhere, so READ_ONCE/WRITE_ONCE should guarantee we read valid values. Free params everywhere with hci_conn_params_free so the cleanup is guaranteed to be done properly. This fixes the following, which can be triggered e.g. by BlueZ new mgmt-tester case ""Add + Remove Device Nowait - Success"", or by changing hci_le_set_cig_params to always return false, and running iso-tester: ================================================================== BUG: KASAN: slab-use-after-free in hci_update_passive_scan_sync (net/bluetooth/hci_sync.c:2536 net/bluetooth/hci_sync.c:2723 net/bluetooth/hci_sync.c:2841) Read of size 8 at addr ffff888001265018 by task kworker/u3:0/32 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-1.fc38 04/01/2014 Workqueue: hci0 hci_cmd_sync_work Call Trace: <TASK> dump_stack_lvl (./arch/x86/include/asm/irqflags.h:134 lib/dump_stack.c:107) print_report (mm/kasan/report.c:320 mm/kasan/report.c:430) ? __virt_addr_valid (./include/linux/mmzone.h:1915 ./include/linux/mmzone.h:2011 arch/x86/mm/physaddr.c:65) ? hci_update_passive_scan_sync (net/bluetooth/hci_sync.c:2536 net/bluetooth/hci_sync.c:2723 net/bluetooth/hci_sync.c:2841) kasan_report (mm/kasan/report.c:538) ? hci_update_passive_scan_sync (net/bluetooth/hci_sync.c:2536 net/bluetooth/hci_sync.c:2723 net/bluetooth/hci_sync.c:2841) hci_update_passive_scan_sync (net/bluetooth/hci_sync.c:2536 net/bluetooth/hci_sync.c:2723 net/bluetooth/hci_sync.c:2841) ? __pfx_hci_update_passive_scan_sync (net/bluetooth/hci_sync.c:2780) ? mutex_lock (kernel/locking/mutex.c:282) ? __pfx_mutex_lock (kernel/locking/mutex.c:282) ? __pfx_mutex_unlock (kernel/locking/mutex.c:538) ? __pfx_update_passive_scan_sync (net/bluetooth/hci_sync.c:2861) hci_cmd_sync_work (net/bluetooth/hci_sync.c:306) process_one_work (./arch/x86/include/asm/preempt.h:27 kernel/workqueue.c:2399) worker_thread (./include/linux/list.h:292 kernel/workqueue.c:2538) ? __pfx_worker_thread (kernel/workqueue.c:2480) kthread (kernel/kthread.c:376) ? __pfx_kthread (kernel/kthread.c:331) ret_from_fork (arch/x86/entry/entry_64.S:314) </TASK> Allocated by task 31: kasan_save_stack (mm/kasan/common.c:46) kasan_set_track (mm/kasan/common.c:52) __kasan_kmalloc (mm/kasan/common.c:374 mm/kasan/common.c:383) hci_conn_params_add (./include/linux/slab.h:580 ./include/linux/slab.h:720 net/bluetooth/hci_core.c:2277) hci_connect_le_scan (net/bluetooth/hci_conn.c:1419 net/bluetooth/hci_conn.c:1589) hci_connect_cis (net/bluetooth/hci_conn.c:2266) iso_connect_cis (net/bluetooth/iso.c:390) iso_sock_connect (net/bluetooth/iso.c:899) __sys_connect (net/socket.c:2003 net/socket.c:2020) __x64_sys_connect (net/socket.c:2027) do_syscall_64 (arch/x86/entry/common.c:50 arch/x86/entry/common.c:80) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:120) Freed by task 15: kasan_save_stack (mm/kasan/common.c:46) kasan_set_track (mm/kasan/common.c:52) kasan_save_free_info (mm/kasan/generic.c:523) __kasan_slab_free (mm/kasan/common.c:238 mm/kasan/common.c:200 mm/kasan/common.c:244) __kmem_cache_free (mm/slub.c:1807 mm/slub.c:3787 mm/slub.c:3800) hci_conn_params_del (net/bluetooth/hci_core.c:2323) le_scan_cleanup (net/bluetooth/hci_conn.c:202) process_one_work (./arch/x86/include/asm/preempt. ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/13ad45ad14df992a6754a130a19abc8c142d54e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/195ef75e19287b4bc413da3e3e3722b030ac881e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cef88a0fd8e9c2e838162fbb742b3e713b811a7e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53253,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:52.620,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: HID: nvidia-shield: Reference hid_device devm allocation of input_dev name Use hid_device for devm allocation of the input_dev name to avoid a use-after-free. input_unregister_device would trigger devres cleanup of all resources associated with the input_dev, free-ing the name. The name would subsequently be used in a uevent fired at the end of unregistering the input_dev.",,,"[{""url"":""https://git.kernel.org/stable/c/197d3143520fec9fde89aebabc9f0d7464f08e50"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b85d3807e5ec368bfd5b20245347d7c1434aff76"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53254,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:52.727,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: cacheinfo: Fix shared_cpu_map to handle shared caches at different levels The cacheinfo sets up the shared_cpu_map by checking whether the caches with the same index are shared between CPUs. However, this will trigger slab-out-of-bounds access if the CPUs do not have the same cache hierarchy. Another problem is the mismatched shared_cpu_map when the shared cache does not have the same index between CPUs. CPU0 I D L3 index 0 1 2 x ^ ^ ^ ^ index 0 1 2 3 CPU1 I D L2 L3 This patch checks each cache is shared with all caches on other CPUs.",,,"[{""url"":""https://git.kernel.org/stable/c/198102c9103fc78d8478495971947af77edb05c1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2f588d0345d69a35e451077afed428fd057a5e34"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dea49f2993f57d8a2df2cacb0bf649ef49b28879"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53255,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:52.860,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: firmware: stratix10-svc: Fix a potential resource leak in svc_create_memory_pool() svc_create_memory_pool() is only called from stratix10_svc_drv_probe(). Most of resources in the probe are managed, but not this memremap() call. There is also no memunmap() call in the file. So switch to devm_memremap() to avoid a resource leak.",,,"[{""url"":""https://git.kernel.org/stable/c/1995f15590ca222f91193ed11461862b450abfd6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7363de081c793e47866cb54ce7cb8a480cffc259"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/974ac045a05ad12a0b4578fb303f00dcc22f3aba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c04ed61ebf01968d7699b121663982493ed577fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cb8a31a56df8492fb0d900959238e1a3ff8b8981"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3373e6b6c79aff698442b00d20c9f285d296e46"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53256,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:52.980,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: firmware: arm_ffa: Fix FFA device names for logical partitions Each physical partition can provide multiple services each with UUID. Each such service can be presented as logical partition with a unique combination of VM ID and UUID. The number of distinct UUID in a system will be less than or equal to the number of logical partitions. However, currently it fails to register more than one logical partition or service within a physical partition as the device name contains only VM ID while both VM ID and UUID are maintained in the partition information. The kernel complains with the below message: | sysfs: cannot create duplicate filename '/devices/arm-ffa-8001' | CPU: 1 PID: 1 Comm: swapper/0 Not tainted 6.3.0-rc7 #8 | Hardware name: FVP Base RevC (DT) | Call trace: | dump_backtrace+0xf8/0x118 | show_stack+0x18/0x24 | dump_stack_lvl+0x50/0x68 | dump_stack+0x18/0x24 | sysfs_create_dir_ns+0xe0/0x13c | kobject_add_internal+0x220/0x3d4 | kobject_add+0x94/0x100 | device_add+0x144/0x5d8 | device_register+0x20/0x30 | ffa_device_register+0x88/0xd8 | ffa_setup_partitions+0x108/0x1b8 | ffa_init+0x2ec/0x3a4 | do_one_initcall+0xcc/0x240 | do_initcall_level+0x8c/0xac | do_initcalls+0x54/0x94 | do_basic_setup+0x1c/0x28 | kernel_init_freeable+0x100/0x16c | kernel_init+0x20/0x1a0 | ret_from_fork+0x10/0x20 | kobject_add_internal failed for arm-ffa-8001 with -EEXIST, don't try to | register things with the same name in the same directory. | arm_ffa arm-ffa: unable to register device arm-ffa-8001 err=-17 | ARM FF-A: ffa_setup_partitions: failed to register partition ID 0x8001 By virtue of being random enough to avoid collisions when generated in a distributed system, there is no way to compress UUID keys to the number of bits required to identify each. We can eliminate '-' in the name but it is not worth eliminating 4 bytes and add unnecessary logic for doing that. Also v1.0 doesn't provide the UUID of the partitions which makes it hard to use the same for the device name. So to keep it simple, let us alloc an ID using ida_alloc() and append the same to ""arm-ffa"" to make up a unique device name. Also stash the id value in ffa_dev to help freeing the ID later when the device is destroyed.",,,"[{""url"":""https://git.kernel.org/stable/c/19b8766459c41c6f318f8a548cc1c66dffd18363"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/93d0cbe88118fcef234d3ebcbdadcb9ebe9d34f1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c2f65991097a62efbdb2bed3c06fc86b08c9593b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dfc5aaa57f52a5800c339369d235fa30fb734feb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53257,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:53.090,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mac80211: check S1G action frame size Before checking the action code, check that it even exists in the frame.",,,"[{""url"":""https://git.kernel.org/stable/c/19e4a47ee74718a22e963e8a647c8c3bfe8bb05c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5e030a2509be72b452b6f4a800786d43229414db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7ae7a1378a119780c8c17a6b5fc03011c3bb7029"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fedd9377dd9c71a950d432fbe1628eebfbed70a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53258,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:53.203,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix possible underflow for displays with large vblank [Why] Underflow observed when using a display with a large vblank region and low refresh rate [How] Simplify calculation of vblank_nom Increase value for VBlankNomDefaultUS to 800us",,,"[{""url"":""https://git.kernel.org/stable/c/1a4bcdbea4319efeb26cc4b05be859a7867e02dc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/64bc8e10c87adf60b2d32aacf3afb288e51d5a62"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d5741133e6e2f304b40ca1da0e16f62af06f4d22"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53259,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:53.317,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: VMCI: check context->notify_page after call to get_user_pages_fast() to avoid GPF The call to get_user_pages_fast() in vmci_host_setup_notify() can return NULL context->notify_page causing a GPF. To avoid GPF check if context->notify_page == NULL and return error if so. general protection fault, probably for non-canonical address 0xe0009d1000000060: 0000 [#1] PREEMPT SMP KASAN NOPTI KASAN: maybe wild-memory-access in range [0x0005088000000300- 0x0005088000000307] CPU: 2 PID: 26180 Comm: repro_34802241 Not tainted 6.1.0-rc4 #1 Hardware name: Red Hat KVM, BIOS 1.15.0-2.module+el8.6.0 04/01/2014 RIP: 0010:vmci_ctx_check_signal_notify+0x91/0xe0 Call Trace: <TASK> vmci_host_unlocked_ioctl+0x362/0x1f40 __x64_sys_ioctl+0x1a1/0x230 do_syscall_64+0x3a/0x90 entry_SYSCALL_64_after_hwframe+0x63/0xcd",,,"[{""url"":""https://git.kernel.org/stable/c/055891397f530f9b1b22be38d7eca8b08382941f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1a726cb47fd204109c767409fa9ca15a96328f14"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/91b8e4f61f8f4594ee65368c8d89e6fdc29d3fb1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a3c89e8c69a58f62451c0a75b77fcab25979b897"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b4239bfb260d1e6837766c41a0b241d7670f1402"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d4198f67e7556b1507f14f60d81a72660e5560e4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53260,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:53.430,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ovl: fix null pointer dereference in ovl_permission() Following process: P1 P2 path_lookupat link_path_walk inode_permission ovl_permission ovl_i_path_real(inode, &realpath) path->dentry = ovl_i_dentry_upper(inode) drop_cache __dentry_kill(ovl_dentry) iput(ovl_inode) ovl_destroy_inode(ovl_inode) dput(oi->__upperdentry) dentry_kill(upperdentry) dentry_unlink_inode upperdentry->d_inode = NULL realinode = d_inode(realpath.dentry) // return NULL inode_permission(realinode) inode->i_sb // NULL pointer dereference , will trigger an null pointer dereference at realinode: [ 335.664979] BUG: kernel NULL pointer dereference, address: 0000000000000002 [ 335.668032] CPU: 0 PID: 2592 Comm: ls Not tainted 6.3.0 [ 335.669956] RIP: 0010:inode_permission+0x33/0x2c0 [ 335.678939] Call Trace: [ 335.679165] <TASK> [ 335.679371] ovl_permission+0xde/0x320 [ 335.679723] inode_permission+0x15e/0x2c0 [ 335.680090] link_path_walk+0x115/0x550 [ 335.680771] path_lookupat.isra.0+0xb2/0x200 [ 335.681170] filename_lookup+0xda/0x240 [ 335.681922] vfs_statx+0xa6/0x1f0 [ 335.682233] vfs_fstatat+0x7b/0xb0 Fetch a reproducer in [Link]. Use the helper ovl_i_path_realinode() to get realinode and then do non-nullptr checking.",,,"[{""url"":""https://git.kernel.org/stable/c/1a73f5b8f079fd42a544c1600beface50c63af7c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/53dd2ca2c02fdcfe3aad2345091d371063f97d17"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/69f9ae7edf9ec0ff500429101923347fcba5c8c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53261,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:53.540,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: coresight: Fix memory leak in acpi_buffer->pointer There are memory leaks reported by kmemleak: ... unreferenced object 0xffff00213c141000 (size 1024): comm ""systemd-udevd"", pid 2123, jiffies 4294909467 (age 6062.160s) hex dump (first 32 bytes): 04 00 00 00 02 00 00 00 18 10 14 3c 21 00 ff ff ...........<!... 00 00 00 00 00 00 00 00 03 00 00 00 10 00 00 00 ................ backtrace: [<000000004b7c9001>] __kmem_cache_alloc_node+0x2f8/0x348 [<00000000b0fc7ceb>] __kmalloc+0x58/0x108 [<0000000064ff4695>] acpi_os_allocate+0x2c/0x68 [<000000007d57d116>] acpi_ut_initialize_buffer+0x54/0xe0 [<0000000024583908>] acpi_evaluate_object+0x388/0x438 [<0000000017b2e72b>] acpi_evaluate_object_typed+0xe8/0x240 [<000000005df0eac2>] coresight_get_platform_data+0x1b4/0x988 [coresight] ... The ACPI buffer memory (buf.pointer) should be freed. But the buffer is also used after returning from acpi_get_dsd_graph(). Move the temporary variables buf to acpi_coresight_parse_graph(), and free it before the function return to prevent memory leak.",,,"[{""url"":""https://git.kernel.org/stable/c/1a9e02673e2550f5612099e64e8761f0c8fc0f50"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d1b60e7c9fee34eaedf1fc4e0471f75b33f83a4a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53262,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-15T15:15:53.647,2025-09-15T15:22:27.090,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: f2fs: fix scheduling while atomic in decompression path [ 16.945668][ C0] Call trace: [ 16.945678][ C0] dump_backtrace+0x110/0x204 [ 16.945706][ C0] dump_stack_lvl+0x84/0xbc [ 16.945735][ C0] __schedule_bug+0xb8/0x1ac [ 16.945756][ C0] __schedule+0x724/0xbdc [ 16.945778][ C0] schedule+0x154/0x258 [ 16.945793][ C0] bit_wait_io+0x48/0xa4 [ 16.945808][ C0] out_of_line_wait_on_bit+0x114/0x198 [ 16.945824][ C0] __sync_dirty_buffer+0x1f8/0x2e8 [ 16.945853][ C0] __f2fs_commit_super+0x140/0x1f4 [ 16.945881][ C0] f2fs_commit_super+0x110/0x28c [ 16.945898][ C0] f2fs_handle_error+0x1f4/0x2f4 [ 16.945917][ C0] f2fs_decompress_cluster+0xc4/0x450 [ 16.945942][ C0] f2fs_end_read_compressed_page+0xc0/0xfc [ 16.945959][ C0] f2fs_handle_step_decompress+0x118/0x1cc [ 16.945978][ C0] f2fs_read_end_io+0x168/0x2b0 [ 16.945993][ C0] bio_endio+0x25c/0x2c8 [ 16.946015][ C0] dm_io_dec_pending+0x3e8/0x57c [ 16.946052][ C0] clone_endio+0x134/0x254 [ 16.946069][ C0] bio_endio+0x25c/0x2c8 [ 16.946084][ C0] blk_update_request+0x1d4/0x478 [ 16.946103][ C0] scsi_end_request+0x38/0x4cc [ 16.946129][ C0] scsi_io_completion+0x94/0x184 [ 16.946147][ C0] scsi_finish_command+0xe8/0x154 [ 16.946164][ C0] scsi_complete+0x90/0x1d8 [ 16.946181][ C0] blk_done_softirq+0xa4/0x11c [ 16.946198][ C0] _stext+0x184/0x614 [ 16.946214][ C0] __irq_exit_rcu+0x78/0x144 [ 16.946234][ C0] handle_domain_irq+0xd4/0x154 [ 16.946260][ C0] gic_handle_irq.33881+0x5c/0x27c [ 16.946281][ C0] call_on_irq_stack+0x40/0x70 [ 16.946298][ C0] do_interrupt_handler+0x48/0xa4 [ 16.946313][ C0] el1_interrupt+0x38/0x68 [ 16.946346][ C0] el1h_64_irq_handler+0x20/0x30 [ 16.946362][ C0] el1h_64_irq+0x78/0x7c [ 16.946377][ C0] finish_task_switch+0xc8/0x3d8 [ 16.946394][ C0] __schedule+0x600/0xbdc [ 16.946408][ C0] preempt_schedule_common+0x34/0x5c [ 16.946423][ C0] preempt_schedule+0x44/0x48 [ 16.946438][ C0] process_one_work+0x30c/0x550 [ 16.946456][ C0] worker_thread+0x414/0x8bc [ 16.946472][ C0] kthread+0x16c/0x1e0 [ 16.946486][ C0] ret_from_fork+0x10/0x20",,,"[{""url"":""https://git.kernel.org/stable/c/1aa161e43106d46ca8e9a86f4aa28d420258134b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74f74c8b8419a289b85aa9c85e5f4d8c2cc9f5fb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/977df5c13a4b253a718ec44a4eb957c612bf73f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d2746c56dd2cc47f70cc3931977be556172c246d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53263,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:34.977,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/nouveau/disp: fix use-after-free in error handling of nouveau_connector_create We can't simply free the connector after calling drm_connector_init on it. We need to clean up the drm side first. It might not fix all regressions from commit 2b5d1c29f6c4 (""drm/nouveau/disp: PIOR DP uses GPIO for HPD, not PMGR AUX interrupts""), but at least it fixes a memory corruption in error handling related to that commit.",,,"[{""url"":""https://git.kernel.org/stable/c/1b254b791d7b7dea6e8adc887fbbd51746d8bb27"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3f27451c9f29d5ed00232968680c7838a44dcac7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/872feeecd08c81d212a52211d212897b8a857544"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53264,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:35.103,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: clk: imx: clk-imxrt1050: fix memory leak in imxrt1050_clocks_probe Use devm_of_iomap() instead of of_iomap() to automatically handle the unused ioremap region. If any error occurs, regions allocated by kzalloc() will leak, but using devm_kzalloc() instead will automatically free the memory using devm_kfree(). Also, fix error handling of hws by adding unregister_hws label, which unregisters remaining hws when iomap failed.",,,"[{""url"":""https://git.kernel.org/stable/c/02e54db221bb001b32f839e0149ee8d890ab9aa1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/0fbdfd2542252e4c02e8158a06b7c0c9cfd40f99"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1839032251a66f2ae5a043c495532830a55d28c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1b280598ab3bd8a2dc8b96a12530d5b1ee7a8f4a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53265,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:35.213,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ubi: ensure that VID header offset + VID header size <= alloc, size Ensure that the VID header offset + VID header size does not exceed the allocated area to avoid slab OOB. BUG: KASAN: slab-out-of-bounds in crc32_body lib/crc32.c:111 [inline] BUG: KASAN: slab-out-of-bounds in crc32_le_generic lib/crc32.c:179 [inline] BUG: KASAN: slab-out-of-bounds in crc32_le_base+0x58c/0x626 lib/crc32.c:197 Read of size 4 at addr ffff88802bb36f00 by task syz-executor136/1555 CPU: 2 PID: 1555 Comm: syz-executor136 Tainted: G W 6.0.0-1868 #1 Hardware name: Red Hat KVM, BIOS 1.13.0-2.module+el8.3.0+7860+a7792d29 04/01/2014 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x85/0xad lib/dump_stack.c:106 print_address_description mm/kasan/report.c:317 [inline] print_report.cold.13+0xb6/0x6bb mm/kasan/report.c:433 kasan_report+0xa7/0x11b mm/kasan/report.c:495 crc32_body lib/crc32.c:111 [inline] crc32_le_generic lib/crc32.c:179 [inline] crc32_le_base+0x58c/0x626 lib/crc32.c:197 ubi_io_write_vid_hdr+0x1b7/0x472 drivers/mtd/ubi/io.c:1067 create_vtbl+0x4d5/0x9c4 drivers/mtd/ubi/vtbl.c:317 create_empty_lvol drivers/mtd/ubi/vtbl.c:500 [inline] ubi_read_volume_table+0x67b/0x288a drivers/mtd/ubi/vtbl.c:812 ubi_attach+0xf34/0x1603 drivers/mtd/ubi/attach.c:1601 ubi_attach_mtd_dev+0x6f3/0x185e drivers/mtd/ubi/build.c:965 ctrl_cdev_ioctl+0x2db/0x347 drivers/mtd/ubi/cdev.c:1043 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:870 [inline] __se_sys_ioctl fs/ioctl.c:856 [inline] __x64_sys_ioctl+0x193/0x213 fs/ioctl.c:856 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3e/0x86 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0x0 RIP: 0033:0x7f96d5cf753d Code: RSP: 002b:00007fffd72206f8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f96d5cf753d RDX: 0000000020000080 RSI: 0000000040186f40 RDI: 0000000000000003 RBP: 0000000000400cd0 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000400be0 R13: 00007fffd72207e0 R14: 0000000000000000 R15: 0000000000000000 </TASK> Allocated by task 1555: kasan_save_stack+0x20/0x3d mm/kasan/common.c:38 kasan_set_track mm/kasan/common.c:45 [inline] set_alloc_info mm/kasan/common.c:437 [inline] ____kasan_kmalloc mm/kasan/common.c:516 [inline] __kasan_kmalloc+0x88/0xa3 mm/kasan/common.c:525 kasan_kmalloc include/linux/kasan.h:234 [inline] __kmalloc+0x138/0x257 mm/slub.c:4429 kmalloc include/linux/slab.h:605 [inline] ubi_alloc_vid_buf drivers/mtd/ubi/ubi.h:1093 [inline] create_vtbl+0xcc/0x9c4 drivers/mtd/ubi/vtbl.c:295 create_empty_lvol drivers/mtd/ubi/vtbl.c:500 [inline] ubi_read_volume_table+0x67b/0x288a drivers/mtd/ubi/vtbl.c:812 ubi_attach+0xf34/0x1603 drivers/mtd/ubi/attach.c:1601 ubi_attach_mtd_dev+0x6f3/0x185e drivers/mtd/ubi/build.c:965 ctrl_cdev_ioctl+0x2db/0x347 drivers/mtd/ubi/cdev.c:1043 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:870 [inline] __se_sys_ioctl fs/ioctl.c:856 [inline] __x64_sys_ioctl+0x193/0x213 fs/ioctl.c:856 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3e/0x86 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0x0 The buggy address belongs to the object at ffff88802bb36e00 which belongs to the cache kmalloc-256 of size 256 The buggy address is located 0 bytes to the right of 256-byte region [ffff88802bb36e00, ffff88802bb36f00) The buggy address belongs to the physical page: page:00000000ea4d1263 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x2bb36 head:00000000ea4d1263 order:1 compound_mapcount:0 compound_pincount:0 flags: 0xfffffc0010200(slab|head|node=0|zone=1|lastcpupid=0x1fffff) raw: 000fffffc0010200 ffffea000066c300 dead000000000003 ffff888100042b40 raw: 0000000000000000 00000000001 ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/1b42b1a36fc946f0d7088425b90d491b4257ca3e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/61aeba0e4b4124cfe3c5427feaf29c626dfa89e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/61e04db3bec87f7dd10074296deb7d083e2ccade"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/701bb3ed5a88a73ebbe1266895bdeff065226dca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/771e207a839a29ba943e89f473b0fecd16089e2e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/846bfba34175c23b13cc2023c2d67b96e8c14c43"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e1b73fe4f4c6bb80755eb4bf4b867a8fd8b1a7fe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f7adb740f97b6fa84e658892dcb08e37a31a4e77"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53266,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:35.353,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: arm64: acpi: Fix possible memory leak of ffh_ctxt Allocated 'ffh_ctxt' memory leak is possible if the SMCCC version and conduit checks fail and -EOPNOTSUPP is returned without freeing the allocated memory. Fix the same by moving the allocation after the SMCCC version and conduit checks.",,,"[{""url"":""https://git.kernel.org/stable/c/1b561d3949f8478c5403c9752b5533211a757226"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7521da2eb42d65f89f511b7912d3757cf3d9168a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53267,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:35.463,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: driver: soc: xilinx: fix memory leak in xlnx_add_cb_for_notify_event() The kfree() should be called when memory fails to be allocated for cb_data in xlnx_add_cb_for_notify_event(), otherwise there will be a memory leak, so add kfree() to fix it.",,,"[{""url"":""https://git.kernel.org/stable/c/1bea534991b9b35c41848a397666ada436456beb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9dfb6c784e385f6e61994bb4e16ce12f3e4940be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d35290addcbac94b076babe0a798a8c043421812"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53268,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:35.577,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ASoC: fsl_mqs: move of_node_put() to the correct location of_node_put() should have been done directly after mqs_priv->regmap = syscon_node_to_regmap(gpr_np); otherwise it creates a reference leak on the success path. To fix this, of_node_put() is moved to the correct location, and change all the gotos to direct returns.",,,"[{""url"":""https://git.kernel.org/stable/c/1bdb4a5ccab2316935ce4ad4fd4df8d36f0ffc6e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1c34890273a020d61d6127ade3f68ed1cb21c16a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/402299cca89273b62384b5f9645ea49cd5fc4a57"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6a129c0e9935112ecf2ffb6de98f83b8fd090c86"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9a2585088a7d6f98a5a910f5b4b74b6d24e63156"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b5a6930fc6a432e32714c4ed3c597077d999cf6d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53269,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:35.680,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: block: ublk: make sure that block size is set correctly block size is one very key setting for block layer, and bad block size could panic kernel easily. Make sure that block size is set correctly. Meantime if ublk_validate_params() fails, clear ub->params so that disk is prevented from being added.",,,"[{""url"":""https://git.kernel.org/stable/c/1d1665279a845d16c93687389e364386e3fe0f38"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/231a49460ac0203270da2471928d392e5586370f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9dbe85ac618ef6ae60abe5dd17ae2b29065d9c1e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53270,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:35.790,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: fix i_disksize exceeding i_size problem in paritally written case It is possible for i_disksize can exceed i_size, triggering a warning. generic_perform_write copied = iov_iter_copy_from_user_atomic(len) // copied < len ext4_da_write_end | ext4_update_i_disksize | new_i_size = pos + copied; | WRITE_ONCE(EXT4_I(inode)->i_disksize, newsize) // update i_disksize | generic_write_end | copied = block_write_end(copied, len) // copied = 0 | if (unlikely(copied < len)) | if (!PageUptodate(page)) | copied = 0; | if (pos + copied > inode->i_size) // return false if (unlikely(copied == 0)) goto again; if (unlikely(iov_iter_fault_in_readable(i, bytes))) { status = -EFAULT; break; } We get i_disksize greater than i_size here, which could trigger WARNING check 'i_size_read(inode) < EXT4_I(inode)->i_disksize' while doing dio: ext4_dio_write_iter iomap_dio_rw __iomap_dio_rw // return err, length is not aligned to 512 ext4_handle_inode_extension WARN_ON_ONCE(i_size_read(inode) < EXT4_I(inode)->i_disksize) // Oops WARNING: CPU: 2 PID: 2609 at fs/ext4/file.c:319 CPU: 2 PID: 2609 Comm: aa Not tainted 6.3.0-rc2 RIP: 0010:ext4_file_write_iter+0xbc7 Call Trace: vfs_write+0x3b1 ksys_write+0x77 do_syscall_64+0x39 Fix it by updating 'copied' value before updating i_disksize just like ext4_write_inline_data_end() does. A reproducer can be found in the buganizer link below.",,,"[{""url"":""https://git.kernel.org/stable/c/18eb23891aeae3229baf8c7c23b76be3364e1967"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1dedde690303c05ef732b7c5c8356fdf60a4ade3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ecea2fee14227712694c8b54ad99d471e61de92"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/53877ed201baa6b58f7ce9df92664a839113c30e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d30090eb546d993ea3f3023452540c476ea614a5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53271,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:35.900,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ubi: Fix unreferenced object reported by kmemleak in ubi_resize_volume() There is a memory leaks problem reported by kmemleak: unreferenced object 0xffff888102007a00 (size 128): comm ""ubirsvol"", pid 32090, jiffies 4298464136 (age 2361.231s) hex dump (first 32 bytes): ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................ ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ................ backtrace: [<ffffffff8176cecd>] __kmalloc+0x4d/0x150 [<ffffffffa02a9a36>] ubi_eba_create_table+0x76/0x170 [ubi] [<ffffffffa029764e>] ubi_resize_volume+0x1be/0xbc0 [ubi] [<ffffffffa02a3321>] ubi_cdev_ioctl+0x701/0x1850 [ubi] [<ffffffff81975d2d>] __x64_sys_ioctl+0x11d/0x170 [<ffffffff83c142a5>] do_syscall_64+0x35/0x80 [<ffffffff83e0006a>] entry_SYSCALL_64_after_hwframe+0x46/0xb0 This is due to a mismatch between create and destroy interfaces, and in detail that ""new_eba_tbl"" created by ubi_eba_create_table() but destroyed by kfree(), while will causing ""new_eba_tbl->entries"" not freed. Fix it by replacing kfree(new_eba_tbl) with ubi_eba_destroy_table(new_eba_tbl)",,,"[{""url"":""https://git.kernel.org/stable/c/07b60f7452d2fa731737552937cb81821919f874"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/09780a44093b53f9cbca76246af2e4ff0884e512"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1e591ea072df7211f64542a09482b5f81cb3ad27"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/26ec2d66aecab8ff997b912c20247fedba4f5740"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/27b760b81951d8d5e5c952a696af8574052b0709"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/31d60afe2cc2b712dbefcaab6b7d6a47036f844e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5c0c81a313492b83bd0c038b8839b0e04eb87563"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/95a72417dd13ebcdcb1bd0c5d4d15f7c5bfbb288"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53272,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:36.013,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: ena: fix shift-out-of-bounds in exponential backoff The ENA adapters on our instances occasionally reset. Once recently logged a UBSAN failure to console in the process: UBSAN: shift-out-of-bounds in build/linux/drivers/net/ethernet/amazon/ena/ena_com.c:540:13 shift exponent 32 is too large for 32-bit type 'unsigned int' CPU: 28 PID: 70012 Comm: kworker/u72:2 Kdump: loaded not tainted 5.15.117 Hardware name: Amazon EC2 c5d.9xlarge/, BIOS 1.0 10/16/2017 Workqueue: ena ena_fw_reset_device [ena] Call Trace: <TASK> dump_stack_lvl+0x4a/0x63 dump_stack+0x10/0x16 ubsan_epilogue+0x9/0x36 __ubsan_handle_shift_out_of_bounds.cold+0x61/0x10e ? __const_udelay+0x43/0x50 ena_delay_exponential_backoff_us.cold+0x16/0x1e [ena] wait_for_reset_state+0x54/0xa0 [ena] ena_com_dev_reset+0xc8/0x110 [ena] ena_down+0x3fe/0x480 [ena] ena_destroy_device+0xeb/0xf0 [ena] ena_fw_reset_device+0x30/0x50 [ena] process_one_work+0x22b/0x3d0 worker_thread+0x4d/0x3f0 ? process_one_work+0x3d0/0x3d0 kthread+0x12a/0x150 ? set_kthread_struct+0x50/0x50 ret_from_fork+0x22/0x30 </TASK> Apparently, the reset delays are getting so large they can trigger a UBSAN panic. Looking at the code, the current timeout is capped at 5000us. Using a base value of 100us, the current code will overflow after (1<<29). Even at values before 32, this function wraps around, perhaps unintentionally. Cap the value of the exponent used for this backoff at (1<<16) which is larger than currently necessary, but large enough to support bigger values in the future.",,,"[{""url"":""https://git.kernel.org/stable/c/0939c264729d4a081ff88efce2ffdf85dc5331e0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1e760b2d18bf129b3da052c2946c02758e97d15e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1e9cb763e9bacf0c932aa948f50dcfca6f519a26"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3e36cc94d6e60a27f27498adf1c71eeba769ab33"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90947ebf8794e3c229fb2e16e37f1bfea6877f14"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53273,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:36.127,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Drivers: vmbus: Check for channel allocation before looking up relids relid2channel() assumes vmbus channel array to be allocated when called. However, in cases such as kdump/kexec, not all relids will be reset by the host. When the second kernel boots and if the guest receives a vmbus interrupt during vmbus driver initialization before vmbus_connect() is called, before it finishes, or if it fails, the vmbus interrupt service routine is called which in turn calls relid2channel() and can cause a null pointer dereference. Print a warning and error out in relid2channel() for a channel id that's invalid in the second kernel.",,,"[{""url"":""https://git.kernel.org/stable/c/176c6b4889195fbe7016d9401175b48c5c9edf68"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1eb65c8687316c65140b48fad27133d583178e15"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c3f0ae5435fd20bb1e3a8308488aa6ac33151ee"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a5c44f3446a0565139b7d8abc78f58b86c398123"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c373e49fbb87aa177819866ed9194ebc5414dfd6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53274,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:36.243,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: clk: mediatek: mt8183: Add back SSPM related clocks This reverts commit 860690a93ef23b567f781c1b631623e27190f101. On the MT8183, the SSPM related clocks were removed claiming a lack of usage. This however causes some issues when the driver was converted to the new simple-probe mechanism. This mechanism allocates enough space for all the clocks defined in the clock driver, not the highest index in the DT binding. This leads to out-of-bound writes if their are holes in the DT binding or the driver (due to deprecated or unimplemented clocks). These errors can go unnoticed and cause memory corruption, leading to crashes in unrelated areas, or nothing at all. KASAN will detect them. Add the SSPM related clocks back to the MT8183 clock driver to fully implement the DT binding. The SSPM clocks are for the power management co-processor, and should never be turned off. They are marked as such.",,,"[{""url"":""https://git.kernel.org/stable/c/1eb8d61ac5c9c7ec56bb96d433532807509b9288"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/45d69917a4af6c869193f95932dc6d6f15d5ef86"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53275,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:36.360,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ALSA: hda: fix a possible null-pointer dereference due to data race in snd_hdac_regmap_sync() The variable codec->regmap is often protected by the lock codec->regmap_lock when is accessed. However, it is accessed without holding the lock when is accessed in snd_hdac_regmap_sync(): if (codec->regmap) In my opinion, this may be a harmful race, because if codec->regmap is set to NULL right after the condition is checked, a null-pointer dereference can occur in the called function regcache_sync(): map->lock(map->lock_arg); --> Line 360 in drivers/base/regmap/regcache.c To fix this possible null-pointer dereference caused by data race, the mutex_lock coverage is extended to protect the if statement as well as the function call to regcache_sync(). [ Note: the lack of the regmap_lock itself is harmless for the current codec driver implementations, as snd_hdac_regmap_sync() is only for PM runtime resume that is prohibited during the codec probe. But the change makes the whole code more consistent, so it's merged as is -- tiwai ]",,,"[{""url"":""https://git.kernel.org/stable/c/109f0aaa0b8838a88af9125b79579023539300a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1f4a08fed450db87fbb5ff5105354158bdbe1a22"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8703b26387e1fa4f8749db98d24c67617b873acb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9f9eed451176ffcac6b5ba0f6dae1a6b4a1cb0eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b32e40379e5b2814de0c4bc199edc2d82317dc07"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cdd412b528dee6e0851c4735d6676ec138da13a4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53276,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:36.473,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ubifs: Free memory for tmpfile name When opening a ubifs tmpfile on an encrypted directory, function fscrypt_setup_filename allocates memory for the name that is to be stored in the directory entry, but after the name has been copied to the directory entry inode, the memory is not freed. When running kmemleak on it we see that it is registered as a leak. The report below is triggered by a simple program 'tmpfile' just opening a tmpfile: unreferenced object 0xffff88810178f380 (size 32): comm ""tmpfile"", pid 509, jiffies 4294934744 (age 1524.742s) backtrace: __kmem_cache_alloc_node __kmalloc fscrypt_setup_filename ubifs_tmpfile vfs_tmpfile path_openat Free this memory after it has been copied to the inode.",,,"[{""url"":""https://git.kernel.org/stable/c/107d481642c356a5668058066360fc473911e628"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1e43d4284bdc3bd34bd770fea13910ac37ab0618"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1fb815b38bb31d6af9bd0540b8652a0d6fe6cfd3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/29738e1bcc799dd754711d4e4aab967f0c018175"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/823f554747f8aafaa965fb2f3ae794110ed429ef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ad8c67a897e68426e85990ebfe0a7d1f71fc79f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b8f444a4fadfb5070ed7e298e0a5ceb4a18014f3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ce840284929b75dbbf062e0ce7fcb78a63b08b5e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd197308c0e4f738c7ea687d5332035c5753881c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53277,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:36.590,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: iwl3945: Add missing check for create_singlethread_workqueue Add the check for the return value of the create_singlethread_workqueue in order to avoid NULL pointer dereference.",,,"[{""url"":""https://git.kernel.org/stable/c/17e07d6587c55015956862ef3b101fd45fa49fbc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1fdeb8b9f29dfd64805bb49475ac7566a3cb06cb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2f80b3ff92514ebd227e5c55d3d1e480401b02b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/34f611204ae589bd5c494b10b41fb13436bd3c3f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ae2fc4de12686f3fe695824169c1272c9f798f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/505c74c4c0b1c5bcaa98a93b3087c268156070f1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7e594abc0424e4f8c2385f11aefeaadcfc507aa5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53278,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:36.697,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ubifs: Fix memory leak in ubifs_sysfs_init() When insmod ubifs.ko, a kmemleak reported as below: unreferenced object 0xffff88817fb1a780 (size 8): comm ""insmod"", pid 25265, jiffies 4295239702 (age 100.130s) hex dump (first 8 bytes): 75 62 69 66 73 00 ff ff ubifs... backtrace: [<ffffffff81b3fc4c>] slab_post_alloc_hook+0x9c/0x3c0 [<ffffffff81b44bf3>] __kmalloc_track_caller+0x183/0x410 [<ffffffff8198d3da>] kstrdup+0x3a/0x80 [<ffffffff8198d486>] kstrdup_const+0x66/0x80 [<ffffffff83989325>] kvasprintf_const+0x155/0x190 [<ffffffff83bf55bb>] kobject_set_name_vargs+0x5b/0x150 [<ffffffff83bf576b>] kobject_set_name+0xbb/0xf0 [<ffffffff8100204c>] do_one_initcall+0x14c/0x5a0 [<ffffffff8157e380>] do_init_module+0x1f0/0x660 [<ffffffff815857be>] load_module+0x6d7e/0x7590 [<ffffffff8158644f>] __do_sys_finit_module+0x19f/0x230 [<ffffffff815866b3>] __x64_sys_finit_module+0x73/0xb0 [<ffffffff88c98e85>] do_syscall_64+0x35/0x80 [<ffffffff88e00087>] entry_SYSCALL_64_after_hwframe+0x63/0xcd When kset_register() failed, we should call kset_put to cleanup it.",,,"[{""url"":""https://git.kernel.org/stable/c/1c5fdf2d4647219d2267ccb08c7f2c7095bf3450"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/203a55f04f66eea1a1ca7e5a302a7f5c99c62327"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d42c2b18c42da7378e67b6414aafe93b65de89d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53279,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:36.803,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: misc: vmw_balloon: fix memory leak with using debugfs_lookup() When calling debugfs_lookup() the result must have dput() called on it, otherwise the memory will leak over time. To make things simpler, just call debugfs_lookup_and_remove() instead which handles all of the logic at once.",,,"[{""url"":""https://git.kernel.org/stable/c/209cdbd07cfaa4b7385bad4eeb47e5ec1887d33d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b94b39bf3d545671f210a2257d18e33c8b874699"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d1c545e44c1ec08bef0c0c14e632eec516431e9c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f7651fa88b17c2d7af949981a2423179db5e9453"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53280,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:36.917,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: qla2xxx: Remove unused nvme_ls_waitq wait queue System crash when qla2x00_start_sp(sp) returns error code EGAIN and wake_up gets called for uninitialized wait queue sp->nvme_ls_waitq. qla2xxx [0000:37:00.1]-2121:5: Returning existing qpair of ffff8ae2c0513400 for idx=0 qla2xxx [0000:37:00.1]-700e:5: qla2x00_start_sp failed = 11 BUG: unable to handle kernel NULL pointer dereference at 0000000000000000 PGD 0 P4D 0 Oops: 0000 [#1] SMP NOPTI Hardware name: HPE ProLiant DL360 Gen10/ProLiant DL360 Gen10, BIOS U32 09/03/2021 Workqueue: nvme-wq nvme_fc_connect_ctrl_work [nvme_fc] RIP: 0010:__wake_up_common+0x4c/0x190 RSP: 0018:ffff95f3e0cb7cd0 EFLAGS: 00010086 RAX: 0000000000000000 RBX: ffff8b08d3b26328 RCX: 0000000000000000 RDX: 0000000000000001 RSI: 0000000000000003 RDI: ffff8b08d3b26320 RBP: 0000000000000001 R08: 0000000000000000 R09: ffffffffffffffe8 R10: 0000000000000000 R11: ffff95f3e0cb7a60 R12: ffff95f3e0cb7d20 R13: 0000000000000003 R14: 0000000000000000 R15: 0000000000000000 FS: 0000000000000000(0000) GS:ffff8b2fdf6c0000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000000 CR3: 0000002f1e410002 CR4: 00000000007706e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 PKRU: 55555554 Call Trace: __wake_up_common_lock+0x7c/0xc0 qla_nvme_ls_req+0x355/0x4c0 [qla2xxx] ? __nvme_fc_send_ls_req+0x260/0x380 [nvme_fc] ? nvme_fc_send_ls_req.constprop.42+0x1a/0x45 [nvme_fc] ? nvme_fc_connect_ctrl_work.cold.63+0x1e3/0xa7d [nvme_fc] Remove unused nvme_ls_waitq wait queue. nvme_ls_waitq logic was removed previously in the commits tagged Fixed: below.",,,"[{""url"":""https://git.kernel.org/stable/c/0b1ce92fabdb7d02ddf8641230a06e2752ae5baa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/20fce500b232b970e40312a9c97e7f3b6d7a709c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/522ee1b3030f3b6b5fd59489d12b4ca767c9e5da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/92529387a0066754fd9cda080fb3298b8cca750c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b7084ebf4f54d46fed5153112d685f4137334175"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f459d586fdf12c53116c9fddf43065165fdd5969"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53281,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:37.030,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drivers: staging: rtl8723bs: Fix locking in _rtw_join_timeout_handler() Commit 041879b12ddb (""drivers: staging: rtl8192bs: Fix deadlock in rtw_joinbss_event_prehandle()"") besides fixing the deadlock also modified _rtw_join_timeout_handler() to use spin_[un]lock_irq() instead of spin_[un]lock_bh(). _rtw_join_timeout_handler() calls rtw_do_join() which takes pmlmepriv->scanned_queue.lock using spin_[un]lock_bh(). This spin_unlock_bh() call re-enables softirqs which triggers an oops in kernel/softirq.c: __local_bh_enable_ip() when it calls lockdep_assert_irqs_enabled(): [ 244.506087] WARNING: CPU: 2 PID: 0 at kernel/softirq.c:376 __local_bh_enable_ip+0xa6/0x100 ... [ 244.509022] Call Trace: [ 244.509048] <IRQ> [ 244.509100] _rtw_join_timeout_handler+0x134/0x170 [r8723bs] [ 244.509468] ? __pfx__rtw_join_timeout_handler+0x10/0x10 [r8723bs] [ 244.509772] ? __pfx__rtw_join_timeout_handler+0x10/0x10 [r8723bs] [ 244.510076] call_timer_fn+0x95/0x2a0 [ 244.510200] __run_timers.part.0+0x1da/0x2d0 This oops is causd by the switch to spin_[un]lock_irq() which disables the IRQs for the entire duration of _rtw_join_timeout_handler(). Disabling the IRQs is not necessary since all code taking this lock runs from either user contexts or from softirqs, switch back to spin_[un]lock_bh() to fix this.",,,"[{""url"":""https://git.kernel.org/stable/c/209850f17717a3b5cc558578bef5631ac7045539"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/215792eda008f6a1e7ed9d77fa20d582d22bb114"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2a50e44a66d268ee5db3d177f1fdc1503dbce6e7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4ab1bace1dd3875371b481ef4301c4671bddea22"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc327e87c6d9bfd9ee08e76396b3c0ba848ec554"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53282,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:37.147,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: lpfc: Fix use-after-free KFENCE violation during sysfs firmware write During the sysfs firmware write process, a use-after-free read warning is logged from the lpfc_wr_object() routine: BUG: KFENCE: use-after-free read in lpfc_wr_object+0x235/0x310 [lpfc] Use-after-free read at 0x0000000000cf164d (in kfence-#111): lpfc_wr_object+0x235/0x310 [lpfc] lpfc_write_firmware.cold+0x206/0x30d [lpfc] lpfc_sli4_request_firmware_update+0xa6/0x100 [lpfc] lpfc_request_firmware_upgrade_store+0x66/0xb0 [lpfc] kernfs_fop_write_iter+0x121/0x1b0 new_sync_write+0x11c/0x1b0 vfs_write+0x1ef/0x280 ksys_write+0x5f/0xe0 do_syscall_64+0x59/0x90 entry_SYSCALL_64_after_hwframe+0x63/0xcd The driver accessed wr_object pointer data, which was initialized into mailbox payload memory, after the mailbox object was released back to the mailbox pool. Fix by moving the mailbox free calls to the end of the routine ensuring that we don't reference internal mailbox memory after release.",,,"[{""url"":""https://git.kernel.org/stable/c/21681b81b9ae548c5dae7ae00d931197a27f480c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/51ab4eb1a25e73c7fc2ad9026520c4d8369c93cc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8becb97918f04bb177bc9c4e00c2bdb302e00944"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8dfefa8f424ab208e552df1bfd008b732f3d0ad1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53283,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:37.260,2025-09-16T09:15:44.807,Rejected,[],Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.,,,[],,,,,,,,,
CVE-2023-53284,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:37.400,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/msm/dpu: check for null return of devm_kzalloc() in dpu_writeback_init() Because of the possilble failure of devm_kzalloc(), dpu_wb_conn might be NULL and will cause null pointer dereference later. Therefore, it might be better to check it and directly return -ENOMEM. Patchwork: https://patchwork.freedesktop.org/patch/512277/ [DB: fixed typo in commit message]",,,"[{""url"":""https://git.kernel.org/stable/c/21e9a838f505178e109ccb3bf19d7808eb0326f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3723c4dbcd14cc96771000ce0b0540801e6ba059"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5ee51b19855c5dd72aca57b8014f3b70d7798733"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53285,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:37.540,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: add bounds checking in get_max_inline_xattr_value_size() Normally the extended attributes in the inode body would have been checked when the inode is first opened, but if someone is writing to the block device while the file system is mounted, it's possible for the inode table to get corrupted. Add bounds checking to avoid reading beyond the end of allocated memory if this happens.",,,"[{""url"":""https://git.kernel.org/stable/c/1d2caddbeeee56fbbc36b428c5b909c3ad88eb7f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2220eaf90992c11d888fe771055d4de330385f01"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3d7b8fbcd2273e2b9f4c6de5ce2f4c0cd3cb1205"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4597554b4f7b29e7fd78aa449bab648f8da4ee2c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/486efbbc9445dca7890a1b86adbccb88b91284b0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a229d21b98d132673096710e8281ef522dab1d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/88a06a94942c5c0a896e9da1113a6bb29e36cbef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e780058bd75614b66882bc02620ddbd884171560"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f22b274429e88d3dc7e79d375b56ce4f2f59f0b4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53286,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:37.680,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/mlx5: Return the firmware result upon destroying QP/RQ Previously when destroying a QP/RQ, the result of the firmware destruction function was ignored and upper layers weren't informed about the failure. Which in turn could lead to various problems since when upper layer isn't aware of the failure it continues its operation thinking that the related QP/RQ was successfully destroyed while it actually wasn't, which could lead to the below kernel WARN. Currently, we return the correct firmware destruction status to upper layers which in case of the RQ would be mlx5_ib_destroy_wq() which was already capable of handling RQ destruction failure or in case of a QP to destroy_qp_common(), which now would actually warn upon qp destruction failure. WARNING: CPU: 3 PID: 995 at drivers/infiniband/core/rdma_core.c:940 uverbs_destroy_ufile_hw+0xcb/0xe0 [ib_uverbs] Modules linked in: xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_iscsi rdma_cm ib_umad ib_ipoib iw_cm ib_cm mlx5_ib ib_uverbs ib_core overlay mlx5_core fuse CPU: 3 PID: 995 Comm: python3 Not tainted 5.16.0-rc5+ #1 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 RIP: 0010:uverbs_destroy_ufile_hw+0xcb/0xe0 [ib_uverbs] Code: 41 5c 41 5d 41 5e e9 44 34 f0 e0 48 89 df e8 4c 77 ff ff 49 8b 86 10 01 00 00 48 85 c0 74 a1 4c 89 e7 ff d0 eb 9a 0f 0b eb c1 <0f> 0b be 04 00 00 00 48 89 df e8 b6 f6 ff ff e9 75 ff ff ff 90 0f RSP: 0018:ffff8881533e3e78 EFLAGS: 00010287 RAX: ffff88811b2cf3e0 RBX: ffff888106209700 RCX: 0000000000000000 RDX: ffff888106209780 RSI: ffff8881533e3d30 RDI: ffff888109b101a0 RBP: 0000000000000001 R08: ffff888127cb381c R09: 0de9890000000009 R10: ffff888127cb3800 R11: 0000000000000000 R12: ffff888106209780 R13: ffff888106209750 R14: ffff888100f20660 R15: 0000000000000000 FS: 00007f8be353b740(0000) GS:ffff88852c980000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f8bd5b117c0 CR3: 000000012cd8a004 CR4: 0000000000370ea0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ib_uverbs_close+0x1a/0x90 [ib_uverbs] __fput+0x82/0x230 task_work_run+0x59/0x90 exit_to_user_mode_prepare+0x138/0x140 syscall_exit_to_user_mode+0x1d/0x50 ? __x64_sys_close+0xe/0x40 do_syscall_64+0x4a/0x90 entry_SYSCALL_64_after_hwframe+0x44/0xae RIP: 0033:0x7f8be3ae0abb Code: 03 00 00 00 0f 05 48 3d 00 f0 ff ff 77 41 c3 48 83 ec 18 89 7c 24 0c e8 83 43 f9 ff 8b 7c 24 0c 41 89 c0 b8 03 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 35 44 89 c7 89 44 24 0c e8 c1 43 f9 ff 8b 44 RSP: 002b:00007ffdb51909c0 EFLAGS: 00000293 ORIG_RAX: 0000000000000003 RAX: 0000000000000000 RBX: 0000557bb7f7c020 RCX: 00007f8be3ae0abb RDX: 0000557bb7c74010 RSI: 0000557bb7f14ca0 RDI: 0000000000000005 RBP: 0000557bb7fbd598 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000293 R12: 0000557bb7fbd5b8 R13: 0000557bb7fbd5a8 R14: 0000000000001000 R15: 0000557bb7f7c020 </TASK>",,,"[{""url"":""https://git.kernel.org/stable/c/04704c201bb08efaf96d7b1396c6864f8984e244"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1a650d3ccd79cdd5796edd864683a6b8dd0bf576"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/22664c06e997087fe37f9ba208008c948571214a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5fe7815e784bf21061885f8112a7108aef5c45bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/73311dd831858d797cf8ebe140654ed519b41c36"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53287,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:37.820,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: usb: cdns3: Put the cdns set active part outside the spin lock The device may be scheduled during the resume process, so this cannot appear in atomic operations. Since pm_runtime_set_active will resume suppliers, put set active outside the spin lock, which is only used to protect the struct cdns data structure, otherwise the kernel will report the following warning: BUG: sleeping function called from invalid context at drivers/base/power/runtime.c:1163 in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 651, name: sh preempt_count: 1, expected: 0 RCU nest depth: 0, expected: 0 CPU: 0 PID: 651 Comm: sh Tainted: G WC 6.1.20 #1 Hardware name: Freescale i.MX8QM MEK (DT) Call trace: dump_backtrace.part.0+0xe0/0xf0 show_stack+0x18/0x30 dump_stack_lvl+0x64/0x80 dump_stack+0x1c/0x38 __might_resched+0x1fc/0x240 __might_sleep+0x68/0xc0 __pm_runtime_resume+0x9c/0xe0 rpm_get_suppliers+0x68/0x1b0 __pm_runtime_set_status+0x298/0x560 cdns_resume+0xb0/0x1c0 cdns3_controller_resume.isra.0+0x1e0/0x250 cdns3_plat_resume+0x28/0x40",,,"[{""url"":""https://git.kernel.org/stable/c/2319b9c87fe243327285f2fefd7374ffd75a65fc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bbc9c3652708108738009e096d608ece3cd9fa8a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c861a61be6d30538ebcf7fcab1d43f244e298840"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d3f372ec95b89776f72d5c9a475424e27734c223"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53288,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:37.940,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/client: Fix memory leak in drm_client_modeset_probe When a new mode is set to modeset->mode, the previous mode should be freed. This fixes the following kmemleak report: drm_mode_duplicate+0x45/0x220 [drm] drm_client_modeset_probe+0x944/0xf50 [drm] __drm_fb_helper_initial_config_and_unlock+0xb4/0x2c0 [drm_kms_helper] drm_fbdev_client_hotplug+0x2bc/0x4d0 [drm_kms_helper] drm_client_register+0x169/0x240 [drm] ast_pci_probe+0x142/0x190 [ast] local_pci_probe+0xdc/0x180 work_for_cpu_fn+0x4e/0xa0 process_one_work+0x8b7/0x1540 worker_thread+0x70a/0xed0 kthread+0x29f/0x340 ret_from_fork+0x1f/0x30",,,"[{""url"":""https://git.kernel.org/stable/c/1369d0c586ad44f2d18fe2f4cbc5bcb24132fa71"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2329cc7a101af1a844fbf706c0724c0baea38365"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5d580017bdb9b3e930b6009e467e5e1589f8ca8a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5f2a12f64347f535c6ef55fa7eb36a2874d69b59"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8108a494639e56aea77e7196a1d6ea89792b9d4a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/917bef37cfaca07781c6fbaf6cd9404d27e64e6f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53289,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:38.067,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: bdisp: Add missing check for create_workqueue Add the check for the return value of the create_workqueue in order to avoid NULL pointer dereference.",,,"[{""url"":""https://git.kernel.org/stable/c/0d09ce05724cfb3f5c5136893bec95305c641875"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2371adeab717d8fe32144a84f3491a03c5838cfb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2bfbe3ad371ac5349302833198df14e442622cbc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4362444dca02ab44ac844feda3cf6238ef953673"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/519b0849401194745ea40f9e07513b870afc1b42"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c2e55481731b0e8c96f30f661e430aa884fbd354"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c6a315f0b14074ac89723f55b749a557dda0ae2b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eef95a2745cb91559bb03aa111c228fe38deaf64"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc1aeafdf6fb0a136c2257000f0d478ee62953fe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53290,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:38.200,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: samples/bpf: Fix fout leak in hbm's run_bpf_prog Fix fout being fopen'ed but then not subsequently fclose'd. In the affected branch, fout is otherwise going out of scope.",,,"[{""url"":""https://git.kernel.org/stable/c/23acb14af1914010dd0aae1bbb7fab28bf518b8e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7560ed6592ff4077528c239c71e91b19de985b97"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a7ec2f424f6edad34651137783a0a59eca9aa37e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3e6e252d74f20f6fc610c7fef3ae7dda0109a6f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/edf37bc8b03d3f948e679b2fd2d14464495f5d1b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f2065b8b0a215bc6aa061287a2e3d9eab2446422"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53291,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:38.313,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: rcu/rcuscale: Stop kfree_scale_thread thread(s) after unloading rcuscale Running the 'kfree_rcu_test' test case [1] results in a splat [2]. The root cause is the kfree_scale_thread thread(s) continue running after unloading the rcuscale module. This commit fixes that isue by invoking kfree_scale_cleanup() from rcu_scale_cleanup() when removing the rcuscale module. [1] modprobe rcuscale kfree_rcu_test=1 // After some time rmmod rcuscale rmmod torture [2] BUG: unable to handle page fault for address: ffffffffc0601a87 #PF: supervisor instruction fetch in kernel mode #PF: error_code(0x0010) - not-present page PGD 11de4f067 P4D 11de4f067 PUD 11de51067 PMD 112f4d067 PTE 0 Oops: 0010 [#1] PREEMPT SMP NOPTI CPU: 1 PID: 1798 Comm: kfree_scale_thr Not tainted 6.3.0-rc1-rcu+ #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 0.0.0 02/06/2015 RIP: 0010:0xffffffffc0601a87 Code: Unable to access opcode bytes at 0xffffffffc0601a5d. RSP: 0018:ffffb25bc2e57e18 EFLAGS: 00010297 RAX: 0000000000000000 RBX: ffffffffc061f0b6 RCX: 0000000000000000 RDX: 0000000000000000 RSI: ffffffff962fd0de RDI: ffffffff962fd0de RBP: ffffb25bc2e57ea8 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000001 R11: 0000000000000001 R12: 0000000000000000 R13: 0000000000000000 R14: 000000000000000a R15: 00000000001c1dbe FS: 0000000000000000(0000) GS:ffff921fa2200000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: ffffffffc0601a5d CR3: 000000011de4c006 CR4: 0000000000370ee0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ? kvfree_call_rcu+0xf0/0x3a0 ? kthread+0xf3/0x120 ? kthread_complete_and_exit+0x20/0x20 ? ret_from_fork+0x1f/0x30 </TASK> Modules linked in: rfkill sunrpc ... [last unloaded: torture] CR2: ffffffffc0601a87 ---[ end trace 0000000000000000 ]---",,,"[{""url"":""https://git.kernel.org/stable/c/1dd7547c7610723b2b6afe1a3c4ddb2bde63387c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/23fc8df26dead16687ae6eb47b0561a4a832e2f6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/29b1da4f90fc42c91beb4e400d926194925ad31b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/604d6a5ff718874904b0fe614878a42b42c0d699"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b8a6ba524d41f4da102e65f90498d9a910839621"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f766d45ab294871a3d588ee76c666852f151cad9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53292,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:38.457,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: blk-mq: fix NULL dereference on q->elevator in blk_mq_elv_switch_none After grabbing q->sysfs_lock, q->elevator may become NULL because of elevator switch. Fix the NULL dereference on q->elevator by checking it with lock.",,,"[{""url"":""https://git.kernel.org/stable/c/245165658e1c9f95c0fecfe02b9b1ebd30a1198a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3e977386521b71471e66ec2ba82efdfcc456adf2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53293,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:38.573,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: btrtl: check for NULL in btrtl_set_quirks() The btrtl_set_quirks() has accessed btrtl_dev->ic_info->lmp_subver since b8e482d02513. However, if installing a Realtek Bluetooth controller without the driver supported, it will hit the NULL point accessed. Add a check for NULL to avoid the Kernel Oops.",,,"[{""url"":""https://git.kernel.org/stable/c/253cf30e8d3d001850a95c4729d668f916b037ab"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c34722f0bb9f7efb0e7e7a75a9cb57601132b51f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ea160ece08668a30ce69f92cc08e87da54a64a9c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53294,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:38.683,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: Fix null-ptr-deref on inode->i_op in ntfs_lookup() Syzbot reported a null-ptr-deref bug: ntfs3: loop0: Different NTFS' sector size (1024) and media sector size (512) ntfs3: loop0: Mark volume as dirty due to NTFS errors general protection fault, probably for non-canonical address 0xdffffc0000000001: 0000 [#1] PREEMPT SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f] RIP: 0010:d_flags_for_inode fs/dcache.c:1980 [inline] RIP: 0010:__d_add+0x5ce/0x800 fs/dcache.c:2796 Call Trace: <TASK> d_splice_alias+0x122/0x3b0 fs/dcache.c:3191 lookup_open fs/namei.c:3391 [inline] open_last_lookups fs/namei.c:3481 [inline] path_openat+0x10e6/0x2df0 fs/namei.c:3688 do_filp_open+0x264/0x4f0 fs/namei.c:3718 do_sys_openat2+0x124/0x4e0 fs/open.c:1310 do_sys_open fs/open.c:1326 [inline] __do_sys_open fs/open.c:1334 [inline] __se_sys_open fs/open.c:1330 [inline] __x64_sys_open+0x221/0x270 fs/open.c:1330 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd If the MFT record of ntfs inode is not a base record, inode->i_op can be NULL. And a null-ptr-deref may happen: ntfs_lookup() dir_search_u() # inode->i_op is set to NULL d_splice_alias() __d_add() d_flags_for_inode() # inode->i_op->get_link null-ptr-deref Fix this by adding a Check on inode->i_op before calling the d_splice_alias() function.",,,"[{""url"":""https://git.kernel.org/stable/c/254e69f284d7270e0abdc023ee53b71401c3ba0c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2ba22cbc6a1cf4b58195adbee0b80262e53992d3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d69d5e2a81df94534bdb468bcdd26060fcb7191a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e78240bc4b94fc42854d65e657bb998100cc8e1b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8d9e062a695a3665c4635c4f216a75912687598"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53295,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:38.810,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: udf: Do not update file length for failed writes to inline files When write to inline file fails (or happens only partly), we still updated length of inline data as if the whole write succeeded. Fix the update of length of inline data to happen only if the write succeeds.",,,"[{""url"":""https://git.kernel.org/stable/c/256fe4162f8b5a1625b8603ca5f7ff79725bfb47"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5621f7a8139053d0c3c47fb68ee9f602139eb40a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5a6c373d761f55635e175fa2f407544bae8f583b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6837910aeb2c9101fc036dcd1b1f32615c20ec1a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6d18cedc1ef0caeb1567cab660079e48844ff6d6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7bd8d9e1cf5607ee14407f4060b9a1dbb3c42802"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c5787d77a5c29fffd295d138bd118b334990a567"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb2133900cac2d2f78befd6be41666cf1a2315d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53296,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:38.937,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: sctp: check send stream number after wait_for_sndbuf This patch fixes a corner case where the asoc out stream count may change after wait_for_sndbuf. When the main thread in the client starts a connection, if its out stream count is set to N while the in stream count in the server is set to N - 2, another thread in the client keeps sending the msgs with stream number N - 1, and waits for sndbuf before processing INIT_ACK. However, after processing INIT_ACK, the out stream count in the client is shrunk to N - 2, the same to the in stream count in the server. The crash occurs when the thread waiting for sndbuf is awake and sends the msg in a non-existing stream(N - 1), the call trace is as below: KASAN: null-ptr-deref in range [0x0000000000000038-0x000000000000003f] Call Trace: <TASK> sctp_cmd_send_msg net/sctp/sm_sideeffect.c:1114 [inline] sctp_cmd_interpreter net/sctp/sm_sideeffect.c:1777 [inline] sctp_side_effects net/sctp/sm_sideeffect.c:1199 [inline] sctp_do_sm+0x197d/0x5310 net/sctp/sm_sideeffect.c:1170 sctp_primitive_SEND+0x9f/0xc0 net/sctp/primitive.c:163 sctp_sendmsg_to_asoc+0x10eb/0x1a30 net/sctp/socket.c:1868 sctp_sendmsg+0x8d4/0x1d90 net/sctp/socket.c:2026 inet_sendmsg+0x9d/0xe0 net/ipv4/af_inet.c:825 sock_sendmsg_nosec net/socket.c:722 [inline] sock_sendmsg+0xde/0x190 net/socket.c:745 The fix is to add an unlikely check for the send stream number after the thread wakes up from the wait_for_sndbuf.",,,"[{""url"":""https://git.kernel.org/stable/c/0443fff49d6352160c200064156c25898bd9f58c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2584024b23552c00d95b50255e47bd18d306d31a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/667eb99cf7c15fe5b0ecefe75cf658e20ef20c9f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9346a1a21142357972a6f466ba6275ddc54b04ac"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a615e7270318fa0b98bf1ff38daf6cf52d840312"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b4b6dfad41aaae9e36e44327b18d5cf4b20dd2ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d2128636b303aa9cf065055402ee6697409a8837"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53297,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:39.053,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: L2CAP: fix ""bad unlock balance"" in l2cap_disconnect_rsp conn->chan_lock isn't acquired before l2cap_get_chan_by_scid, if l2cap_get_chan_by_scid returns NULL, then 'bad unlock balance' is triggered.",,,"[{""url"":""https://git.kernel.org/stable/c/116b9c002c894097adc2b8684db2d1da4229ed46"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2112c4c47d36bc5aba3ddeb9afedce6ae6a67e7d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/25e97f7b1866e6b8503be349eeea44bb52d661ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5134556c9be582793f30695c09d18a26fe1ff2d7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/55410a9144c76ecda126e6cdec556dfcd8f343b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5f352a56f0e607e6ff539cbf12156bfd8af232be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6a27762340ad08643de3bc17fe1646ea489ca2e2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd269a0435f8e9943b7a57c5a59688848d42d449"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53298,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:39.167,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nfc: fix memory leak of se_io context in nfc_genl_se_io The callback context for sending/receiving APDUs to/from the selected secure element is allocated inside nfc_genl_se_io and supposed to be eventually freed in se_io_cb callback function. However, there are several error paths where the bwi_timer is not charged to call se_io_cb later, and the cb_context is leaked. The patch proposes to free the cb_context explicitly on those error paths. At the moment we can't simply check 'dev->ops->se_io()' return value as it may be negative in both cases: when the timer was charged and was not.",,,"[{""url"":""https://git.kernel.org/stable/c/25ff6f8a5a3b8dc48e8abda6f013e8cc4b14ffea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/271eed1736426103335c5aac50f15b0f4d236bc0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5321da6d84b87a34eea441677d649c34bd854169"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8978315cb4bf8878c9c8ec05dafd8f7ff539860d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/af452e35b9e6a87cd49e54a7a3d60d934b194651"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b2036a252381949d3b743a3de069324ae3028a57"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ba98db08895748c12e5ded52cd1598dce2c79e55"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c494365432dcdc549986f4d9af9eb6190cbdb153"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53299,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:39.283,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: md/raid10: fix leak of 'r10bio->remaining' for recovery raid10_sync_request() will add 'r10bio->remaining' for both rdev and replacement rdev. However, if the read io fails, recovery_request_write() returns without issuing the write io, in this case, end_sync_request() is only called once and 'remaining' is leaked, cause an io hang. Fix the problem by decreasing 'remaining' according to if 'bio' and 'repl_bio' is valid.",,,"[{""url"":""https://git.kernel.org/stable/c/11141630f03efffdfe260b3582b2d93d38171b97"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1697fb124c6d6c5237e9cbd78890310154738084"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1d2c6c6e37fe5de11fd01a82badf03390e12df7a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/26208a7cffd0c7cbf14237ccd20c7270b3ffeb7e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3481dec5ecbbbbe44ab23e22c2b14bd65c644ec6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4f82e7e07cdaf2947d71968e3d6b73370a217093"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c5d5d7ffd1e76734811b8ea5417cf0432b9952c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8d09065802c53cc938d162b62f6c4150b392c90e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cb827ed2bb34480dc102146d3a1f89fdbcafc028"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53300,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:39.397,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: media: hi846: Fix memleak in hi846_init_controls() hi846_init_controls doesn't clean the allocated ctrl_hdlr in case there is a failure, which causes memleak. Add v4l2_ctrl_handler_free to free the resource properly.",,,"[{""url"":""https://git.kernel.org/stable/c/07f0f15e5db60c5b0722049d3251ef4a46dc3b76"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/12a80b1490e398f5ad7157508cf32b73511de5fc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2649c1a20e8e399ee955d0e22192f9992662c3d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd22e8c8c38fb40f130d3a60e52c59996a5bbae9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53301,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:39.517,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: f2fs: fix kernel crash due to null io->bio We should return when io->bio is null before doing anything. Otherwise, panic. BUG: kernel NULL pointer dereference, address: 0000000000000010 RIP: 0010:__submit_merged_write_cond+0x164/0x240 [f2fs] Call Trace: <TASK> f2fs_submit_merged_write+0x1d/0x30 [f2fs] commit_checkpoint+0x110/0x1e0 [f2fs] f2fs_write_checkpoint+0x9f7/0xf00 [f2fs] ? __pfx_issue_checkpoint_thread+0x10/0x10 [f2fs] __checkpoint_and_complete_reqs+0x84/0x190 [f2fs] ? preempt_count_add+0x82/0xc0 ? __pfx_issue_checkpoint_thread+0x10/0x10 [f2fs] issue_checkpoint_thread+0x4c/0xf0 [f2fs] ? __pfx_autoremove_wake_function+0x10/0x10 kthread+0xff/0x130 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x2c/0x50 </TASK>",,,"[{""url"":""https://git.kernel.org/stable/c/267c159f9c7bcb7009dae16889b880c5ed8759a8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/83dbb9a1bd5ef2eea73275906fc50b2fdda39cd5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/eb52f13c6093ac761dbeaa459c810fc0253209fc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53302,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:39.627,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: iwl4965: Add missing check for create_singlethread_workqueue() Add the check for the return value of the create_singlethread_workqueue() in order to avoid NULL pointer dereference.",,,"[{""url"":""https://git.kernel.org/stable/c/26e6775f75517ad6844fe5b79bc5f3fa8c22ee61"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2f85c768bea2057e3299d19514da9e932c4f92d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3185d6cfc59277a77bf311dce701b7e25193f66a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/874a85051cc8df8c5b928d8ff172b342cdc5424b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/878a7c8357764e08bc778bcb26127fc12a4b36b7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c002d2741400771171b68dde9af937a4dfa0d1b3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f15ef0ebcf56be1d4a3c9a7a80a1f1f82ab0eaad"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53303,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T08:15:39.737,2025-09-16T12:49:16.060,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: microchip: vcap api: Fix possible memory leak for vcap_dup_rule() Inject fault When select CONFIG_VCAP_KUNIT_TEST, the below memory leak occurs. If kzalloc() for duprule succeeds, but the following kmemdup() fails, the duprule, ckf and caf memory will be leaked. So kfree them in the error path. unreferenced object 0xffff122744c50600 (size 192): comm ""kunit_try_catch"", pid 346, jiffies 4294896122 (age 911.812s) hex dump (first 32 bytes): 10 27 00 00 04 00 00 00 1e 00 00 00 2c 01 00 00 .'..........,... 00 00 00 00 00 00 00 00 18 06 c5 44 27 12 ff ff ...........D'... backtrace: [<00000000394b0db8>] __kmem_cache_alloc_node+0x274/0x2f8 [<0000000001bedc67>] kmalloc_trace+0x38/0x88 [<00000000b0612f98>] vcap_dup_rule+0x50/0x460 [<000000005d2d3aca>] vcap_add_rule+0x8cc/0x1038 [<00000000eef9d0f8>] test_vcap_xn_rule_creator.constprop.0.isra.0+0x238/0x494 [<00000000cbda607b>] vcap_api_rule_remove_in_front_test+0x1ac/0x698 [<00000000c8766299>] kunit_try_run_case+0xe0/0x20c [<00000000c4fe9186>] kunit_generic_run_threadfn_adapter+0x50/0x94 [<00000000f6864acf>] kthread+0x2e8/0x374 [<0000000022e639b3>] ret_from_fork+0x10/0x20",,,"[{""url"":""https://git.kernel.org/stable/c/281f65d29d6da1a9b6907fb0b145aaf34f4e4822"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a26ba60413b2c8f95daf0ee0152cf82abd7bfbe4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53304,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:35.240,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: nft_set_rbtree: fix overlap expiration walk The lazy gc on insert that should remove timed-out entries fails to release the other half of the interval, if any. Can be reproduced with tests/shell/testcases/sets/0044interval_overlap_0 in nftables.git and kmemleak enabled kernel. Second bug is the use of rbe_prev vs. prev pointer. If rbe_prev() returns NULL after at least one iteration, rbe_prev points to element that is not an end interval, hence it should not be removed. Lastly, check the genmask of the end interval if this is active in the current generation.",,,"[{""url"":""https://git.kernel.org/stable/c/50cbb9d195c197af671869c8cadce3bd483735a0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8284a79136c384059e85e278da2210b809730287"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/893cb3c3513cf661a0ff45fe0cfa83fe27131f76"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/89a4d1a89751a0fbd520e64091873e19cc0979e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/acaee227cf79c45a5d2d49c3e9a66333a462802c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cd66733932399475fe933cb3ec03e687ed401462"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f718863aca469a109895cb855e6b81fff4827d71"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53305,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:36.260,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: Bluetooth: L2CAP: Fix use-after-free Fix potential use-after-free in l2cap_le_command_rej.",,,"[{""url"":""https://git.kernel.org/stable/c/149daab45922ab1ac7f0cbeacab7251a46bf5e63"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1a40c56e8bff3e424724d78a9a6b3272dd8a371d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/255be68150291440657b2cdb09420b69441af3d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2958cf9f805b9f0bdc4a761bf6ea281eb8d44f8e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/548a6b64b3c0688f01119a6fcccceb41f8c984e4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e76bab1b7afa580cd76362540fc37551ada4359b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f752a0b334bb95fe9b42ecb511e0864e2768046f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe49aa73cca6608714477b74bfc6874b9db979df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53306,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:36.370,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fsdax: force clear dirty mark if CoW XFS allows CoW on non-shared extents to combat fragmentation[1]. The old non-shared extent could be mwrited before, its dax entry is marked dirty. This results in a WARNing: [ 28.512349] ------------[ cut here ]------------ [ 28.512622] WARNING: CPU: 2 PID: 5255 at fs/dax.c:390 dax_insert_entry+0x342/0x390 [ 28.513050] Modules linked in: rpcsec_gss_krb5 auth_rpcgss nfsv4 nfs lockd grace fscache netfs nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables [ 28.515462] CPU: 2 PID: 5255 Comm: fsstress Kdump: loaded Not tainted 6.3.0-rc1-00001-g85e1481e19c1-dirty #117 [ 28.515902] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS Arch Linux 1.16.1-1-1 04/01/2014 [ 28.516307] RIP: 0010:dax_insert_entry+0x342/0x390 [ 28.516536] Code: 30 5b 5d 41 5c 41 5d 41 5e 41 5f c3 cc cc cc cc 48 8b 45 20 48 83 c0 01 e9 e2 fe ff ff 48 8b 45 20 48 83 c0 01 e9 cd fe ff ff <0f> 0b e9 53 ff ff ff 48 8b 7c 24 08 31 f6 e8 1b 61 a1 00 eb 8c 48 [ 28.517417] RSP: 0000:ffffc9000845fb18 EFLAGS: 00010086 [ 28.517721] RAX: 0000000000000053 RBX: 0000000000000155 RCX: 000000000018824b [ 28.518113] RDX: 0000000000000000 RSI: ffffffff827525a6 RDI: 00000000ffffffff [ 28.518515] RBP: ffffea00062092c0 R08: 0000000000000000 R09: ffffc9000845f9c8 [ 28.518905] R10: 0000000000000003 R11: ffffffff82ddb7e8 R12: 0000000000000155 [ 28.519301] R13: 0000000000000000 R14: 000000000018824b R15: ffff88810cfa76b8 [ 28.519703] FS: 00007f14a0c94740(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000 [ 28.520148] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 28.520472] CR2: 00007f14a0c8d000 CR3: 000000010321c004 CR4: 0000000000770ee0 [ 28.520863] PKRU: 55555554 [ 28.521043] Call Trace: [ 28.521219] <TASK> [ 28.521368] dax_fault_iter+0x196/0x390 [ 28.521595] dax_iomap_pte_fault+0x19b/0x3d0 [ 28.521852] __xfs_filemap_fault+0x234/0x2b0 [ 28.522116] __do_fault+0x30/0x130 [ 28.522334] do_fault+0x193/0x340 [ 28.522586] __handle_mm_fault+0x2d3/0x690 [ 28.522975] handle_mm_fault+0xe6/0x2c0 [ 28.523259] do_user_addr_fault+0x1bc/0x6f0 [ 28.523521] exc_page_fault+0x60/0x140 [ 28.523763] asm_exc_page_fault+0x22/0x30 [ 28.524001] RIP: 0033:0x7f14a0b589ca [ 28.524225] Code: c5 fe 7f 07 c5 fe 7f 47 20 c5 fe 7f 47 40 c5 fe 7f 47 60 c5 f8 77 c3 66 0f 1f 84 00 00 00 00 00 40 0f b6 c6 48 89 d1 48 89 fa <f3> aa 48 89 d0 c5 f8 77 c3 66 66 2e 0f 1f 84 00 00 00 00 00 66 90 [ 28.525198] RSP: 002b:00007fff1dea1c98 EFLAGS: 00010202 [ 28.525505] RAX: 000000000000001e RBX: 000000000014a000 RCX: 0000000000006046 [ 28.525895] RDX: 00007f14a0c82000 RSI: 000000000000001e RDI: 00007f14a0c8d000 [ 28.526290] RBP: 000000000000006f R08: 0000000000000004 R09: 000000000014a000 [ 28.526681] R10: 0000000000000008 R11: 0000000000000246 R12: 028f5c28f5c28f5c [ 28.527067] R13: 8f5c28f5c28f5c29 R14: 0000000000011046 R15: 00007f14a0c946c0 [ 28.527449] </TASK> [ 28.527600] ---[ end trace 0000000000000000 ]--- To be able to delete this entry, clear its dirty mark before invalidate_inode_pages2_range(). [1] https://lore.kernel.org/linux-xfs/20230321151339.GA11376@frogsfrogsfrogs/",,,"[{""url"":""https://git.kernel.org/stable/c/f76b3a32879de215ced3f8c754c4077b0c2f79e3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fac05f800abb63dc4d7cc48fe7edf16e0520dc1f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53307,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:36.477,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: rbd: avoid use-after-free in do_rbd_add() when rbd_dev_create() fails If getting an ID or setting up a work queue in rbd_dev_create() fails, use-after-free on rbd_dev->rbd_client, rbd_dev->spec and rbd_dev->opts is triggered in do_rbd_add(). The root cause is that the ownership of these structures is transfered to rbd_dev prematurely and they all end up getting freed when rbd_dev_create() calls rbd_dev_free() prior to returning to do_rbd_add(). Found by Linux Verification Center (linuxtesting.org) with SVACE, an incomplete patch submitted by Natalia Petrova <n.petrova@fintech.ru>.",,,"[{""url"":""https://git.kernel.org/stable/c/71da2a151ed1adb0aea4252b16d81b53012e7afd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9787b328c42c13c4f31e7d5042c4e877e9344068"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a73783e4e0c4d1507794da211eeca75498544dff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ae16346078b1189aee934afd872d9f3d0a682c33"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc8c0dd2984503ed09efa37bcafcef3d3da104e8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3cbb4d60764295992c95344f2d779439e8b34ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f7c4d9b133c7a04ca619355574e96b6abf209fba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/faa7b683e436664fff5648426950718277831348"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53308,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:36.597,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: fec: Better handle pm_runtime_get() failing in .remove() In the (unlikely) event that pm_runtime_get() (disguised as pm_runtime_resume_and_get()) fails, the remove callback returned an error early. The problem with this is that the driver core ignores the error value and continues removing the device. This results in a resource leak. Worse the devm allocated resources are freed and so if a callback of the driver is called later the register mapping is already gone which probably results in a crash.",,,"[{""url"":""https://git.kernel.org/stable/c/83996d317b1deddc85006376082e8886f55aa709"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9407454a9b18bbeff216e8ecde87ffb2171e9ccf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b22b514209ff8c4287abb853399890ab97e1b5ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be85912c36ddca3e8b2eef1b5392cd8db6bdb730"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c1bc2870f14e526a01897e14c747a0a0ca125231"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d52a0cca591e899d4e5c8ab19e067b4c6b7d104f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e02d8d5b1602689b98d9b91550a11b9b57baedbe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f816b9829b19394d318e01953aa3b2721bca040d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53309,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:36.720,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/radeon: Fix integer overflow in radeon_cs_parser_init The type of size is unsigned, if size is 0x40000000, there will be an integer overflow, size will be zero after size *= sizeof(uint32_t), will cause uninitialized memory to be referenced later",,,"[{""url"":""https://git.kernel.org/stable/c/25e634d7f44eb13113139040e5366bebe48c882f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2e1be420b86980c25a75325e90dfc3fc73126f61"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b8fab6aebdf2115ec2d7bd2f3498d5b911ff351e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c0d7dbc6b7a61a56028118c00af2c8319d44a682"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cfa9148bafb2d3292b65de1bac79dcca65be2643"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d05ba46134d07e889de7d23cf8503574a22ede09"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e6825b30d37fe89ceb87f926d33d4fad321a331e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f828b681d0cd566f86351c0b913e6cb6ed8c7b9c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53310,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:36.847,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: power: supply: axp288_fuel_gauge: Fix external_power_changed race fuel_gauge_external_power_changed() dereferences info->bat, which gets sets in axp288_fuel_gauge_probe() like this: info->bat = devm_power_supply_register(dev, &fuel_gauge_desc, &psy_cfg); As soon as devm_power_supply_register() has called device_add() the external_power_changed callback can get called. So there is a window where fuel_gauge_external_power_changed() may get called while info->bat has not been set yet leading to a NULL pointer dereference. Fixing this is easy. The external_power_changed callback gets passed the power_supply which will eventually get stored in info->bat, so fuel_gauge_external_power_changed() can simply directly use the passed in psy argument which is always valid.",,,"[{""url"":""https://git.kernel.org/stable/c/0456b912121e45b3ef54abe3135e5dcb541f956c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a636c6ba9ce898207f283271cb28511206ab739b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8319774d6f1567d6e7d03653174ab0c82c5c66d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53311,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:36.967,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: nilfs2: fix use-after-free of nilfs_root in dirtying inodes via iput During unmount process of nilfs2, nothing holds nilfs_root structure after nilfs2 detaches its writer in nilfs_detach_log_writer(). Previously, nilfs_evict_inode() could cause use-after-free read for nilfs_root if inodes are left in ""garbage_list"" and released by nilfs_dispose_list at the end of nilfs_detach_log_writer(), and this bug was fixed by commit 9b5a04ac3ad9 (""nilfs2: fix use-after-free bug of nilfs_root in nilfs_evict_inode()""). However, it turned out that there is another possibility of UAF in the call path where mark_inode_dirty_sync() is called from iput(): nilfs_detach_log_writer() nilfs_dispose_list() iput() mark_inode_dirty_sync() __mark_inode_dirty() nilfs_dirty_inode() __nilfs_mark_inode_dirty() nilfs_load_inode_block() --> causes UAF of nilfs_root struct This can happen after commit 0ae45f63d4ef (""vfs: add support for a lazytime mount option""), which changed iput() to call mark_inode_dirty_sync() on its final reference if i_state has I_DIRTY_TIME flag and i_nlink is non-zero. This issue appears after commit 28a65b49eb53 (""nilfs2: do not write dirty data after degenerating to read-only"") when using the syzbot reproducer, but the issue has potentially existed before. Fix this issue by adding a ""purging flag"" to the nilfs structure, setting that flag while disposing the ""garbage_list"" and checking it in __nilfs_mark_inode_dirty(). Unlike commit 9b5a04ac3ad9 (""nilfs2: fix use-after-free bug of nilfs_root in nilfs_evict_inode()""), this patch does not rely on ns_writer to determine whether to skip operations, so as not to break recovery on mount. The nilfs_salvage_orphan_logs routine dirties the buffer of salvaged data before attaching the log writer, so changing __nilfs_mark_inode_dirty() to skip the operation when ns_writer is NULL will cause recovery write to fail. The purpose of using the cleanup-only flag is to allow for narrowing of such conditions.",,,"[{""url"":""https://git.kernel.org/stable/c/11afd67f1b3c28eb216e50a3ca8dbcb69bb71793"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3645510cf926e6af2f4d44899370d7e5331c93bd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/37207240872456fbab44a110bde6640445233963"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5828d5f5dc877dcfdd7b23102e978e2ecfd86d82"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7532ff6edbf5242376b24a95a2fefb59bb653e5a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a3c3b4cbf9b8554120fb230e6516e980c6277487"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d2c539c216cce74837a9cf5804eb205939b82227"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8654743a0e6909dc634cbfad6db6816f10f3399"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53312,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:37.117,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: net: fix net_dev_start_xmit trace event vs skb_transport_offset() After blamed commit, we must be more careful about using skb_transport_offset(), as reminded us by syzbot: WARNING: CPU: 0 PID: 10 at include/linux/skbuff.h:2868 skb_transport_offset include/linux/skbuff.h:2977 [inline] WARNING: CPU: 0 PID: 10 at include/linux/skbuff.h:2868 perf_trace_net_dev_start_xmit+0x89a/0xce0 include/trace/events/net.h:14 Modules linked in: CPU: 0 PID: 10 Comm: kworker/u4:1 Not tainted 6.1.30-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/27/2023 Workqueue: bat_events batadv_iv_send_outstanding_bat_ogm_packet RIP: 0010:skb_transport_header include/linux/skbuff.h:2868 [inline] RIP: 0010:skb_transport_offset include/linux/skbuff.h:2977 [inline] RIP: 0010:perf_trace_net_dev_start_xmit+0x89a/0xce0 include/trace/events/net.h:14 Code: 8b 04 25 28 00 00 00 48 3b 84 24 c0 00 00 00 0f 85 4e 04 00 00 48 8d 65 d8 5b 41 5c 41 5d 41 5e 41 5f 5d c3 cc e8 56 22 01 fd <0f> 0b e9 f6 fc ff ff 89 f9 80 e1 07 80 c1 03 38 c1 0f 8c 86 f9 ff RSP: 0018:ffffc900002bf700 EFLAGS: 00010293 RAX: ffffffff8485d8ca RBX: 000000000000ffff RCX: ffff888100914280 RDX: 0000000000000000 RSI: 000000000000ffff RDI: 000000000000ffff RBP: ffffc900002bf818 R08: ffffffff8485d5b6 R09: fffffbfff0f8fb5e R10: 0000000000000000 R11: dffffc0000000001 R12: 1ffff110217d8f67 R13: ffff88810bec7b3a R14: dffffc0000000000 R15: dffffc0000000000 FS: 0000000000000000(0000) GS:ffff8881f6a00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f96cf6d52f0 CR3: 000000012224c000 CR4: 0000000000350ef0 Call Trace: <TASK> [<ffffffff84715e35>] trace_net_dev_start_xmit include/trace/events/net.h:14 [inline] [<ffffffff84715e35>] xmit_one net/core/dev.c:3643 [inline] [<ffffffff84715e35>] dev_hard_start_xmit+0x705/0x980 net/core/dev.c:3660 [<ffffffff8471a232>] __dev_queue_xmit+0x16b2/0x3370 net/core/dev.c:4324 [<ffffffff85416493>] dev_queue_xmit include/linux/netdevice.h:3030 [inline] [<ffffffff85416493>] batadv_send_skb_packet+0x3f3/0x680 net/batman-adv/send.c:108 [<ffffffff85416744>] batadv_send_broadcast_skb+0x24/0x30 net/batman-adv/send.c:127 [<ffffffff853bc52a>] batadv_iv_ogm_send_to_if net/batman-adv/bat_iv_ogm.c:393 [inline] [<ffffffff853bc52a>] batadv_iv_ogm_emit net/batman-adv/bat_iv_ogm.c:421 [inline] [<ffffffff853bc52a>] batadv_iv_send_outstanding_bat_ogm_packet+0x69a/0x840 net/batman-adv/bat_iv_ogm.c:1701 [<ffffffff8151023c>] process_one_work+0x8ac/0x1170 kernel/workqueue.c:2289 [<ffffffff81511938>] worker_thread+0xaa8/0x12d0 kernel/workqueue.c:2436",,,"[{""url"":""https://git.kernel.org/stable/c/58f9e88eb247263c74383b4ee8858abac15cdbe0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ced61418f46993d571385812bafed3a7d4ab6918"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f88fcb1d7d961b4b402d675109726f94db87571c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53313,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:37.233,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: md/raid10: fix wrong setting of max_corr_read_errors There is no input check when echo md/max_read_errors and overflow might occur. Add check of input number.",,,"[{""url"":""https://git.kernel.org/stable/c/025fde32fb957a5c271711bc66841f817ff5f299"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/05d10428e8dffed0bac2502f34151729fc189cd3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/31c805a44b7569ca1017a4714385182d98bba212"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3c76920e547d4b931bed758bad83fd658dd88b4e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74050a3fdd4aecfd2cbf74d3c145812ab2744375"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aef6e98eb772594edd4399625e4e1bbe45971fa1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b1d8f38310bce3282374983b229d94edbaf1e570"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e83cb411aa1c6c9617db9329897f4506ba9e9b9d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f8b20a405428803bd9881881d8242c9d72c6b2b2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53314,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:37.360,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fbdev/ep93xx-fb: Do not assign to struct fb_info.dev Do not assing the Linux device to struct fb_info.dev. The call to register_framebuffer() initializes the field to the fbdev device. Drivers should not override its value. Fixes a bug where the driver incorrectly decreases the hardware device's reference counter and leaks the fbdev device. v2: * add Fixes tag (Dan)",,,"[{""url"":""https://git.kernel.org/stable/c/0517fc5a71333b315164736bbd32608894fbb872"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1c6ff2a7c593db851f23e31ace2baf557ea9d0ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/309c27162afea79b3c7f8747bb650faf6923b639"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4aade6c9100a3537788b6a9c7ac481037d19efdf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ffa40ff64aa43a9a28fcf209b48d86a3e0f4972"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f83c1b13f8154e0284448912756d0a351a1a602a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f90a0e5265b60cdd3c77990e8105f79aa2fac994"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ffdf2b020db717853167391a3a8d912e13428fa6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53315,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:37.480,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: ath11k: Fix SKB corruption in REO destination ring While running traffics for a long time, randomly an RX descriptor filled with value ""0"" from REO destination ring is received. This descriptor which is invalid causes the wrong SKB (SKB stored in the IDR lookup with buffer id ""0"") to be fetched which in turn causes SKB memory corruption issue and the same leads to crash after some time. Changed the start id for idr allocation to ""1"" and the buffer id ""0"" is reserved for error validation. Introduced Sanity check to validate the descriptor, before processing the SKB. Crash Signature : Unable to handle kernel paging request at virtual address 3f004900 PC points to ""b15_dma_inv_range+0x30/0x50"" LR points to ""dma_cache_maint_page+0x8c/0x128"". The Backtrace obtained is as follows: [<8031716c>] (b15_dma_inv_range) from [<80313a4c>] (dma_cache_maint_page+0x8c/0x128) [<80313a4c>] (dma_cache_maint_page) from [<80313b90>] (__dma_page_dev_to_cpu+0x28/0xcc) [<80313b90>] (__dma_page_dev_to_cpu) from [<7fb5dd68>] (ath11k_dp_process_rx+0x1e8/0x4a4 [ath11k]) [<7fb5dd68>] (ath11k_dp_process_rx [ath11k]) from [<7fb53c20>] (ath11k_dp_service_srng+0xb0/0x2ac [ath11k]) [<7fb53c20>] (ath11k_dp_service_srng [ath11k]) from [<7f67bba4>] (ath11k_pci_ext_grp_napi_poll+0x1c/0x78 [ath11k_pci]) [<7f67bba4>] (ath11k_pci_ext_grp_napi_poll [ath11k_pci]) from [<807d5cf4>] (__napi_poll+0x28/0xb8) [<807d5cf4>] (__napi_poll) from [<807d5f28>] (net_rx_action+0xf0/0x280) [<807d5f28>] (net_rx_action) from [<80302148>] (__do_softirq+0xd0/0x280) [<80302148>] (__do_softirq) from [<80320408>] (irq_exit+0x74/0xd4) [<80320408>] (irq_exit) from [<803638a4>] (__handle_domain_irq+0x90/0xb4) [<803638a4>] (__handle_domain_irq) from [<805bedec>] (gic_handle_irq+0x58/0x90) [<805bedec>] (gic_handle_irq) from [<80301a78>] (__irq_svc+0x58/0x8c) Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1",,,"[{""url"":""https://git.kernel.org/stable/c/068fd06148fbf0af95bb08dc77cff34ee679fdbc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3d3f8fe01a01d94a17fe1ae0d2e894049a972717"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/67459491f78146bcf7d93596e5b709d063dff5d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/866921dc06b94df91acfcf9359b57da943ed99b3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f9fff67d2d7ca6fa8066132003a3deef654c55b1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53316,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:37.600,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/msm/dp: Free resources after unregistering them The DP component's unbind operation walks through the submodules to unregister and clean things up. But if the unbind happens because the DP controller itself is being removed, all the memory for those submodules has just been freed. Change the order of these operations to avoid the many use-after-free that otherwise happens in this code path. Patchwork: https://patchwork.freedesktop.org/patch/542166/",,,"[{""url"":""https://git.kernel.org/stable/c/3c3f3d35f5e05c468b048eb42a4f8c62c6655692"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4e9f1a2367aea7d61f6781213e25313cd983b0d7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5c3278db06e332fdc14f3f297499fb88ded264d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c67a55f7cc8d767d624235bf1bcd0947e56abe0f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ca47d0dc00968358c136a1847cfed550cedfd1b5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa0048a4b1fa7a50c8b0e514f5b428abdf69a6f8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53317,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:37.713,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext4: fix WARNING in mb_find_extent Syzbot found the following issue: EXT4-fs: Warning: mounting with data=journal disables delayed allocation, dioread_nolock, O_DIRECT and fast_commit support! EXT4-fs (loop0): orphan cleanup on readonly fs ------------[ cut here ]------------ WARNING: CPU: 1 PID: 5067 at fs/ext4/mballoc.c:1869 mb_find_extent+0x8a1/0xe30 Modules linked in: CPU: 1 PID: 5067 Comm: syz-executor307 Not tainted 6.2.0-rc1-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022 RIP: 0010:mb_find_extent+0x8a1/0xe30 fs/ext4/mballoc.c:1869 RSP: 0018:ffffc90003c9e098 EFLAGS: 00010293 RAX: ffffffff82405731 RBX: 0000000000000041 RCX: ffff8880783457c0 RDX: 0000000000000000 RSI: 0000000000000041 RDI: 0000000000000040 RBP: 0000000000000040 R08: ffffffff82405723 R09: ffffed10053c9402 R10: ffffed10053c9402 R11: 1ffff110053c9401 R12: 0000000000000000 R13: ffffc90003c9e538 R14: dffffc0000000000 R15: ffffc90003c9e2cc FS: 0000555556665300(0000) GS:ffff8880b9900000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000056312f6796f8 CR3: 0000000022437000 CR4: 00000000003506e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ext4_mb_complex_scan_group+0x353/0x1100 fs/ext4/mballoc.c:2307 ext4_mb_regular_allocator+0x1533/0x3860 fs/ext4/mballoc.c:2735 ext4_mb_new_blocks+0xddf/0x3db0 fs/ext4/mballoc.c:5605 ext4_ext_map_blocks+0x1868/0x6880 fs/ext4/extents.c:4286 ext4_map_blocks+0xa49/0x1cc0 fs/ext4/inode.c:651 ext4_getblk+0x1b9/0x770 fs/ext4/inode.c:864 ext4_bread+0x2a/0x170 fs/ext4/inode.c:920 ext4_quota_write+0x225/0x570 fs/ext4/super.c:7105 write_blk fs/quota/quota_tree.c:64 [inline] get_free_dqblk+0x34a/0x6d0 fs/quota/quota_tree.c:130 do_insert_tree+0x26b/0x1aa0 fs/quota/quota_tree.c:340 do_insert_tree+0x722/0x1aa0 fs/quota/quota_tree.c:375 do_insert_tree+0x722/0x1aa0 fs/quota/quota_tree.c:375 do_insert_tree+0x722/0x1aa0 fs/quota/quota_tree.c:375 dq_insert_tree fs/quota/quota_tree.c:401 [inline] qtree_write_dquot+0x3b6/0x530 fs/quota/quota_tree.c:420 v2_write_dquot+0x11b/0x190 fs/quota/quota_v2.c:358 dquot_acquire+0x348/0x670 fs/quota/dquot.c:444 ext4_acquire_dquot+0x2dc/0x400 fs/ext4/super.c:6740 dqget+0x999/0xdc0 fs/quota/dquot.c:914 __dquot_initialize+0x3d0/0xcf0 fs/quota/dquot.c:1492 ext4_process_orphan+0x57/0x2d0 fs/ext4/orphan.c:329 ext4_orphan_cleanup+0xb60/0x1340 fs/ext4/orphan.c:474 __ext4_fill_super fs/ext4/super.c:5516 [inline] ext4_fill_super+0x81cd/0x8700 fs/ext4/super.c:5644 get_tree_bdev+0x400/0x620 fs/super.c:1282 vfs_get_tree+0x88/0x270 fs/super.c:1489 do_new_mount+0x289/0xad0 fs/namespace.c:3145 do_mount fs/namespace.c:3488 [inline] __do_sys_mount fs/namespace.c:3697 [inline] __se_sys_mount+0x2d3/0x3c0 fs/namespace.c:3674 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd Add some debug information: mb_find_extent: mb_find_extent block=41, order=0 needed=64 next=0 ex=0/41/1@3735929054 64 64 7 block_bitmap: ff 3f 0c 00 fc 01 00 00 d2 3d 00 00 00 00 00 00 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff Acctually, blocks per group is 64, but block bitmap indicate at least has 128 blocks. Now, ext4_validate_block_bitmap() didn't check invalid block's bitmap if set. To resolve above issue, add check like fsck ""Padding at end of block bitmap is not set"".",,,"[{""url"":""https://git.kernel.org/stable/c/1b90fbc7590124c57a2e590de7fd07eba26606f1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5d356d902e9d5b1aaaaf2326d365340fa8a90c1b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/775b00ba23f6f916fe2ac60c5ff7fd0fe4f28d0d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d55e76e11592a1d18a179c7fd34ca1b52632beb3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dba62fa84a8eac44a53a2862de8a40e5bdfa0ae3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dd45e536f47a82e0a405f9a4b6c7ceb367171ee9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e4d503c956a744cb59e509ca5f134cfad423c7a3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa08a7b61dff8a4df11ff1e84abfc214b487caf7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53318,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:37.833,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: recordmcount: Fix memory leaks in the uwrite function Common realloc mistake: 'file_append' nulled but not freed upon failure",,,"[{""url"":""https://git.kernel.org/stable/c/25c9b185f121812cbc215fdaa1192c6b9025b428"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2d9ca5f62f2ba160ff9c9be4adf401c46c04edef"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ed95a6f6c646e8bb15c354536e0ab10e8f39c08"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/444ec005404cead222ebce2561a9451c9ee5ad89"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/895130e63c93926f07caf5db286b97bd27b81de9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd39f68a309a947670379bf9a39b16c584f86ddb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa359d068574d29e7d2f0fdd0ebe4c6a12b5cfb9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff70ad9159fbb566b2c15724f44207e8deccd527"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53319,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:37.947,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: KVM: arm64: Handle kvm_arm_init failure correctly in finalize_pkvm Currently there is no synchronisation between finalize_pkvm() and kvm_arm_init() initcalls. The finalize_pkvm() proceeds happily even if kvm_arm_init() fails resulting in the following warning on all the CPUs and eventually a HYP panic: | kvm [1]: IPA Size Limit: 48 bits | kvm [1]: Failed to init hyp memory protection | kvm [1]: error initializing Hyp mode: -22 | | <snip> | | WARNING: CPU: 0 PID: 0 at arch/arm64/kvm/pkvm.c:226 _kvm_host_prot_finalize+0x30/0x50 | Modules linked in: | CPU: 0 PID: 0 Comm: swapper/0 Not tainted 6.4.0 #237 | Hardware name: FVP Base RevC (DT) | pstate: 634020c5 (nZCv daIF +PAN -UAO +TCO +DIT -SSBS BTYPE=--) | pc : _kvm_host_prot_finalize+0x30/0x50 | lr : __flush_smp_call_function_queue+0xd8/0x230 | | Call trace: | _kvm_host_prot_finalize+0x3c/0x50 | on_each_cpu_cond_mask+0x3c/0x6c | pkvm_drop_host_privileges+0x4c/0x78 | finalize_pkvm+0x3c/0x5c | do_one_initcall+0xcc/0x240 | do_initcall_level+0x8c/0xac | do_initcalls+0x54/0x94 | do_basic_setup+0x1c/0x28 | kernel_init_freeable+0x100/0x16c | kernel_init+0x20/0x1a0 | ret_from_fork+0x10/0x20 | Failed to finalize Hyp protection: -22 | dtb=fvp-base-revc.dtb | kvm [95]: nVHE hyp BUG at: arch/arm64/kvm/hyp/nvhe/mem_protect.c:540! | kvm [95]: nVHE call trace: | kvm [95]: [<ffff800081052984>] __kvm_nvhe_hyp_panic+0xac/0xf8 | kvm [95]: [<ffff800081059644>] __kvm_nvhe_handle_host_mem_abort+0x1a0/0x2ac | kvm [95]: [<ffff80008105511c>] __kvm_nvhe_handle_trap+0x4c/0x160 | kvm [95]: [<ffff8000810540fc>] __kvm_nvhe___skip_pauth_save+0x4/0x4 | kvm [95]: ---[ end nVHE call trace ]--- | kvm [95]: Hyp Offset: 0xfffe8db00ffa0000 | Kernel panic - not syncing: HYP panic: | PS:a34023c9 PC:0000f250710b973c ESR:00000000f2000800 | FAR:ffff000800cb00d0 HPFAR:000000000880cb00 PAR:0000000000000000 | VCPU:0000000000000000 | CPU: 3 PID: 95 Comm: kworker/u16:2 Tainted: G W 6.4.0 #237 | Hardware name: FVP Base RevC (DT) | Workqueue: rpciod rpc_async_schedule | Call trace: | dump_backtrace+0xec/0x108 | show_stack+0x18/0x2c | dump_stack_lvl+0x50/0x68 | dump_stack+0x18/0x24 | panic+0x138/0x33c | nvhe_hyp_panic_handler+0x100/0x184 | new_slab+0x23c/0x54c | ___slab_alloc+0x3e4/0x770 | kmem_cache_alloc_node+0x1f0/0x278 | __alloc_skb+0xdc/0x294 | tcp_stream_alloc_skb+0x2c/0xf0 | tcp_sendmsg_locked+0x3d0/0xda4 | tcp_sendmsg+0x38/0x5c | inet_sendmsg+0x44/0x60 | sock_sendmsg+0x1c/0x34 | xprt_sock_sendmsg+0xdc/0x274 | xs_tcp_send_request+0x1ac/0x28c | xprt_transmit+0xcc/0x300 | call_transmit+0x78/0x90 | __rpc_execute+0x114/0x3d8 | rpc_async_schedule+0x28/0x48 | process_one_work+0x1d8/0x314 | worker_thread+0x248/0x474 | kthread+0xfc/0x184 | ret_from_fork+0x10/0x20 | SMP: stopping secondary CPUs | Kernel Offset: 0x57c5cb460000 from 0xffff800080000000 | PHYS_OFFSET: 0x80000000 | CPU features: 0x00000000,1035b7a3,ccfe773f | Memory Limit: none | ---[ end Kernel panic - not syncing: HYP panic: | PS:a34023c9 PC:0000f250710b973c ESR:00000000f2000800 | FAR:ffff000800cb00d0 HPFAR:000000000880cb00 PAR:0000000000000000 | VCPU:0000000000000000 ]--- Fix it by checking for the successfull initialisation of kvm_arm_init() in finalize_pkvm() before proceeding any futher.",,,"[{""url"":""https://git.kernel.org/stable/c/91450dec0445f4d12f960ba68d8d05c3cb2ab5b8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fa729bc7c9c8c17a2481358c841ef8ca920485d3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53320,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:38.050,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: mpi3mr: Fix issues in mpi3mr_get_all_tgt_info() The function mpi3mr_get_all_tgt_info() has four issues: 1) It calculates valid entry length in alltgt_info assuming the header part of the struct mpi3mr_device_map_info would equal to sizeof(u32). The correct size is sizeof(u64). 2) When it calculates the valid entry length kern_entrylen, it excludes one entry by subtracting 1 from num_devices. 3) It copies num_device by calling memcpy(). Substitution is enough. 4) It does not specify the calculated length to sg_copy_from_buffer(). Instead, it specifies the payload length which is larger than the alltgt_info size. It causes ""BUG: KASAN: slab-out-of-bounds"". Fix the issues by using the correct header size, removing the subtraction from num_devices, replacing the memcpy() with substitution and specifying the correct length to sg_copy_from_buffer().",,,"[{""url"":""https://git.kernel.org/stable/c/2f3d3fa5b8ed7d3b147478f42b00b468eeb1ecd2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8ba997b22f2cd5d29aad8c39f6201f7608ed0c04"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fb428a2005fc1260d18b989cc5199f281617f44d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53321,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:38.173,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: wifi: mac80211_hwsim: drop short frames While technically some control frames like ACK are shorter and end after Address 1, such frames shouldn't be forwarded through wmediumd or similar userspace, so require the full 3-address header to avoid accessing invalid memory if shorter frames are passed in.",,,"[{""url"":""https://git.kernel.org/stable/c/3beb97bed860d95b14ad23578ce8ddaea62023db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/672205c6f2d11978fcd7f0f336bb2c708e28874b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/89a41ed7f21476301659ebd25ccb48a60791c1a7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b9a175e3b250b0dc6e152988040aa5014e98e61e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c64ee9dd335832d5e2ab0a8fc83a34ad4c729799"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fba360a047d5eeeb9d4b7c3a9b1c8308980ce9a6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53322,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:38.287,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: scsi: qla2xxx: Wait for io return on terminate rport System crash due to use after free. Current code allows terminate_rport_io to exit before making sure all IOs has returned. For FCP-2 device, IO's can hang on in HW because driver has not tear down the session in FW at first sign of cable pull. When dev_loss_tmo timer pops, terminate_rport_io is called and upper layer is about to free various resources. Terminate_rport_io trigger qla to do the final cleanup, but the cleanup might not be fast enough where it leave qla still holding on to the same resource. Wait for IO's to return to upper layer before resources are freed.",,,"[{""url"":""https://git.kernel.org/stable/c/079c8264ed9fea8cbcac01ad29040f901cbc3692"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4647d2e88918a078359d1532d90c417a38542c9e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5bcdaafd92be6035ddc77fa76650cf9dd5b864c4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8a55556cd7e0220486163b1285ce11a8be2ce5fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90770dad1eb30967ebd8d37d82830bcf270b3293"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a9fe97fb7b4ee21bffb76f2acb05769bad27ae70"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d25fded78d88e1515439b3ba581684d683e0b6ab"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc0cba0c7be8261a1625098bd1d695077ec621c9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53323,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:38.410,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: ext2/dax: Fix ext2_setsize when len is page aligned PAGE_ALIGN(x) macro gives the next highest value which is multiple of pagesize. But if x is already page aligned then it simply returns x. So, if x passed is 0 in dax_zero_range() function, that means the length gets passed as 0 to ->iomap_begin(). In ext2 it then calls ext2_get_blocks -> max_blocks as 0 and hits bug_on here in ext2_get_blocks(). BUG_ON(maxblocks == 0); Instead we should be calling dax_truncate_page() here which takes care of it. i.e. it only calls dax_zero_range if the offset is not page/block aligned. This can be easily triggered with following on fsdax mounted pmem device. dd if=/dev/zero of=file count=1 bs=512 truncate -s 0 file [79.525838] EXT2-fs (pmem0): DAX enabled. Warning: EXPERIMENTAL, use at your own risk [79.529376] ext2 filesystem being mounted at /mnt1/test supports timestamps until 2038 (0x7fffffff) [93.793207] ------------[ cut here ]------------ [93.795102] kernel BUG at fs/ext2/inode.c:637! [93.796904] invalid opcode: 0000 [#1] PREEMPT SMP PTI [93.798659] CPU: 0 PID: 1192 Comm: truncate Not tainted 6.3.0-rc2-xfstests-00056-g131086faa369 #139 [93.806459] RIP: 0010:ext2_get_blocks.constprop.0+0x524/0x610 <...> [93.835298] Call Trace: [93.836253] <TASK> [93.837103] ? lock_acquire+0xf8/0x110 [93.838479] ? d_lookup+0x69/0xd0 [93.839779] ext2_iomap_begin+0xa7/0x1c0 [93.841154] iomap_iter+0xc7/0x150 [93.842425] dax_zero_range+0x6e/0xa0 [93.843813] ext2_setsize+0x176/0x1b0 [93.845164] ext2_setattr+0x151/0x200 [93.846467] notify_change+0x341/0x4e0 [93.847805] ? lock_acquire+0xf8/0x110 [93.849143] ? do_truncate+0x74/0xe0 [93.850452] ? do_truncate+0x84/0xe0 [93.851739] do_truncate+0x84/0xe0 [93.852974] do_sys_ftruncate+0x2b4/0x2f0 [93.854404] do_syscall_64+0x3f/0x90 [93.855789] entry_SYSCALL_64_after_hwframe+0x72/0xdc",,,"[{""url"":""https://git.kernel.org/stable/c/5cee8bfb8cbd99c97aff85d2bf066b6a496e13ab"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9e54fd14bd143c261e52fde74355e85e9526c58c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fcced95b6ba2a507a83b8b3e0358a8ac16b13e35"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53324,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:38.520,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/msm/mdp5: Don't leak some plane state Apparently no one noticed that mdp5 plane states leak like a sieve ever since we introduced plane_state->commit refcount a few years ago in 21a01abbe32a (""drm/atomic: Fix freeing connector/plane state too early by tracking commits, v3."") Fix it by using the right helpers. Patchwork: https://patchwork.freedesktop.org/patch/551236/",,,"[{""url"":""https://git.kernel.org/stable/c/12dfd02cbd1a678fbd66be0c2f79d5299c4921a9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2965015006ef18ca96d2eab9ebe6bca884c63291"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5b0dd3a102f64996598bd1e8d8388848a7c561bc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7fc11a830b2eb07a0e3c6f917e5e636df6fc5d4c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/815e42029f6e1e762898079f85546d6a0391ab95"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b8a61df6f40448cf46611f7af05b00970d08d620"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c0b1eee648702e04f1005d451f9689575b7f52ed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd0ad3b2365c1c58aa5a761c18efc4817193beb6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53325,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:38.657,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: drm/mediatek: dp: Change logging to dev for mtk_dp_aux_transfer() Change logging from drm_{err,info}() to dev_{err,info}() in functions mtk_dp_aux_transfer() and mtk_dp_aux_do_transfer(): this will be essential to avoid getting NULL pointer kernel panics if any kind of error happens during AUX transfers happening before the bridge is attached. This may potentially start happening in a later commit implementing aux-bus support, as AUX transfers will be triggered from the panel driver (for EDID) before the mtk-dp bridge gets attached, and it's done in preparation for the same.",,,"[{""url"":""https://git.kernel.org/stable/c/4c743c1dd2ee2a72951660b6798d4d7f7674f87b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7839f62294039959076dd06232e07aec7f7d5b2b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd70e2019bfbcb0ed90c5e23839bf510ce6acf8f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53326,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:38.783,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: powerpc: Don't try to copy PPR for task with NULL pt_regs powerpc sets up PF_KTHREAD and PF_IO_WORKER with a NULL pt_regs, which from my (arguably very short) checking is not commonly done for other archs. This is fine, except when PF_IO_WORKER's have been created and the task does something that causes a coredump to be generated. Then we get this crash: Kernel attempted to read user page (160) - exploit attempt? (uid: 1000) BUG: Kernel NULL pointer dereference on read at 0x00000160 Faulting instruction address: 0xc0000000000c3a60 Oops: Kernel access of bad area, sig: 11 [#1] LE PAGE_SIZE=64K MMU=Radix SMP NR_CPUS=32 NUMA pSeries Modules linked in: bochs drm_vram_helper drm_kms_helper xts binfmt_misc ecb ctr syscopyarea sysfillrect cbc sysimgblt drm_ttm_helper aes_generic ttm sg libaes evdev joydev virtio_balloon vmx_crypto gf128mul drm dm_mod fuse loop configfs drm_panel_orientation_quirks ip_tables x_tables autofs4 hid_generic usbhid hid xhci_pci xhci_hcd usbcore usb_common sd_mod CPU: 1 PID: 1982 Comm: ppc-crash Not tainted 6.3.0-rc2+ #88 Hardware name: IBM pSeries (emulated by qemu) POWER9 (raw) 0x4e1202 0xf000005 of:SLOF,HEAD hv:linux,kvm pSeries NIP: c0000000000c3a60 LR: c000000000039944 CTR: c0000000000398e0 REGS: c0000000041833b0 TRAP: 0300 Not tainted (6.3.0-rc2+) MSR: 800000000280b033 <SF,VEC,VSX,EE,FP,ME,IR,DR,RI,LE> CR: 88082828 XER: 200400f8 ... NIP memcpy_power7+0x200/0x7d0 LR ppr_get+0x64/0xb0 Call Trace: ppr_get+0x40/0xb0 (unreliable) __regset_get+0x180/0x1f0 regset_get_alloc+0x64/0x90 elf_core_dump+0xb98/0x1b60 do_coredump+0x1c34/0x24a0 get_signal+0x71c/0x1410 do_notify_resume+0x140/0x6f0 interrupt_exit_user_prepare_main+0x29c/0x320 interrupt_exit_user_prepare+0x6c/0xa0 interrupt_return_srr_user+0x8/0x138 Because ppr_get() is trying to copy from a PF_IO_WORKER with a NULL pt_regs. Check for a valid pt_regs in both ppc_get/ppr_set, and return an error if not set. The actual error value doesn't seem to be important here, so just pick -EINVAL. [mpe: Trim oops in change log, add Fixes & Cc stable]",,,"[{""url"":""https://git.kernel.org/stable/c/01849382373b867ddcbe7536b9dfa89f3bcea60e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/064a1c7b0f8403260d77627e62424a72ca26cee2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7624973bc15b76d000e8e6f9b8080fcb76d36595"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/80a4200d51e5a7e046f4a90f5faa5bafd5a60c58"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd7276189450110ed835eb0a334e62d2f1c4e3be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53327,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:38.910,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: iommufd/selftest: Catch overflow of uptr and length syzkaller hits a WARN_ON when trying to have a uptr close to UINTPTR_MAX: WARNING: CPU: 1 PID: 393 at drivers/iommu/iommufd/selftest.c:403 iommufd_test+0xb19/0x16f0 Modules linked in: CPU: 1 PID: 393 Comm: repro Not tainted 6.2.0-c9c3395d5e3d #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014 RIP: 0010:iommufd_test+0xb19/0x16f0 Code: 94 c4 31 ff 44 89 e6 e8 a5 54 17 ff 45 84 e4 0f 85 bb 0b 00 00 41 be fb ff ff ff e8 31 53 17 ff e9 a0 f7 ff ff e8 27 53 17 ff <0f> 0b 41 be 8 RSP: 0018:ffffc90000eabdc0 EFLAGS: 00010246 RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff8214c487 RDX: 0000000000000000 RSI: ffff88800f5c8000 RDI: 0000000000000002 RBP: ffffc90000eabe48 R08: 0000000000000000 R09: 0000000000000001 R10: 0000000000000001 R11: 0000000000000000 R12: 00000000cd2b0000 R13: 00000000cd2af000 R14: 0000000000000000 R15: ffffc90000eabe68 FS: 00007f94d76d5740(0000) GS:ffff88807dd00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000020000043 CR3: 0000000006880006 CR4: 0000000000770ee0 PKRU: 55555554 Call Trace: <TASK> ? write_comp_data+0x2f/0x90 iommufd_fops_ioctl+0x1ef/0x310 __x64_sys_ioctl+0x10e/0x160 ? __pfx_iommufd_fops_ioctl+0x10/0x10 do_syscall_64+0x3b/0x90 entry_SYSCALL_64_after_hwframe+0x72/0xdc Check that the user memory range doesn't overflow.",,,"[{""url"":""https://git.kernel.org/stable/c/3fb3505636d033bbf7a0851dac63d01732c51d62"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/adac6508c235a092b91ed9c0110ecf140e9e9441"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fd8c1a4aee973e87d890a5861e106625a33b2c4e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53328,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:39.053,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: Enhance sanity check while generating attr_list ni_create_attr_list uses WARN_ON to catch error cases while generating attribute list, which only prints out stack trace and may not be enough. This repalces them with more proper error handling flow. [ 59.666332] BUG: kernel NULL pointer dereference, address: 000000000000000e [ 59.673268] #PF: supervisor read access in kernel mode [ 59.678354] #PF: error_code(0x0000) - not-present page [ 59.682831] PGD 8000000005ff1067 P4D 8000000005ff1067 PUD 7dee067 PMD 0 [ 59.688556] Oops: 0000 [#1] PREEMPT SMP KASAN PTI [ 59.692642] CPU: 0 PID: 198 Comm: poc Tainted: G B W 6.2.0-rc1+ #4 [ 59.698868] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014 [ 59.708795] RIP: 0010:ni_create_attr_list+0x505/0x860 [ 59.713657] Code: 7e 10 e8 5e d0 d0 ff 45 0f b7 76 10 48 8d 7b 16 e8 00 d1 d0 ff 66 44 89 73 16 4d 8d 75 0e 4c 89 f7 e8 3f d0 d0 ff 4c 8d8 [ 59.731559] RSP: 0018:ffff88800a56f1e0 EFLAGS: 00010282 [ 59.735691] RAX: 0000000000000001 RBX: ffff88800b7b5088 RCX: ffffffffb83079fe [ 59.741792] RDX: 0000000000000001 RSI: 0000000000000008 RDI: ffffffffbb7f9fc0 [ 59.748423] RBP: ffff88800a56f3a8 R08: ffff88800b7b50a0 R09: fffffbfff76ff3f9 [ 59.754654] R10: ffffffffbb7f9fc7 R11: fffffbfff76ff3f8 R12: ffff88800b756180 [ 59.761552] R13: 0000000000000000 R14: 000000000000000e R15: 0000000000000050 [ 59.768323] FS: 00007feaa8c96440(0000) GS:ffff88806d400000(0000) knlGS:0000000000000000 [ 59.776027] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 59.781395] CR2: 00007f3a2e0b1000 CR3: 000000000a5bc000 CR4: 00000000000006f0 [ 59.787607] Call Trace: [ 59.790271] <TASK> [ 59.792488] ? __pfx_ni_create_attr_list+0x10/0x10 [ 59.797235] ? kernel_text_address+0xd3/0xe0 [ 59.800856] ? unwind_get_return_address+0x3e/0x60 [ 59.805101] ? __kasan_check_write+0x18/0x20 [ 59.809296] ? preempt_count_sub+0x1c/0xd0 [ 59.813421] ni_ins_attr_ext+0x52c/0x5c0 [ 59.817034] ? __pfx_ni_ins_attr_ext+0x10/0x10 [ 59.821926] ? __vfs_setxattr+0x121/0x170 [ 59.825718] ? __vfs_setxattr_noperm+0x97/0x300 [ 59.829562] ? __vfs_setxattr_locked+0x145/0x170 [ 59.833987] ? vfs_setxattr+0x137/0x2a0 [ 59.836732] ? do_setxattr+0xce/0x150 [ 59.839807] ? setxattr+0x126/0x140 [ 59.842353] ? path_setxattr+0x164/0x180 [ 59.845275] ? __x64_sys_setxattr+0x71/0x90 [ 59.848838] ? do_syscall_64+0x3f/0x90 [ 59.851898] ? entry_SYSCALL_64_after_hwframe+0x72/0xdc [ 59.857046] ? stack_depot_save+0x17/0x20 [ 59.860299] ni_insert_attr+0x1ba/0x420 [ 59.863104] ? __pfx_ni_insert_attr+0x10/0x10 [ 59.867069] ? preempt_count_sub+0x1c/0xd0 [ 59.869897] ? _raw_spin_unlock_irqrestore+0x2b/0x50 [ 59.874088] ? __create_object+0x3ae/0x5d0 [ 59.877865] ni_insert_resident+0xc4/0x1c0 [ 59.881430] ? __pfx_ni_insert_resident+0x10/0x10 [ 59.886355] ? kasan_save_alloc_info+0x1f/0x30 [ 59.891117] ? __kasan_kmalloc+0x8b/0xa0 [ 59.894383] ntfs_set_ea+0x90d/0xbf0 [ 59.897703] ? __pfx_ntfs_set_ea+0x10/0x10 [ 59.901011] ? kernel_text_address+0xd3/0xe0 [ 59.905308] ? __kernel_text_address+0x16/0x50 [ 59.909811] ? unwind_get_return_address+0x3e/0x60 [ 59.914898] ? __pfx_stack_trace_consume_entry+0x10/0x10 [ 59.920250] ? arch_stack_walk+0xa2/0x100 [ 59.924560] ? filter_irq_stacks+0x27/0x80 [ 59.928722] ntfs_setxattr+0x405/0x440 [ 59.932512] ? __pfx_ntfs_setxattr+0x10/0x10 [ 59.936634] ? kvmalloc_node+0x2d/0x120 [ 59.940378] ? kasan_save_stack+0x41/0x60 [ 59.943870] ? kasan_save_stack+0x2a/0x60 [ 59.947719] ? kasan_set_track+0x29/0x40 [ 59.951417] ? kasan_save_alloc_info+0x1f/0x30 [ 59.955733] ? __kasan_kmalloc+0x8b/0xa0 [ 59.959598] ? __kmalloc_node+0x68/0x150 [ 59.963163] ? kvmalloc_node+0x2d/0x120 [ 59.966490] ? vmemdup_user+0x2b/0xa0 ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/4246bbef0442f4a1e974df0ab091f4f33ac69451"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/64fab8bce5237ca225ee1ec9dff5cc8c31b0631f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e7799bb4dbe26bfb665f29ea87981708fd6012d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fdec309c7672cbee4dc0229ee4cbb33c948a1bdd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53329,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:39.207,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: workqueue: fix data race with the pwq->stats[] increment KCSAN has discovered a data race in kernel/workqueue.c:2598: [ 1863.554079] ================================================================== [ 1863.554118] BUG: KCSAN: data-race in process_one_work / process_one_work [ 1863.554142] write to 0xffff963d99d79998 of 8 bytes by task 5394 on cpu 27: [ 1863.554154] process_one_work (kernel/workqueue.c:2598) [ 1863.554166] worker_thread (./include/linux/list.h:292 kernel/workqueue.c:2752) [ 1863.554177] kthread (kernel/kthread.c:389) [ 1863.554186] ret_from_fork (arch/x86/kernel/process.c:145) [ 1863.554197] ret_from_fork_asm (arch/x86/entry/entry_64.S:312) [ 1863.554213] read to 0xffff963d99d79998 of 8 bytes by task 5450 on cpu 12: [ 1863.554224] process_one_work (kernel/workqueue.c:2598) [ 1863.554235] worker_thread (./include/linux/list.h:292 kernel/workqueue.c:2752) [ 1863.554247] kthread (kernel/kthread.c:389) [ 1863.554255] ret_from_fork (arch/x86/kernel/process.c:145) [ 1863.554266] ret_from_fork_asm (arch/x86/entry/entry_64.S:312) [ 1863.554280] value changed: 0x0000000000001766 -> 0x000000000000176a [ 1863.554295] Reported by Kernel Concurrency Sanitizer on: [ 1863.554303] CPU: 12 PID: 5450 Comm: kworker/u64:1 Tainted: G L 6.5.0-rc6+ #44 [ 1863.554314] Hardware name: ASRock X670E PG Lightning/X670E PG Lightning, BIOS 1.21 04/26/2023 [ 1863.554322] Workqueue: btrfs-endio btrfs_end_bio_work [btrfs] [ 1863.554941] ================================================================== lockdep_invariant_state(true); → pwq->stats[PWQ_STAT_STARTED]++; trace_workqueue_execute_start(work); worker->current_func(work); Moving pwq->stats[PWQ_STAT_STARTED]++; before the line raw_spin_unlock_irq(&pool->lock); resolves the data race without performance penalty. KCSAN detected at least one additional data race: [ 157.834751] ================================================================== [ 157.834770] BUG: KCSAN: data-race in process_one_work / process_one_work [ 157.834793] write to 0xffff9934453f77a0 of 8 bytes by task 468 on cpu 29: [ 157.834804] process_one_work (/home/marvin/linux/kernel/linux_torvalds/kernel/workqueue.c:2606) [ 157.834815] worker_thread (/home/marvin/linux/kernel/linux_torvalds/./include/linux/list.h:292 /home/marvin/linux/kernel/linux_torvalds/kernel/workqueue.c:2752) [ 157.834826] kthread (/home/marvin/linux/kernel/linux_torvalds/kernel/kthread.c:389) [ 157.834834] ret_from_fork (/home/marvin/linux/kernel/linux_torvalds/arch/x86/kernel/process.c:145) [ 157.834845] ret_from_fork_asm (/home/marvin/linux/kernel/linux_torvalds/arch/x86/entry/entry_64.S:312) [ 157.834859] read to 0xffff9934453f77a0 of 8 bytes by task 214 on cpu 7: [ 157.834868] process_one_work (/home/marvin/linux/kernel/linux_torvalds/kernel/workqueue.c:2606) [ 157.834879] worker_thread (/home/marvin/linux/kernel/linux_torvalds/./include/linux/list.h:292 /home/marvin/linux/kernel/linux_torvalds/kernel/workqueue.c:2752) [ 157.834890] kthread (/home/marvin/linux/kernel/linux_torvalds/kernel/kthread.c:389) [ 157.834897] ret_from_fork (/home/marvin/linux/kernel/linux_torvalds/arch/x86/kernel/process.c:145) [ 157.834907] ret_from_fork_asm (/home/marvin/linux/kernel/linux_torvalds/arch/x86/entry/entry_64.S:312) [ 157.834920] value changed: 0x000000000000052a -> 0x0000000000000532 [ 157.834933] Reported by Kernel Concurrency Sanitizer on: [ 157.834941] CPU: 7 PID: 214 Comm: kworker/u64:2 Tainted: G L 6.5.0-rc7-kcsan-00169-g81eaf55a60fc #4 [ 157.834951] Hardware name: ASRock X670E PG Lightning/X670E PG Lightning, BIOS 1.21 04/26/2023 [ 157.834958] Workqueue: btrfs-endio btrfs_end_bio_work [btrfs] [ 157.835567] ================================================================== in code: trace_workqueue_execute_end(work, worker->current_func); → pwq->stats[PWQ_STAT_COM ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/ce55024f28589b0012fa2c6b5748ec5a180b7fbe"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe48ba7daefe75bbbefa2426deddc05f2d530d2d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53330,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:39.313,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: caif: fix memory leak in cfctrl_linkup_request() When linktype is unknown or kzalloc failed in cfctrl_linkup_request(), pkt is not released. Add release process to error path.",,,"[{""url"":""https://git.kernel.org/stable/c/1dddeceb26002cfea4c375e92ac6498768dc7349"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/33df9c5d5e2a18c70f5f5f3c2757d654c1b6ffa3"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3acf3783a84cbdf0c9f8cf2f32ee9c49af93a2da"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3ad47c8aa5648226184415e4a0cb1bf67ffbfd48"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/84b2cc7b36b7f6957d307fb3d01603f93cb2d655"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/badea57569db04b010e922e29a7aaf40a979a70b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc1bc903970bdf63ca40ab923d3ccb765da9a8d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe69230f05897b3de758427b574fc98025dfc907"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53331,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:39.597,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: pstore/ram: Check start of empty przs during init After commit 30696378f68a (""pstore/ram: Do not treat empty buffers as valid""), initialization would assume a prz was valid after seeing that the buffer_size is zero (regardless of the buffer start position). This unchecked start value means it could be outside the bounds of the buffer, leading to future access panics when written to: sysdump_panic_event+0x3b4/0x5b8 atomic_notifier_call_chain+0x54/0x90 panic+0x1c8/0x42c die+0x29c/0x2a8 die_kernel_fault+0x68/0x78 __do_kernel_fault+0x1c4/0x1e0 do_bad_area+0x40/0x100 do_translation_fault+0x68/0x80 do_mem_abort+0x68/0xf8 el1_da+0x1c/0xc0 __raw_writeb+0x38/0x174 __memcpy_toio+0x40/0xac persistent_ram_update+0x44/0x12c persistent_ram_write+0x1a8/0x1b8 ramoops_pstore_write+0x198/0x1e8 pstore_console_write+0x94/0xe0 ... To avoid this, also check if the prz start is 0 during the initialization phase. If not, the next prz sanity check case will discover it (start > size) and zap the buffer back to a sane state. [kees: update commit log with backtrace and clarifications]",,,"[{""url"":""https://git.kernel.org/stable/c/25fb4e3402d46f425ec135ef6f09792a4c1b3003"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/89312657337e6e03ad6e9ea1a462bd9c158c85c8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c807ccdd812d18985860504b503899f3140a9549"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc2f60de9a7d3efd982440117dab5579898d808c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e95d7a8a6edd14f8fab44c777dd7281db91f6ae2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e972231db29b5d1dccc13bf9d5ba55b6979a69ed"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f77990358628b01bdc03752126ff5f716ea37615"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fe8c3623ab06603eb760444a032d426542212021"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fedecaeef88899d940b69368c996e8b3b0b8650d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53332,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:39.730,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: genirq/ipi: Fix NULL pointer deref in irq_data_get_affinity_mask() If ipi_send_{mask|single}() is called with an invalid interrupt number, all the local variables there will be NULL. ipi_send_verify() which is invoked from these functions does verify its 'data' parameter, resulting in a kernel oops in irq_data_get_affinity_mask() as the passed NULL pointer gets dereferenced. Add a missing NULL pointer check in ipi_send_verify()... Found by Linux Verification Center (linuxtesting.org) with the SVACE static analysis tool.",,,"[{""url"":""https://git.kernel.org/stable/c/7448c73d64075051f50caed2c62f46553b69ab8a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/926aef60ea64cd9becf2829f7388f48dbe8bcb11"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/feabecaff5902f896531dde90646ca5dfa9d4f7d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53333,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:39.837,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: netfilter: conntrack: dccp: copy entire header to stack buffer, not just basic one Eric Dumazet says: nf_conntrack_dccp_packet() has an unique: dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh); And nothing more is 'pulled' from the packet, depending on the content. dh->dccph_doff, and/or dh->dccph_x ...) So dccp_ack_seq() is happily reading stuff past the _dh buffer. BUG: KASAN: stack-out-of-bounds in nf_conntrack_dccp_packet+0x1134/0x11c0 Read of size 4 at addr ffff000128f66e0c by task syz-executor.2/29371 [..] Fix this by increasing the stack buffer to also include room for the extra sequence numbers and all the known dccp packet type headers, then pull again after the initial validation of the basic header. While at it, mark packets invalid that lack 48bit sequence bit but where RFC says the type MUST use them. Compile tested only. v2: first skb_header_pointer() now needs to adjust the size to only pull the generic header. (Eric) Heads-up: I intend to remove dccp conntrack support later this year.",,,"[{""url"":""https://git.kernel.org/stable/c/26bd1f210d3783a691052c51d76bb8a8bbd24c67"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/337fdce450637ea663bc816edc2ba81e5cdad02e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5c618daa5038712c4a4ef8923905a2ea1b8836a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8c0980493beed3a80d6329c44ab293dc8c032927"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9bdcda7abaf22f6453e5b5efb7eb4e524095d5d8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c052797ac36813419ad3bfa54cb8615db4b41f15"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff0a3a7d52ff7282dbd183e7fc29a1fe386b0c30"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53334,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-16T17:15:39.957,2025-09-17T14:18:55.093,Awaiting Analysis,[],"In the Linux kernel, the following vulnerability has been resolved: USB: chipidea: fix memory leak with using debugfs_lookup() When calling debugfs_lookup() the result must have dput() called on it, otherwise the memory will leak over time. To make things simpler, just call debugfs_lookup_and_remove() instead which handles all of the logic at once.",,,"[{""url"":""https://git.kernel.org/stable/c/4322661af6d7a586a5798ab9aa443f49895b6943"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/610373dd354f3d393aa3bdcab59f55024c16b5e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/972e0682f6e3ee6ecf002657df4aaa511d51dd6c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ff35f3ea3baba5b81416ac02d005cfbf6dd182fa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53335,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:36.560,2025-09-17T15:15:36.560,Received,[],"In the Linux kernel, the following vulnerability has been resolved: RDMA/cxgb4: Fix potential null-ptr-deref in pass_establish() If get_ep_from_tid() fails to lookup non-NULL value for ep, ep is dereferenced later regardless of whether it is empty. This patch adds a simple sanity check to fix the issue. Found by Linux Verification Center (linuxtesting.org) with SVACE.",,,"[{""url"":""https://git.kernel.org/stable/c/283861a4c52c1ea4df3dd1b6fc75a50796ce3524"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2cfc00e974d75a3aa8155f2660f57d342e1f67ca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9dca64042d855a24b0bd81ce242e5dc7e939f6eb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/9ddc77eefb2a567b705c3c86ab2ddabe43cadf1b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53336,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:36.680,2025-09-17T15:15:36.680,Received,[],"In the Linux kernel, the following vulnerability has been resolved: media: ipu-bridge: Fix null pointer deref on SSDB/PLD parsing warnings When ipu_bridge_parse_rotation() and ipu_bridge_parse_orientation() run sensor->adev is not set yet. So if either of the dev_warn() calls about unknown values are hit this will lead to a NULL pointer deref. Set sensor->adev earlier, with a borrowed ref to avoid making unrolling on errors harder, to fix this.",,,"[{""url"":""https://git.kernel.org/stable/c/284be5693163343e1cf17c03917eecd1d6681bcf"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3de35e29cfddfe6bff762b15bcfe8d80bebac6cb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e08b091e33ecf6e4cb2c0c5820a69abe7673280b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53337,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:36.793,2025-09-17T15:15:36.793,Received,[],"In the Linux kernel, the following vulnerability has been resolved: nilfs2: do not write dirty data after degenerating to read-only According to syzbot's report, mark_buffer_dirty() called from nilfs_segctor_do_construct() outputs a warning with some patterns after nilfs2 detects metadata corruption and degrades to read-only mode. After such read-only degeneration, page cache data may be cleared through nilfs_clear_dirty_page() which may also clear the uptodate flag for their buffer heads. However, even after the degeneration, log writes are still performed by unmount processing etc., which causes mark_buffer_dirty() to be called for buffer heads without the ""uptodate"" flag and causes the warning. Since any writes should not be done to a read-only file system in the first place, this fixes the warning in mark_buffer_dirty() by letting nilfs_segctor_do_construct() abort early if in read-only mode. This also changes the retry check of nilfs_segctor_write_out() to avoid unnecessary log write retries if it detects -EROFS that nilfs_segctor_do_construct() returned.",,,"[{""url"":""https://git.kernel.org/stable/c/13f73ef77baa4764dc1ca4fcbae9cade05b83866"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/28a65b49eb53e172d23567005465019658bfdb4d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4005cec6847c06ee191583270b7cdd7e696543cc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/4569a292a84e340e97d178898ad1cfe1a3080a61"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/55f7810632f993cff622a0ddbc7c865892294b61"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c3e662048053802f6b0db3a78e97f4e1f7edc4f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a73201c607d8e506358d60aafddda4246bdd9350"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd89073fc7a5d03b1d06b372addbe405e5a925f4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e9c5412c5972124776c1b873533eb39e287a4dfa"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53338,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:36.913,2025-09-17T15:15:36.913,Received,[],"In the Linux kernel, the following vulnerability has been resolved: lwt: Fix return values of BPF xmit ops BPF encap ops can return different types of positive values, such like NET_RX_DROP, NET_XMIT_CN, NETDEV_TX_BUSY, and so on, from function skb_do_redirect and bpf_lwt_xmit_reroute. At the xmit hook, such return values would be treated implicitly as LWTUNNEL_XMIT_CONTINUE in ip(6)_finish_output2. When this happens, skbs that have been freed would continue to the neighbor subsystem, causing use-after-free bug and kernel crashes. To fix the incorrect behavior, skb_do_redirect return values can be simply discarded, the same as tc-egress behavior. On the other hand, bpf_lwt_xmit_reroute returns useful errors to local senders, e.g. PMTU information. Thus convert its return values to avoid the conflict with LWTUNNEL_XMIT_CONTINUE.",,,"[{""url"":""https://git.kernel.org/stable/c/065d5f17096ec9161180e2c890afdff4dc6125f2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/29b22badb7a84b783e3a4fffca16f7768fb31205"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/65583f9e070db7bece20710cfa2e3daeb0b831d9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/67f8f2bae8e7ac72e09def2b667e44704c4d1ee1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a97f221651fcdc891166e9bc270e3d9bfa5a0080"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d68c17402442f5f494a2c3ebde5cb82f6aa9160a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e3f647e4b642f9f6d32795a16f92c116c138d2af"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53339,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:37.030,2025-09-17T15:15:37.030,Received,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: fix BUG_ON condition in btrfs_cancel_balance Pausing and canceling balance can race to interrupt balance lead to BUG_ON panic in btrfs_cancel_balance. The BUG_ON condition in btrfs_cancel_balance does not take this race scenario into account. However, the race condition has no other side effects. We can fix that. Reproducing it with panic trace like this: kernel BUG at fs/btrfs/volumes.c:4618! RIP: 0010:btrfs_cancel_balance+0x5cf/0x6a0 Call Trace: <TASK> ? do_nanosleep+0x60/0x120 ? hrtimer_nanosleep+0xb7/0x1a0 ? sched_core_clone_cookie+0x70/0x70 btrfs_ioctl_balance_ctl+0x55/0x70 btrfs_ioctl+0xa46/0xd20 __x64_sys_ioctl+0x7d/0xa0 do_syscall_64+0x38/0x80 entry_SYSCALL_64_after_hwframe+0x63/0xcd Race scenario as follows: > mutex_unlock(&fs_info->balance_mutex); > -------------------- > .......issue pause and cancel req in another thread > -------------------- > ret = __btrfs_balance(fs_info); > > mutex_lock(&fs_info->balance_mutex); > if (ret == -ECANCELED && atomic_read(&fs_info->balance_pause_req)) { > btrfs_info(fs_info, ""balance: paused""); > btrfs_exclop_balance(fs_info, BTRFS_EXCLOP_BALANCE_PAUSED); > }",,,"[{""url"":""https://git.kernel.org/stable/c/29eefa6d0d07e185f7bfe9576f91e6dba98189c2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c93b89cd46636b5e74c12fa21dd86167bc6ea8d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a0a462a0f20926918d6009f0b4b25673e883fc98"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ae81329f7de3aa6f34ecdfa5412e72161a30e9ce"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b966e9e1e250dfdb41a7f41775faea4a37af923c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd7bef82ce0e929ef4cf63a34990545aaca28077"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ceb9ba8e30833a4823e2dc73f80ebcdf2498d01a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53340,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:37.153,2025-09-17T15:15:37.153,Received,[],"In the Linux kernel, the following vulnerability has been resolved: net/mlx5: Collect command failures data only for known commands DEVX can issue a general command, which is not used by mlx5 driver. In case such command is failed, mlx5 is trying to collect the failure data, However, mlx5 doesn't create a storage for this command, since mlx5 doesn't use it. This lead to array-index-out-of-bounds error. Fix it by checking whether the command is known before collecting the failure data.",,,"[{""url"":""https://git.kernel.org/stable/c/2a0a935fb64ee8af253b9c6133bb6702fb152ac2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/411e4d6caa7f7169192b8dacc8421ac4fd64a354"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d8b6f175235d7327b4e1b13216859e89496dfbd5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53341,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:37.273,2025-09-17T15:15:37.273,Received,[],"In the Linux kernel, the following vulnerability has been resolved: of/fdt: run soc memory setup when early_init_dt_scan_memory fails If memory has been found early_init_dt_scan_memory now returns 1. If it hasn't found any memory it will return 0, allowing other memory setup mechanisms to carry on. Previously early_init_dt_scan_memory always returned 0 without distinguishing between any kind of memory setup being done or not. Any code path after the early_init_dt_scan memory call in the ramips plat_mem_setup code wouldn't be executed anymore. Making early_init_dt_scan_memory the only way to initialize the memory. Some boards, including my mt7621 based Cudy X6 board, depend on memory initialization being done via the soc_info.mem_detect function pointer. Those wouldn't be able to obtain memory and panic the kernel during early bootup with the message ""early_init_dt_alloc_memory_arch: Failed to allocate 12416 bytes align=0x40"".",,,"[{""url"":""https://git.kernel.org/stable/c/04836fc5b720dfa32ff781383d84f63019abf9b9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2a12187d5853d9fd5102278cecef7dac7c8ce7ea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c4849f18185fd4e93b04cd45552f8d68c0240e21"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53342,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:37.393,2025-09-17T15:15:37.393,Received,[],"In the Linux kernel, the following vulnerability has been resolved: net: marvell: prestera: fix handling IPv4 routes with nhid Fix handling IPv4 routes referencing a nexthop via its id by replacing calls to fib_info_nh() with fib_info_nhc(). Trying to add an IPv4 route referencing a nextop via nhid: $ ip link set up swp5 $ ip a a 10.0.0.1/24 dev swp5 $ ip nexthop add dev swp5 id 20 via 10.0.0.2 $ ip route add 10.0.1.0/24 nhid 20 triggers warnings when trying to handle the route: [ 528.805763] ------------[ cut here ]------------ [ 528.810437] WARNING: CPU: 3 PID: 53 at include/net/nexthop.h:468 __prestera_fi_is_direct+0x2c/0x68 [prestera] [ 528.820434] Modules linked in: prestera_pci act_gact act_police sch_ingress cls_u32 cls_flower prestera arm64_delta_tn48m_dn_led(O) arm64_delta_tn48m_dn_cpld(O) [last unloaded: prestera_pci] [ 528.837485] CPU: 3 PID: 53 Comm: kworker/u8:3 Tainted: G O 6.4.5 #1 [ 528.845178] Hardware name: delta,tn48m-dn (DT) [ 528.849641] Workqueue: prestera_ordered __prestera_router_fib_event_work [prestera] [ 528.857352] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 528.864347] pc : __prestera_fi_is_direct+0x2c/0x68 [prestera] [ 528.870135] lr : prestera_k_arb_fib_evt+0xb20/0xd50 [prestera] [ 528.876007] sp : ffff80000b20bc90 [ 528.879336] x29: ffff80000b20bc90 x28: 0000000000000000 x27: ffff0001374d3a48 [ 528.886510] x26: ffff000105604000 x25: ffff000134af8a28 x24: ffff0001374d3800 [ 528.893683] x23: ffff000101c89148 x22: ffff000101c89000 x21: ffff000101c89200 [ 528.900855] x20: ffff00013641fda0 x19: ffff800009d01088 x18: 0000000000000059 [ 528.908027] x17: 0000000000000277 x16: 0000000000000000 x15: 0000000000000000 [ 528.915198] x14: 0000000000000003 x13: 00000000000fe400 x12: 0000000000000000 [ 528.922371] x11: 0000000000000002 x10: 0000000000000aa0 x9 : ffff8000013d2020 [ 528.929543] x8 : 0000000000000018 x7 : 000000007b1703f8 x6 : 000000001ca72f86 [ 528.936715] x5 : 0000000033399ea7 x4 : 0000000000000000 x3 : ffff0001374d3acc [ 528.943886] x2 : 0000000000000000 x1 : ffff00010200de00 x0 : ffff000134ae3f80 [ 528.951058] Call trace: [ 528.953516] __prestera_fi_is_direct+0x2c/0x68 [prestera] [ 528.958952] __prestera_router_fib_event_work+0x100/0x158 [prestera] [ 528.965348] process_one_work+0x208/0x488 [ 528.969387] worker_thread+0x4c/0x430 [ 528.973068] kthread+0x120/0x138 [ 528.976313] ret_from_fork+0x10/0x20 [ 528.979909] ---[ end trace 0000000000000000 ]--- [ 528.984998] ------------[ cut here ]------------ [ 528.989645] WARNING: CPU: 3 PID: 53 at include/net/nexthop.h:468 __prestera_fi_is_direct+0x2c/0x68 [prestera] [ 528.999628] Modules linked in: prestera_pci act_gact act_police sch_ingress cls_u32 cls_flower prestera arm64_delta_tn48m_dn_led(O) arm64_delta_tn48m_dn_cpld(O) [last unloaded: prestera_pci] [ 529.016676] CPU: 3 PID: 53 Comm: kworker/u8:3 Tainted: G W O 6.4.5 #1 [ 529.024368] Hardware name: delta,tn48m-dn (DT) [ 529.028830] Workqueue: prestera_ordered __prestera_router_fib_event_work [prestera] [ 529.036539] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 529.043533] pc : __prestera_fi_is_direct+0x2c/0x68 [prestera] [ 529.049318] lr : __prestera_k_arb_fc_apply+0x280/0x2f8 [prestera] [ 529.055452] sp : ffff80000b20bc60 [ 529.058781] x29: ffff80000b20bc60 x28: 0000000000000000 x27: ffff0001374d3a48 [ 529.065953] x26: ffff000105604000 x25: ffff000134af8a28 x24: ffff0001374d3800 [ 529.073126] x23: ffff000101c89148 x22: ffff000101c89148 x21: ffff00013641fda0 [ 529.080299] x20: ffff000101c89000 x19: ffff000101c89020 x18: 0000000000000059 [ 529.087471] x17: 0000000000000277 x16: 0000000000000000 x15: 0000000000000000 [ 529.094642] x14: 0000000000000003 x13: 00000000000fe400 x12: 0000000000000000 [ 529.101814] x11: 0000000000000002 x10: 0000000000000aa0 x9 : ffff8000013cee80 [ 529.108985] x8 : 0000000000000018 x7 : 000000007b1703f8 x6 ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/2aa71b4b294ee2c3041d085404cea914be9b3225"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8373dca3c1f8a203cecebe3421dbe890c4f08e16"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a3e5f3b7f25d7b90f3b76d98a946fec6e5f79216"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53343,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:38.100,2025-09-17T15:15:38.100,Received,[],"In the Linux kernel, the following vulnerability has been resolved: icmp6: Fix null-ptr-deref of ip6_null_entry->rt6i_idev in icmp6_dev(). With some IPv6 Ext Hdr (RPL, SRv6, etc.), we can send a packet that has the link-local address as src and dst IP and will be forwarded to an external IP in the IPv6 Ext Hdr. For example, the script below generates a packet whose src IP is the link-local address and dst is updated to 11::. # for f in $(find /proc/sys/net/ -name *seg6_enabled*); do echo 1 > $f; done # python3 >>> from socket import * >>> from scapy.all import * >>> >>> SRC_ADDR = DST_ADDR = ""fe80::5054:ff:fe12:3456"" >>> >>> pkt = IPv6(src=SRC_ADDR, dst=DST_ADDR) >>> pkt /= IPv6ExtHdrSegmentRouting(type=4, addresses=[""11::"", ""22::""], segleft=1) >>> >>> sk = socket(AF_INET6, SOCK_RAW, IPPROTO_RAW) >>> sk.sendto(bytes(pkt), (DST_ADDR, 0)) For such a packet, we call ip6_route_input() to look up a route for the next destination in these three functions depending on the header type. * ipv6_rthdr_rcv() * ipv6_rpl_srh_rcv() * ipv6_srh_rcv() If no route is found, ip6_null_entry is set to skb, and the following dst_input(skb) calls ip6_pkt_drop(). Finally, in icmp6_dev(), we dereference skb_rt6_info(skb)->rt6i_idev->dev as the input device is the loopback interface. Then, we have to check if skb_rt6_info(skb)->rt6i_idev is NULL or not to avoid NULL pointer deref for ip6_null_entry. BUG: kernel NULL pointer dereference, address: 0000000000000000 PF: supervisor read access in kernel mode PF: error_code(0x0000) - not-present page PGD 0 P4D 0 Oops: 0000 [#1] PREEMPT SMP PTI CPU: 0 PID: 157 Comm: python3 Not tainted 6.4.0-11996-gb121d614371c #35 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014 RIP: 0010:icmp6_send (net/ipv6/icmp.c:436 net/ipv6/icmp.c:503) Code: fe ff ff 48 c7 40 30 c0 86 5d 83 e8 c6 44 1c 00 e9 c8 fc ff ff 49 8b 46 58 48 83 e0 fe 0f 84 4a fb ff ff 48 8b 80 d0 00 00 00 <48> 8b 00 44 8b 88 e0 00 00 00 e9 34 fb ff ff 4d 85 ed 0f 85 69 01 RSP: 0018:ffffc90000003c70 EFLAGS: 00000286 RAX: 0000000000000000 RBX: 0000000000000001 RCX: 00000000000000e0 RDX: 0000000000000021 RSI: 0000000000000000 RDI: ffff888006d72a18 RBP: ffffc90000003d80 R08: 0000000000000000 R09: 0000000000000001 R10: ffffc90000003d98 R11: 0000000000000040 R12: ffff888006d72a10 R13: 0000000000000000 R14: ffff8880057fb800 R15: ffffffff835d86c0 FS: 00007f9dc72ee740(0000) GS:ffff88807dc00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000000 CR3: 00000000057b2000 CR4: 00000000007506f0 PKRU: 55555554 Call Trace: <IRQ> ip6_pkt_drop (net/ipv6/route.c:4513) ipv6_rthdr_rcv (net/ipv6/exthdrs.c:640 net/ipv6/exthdrs.c:686) ip6_protocol_deliver_rcu (net/ipv6/ip6_input.c:437 (discriminator 5)) ip6_input_finish (./include/linux/rcupdate.h:781 net/ipv6/ip6_input.c:483) __netif_receive_skb_one_core (net/core/dev.c:5455) process_backlog (./include/linux/rcupdate.h:781 net/core/dev.c:5895) __napi_poll (net/core/dev.c:6460) net_rx_action (net/core/dev.c:6529 net/core/dev.c:6660) __do_softirq (./arch/x86/include/asm/jump_label.h:27 ./include/linux/jump_label.h:207 ./include/trace/events/irq.h:142 kernel/softirq.c:554) do_softirq (kernel/softirq.c:454 kernel/softirq.c:441) </IRQ> <TASK> __local_bh_enable_ip (kernel/softirq.c:381) __dev_queue_xmit (net/core/dev.c:4231) ip6_finish_output2 (./include/net/neighbour.h:544 net/ipv6/ip6_output.c:135) rawv6_sendmsg (./include/net/dst.h:458 ./include/linux/netfilter.h:303 net/ipv6/raw.c:656 net/ipv6/raw.c:914) sock_sendmsg (net/socket.c:725 net/socket.c:748) __sys_sendto (net/socket.c:2134) __x64_sys_sendto (net/socket.c:2146 net/socket.c:2142 net/socket.c:2142) do_syscall_64 (arch/x86/entry/common.c:50 arch/x86/entry/common.c:80) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:120) RIP: 0033:0x7f9dc751baea Code: d8 64 89 02 48 c7 c0 ff f ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/1462e9d9aa52d14665eaca6d89d22c4af44ede04"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2aaa8a15de73874847d62eb595c6683bface80fd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3fabca5d9cae0140b6aad09a1c6b9aa57089fbb8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/61b4c4659746959056450b92a5d7e6bc1243b31b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8803c59fde4dd370a627dfbf7183682fa0cabf70"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa657d319e6c7502a4eb85cc0ee80cc81b8e5724"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d30ddd7ff15df9d91a793ce3f06f0190ff7afacc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53344,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:38.237,2025-09-17T15:15:38.237,Received,[],"In the Linux kernel, the following vulnerability has been resolved: can: bcm: bcm_tx_setup(): fix KMSAN uninit-value in vfs_write Syzkaller reported the following issue: ===================================================== BUG: KMSAN: uninit-value in aio_rw_done fs/aio.c:1520 [inline] BUG: KMSAN: uninit-value in aio_write+0x899/0x950 fs/aio.c:1600 aio_rw_done fs/aio.c:1520 [inline] aio_write+0x899/0x950 fs/aio.c:1600 io_submit_one+0x1d1c/0x3bf0 fs/aio.c:2019 __do_sys_io_submit fs/aio.c:2078 [inline] __se_sys_io_submit+0x293/0x770 fs/aio.c:2048 __x64_sys_io_submit+0x92/0xd0 fs/aio.c:2048 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd Uninit was created at: slab_post_alloc_hook mm/slab.h:766 [inline] slab_alloc_node mm/slub.c:3452 [inline] __kmem_cache_alloc_node+0x71f/0xce0 mm/slub.c:3491 __do_kmalloc_node mm/slab_common.c:967 [inline] __kmalloc+0x11d/0x3b0 mm/slab_common.c:981 kmalloc_array include/linux/slab.h:636 [inline] bcm_tx_setup+0x80e/0x29d0 net/can/bcm.c:930 bcm_sendmsg+0x3a2/0xce0 net/can/bcm.c:1351 sock_sendmsg_nosec net/socket.c:714 [inline] sock_sendmsg net/socket.c:734 [inline] sock_write_iter+0x495/0x5e0 net/socket.c:1108 call_write_iter include/linux/fs.h:2189 [inline] aio_write+0x63a/0x950 fs/aio.c:1600 io_submit_one+0x1d1c/0x3bf0 fs/aio.c:2019 __do_sys_io_submit fs/aio.c:2078 [inline] __se_sys_io_submit+0x293/0x770 fs/aio.c:2048 __x64_sys_io_submit+0x92/0xd0 fs/aio.c:2048 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd CPU: 1 PID: 5034 Comm: syz-executor350 Not tainted 6.2.0-rc6-syzkaller-80422-geda666ff2276 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/12/2023 ===================================================== We can follow the call chain and find that 'bcm_tx_setup' function calls 'memcpy_from_msg' to copy some content to the newly allocated frame of 'op->frames'. After that the 'len' field of copied structure being compared with some constant value (64 or 8). However, if 'memcpy_from_msg' returns an error, we will compare some uninitialized memory. This triggers 'uninit-value' issue. This patch will add 'memcpy_from_msg' possible errors processing to avoid uninit-value issue. Tested via syzkaller",,,"[{""url"":""https://git.kernel.org/stable/c/2b4c99f7d9a57ecd644eda9b1fb0a1072414959f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2e6ad51c709fa794e0ce26003c9c9cd944e3383a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3fa0f1e0e31b1b73cdf59d4c36c7242e6ef821be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/618b15d09fed6126356101543451d49860db4388"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/78bc7f0ab99458221224d3ab97199c0f8e6861f1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ab2a55907823f0bca56b6d03ea05e4071ba8535f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bf70e0eab64c625da84d9fdf4e84466b79418920"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c11dbc7705b3739974ac31a13f4ab81e61a5fb07"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53345,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:38.363,2025-09-17T15:15:38.363,Received,[],"In the Linux kernel, the following vulnerability has been resolved: rxrpc: Fix potential data race in rxrpc_wait_to_be_connected() Inside the loop in rxrpc_wait_to_be_connected() it checks call->error to see if it should exit the loop without first checking the call state. This is probably safe as if call->error is set, the call is dead anyway, but we should probably wait for the call state to have been set to completion first, lest it cause surprise on the way out. Fix this by only accessing call->error if the call is complete. We don't actually need to access the error inside the loop as we'll do that after. This caused the following report: BUG: KCSAN: data-race in rxrpc_send_data / rxrpc_set_call_completion write to 0xffff888159cf3c50 of 4 bytes by task 25673 on cpu 1: rxrpc_set_call_completion+0x71/0x1c0 net/rxrpc/call_state.c:22 rxrpc_send_data_packet+0xba9/0x1650 net/rxrpc/output.c:479 rxrpc_transmit_one+0x1e/0x130 net/rxrpc/output.c:714 rxrpc_decant_prepared_tx net/rxrpc/call_event.c:326 [inline] rxrpc_transmit_some_data+0x496/0x600 net/rxrpc/call_event.c:350 rxrpc_input_call_event+0x564/0x1220 net/rxrpc/call_event.c:464 rxrpc_io_thread+0x307/0x1d80 net/rxrpc/io_thread.c:461 kthread+0x1ac/0x1e0 kernel/kthread.c:376 ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:308 read to 0xffff888159cf3c50 of 4 bytes by task 25672 on cpu 0: rxrpc_send_data+0x29e/0x1950 net/rxrpc/sendmsg.c:296 rxrpc_do_sendmsg+0xb7a/0xc20 net/rxrpc/sendmsg.c:726 rxrpc_sendmsg+0x413/0x520 net/rxrpc/af_rxrpc.c:565 sock_sendmsg_nosec net/socket.c:724 [inline] sock_sendmsg net/socket.c:747 [inline] ____sys_sendmsg+0x375/0x4c0 net/socket.c:2501 ___sys_sendmsg net/socket.c:2555 [inline] __sys_sendmmsg+0x263/0x500 net/socket.c:2641 __do_sys_sendmmsg net/socket.c:2670 [inline] __se_sys_sendmmsg net/socket.c:2667 [inline] __x64_sys_sendmmsg+0x57/0x60 net/socket.c:2667 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x41/0xc0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd value changed: 0x00000000 -> 0xffffffea",,,"[{""url"":""https://git.kernel.org/stable/c/2b5fdc0f5caa505afe34d608e2eefadadf2ee67a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3e8ba61a3fe4475a9b5c9fbfc664435c6795d872"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/454e48a9ff04c5fa1631bb172070fcb6389b97f9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53346,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:38.480,2025-09-17T15:15:38.480,Received,[],"In the Linux kernel, the following vulnerability has been resolved: kernel/fail_function: fix memory leak with using debugfs_lookup() When calling debugfs_lookup() the result must have dput() called on it, otherwise the memory will leak over time. To make things simpler, just call debugfs_lookup_and_remove() instead which handles all of the logic at once.",,,"[{""url"":""https://git.kernel.org/stable/c/29d53c4c5a6f6d2b93aaac95b65cb4c907faf2ff"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2bb3669f576559db273efe49e0e69f82450efbca"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/94f68f3e059c478e240f65fcb64746fe371295df"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bb99db06b8b6ce9351633fc61bec9919d8f6f52b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dd9981a11d74ff2eb253bb5c459876f8bd3c6c36"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f6d3aee1c66358471275df9dddd480010f061b0e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53347,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:38.603,2025-09-17T15:15:38.603,Received,[],"In the Linux kernel, the following vulnerability has been resolved: net/mlx5: Handle pairing of E-switch via uplink un/load APIs In case user switch a device from switchdev mode to legacy mode, mlx5 first unpair the E-switch and afterwards unload the uplink vport. From the other hand, in case user remove or reload a device, mlx5 first unload the uplink vport and afterwards unpair the E-switch. The latter is causing a bug[1], hence, handle pairing of E-switch as part of uplink un/load APIs. [1] In case VF_LAG is used, every tc fdb flow is duplicated to the peer esw. However, the original esw keeps a pointer to this duplicated flow, not the peer esw. e.g.: if user create tc fdb flow over esw0, the flow is duplicated over esw1, in FW/HW, but in SW, esw0 keeps a pointer to the duplicated flow. During module unload while a peer tc fdb flow is still offloaded, in case the first device to be removed is the peer device (esw1 in the example above), the peer net-dev is destroyed, and so the mlx5e_priv is memset to 0. Afterwards, the peer device is trying to unpair himself from the original device (esw0 in the example above). Unpair API invoke the original device to clear peer flow from its eswitch (esw0), but the peer flow, which is stored over the original eswitch (esw0), is trying to use the peer mlx5e_priv, which is memset to 0 and result in bellow kernel-oops. [ 157.964081 ] BUG: unable to handle page fault for address: 000000000002ce60 [ 157.964662 ] #PF: supervisor read access in kernel mode [ 157.965123 ] #PF: error_code(0x0000) - not-present page [ 157.965582 ] PGD 0 P4D 0 [ 157.965866 ] Oops: 0000 [#1] SMP [ 157.967670 ] RIP: 0010:mlx5e_tc_del_fdb_flow+0x48/0x460 [mlx5_core] [ 157.976164 ] Call Trace: [ 157.976437 ] <TASK> [ 157.976690 ] __mlx5e_tc_del_fdb_peer_flow+0xe6/0x100 [mlx5_core] [ 157.977230 ] mlx5e_tc_clean_fdb_peer_flows+0x67/0x90 [mlx5_core] [ 157.977767 ] mlx5_esw_offloads_unpair+0x2d/0x1e0 [mlx5_core] [ 157.984653 ] mlx5_esw_offloads_devcom_event+0xbf/0x130 [mlx5_core] [ 157.985212 ] mlx5_devcom_send_event+0xa3/0xb0 [mlx5_core] [ 157.985714 ] esw_offloads_disable+0x5a/0x110 [mlx5_core] [ 157.986209 ] mlx5_eswitch_disable_locked+0x152/0x170 [mlx5_core] [ 157.986757 ] mlx5_eswitch_disable+0x51/0x80 [mlx5_core] [ 157.987248 ] mlx5_unload+0x2a/0xb0 [mlx5_core] [ 157.987678 ] mlx5_uninit_one+0x5f/0xd0 [mlx5_core] [ 157.988127 ] remove_one+0x64/0xe0 [mlx5_core] [ 157.988549 ] pci_device_remove+0x31/0xa0 [ 157.988933 ] device_release_driver_internal+0x18f/0x1f0 [ 157.989402 ] driver_detach+0x3f/0x80 [ 157.989754 ] bus_remove_driver+0x70/0xf0 [ 157.990129 ] pci_unregister_driver+0x34/0x90 [ 157.990537 ] mlx5_cleanup+0xc/0x1c [mlx5_core] [ 157.990972 ] __x64_sys_delete_module+0x15a/0x250 [ 157.991398 ] ? exit_to_user_mode_prepare+0xea/0x110 [ 157.991840 ] do_syscall_64+0x3d/0x90 [ 157.992198 ] entry_SYSCALL_64_after_hwframe+0x46/0xb0",,,"[{""url"":""https://git.kernel.org/stable/c/10cbfecc0f99f579fb170feee866c9efaab7ee47"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2be5bd42a5bba1a05daedc86cf0e248210009669"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b17294e7aa8c39dbb9c3e28e2d1983c88b94b387"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53348,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:38.727,2025-09-17T15:15:38.727,Received,[],"In the Linux kernel, the following vulnerability has been resolved: btrfs: fix deadlock when aborting transaction during relocation with scrub Before relocating a block group we pause scrub, then do the relocation and then unpause scrub. The relocation process requires starting and committing a transaction, and if we have a failure in the critical section of the transaction commit path (transaction state >= TRANS_STATE_COMMIT_START), we will deadlock if there is a paused scrub. That results in stack traces like the following: [42.479] BTRFS info (device sdc): relocating block group 53876686848 flags metadata|raid6 [42.936] BTRFS warning (device sdc): Skipping commit of aborted transaction. [42.936] ------------[ cut here ]------------ [42.936] BTRFS: Transaction aborted (error -28) [42.936] WARNING: CPU: 11 PID: 346822 at fs/btrfs/transaction.c:1977 btrfs_commit_transaction+0xcc8/0xeb0 [btrfs] [42.936] Modules linked in: dm_flakey dm_mod loop btrfs (...) [42.936] CPU: 11 PID: 346822 Comm: btrfs Tainted: G W 6.3.0-rc2-btrfs-next-127+ #1 [42.936] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014 [42.936] RIP: 0010:btrfs_commit_transaction+0xcc8/0xeb0 [btrfs] [42.936] Code: ff ff 45 8b (...) [42.936] RSP: 0018:ffffb58649633b48 EFLAGS: 00010282 [42.936] RAX: 0000000000000000 RBX: ffff8be6ef4d5bd8 RCX: 0000000000000000 [42.936] RDX: 0000000000000002 RSI: ffffffffb35e7782 RDI: 00000000ffffffff [42.936] RBP: ffff8be6ef4d5c98 R08: 0000000000000000 R09: ffffb586496339e8 [42.936] R10: 0000000000000001 R11: 0000000000000001 R12: ffff8be6d38c7c00 [42.936] R13: 00000000ffffffe4 R14: ffff8be6c268c000 R15: ffff8be6ef4d5cf0 [42.936] FS: 00007f381a82b340(0000) GS:ffff8beddfcc0000(0000) knlGS:0000000000000000 [42.936] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [42.936] CR2: 00007f1e35fb7638 CR3: 0000000117680006 CR4: 0000000000370ee0 [42.936] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [42.936] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [42.936] Call Trace: [42.936] <TASK> [42.936] ? start_transaction+0xcb/0x610 [btrfs] [42.936] prepare_to_relocate+0x111/0x1a0 [btrfs] [42.936] relocate_block_group+0x57/0x5d0 [btrfs] [42.936] ? btrfs_wait_nocow_writers+0x25/0xb0 [btrfs] [42.936] btrfs_relocate_block_group+0x248/0x3c0 [btrfs] [42.936] ? __pfx_autoremove_wake_function+0x10/0x10 [42.936] btrfs_relocate_chunk+0x3b/0x150 [btrfs] [42.936] btrfs_balance+0x8ff/0x11d0 [btrfs] [42.936] ? __kmem_cache_alloc_node+0x14a/0x410 [42.936] btrfs_ioctl+0x2334/0x32c0 [btrfs] [42.937] ? mod_objcg_state+0xd2/0x360 [42.937] ? refill_obj_stock+0xb0/0x160 [42.937] ? seq_release+0x25/0x30 [42.937] ? __rseq_handle_notify_resume+0x3b5/0x4b0 [42.937] ? percpu_counter_add_batch+0x2e/0xa0 [42.937] ? __x64_sys_ioctl+0x88/0xc0 [42.937] __x64_sys_ioctl+0x88/0xc0 [42.937] do_syscall_64+0x38/0x90 [42.937] entry_SYSCALL_64_after_hwframe+0x72/0xdc [42.937] RIP: 0033:0x7f381a6ffe9b [42.937] Code: 00 48 89 44 24 (...) [42.937] RSP: 002b:00007ffd45ecf060 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 [42.937] RAX: ffffffffffffffda RBX: 0000000000000001 RCX: 00007f381a6ffe9b [42.937] RDX: 00007ffd45ecf150 RSI: 00000000c4009420 RDI: 0000000000000003 [42.937] RBP: 0000000000000003 R08: 0000000000000013 R09: 0000000000000000 [42.937] R10: 00007f381a60c878 R11: 0000000000000246 R12: 00007ffd45ed0423 [42.937] R13: 00007ffd45ecf150 R14: 0000000000000000 R15: 00007ffd45ecf148 [42.937] </TASK> [42.937] ---[ end trace 0000000000000000 ]--- [42.937] BTRFS: error (device sdc: state A) in cleanup_transaction:1977: errno=-28 No space left [59.196] INFO: task btrfs:346772 blocked for more than 120 seconds. [59.196] Tainted: G W 6.3.0-rc2-btrfs-next-127+ #1 [59.196] ""echo 0 > /proc/sys/kernel/hung_ ---truncated---",,,"[{""url"":""https://git.kernel.org/stable/c/10a5831b193390b77705fc174a309476c23ba64a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2d82a40aa7d6fcae0250ec68b8566cdee7bfd44c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6134a4bb6b1c411a244edee041ac89266c78d45c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53349,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:38.827,2025-09-17T15:15:38.827,Received,[],"In the Linux kernel, the following vulnerability has been resolved: media: ov2740: Fix memleak in ov2740_init_controls() There is a kmemleak when testing the media/i2c/ov2740.c with bpf mock device: unreferenced object 0xffff8881090e19e0 (size 16): comm ""51-i2c-ov2740"", pid 278, jiffies 4294781584 (age 23.613s) hex dump (first 16 bytes): 00 f3 7c 0b 81 88 ff ff 80 75 6a 09 81 88 ff ff ..|......uj..... backtrace: [<000000004e9fad8f>] __kmalloc_node+0x44/0x1b0 [<0000000039c802f4>] kvmalloc_node+0x34/0x180 [<000000009b8b5c63>] v4l2_ctrl_handler_init_class+0x11d/0x180 [videodev] [<0000000038644056>] ov2740_probe+0x37d/0x84f [ov2740] [<0000000092489f59>] i2c_device_probe+0x28d/0x680 [<000000001038babe>] really_probe+0x17c/0x3f0 [<0000000098c7af1c>] __driver_probe_device+0xe3/0x170 [<00000000e1b3dc24>] device_driver_attach+0x34/0x80 [<000000005a04a34d>] bind_store+0x10b/0x1a0 [<00000000ce25d4f2>] drv_attr_store+0x49/0x70 [<000000007d9f4e9a>] sysfs_kf_write+0x8c/0xb0 [<00000000be6cff0f>] kernfs_fop_write_iter+0x216/0x2e0 [<0000000031ddb40a>] vfs_write+0x658/0x810 [<0000000041beecdd>] ksys_write+0xd6/0x1b0 [<0000000023755840>] do_syscall_64+0x38/0x90 [<00000000b2cc2da2>] entry_SYSCALL_64_after_hwframe+0x63/0xcd ov2740_init_controls() won't clean all the allocated resources in fail path, which may causes the memleaks. Add v4l2_ctrl_handler_free() to prevent memleak.",,,"[{""url"":""https://git.kernel.org/stable/c/2d899592ed7829d0d5140853bac4d58742a6b8af"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3969b2ebc66039306f505c7c630c5530800f83c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/7c405ee63447f14eefcfe12a18aa749abbd596ea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a163ee11345d8322321c28bd61631de32455b987"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fc33380ae06f438b652f66b9370b543976ac8a03"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53350,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:38.943,2025-09-17T15:15:38.943,Received,[],"In the Linux kernel, the following vulnerability has been resolved: accel/qaic: Fix slicing memory leak The temporary buffer storing slicing configuration data from user is only freed on error. This is a memory leak. Free the buffer unconditionally.",,,"[{""url"":""https://git.kernel.org/stable/c/2d956177b7c96e62fac762a3b7da4318cde27a73"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/df45c3e46cdb41f486eecb4277fbcc4c1ffbf9be"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53351,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:39.057,2025-09-17T15:15:39.057,Received,[],"In the Linux kernel, the following vulnerability has been resolved: drm/sched: Check scheduler work queue before calling timeout handling During an IGT GPU reset test we see again oops despite of commit 0c8c901aaaebc9 (drm/sched: Check scheduler ready before calling timeout handling). It uses ready condition whether to call drm_sched_fault which unwind the TDR leads to GPU reset. However it looks the ready condition is overloaded with other meanings, for example, for the following stack is related GPU reset : 0 gfx_v9_0_cp_gfx_start 1 gfx_v9_0_cp_gfx_resume 2 gfx_v9_0_cp_resume 3 gfx_v9_0_hw_init 4 gfx_v9_0_resume 5 amdgpu_device_ip_resume_phase2 does the following: /* start the ring */ gfx_v9_0_cp_gfx_start(adev); ring->sched.ready = true; The same approach is for other ASICs as well : gfx_v8_0_cp_gfx_resume gfx_v10_0_kiq_resume, etc... As a result, our GPU reset test causes GPU fault which calls unconditionally gfx_v9_0_fault and then drm_sched_fault. However now it depends on whether the interrupt service routine drm_sched_fault is executed after gfx_v9_0_cp_gfx_start is completed which sets the ready field of the scheduler to true even for uninitialized schedulers and causes oops vs no fault or when ISR drm_sched_fault is completed prior gfx_v9_0_cp_gfx_start and NULL pointer dereference does not occur. Use the field timeout_wq to prevent oops for uninitialized schedulers. The field could be initialized by the work queue of resetting the domain. v1: Corrections to commit message (Luben)",,,"[{""url"":""https://git.kernel.org/stable/c/2da5bffe9eaa5819a868e8eaaa11b3fd0f16a691"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c43a96fc00b662cef1ef0eb22d40441ce2abae8f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53352,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:39.173,2025-09-17T15:15:39.173,Received,[],"In the Linux kernel, the following vulnerability has been resolved: drm/ttm: check null pointer before accessing when swapping Add a check to avoid null pointer dereference as below: [ 90.002283] general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN NOPTI [ 90.002292] KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007] [ 90.002346] ? exc_general_protection+0x159/0x240 [ 90.002352] ? asm_exc_general_protection+0x26/0x30 [ 90.002357] ? ttm_bo_evict_swapout_allowable+0x322/0x5e0 [ttm] [ 90.002365] ? ttm_bo_evict_swapout_allowable+0x42e/0x5e0 [ttm] [ 90.002373] ttm_bo_swapout+0x134/0x7f0 [ttm] [ 90.002383] ? __pfx_ttm_bo_swapout+0x10/0x10 [ttm] [ 90.002391] ? lock_acquire+0x44d/0x4f0 [ 90.002398] ? ttm_device_swapout+0xa5/0x260 [ttm] [ 90.002412] ? lock_acquired+0x355/0xa00 [ 90.002416] ? do_raw_spin_trylock+0xb6/0x190 [ 90.002421] ? __pfx_lock_acquired+0x10/0x10 [ 90.002426] ? ttm_global_swapout+0x25/0x210 [ttm] [ 90.002442] ttm_device_swapout+0x198/0x260 [ttm] [ 90.002456] ? __pfx_ttm_device_swapout+0x10/0x10 [ttm] [ 90.002472] ttm_global_swapout+0x75/0x210 [ttm] [ 90.002486] ttm_tt_populate+0x187/0x3f0 [ttm] [ 90.002501] ttm_bo_handle_move_mem+0x437/0x590 [ttm] [ 90.002517] ttm_bo_validate+0x275/0x430 [ttm] [ 90.002530] ? __pfx_ttm_bo_validate+0x10/0x10 [ttm] [ 90.002544] ? kasan_save_stack+0x33/0x60 [ 90.002550] ? kasan_set_track+0x25/0x30 [ 90.002554] ? __kasan_kmalloc+0x8f/0xa0 [ 90.002558] ? amdgpu_gtt_mgr_new+0x81/0x420 [amdgpu] [ 90.003023] ? ttm_resource_alloc+0xf6/0x220 [ttm] [ 90.003038] amdgpu_bo_pin_restricted+0x2dd/0x8b0 [amdgpu] [ 90.003210] ? __x64_sys_ioctl+0x131/0x1a0 [ 90.003210] ? do_syscall_64+0x60/0x90",,,"[{""url"":""https://git.kernel.org/stable/c/1fdd16d89c01336d9a942b5f03673c17d401da87"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2dedcf414bb01b8d966eb445db1d181d92304fb2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/49b3b979e79faef129605018ad82aa0f2258f2f7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8089eb93d6787dbf348863e935698b4610d90321"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d39971d902d067b4dc366981b75b17c8c57ed5d1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53353,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:39.293,2025-09-17T15:15:39.293,Received,[],"In the Linux kernel, the following vulnerability has been resolved: accel/habanalabs: postpone mem_mgr IDR destruction to hpriv_release() The memory manager IDR is currently destroyed when user releases the file descriptor. However, at this point the user context might be still held, and memory buffers might be still in use. Later on, calls to release those buffers will fail due to not finding their handles in the IDR, leading to a memory leak. To avoid this leak, split the IDR destruction from the memory manager fini, and postpone it to hpriv_release() when there is no user context and no buffers are used.",,,"[{""url"":""https://git.kernel.org/stable/c/2e8e9a895c4589f124a37fc84d123b5114406e94"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/840de329ca99cafd0cdde9c6ac160b1330942aba"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53354,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:39.403,2025-09-17T15:15:39.403,Received,[],"In the Linux kernel, the following vulnerability has been resolved: skbuff: skb_segment, Call zero copy functions before using skbuff frags Commit bf5c25d60861 (""skbuff: in skb_segment, call zerocopy functions once per nskb"") added the call to zero copy functions in skb_segment(). The change introduced a bug in skb_segment() because skb_orphan_frags() may possibly change the number of fragments or allocate new fragments altogether leaving nrfrags and frag to point to the old values. This can cause a panic with stacktrace like the one below. [ 193.894380] BUG: kernel NULL pointer dereference, address: 00000000000000bc [ 193.895273] CPU: 13 PID: 18164 Comm: vh-net-17428 Kdump: loaded Tainted: G O 5.15.123+ #26 [ 193.903919] RIP: 0010:skb_segment+0xb0e/0x12f0 [ 194.021892] Call Trace: [ 194.027422] <TASK> [ 194.072861] tcp_gso_segment+0x107/0x540 [ 194.082031] inet_gso_segment+0x15c/0x3d0 [ 194.090783] skb_mac_gso_segment+0x9f/0x110 [ 194.095016] __skb_gso_segment+0xc1/0x190 [ 194.103131] netem_enqueue+0x290/0xb10 [sch_netem] [ 194.107071] dev_qdisc_enqueue+0x16/0x70 [ 194.110884] __dev_queue_xmit+0x63b/0xb30 [ 194.121670] bond_start_xmit+0x159/0x380 [bonding] [ 194.128506] dev_hard_start_xmit+0xc3/0x1e0 [ 194.131787] __dev_queue_xmit+0x8a0/0xb30 [ 194.138225] macvlan_start_xmit+0x4f/0x100 [macvlan] [ 194.141477] dev_hard_start_xmit+0xc3/0x1e0 [ 194.144622] sch_direct_xmit+0xe3/0x280 [ 194.147748] __dev_queue_xmit+0x54a/0xb30 [ 194.154131] tap_get_user+0x2a8/0x9c0 [tap] [ 194.157358] tap_sendmsg+0x52/0x8e0 [tap] [ 194.167049] handle_tx_zerocopy+0x14e/0x4c0 [vhost_net] [ 194.173631] handle_tx+0xcd/0xe0 [vhost_net] [ 194.176959] vhost_worker+0x76/0xb0 [vhost] [ 194.183667] kthread+0x118/0x140 [ 194.190358] ret_from_fork+0x1f/0x30 [ 194.193670] </TASK> In this case calling skb_orphan_frags() updated nr_frags leaving nrfrags local variable in skb_segment() stale. This resulted in the code hitting i >= nrfrags prematurely and trying to move to next frag_skb using list_skb pointer, which was NULL, and caused kernel panic. Move the call to zero copy functions before using frags and nr_frags.",,,"[{""url"":""https://git.kernel.org/stable/c/04c3eee4e13f60bf6f9a366ad39f88a01a57166e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2ea35288c83b3d501a88bc17f2df8f176b5cc96f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6c26ed3c6abe86ddab0510529000b970b05c9b40"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8836c266201c29a5acb4f582227686f47b65ad61"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d44403ec0676317b7f7edf2a035bb219fee3304e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/d5790386595d06ea9decfd9ba5f1ea48cf09aa02"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/f99006e840a4dbc8f5a34cecc6b5b26c73ef49bb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fcab3f661dbfd88e27ddbbe65368f3fa2d823175"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53355,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:39.523,2025-09-17T15:15:39.523,Received,[],"In the Linux kernel, the following vulnerability has been resolved: staging: pi433: fix memory leak with using debugfs_lookup() When calling debugfs_lookup() the result must have dput() called on it, otherwise the memory will leak over time. To make things simpler, just call debugfs_lookup_and_remove() instead which handles all of the logic at once. This requires saving off the root directory dentry to make creation of individual device subdirectories easier.",,,"[{""url"":""https://git.kernel.org/stable/c/04f3cda40e9f6653ae15ed3fcf26ef2860f4df66"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2f36e789e540df6a9fbf471b3a2ba62a8b361586"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bb16f3102607b69e1a0233f4b73c6e337f86ef8d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53356,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:39.640,2025-09-17T15:15:39.640,Received,[],"In the Linux kernel, the following vulnerability has been resolved: usb: gadget: u_serial: Add null pointer check in gserial_suspend Consider a case where gserial_disconnect has already cleared gser->ioport. And if gserial_suspend gets called afterwards, it will lead to accessing of gser->ioport and thus causing null pointer dereference. Avoid this by adding a null pointer check. Added a static spinlock to prevent gser->ioport from becoming null after the newly added null pointer check.",,,"[{""url"":""https://git.kernel.org/stable/c/2788a3553f7497075653210b42e2aeb6ba95e28e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/2f6ecb89fe8feb2b60a53325b0eeb9866d88909a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/374447e3367767156405bedd230c5d391f4b7962"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a8ea7ed644cbf6314b5b0136b5398754b549fb8f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/e60a827ac074ce6bd58305fe5a86afab5fce6a04"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53357,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:39.763,2025-09-17T15:15:39.763,Received,[],"In the Linux kernel, the following vulnerability has been resolved: md/raid10: check slab-out-of-bounds in md_bitmap_get_counter If we write a large number to md/bitmap_set_bits, md_bitmap_checkpage() will return -EINVAL because 'page >= bitmap->pages', but the return value was not checked immediately in md_bitmap_get_counter() in order to set *blocks value and slab-out-of-bounds occurs. Move check of 'page >= bitmap->pages' to md_bitmap_get_counter() and return directly if true.",,,"[{""url"":""https://git.kernel.org/stable/c/152bb26796ff054af50b2ee1b3ca56e364e4f61b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/301867b1c16805aebbc306aafa6ecdc68b73c7e5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/374fb914304d9b500721007f3837ea8f1f9a2418"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/39fa14e824acfd470db4f42c354297456bd82b53"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a134dd582c0d5b6068efa308bd485cf1d00b3f65"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b0b971fe7d61411ede63c3291764dbde1577ef2c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/be1a3ec63a840cc9e59a033acf154f56255699a1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bea301c046110bf421a3ce153fb868cb8d618e90"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53358,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:39.890,2025-09-17T15:15:39.890,Received,[],"In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix racy issue under cocurrent smb2 tree disconnect There is UAF issue under cocurrent smb2 tree disconnect. This patch introduce TREE_CONN_EXPIRE flags for tcon to avoid cocurrent access.",,,"[{""url"":""https://git.kernel.org/stable/c/30210947a343b6b3ca13adc9bfc88e1543e16dd5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/39366b47a59d46af15ac57beb0996268bf911f6a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/b36295c17fb97424406f0c3ab321b1ccaabb9be8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/bd80d35725a0cf4df9307bfe2f1a3b2cb983d8e6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/dc1c17716c099c90948ebb83e2170dd75a3be6b6"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53359,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:40.010,2025-09-17T15:15:40.010,Received,[],"In the Linux kernel, the following vulnerability has been resolved: USB: fix memory leak with using debugfs_lookup() When calling debugfs_lookup() the result must have dput() called on it, otherwise the memory will leak over time. To make things simpler, just call debugfs_lookup_and_remove() instead which handles all of the logic at once.",,,"[{""url"":""https://git.kernel.org/stable/c/30374434edab20e25776f8ecb4bc9d1e54309487"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6683327b51a601daba32900072349dfa1d4e8fea"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c68ece7baf2aa9783b8244482c03010d477d4a93"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc00340fb1226a2a3a5cf15473ac417da3c952f1"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53360,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:40.123,2025-09-17T15:15:40.123,Received,[],"In the Linux kernel, the following vulnerability has been resolved: NFSv4.2: Rework scratch handling for READ_PLUS (again) I found that the read code might send multiple requests using the same nfs_pgio_header, but nfs4_proc_read_setup() is only called once. This is how we ended up occasionally double-freeing the scratch buffer, but also means we set a NULL pointer but non-zero length to the xdr scratch buffer. This results in an oops the first time decoding needs to copy something to scratch, which frequently happens when decoding READ_PLUS hole segments. I fix this by moving scratch handling into the pageio read code. I provide a function to allocate scratch space for decoding read replies, and free the scratch buffer when the nfs_pgio_header is freed.",,,"[{""url"":""https://git.kernel.org/stable/c/303a78052091c81e9003915c521fdca1c7e117af"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a2f4cb206bd94b3f4a7bb05fcdce9525283b5681"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/adac9f0ddd2b291c7ce41f549fdb27a13616cff5"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ae5d5672f1db711e91db6f52df5cb16ecd8f5692"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53361,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:40.247,2025-09-17T15:15:40.247,Received,[],"In the Linux kernel, the following vulnerability has been resolved: LoongArch: mm: Add p?d_leaf() definitions When I do LTP test, LTP test case ksm06 caused panic at break_ksm_pmd_entry -> pmd_leaf (Huge page table but False) -> pte_present (panic) The reason is pmd_leaf() is not defined, So like commit 501b81046701 (""mips: mm: add p?d_leaf() definitions"") add p?d_leaf() definition for LoongArch.",,,"[{""url"":""https://git.kernel.org/stable/c/303be4b33562a5b689261ced1616bf16ad49efa7"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/593ad636bac41d67bdc44c83c6945015471313fc"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/77aaf22a9200b9557793c96debead911b80acc1c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/cc9bf2d62f196ec600f9e6ea3a6ced11f54a2df9"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53362,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:40.370,2025-09-17T15:15:40.370,Received,[],"In the Linux kernel, the following vulnerability has been resolved: bus: fsl-mc: don't assume child devices are all fsl-mc devices Changes in VFIO caused a pseudo-device to be created as child of fsl-mc devices causing a crash [1] when trying to bind a fsl-mc device to VFIO. Fix this by checking the device type when enumerating fsl-mc child devices. [1] Modules linked in: Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP CPU: 6 PID: 1289 Comm: sh Not tainted 6.2.0-rc5-00047-g7c46948a6e9c #2 Hardware name: NXP Layerscape LX2160ARDB (DT) pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : mc_send_command+0x24/0x1f0 lr : dprc_get_obj_region+0xfc/0x1c0 sp : ffff80000a88b900 x29: ffff80000a88b900 x28: ffff48a9429e1400 x27: 00000000000002b2 x26: ffff48a9429e1718 x25: 0000000000000000 x24: 0000000000000000 x23: ffffd59331ba3918 x22: ffffd59331ba3000 x21: 0000000000000000 x20: ffff80000a88b9b8 x19: 0000000000000000 x18: 0000000000000001 x17: 7270642f636d2d6c x16: 73662e3030303030 x15: ffffffffffffffff x14: ffffd59330f1d668 x13: ffff48a8727dc389 x12: ffff48a8727dc386 x11: 0000000000000002 x10: 00008ceaf02f35d4 x9 : 0000000000000012 x8 : 0000000000000000 x7 : 0000000000000006 x6 : ffff80000a88bab0 x5 : 0000000000000000 x4 : 0000000000000000 x3 : ffff80000a88b9e8 x2 : ffff80000a88b9e8 x1 : 0000000000000000 x0 : ffff48a945142b80 Call trace: mc_send_command+0x24/0x1f0 dprc_get_obj_region+0xfc/0x1c0 fsl_mc_device_add+0x340/0x590 fsl_mc_obj_device_add+0xd0/0xf8 dprc_scan_objects+0x1c4/0x340 dprc_scan_container+0x38/0x60 vfio_fsl_mc_probe+0x9c/0xf8 fsl_mc_driver_probe+0x24/0x70 really_probe+0xbc/0x2a8 __driver_probe_device+0x78/0xe0 device_driver_attach+0x30/0x68 bind_store+0xa8/0x130 drv_attr_store+0x24/0x38 sysfs_kf_write+0x44/0x60 kernfs_fop_write_iter+0x128/0x1b8 vfs_write+0x334/0x448 ksys_write+0x68/0xf0 __arm64_sys_write+0x1c/0x28 invoke_syscall+0x44/0x108 el0_svc_common.constprop.1+0x94/0xf8 do_el0_svc+0x38/0xb0 el0_svc+0x20/0x50 el0t_64_sync_handler+0x98/0xc0 el0t_64_sync+0x174/0x178 Code: aa0103f4 a9025bf5 d5384100 b9400801 (79401260) ---[ end trace 0000000000000000 ]---",,,"[{""url"":""https://git.kernel.org/stable/c/303c9c63abb9390e906052863f82bb4e9824e5c0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/5bd9dc3e767edf582be483be8d6bbc7433bd4cf8"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8bdd5c21ec02835bd445d022f4c23195aff407d2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53363,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:40.503,2025-09-17T15:15:40.503,Received,[],"In the Linux kernel, the following vulnerability has been resolved: PCI: Fix use-after-free in pci_bus_release_domain_nr() Commit c14f7ccc9f5d (""PCI: Assign PCI domain IDs by ida_alloc()"") introduced a use-after-free bug in the bus removal cleanup. The issue was found with kfence: [ 19.293351] BUG: KFENCE: use-after-free read in pci_bus_release_domain_nr+0x10/0x70 [ 19.302817] Use-after-free read at 0x000000007f3b80eb (in kfence-#115): [ 19.309677] pci_bus_release_domain_nr+0x10/0x70 [ 19.309691] dw_pcie_host_deinit+0x28/0x78 [ 19.309702] tegra_pcie_deinit_controller+0x1c/0x38 [pcie_tegra194] [ 19.309734] tegra_pcie_dw_probe+0x648/0xb28 [pcie_tegra194] [ 19.309752] platform_probe+0x90/0xd8 ... [ 19.311457] kfence-#115: 0x00000000063a155a-0x00000000ba698da8, size=1072, cache=kmalloc-2k [ 19.311469] allocated by task 96 on cpu 10 at 19.279323s: [ 19.311562] __kmem_cache_alloc_node+0x260/0x278 [ 19.311571] kmalloc_trace+0x24/0x30 [ 19.311580] pci_alloc_bus+0x24/0xa0 [ 19.311590] pci_register_host_bridge+0x48/0x4b8 [ 19.311601] pci_scan_root_bus_bridge+0xc0/0xe8 [ 19.311613] pci_host_probe+0x18/0xc0 [ 19.311623] dw_pcie_host_init+0x2c0/0x568 [ 19.311630] tegra_pcie_dw_probe+0x610/0xb28 [pcie_tegra194] [ 19.311647] platform_probe+0x90/0xd8 ... [ 19.311782] freed by task 96 on cpu 10 at 19.285833s: [ 19.311799] release_pcibus_dev+0x30/0x40 [ 19.311808] device_release+0x30/0x90 [ 19.311814] kobject_put+0xa8/0x120 [ 19.311832] device_unregister+0x20/0x30 [ 19.311839] pci_remove_bus+0x78/0x88 [ 19.311850] pci_remove_root_bus+0x5c/0x98 [ 19.311860] dw_pcie_host_deinit+0x28/0x78 [ 19.311866] tegra_pcie_deinit_controller+0x1c/0x38 [pcie_tegra194] [ 19.311883] tegra_pcie_dw_probe+0x648/0xb28 [pcie_tegra194] [ 19.311900] platform_probe+0x90/0xd8 ... [ 19.313579] CPU: 10 PID: 96 Comm: kworker/u24:2 Not tainted 6.2.0 #4 [ 19.320171] Hardware name: /, BIOS 1.0-d7fb19b 08/10/2022 [ 19.325852] Workqueue: events_unbound deferred_probe_work_func The stack trace is a bit misleading as dw_pcie_host_deinit() doesn't directly call pci_bus_release_domain_nr(). The issue turns out to be in pci_remove_root_bus() which first calls pci_remove_bus() which frees the struct pci_bus when its struct device is released. Then pci_bus_release_domain_nr() is called and accesses the freed struct pci_bus. Reordering these fixes the issue.",,,"[{""url"":""https://git.kernel.org/stable/c/07a75c0050e59c50f038cc5f4e2a3258c8f8c9d0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/30ba2d09edb5ea857a1473ae3d820911347ada62"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/52b0343c7d628f37b38e3279ba585526b850ad3b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/ad367516b1c09317111255ecfbf5e42c33e31918"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/fbf45385e3419b8698b5e0a434847072375cfec2"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53364,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:40.650,2025-09-17T15:15:40.650,Received,[],"In the Linux kernel, the following vulnerability has been resolved: regulator: da9063: better fix null deref with partial DT Two versions of the original patch were sent but V1 was merged instead of V2 due to a mistake. So update to V2. The advantage of V2 is that it completely avoids dereferencing the pointer, even just to take the address, which may fix problems with some compilers. Both versions work on my gcc 9.4 but use the safer one.",,,"[{""url"":""https://git.kernel.org/stable/c/30c694fd4a99fbbc4115d180156ca01b60953371"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/aa402a3b553bd4829f4504058d53b0351c66c9d4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53365,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:40.803,2025-09-17T15:15:40.803,Received,[],"In the Linux kernel, the following vulnerability has been resolved: ip6mr: Fix skb_under_panic in ip6mr_cache_report() skbuff: skb_under_panic: text:ffffffff88771f69 len:56 put:-4 head:ffff88805f86a800 data:ffff887f5f86a850 tail:0x88 end:0x2c0 dev:pim6reg ------------[ cut here ]------------ kernel BUG at net/core/skbuff.c:192! invalid opcode: 0000 [#1] PREEMPT SMP KASAN CPU: 2 PID: 22968 Comm: kworker/2:11 Not tainted 6.5.0-rc3-00044-g0a8db05b571a #236 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 Workqueue: ipv6_addrconf addrconf_dad_work RIP: 0010:skb_panic+0x152/0x1d0 Call Trace: <TASK> skb_push+0xc4/0xe0 ip6mr_cache_report+0xd69/0x19b0 reg_vif_xmit+0x406/0x690 dev_hard_start_xmit+0x17e/0x6e0 __dev_queue_xmit+0x2d6a/0x3d20 vlan_dev_hard_start_xmit+0x3ab/0x5c0 dev_hard_start_xmit+0x17e/0x6e0 __dev_queue_xmit+0x2d6a/0x3d20 neigh_connected_output+0x3ed/0x570 ip6_finish_output2+0x5b5/0x1950 ip6_finish_output+0x693/0x11c0 ip6_output+0x24b/0x880 NF_HOOK.constprop.0+0xfd/0x530 ndisc_send_skb+0x9db/0x1400 ndisc_send_rs+0x12a/0x6c0 addrconf_dad_completed+0x3c9/0xea0 addrconf_dad_work+0x849/0x1420 process_one_work+0xa22/0x16e0 worker_thread+0x679/0x10c0 ret_from_fork+0x28/0x60 ret_from_fork_asm+0x11/0x20 When setup a vlan device on dev pim6reg, DAD ns packet may sent on reg_vif_xmit(). reg_vif_xmit() ip6mr_cache_report() skb_push(skb, -skb_network_offset(pkt));//skb_network_offset(pkt) is 4 And skb_push declared as: void *skb_push(struct sk_buff *skb, unsigned int len); skb->data -= len; //0xffff88805f86a84c - 0xfffffffc = 0xffff887f5f86a850 skb->data is set to 0xffff887f5f86a850, which is invalid mem addr, lead to skb_push() fails.",,,"[{""url"":""https://git.kernel.org/stable/c/0438e60a00d4e335b3c36397dbf26c74b5d13ef0"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1683124129a4263dd5bce2475bab110e95fa0346"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1bb54a21f4d9b88442f8c3307c780e2db64417e4"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/30e0191b16e8a58e4620fa3e2839ddc7b9d4281c"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/3326c711f18d18fe6e1f5d83d3a7eab07e5a1560"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/691a09eecad97e745b9aa0e3918db46d020bdacb"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/8382e7ed2d63e6c2daf6881fa091526dc6c879cd"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/a96d74d1076c82a4cef02c150d9996b21354c78d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53366,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:40.957,2025-09-17T15:15:40.957,Received,[],"In the Linux kernel, the following vulnerability has been resolved: block: be a bit more careful in checking for NULL bdev while polling Wei reports a crash with an application using polled IO: PGD 14265e067 P4D 14265e067 PUD 47ec50067 PMD 0 Oops: 0000 [#1] SMP CPU: 0 PID: 21915 Comm: iocore_0 Kdump: loaded Tainted: G S 5.12.0-0_fbk12_clang_7346_g1bb6f2e7058f #1 Hardware name: Wiwynn Delta Lake MP T8/Delta Lake-Class2, BIOS Y3DLM08 04/10/2022 RIP: 0010:bio_poll+0x25/0x200 Code: 0f 1f 44 00 00 0f 1f 44 00 00 55 41 57 41 56 41 55 41 54 53 48 83 ec 28 65 48 8b 04 25 28 00 00 00 48 89 44 24 20 48 8b 47 08 <48> 8b 80 70 02 00 00 4c 8b 70 50 8b 6f 34 31 db 83 fd ff 75 25 65 RSP: 0018:ffffc90005fafdf8 EFLAGS: 00010292 RAX: 0000000000000000 RBX: 0000000000000000 RCX: 74b43cd65dd66600 RDX: 0000000000000003 RSI: ffffc90005fafe78 RDI: ffff8884b614e140 RBP: ffff88849964df78 R08: 0000000000000000 R09: 0000000000000008 R10: 0000000000000000 R11: 0000000000000000 R12: ffff88849964df00 R13: ffffc90005fafe78 R14: ffff888137d3c378 R15: 0000000000000001 FS: 00007fd195000640(0000) GS:ffff88903f400000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000270 CR3: 0000000466121001 CR4: 00000000007706f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 PKRU: 55555554 Call Trace: iocb_bio_iopoll+0x1d/0x30 io_do_iopoll+0xac/0x250 __se_sys_io_uring_enter+0x3c5/0x5a0 ? __x64_sys_write+0x89/0xd0 do_syscall_64+0x2d/0x40 entry_SYSCALL_64_after_hwframe+0x44/0xae RIP: 0033:0x94f225d Code: 24 cc 00 00 00 41 8b 84 24 d0 00 00 00 c1 e0 04 83 e0 10 41 09 c2 8b 33 8b 53 04 4c 8b 43 18 4c 63 4b 0c b8 aa 01 00 00 0f 05 <85> c0 0f 88 85 00 00 00 29 03 45 84 f6 0f 84 88 00 00 00 41 f6 c7 RSP: 002b:00007fd194ffcd88 EFLAGS: 00000202 ORIG_RAX: 00000000000001aa RAX: ffffffffffffffda RBX: 00007fd194ffcdc0 RCX: 00000000094f225d RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000007 RBP: 00007fd194ffcdb0 R08: 0000000000000000 R09: 0000000000000008 R10: 0000000000000001 R11: 0000000000000202 R12: 00007fd269d68030 R13: 0000000000000000 R14: 0000000000000001 R15: 0000000000000000 which is due to bio->bi_bdev being NULL. This can happen if we have two tasks doing polled IO, and task B ends up completing IO from task A if they are sharing a poll queue. If task B completes the IO and puts the bio into our cache, then it can allocate that bio again before task A is done polling for it. As that would necessitate a preempt between the two tasks, it's enough to just be a bit more careful in checking for whether or not bio->bi_bdev is NULL.",,,"[{""url"":""https://git.kernel.org/stable/c/0510d5e654d05053ed0e6309a9b42043ac9903ab"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/1af0bdca03f367874da45d6cbe05fa05b90b1439"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/310726c33ad76cebdee312dbfafc12c1b44bf977"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53367,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:41.100,2025-09-17T15:15:41.100,Received,[],"In the Linux kernel, the following vulnerability has been resolved: accel/habanalabs: fix mem leak in capture user mappings This commit fixes a memory leak caused when clearing the user_mappings info when a new context is opened immediately after user_mapping is captured and a hard reset is performed.",,,"[{""url"":""https://git.kernel.org/stable/c/314a7ffd7c196b27eedd50cb7553029e17789b55"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/973e0890e5264cb075ef668661cad06b67777121"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
CVE-2023-53368,416baaa9-dc9f-4396-8d5f-8c081fb06d67,2025-09-17T15:15:41.220,2025-09-17T15:15:41.220,Received,[],"In the Linux kernel, the following vulnerability has been resolved: tracing: Fix race issue between cpu buffer write and swap Warning happened in rb_end_commit() at code: if (RB_WARN_ON(cpu_buffer, !local_read(&cpu_buffer->committing))) WARNING: CPU: 0 PID: 139 at kernel/trace/ring_buffer.c:3142 rb_commit+0x402/0x4a0 Call Trace: ring_buffer_unlock_commit+0x42/0x250 trace_buffer_unlock_commit_regs+0x3b/0x250 trace_event_buffer_commit+0xe5/0x440 trace_event_buffer_reserve+0x11c/0x150 trace_event_raw_event_sched_switch+0x23c/0x2c0 __traceiter_sched_switch+0x59/0x80 __schedule+0x72b/0x1580 schedule+0x92/0x120 worker_thread+0xa0/0x6f0 It is because the race between writing event into cpu buffer and swapping cpu buffer through file per_cpu/cpu0/snapshot: Write on CPU 0 Swap buffer by per_cpu/cpu0/snapshot on CPU 1 -------- -------- tracing_snapshot_write() [...] ring_buffer_lock_reserve() cpu_buffer = buffer->buffers[cpu]; // 1. Suppose find 'cpu_buffer_a'; [...] rb_reserve_next_event() [...] ring_buffer_swap_cpu() if (local_read(&cpu_buffer_a->committing)) goto out_dec; if (local_read(&cpu_buffer_b->committing)) goto out_dec; buffer_a->buffers[cpu] = cpu_buffer_b; buffer_b->buffers[cpu] = cpu_buffer_a; // 2. cpu_buffer has swapped here. rb_start_commit(cpu_buffer); if (unlikely(READ_ONCE(cpu_buffer->buffer) != buffer)) { // 3. This check passed due to 'cpu_buffer->buffer' [...] // has not changed here. return NULL; } cpu_buffer_b->buffer = buffer_a; cpu_buffer_a->buffer = buffer_b; [...] // 4. Reserve event from 'cpu_buffer_a'. ring_buffer_unlock_commit() [...] cpu_buffer = buffer->buffers[cpu]; // 5. Now find 'cpu_buffer_b' !!! rb_commit(cpu_buffer) rb_end_commit() // 6. WARN for the wrong 'committing' state !!! Based on above analysis, we can easily reproduce by following testcase: ``` bash #!/bin/bash dmesg -n 7 sysctl -w kernel.panic_on_warn=1 TR=/sys/kernel/tracing echo 7 > ${TR}/buffer_size_kb echo ""sched:sched_switch"" > ${TR}/set_event while [ true ]; do echo 1 > ${TR}/per_cpu/cpu0/snapshot done & while [ true ]; do echo 1 > ${TR}/per_cpu/cpu0/snapshot done & while [ true ]; do echo 1 > ${TR}/per_cpu/cpu0/snapshot done & ``` To fix it, IIUC, we can use smp_call_function_single() to do the swap on the target cpu where the buffer is located, so that above race would be avoided.",,,"[{""url"":""https://git.kernel.org/stable/c/3163f635b20e9e1fb4659e74f47918c9dddfe64e"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/37ca1b686078b00cc4ffa008e2190615f7709b5d"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/6182318ac04648b46db9d441fd7d696337fcdd0b"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/74c85396bd73eca80b96510b4edf93b9a3aff75f"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/89c89da92a60028013f9539be0dcce7e44405a43"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/90e037cabc2c2dfc39b3dd9c5b22ea91f995539a"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""},{""url"":""https://git.kernel.org/stable/c/c5d30d6aa83d99fba8dfdd9cf6c4e4e7a63244db"",""source"":""416baaa9-dc9f-4396-8d5f-8c081fb06d67""}]",,,,,,,,,
